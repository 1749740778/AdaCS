1	public IntervalsSet(final double tolerance) {\n super(tolerance);\n }\n 
2	public IntervalsSet(final double lower, final double upper, final double tolerance) {\n super(buildTree(lower, upper, tolerance), tolerance);\n }\n 
3	public IntervalsSet(final BSPTree<Euclidean1D> tree, final double tolerance) {\n super(tree, tolerance);\n }\n 
4	public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary,\n final double tolerance) {\n super(boundary, tolerance);\n }\n 
5	@Deprecated\n public IntervalsSet() {\n this(DEFAULT_TOLERANCE);\n }\n 
6	@Deprecated\n public IntervalsSet(final double lower, final double upper) {\n this(lower, upper, DEFAULT_TOLERANCE);\n }\n 
7	@Deprecated\n public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n this(tree, DEFAULT_TOLERANCE);\n }\n 
8	@Deprecated\n public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n this(boundary, DEFAULT_TOLERANCE);\n }\n 
9	private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper,\n final double tolerance) {\n if (Double.isInfinite(lower) && (lower < 0)) {\n if (Double.isInfinite(upper) && (upper > 0)) {\n // the tree must cover the whole real line\n return new BSPTree<Euclidean1D>(Boolean.TRUE);\n }\n // the tree must be open on the negative infinity side\n final SubHyperplane<Euclidean1D> upperCut =\n new OrientedPoint(new Vector1D(upper), true, tolerance).wholeHyperplane();\n return new BSPTree<Euclidean1D>(upperCut,\n new BSPTree<Euclidean1D>(Boolean.FALSE),\n new BSPTree<Euclidean1D>(Boolean.TRUE),\n null);\n }\n final SubHyperplane<Euclidean1D> lowerCut =\n new OrientedPoint(new Vector1D(lower), false, tolerance).wholeHyperplane();\n if (Double.isInfinite(upper) && (upper > 0)) {\n // the tree must be open on the positive infinity side\n return new BSPTree<Euclidean1D>(lowerCut,\n new BSPTree<Euclidean1D>(Boolean.FALSE),\n new BSPTree<Euclidean1D>(Boolean.TRUE),\n null);\n }\n // the tree must be bounded on the two sides\n final SubHyperplane<Euclidean1D> upperCut =\n new OrientedPoint(new Vector1D(upper), true, tolerance).wholeHyperplane();\n return new BSPTree<Euclidean1D>(lowerCut,\n new BSPTree<Euclidean1D>(Boolean.FALSE),\n new BSPTree<Euclidean1D>(upperCut,\n new BSPTree<Euclidean1D>(Boolean.FALSE),\n new BSPTree<Euclidean1D>(Boolean.TRUE),\n null),\n null);\n }\n 
10	@Override\n public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n return new IntervalsSet(tree, getTolerance());\n }\n 
11	@Override\n protected void computeGeometricalProperties() {\n if (getTree(false).getCut() == null) {\n setBarycenter((Point<Euclidean1D>) Vector1D.NaN);\n setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n } else {\n double size = 0.0;\n double sum = 0.0;\n for (final Interval interval : asList()) {\n size += interval.getSize();\n sum  += interval.getSize() * interval.getBarycenter();\n }\n setSize(size);\n if (Double.isInfinite(size)) {\n setBarycenter((Point<Euclidean1D>) Vector1D.NaN);\n } else if (size >= Precision.SAFE_MIN) {\n setBarycenter((Point<Euclidean1D>) new Vector1D(sum / size));\n } else {\n setBarycenter((Point<Euclidean1D>) ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n }\n }\n }\n 
12	public double getInf() {\n BSPTree<Euclidean1D> node = getTree(false);\n double  inf  = Double.POSITIVE_INFINITY;\n while (node.getCut() != null) {\n final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n inf  = op.getLocation().getX();\n node = op.isDirect() ? node.getMinus() : node.getPlus();\n }\n return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n }\n 
13	public double getSup() {\n BSPTree<Euclidean1D> node = getTree(false);\n double  sup  = Double.NEGATIVE_INFINITY;\n while (node.getCut() != null) {\n final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n sup  = op.getLocation().getX();\n node = op.isDirect() ? node.getPlus() : node.getMinus();\n }\n return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n }\n 
14	@Override\n public BoundaryProjection<Euclidean1D> projectToBoundary(final Point<Euclidean1D> point) {\n // get position of test point\n final double x = ((Vector1D) point).getX();\n double previous = Double.NEGATIVE_INFINITY;\n for (final double[] a : this) {\n if (x < a[0]) {\n // the test point lies between the previous and the current intervals\n // offset will be positive\n final double previousOffset = x - previous;\n final double currentOffset  = a[0] - x;\n if (previousOffset < currentOffset) {\n return new BoundaryProjection<Euclidean1D>(point, finiteOrNullPoint(previous), previousOffset);\n } else {\n return new BoundaryProjection<Euclidean1D>(point, finiteOrNullPoint(a[0]), currentOffset);\n }\n } else if (x <= a[1]) {\n // the test point lies within the current interval\n // offset will be negative\n final double offset0 = a[0] - x;\n final double offset1 = x - a[1];\n if (offset0 < offset1) {\n return new BoundaryProjection<Euclidean1D>(point, finiteOrNullPoint(a[1]), offset1);\n } else {\n return new BoundaryProjection<Euclidean1D>(point, finiteOrNullPoint(a[0]), offset0);\n }\n }\n previous = a[1];\n }\n // the test point if past the last sub-interval\n return new BoundaryProjection<Euclidean1D>(point, finiteOrNullPoint(previous), x - previous);\n }\n 
15	private Vector1D finiteOrNullPoint(final double x) {\n return Double.isInfinite(x) ? null : new Vector1D(x);\n }\n 
16	public List<Interval> asList() {\n final List<Interval> list = new ArrayList<Interval>();\n for (final double[] a : this) {\n list.add(new Interval(a[0], a[1]));\n }\n return list;\n }\n 
17	private BSPTree<Euclidean1D> getFirstLeaf(final BSPTree<Euclidean1D> root) {\n if (root.getCut() == null) {\n return root;\n }\n // find the smallest internal node\n BSPTree<Euclidean1D> smallest = null;\n for (BSPTree<Euclidean1D> n = root; n != null; n = previousInternalNode(n)) {\n smallest = n;\n }\n return leafBefore(smallest);\n }\n 
18	private BSPTree<Euclidean1D> getFirstIntervalBoundary() {\n // start search at the tree root\n BSPTree<Euclidean1D> node = getTree(false);\n if (node.getCut() == null) {\n return null;\n }\n // walk tree until we find the smallest internal node\n node = getFirstLeaf(node).getParent();\n // walk tree until we find an interval boundary\n while (node != null && !(isIntervalStart(node) || isIntervalEnd(node))) {\n node = nextInternalNode(node);\n }\n return node;\n }\n 
19	private boolean isIntervalStart(final BSPTree<Euclidean1D> node) {\n if ((Boolean) leafBefore(node).getAttribute()) {\n // it has an inside cell before it, it may end an interval but not start it\n return false;\n }\n if (!(Boolean) leafAfter(node).getAttribute()) {\n // it has an outside cell after it, it is a dummy cut away from real intervals\n return false;\n }\n // the cell has an outside before and an inside after it\n // it is the start of an interval\n return true;\n }\n 
20	private boolean isIntervalEnd(final BSPTree<Euclidean1D> node) {\n if (!(Boolean) leafBefore(node).getAttribute()) {\n // it has an outside cell before it, it may start an interval but not end it\n return false;\n }\n if ((Boolean) leafAfter(node).getAttribute()) {\n // it has an inside cell after it, it is a dummy cut in the middle of an interval\n return false;\n }\n // the cell has an inside before and an outside after it\n // it is the end of an interval\n return true;\n }\n 
21	private BSPTree<Euclidean1D> nextInternalNode(BSPTree<Euclidean1D> node) {\n if (childAfter(node).getCut() != null) {\n // the next node is in the sub-tree\n return leafAfter(node).getParent();\n }\n // there is nothing left deeper in the tree, we backtrack\n while (isAfterParent(node)) {\n node = node.getParent();\n }\n return node.getParent();\n }\n 
22	private BSPTree<Euclidean1D> previousInternalNode(BSPTree<Euclidean1D> node) {\n if (childBefore(node).getCut() != null) {\n // the next node is in the sub-tree\n return leafBefore(node).getParent();\n }\n // there is nothing left deeper in the tree, we backtrack\n while (isBeforeParent(node)) {\n node = node.getParent();\n }\n return node.getParent();\n }\n 
23	private BSPTree<Euclidean1D> leafBefore(BSPTree<Euclidean1D> node) {\n node = childBefore(node);\n while (node.getCut() != null) {\n node = childAfter(node);\n }\n return node;\n }\n 
24	private BSPTree<Euclidean1D> leafAfter(BSPTree<Euclidean1D> node) {\n node = childAfter(node);\n while (node.getCut() != null) {\n node = childBefore(node);\n }\n return node;\n }\n 
25	private boolean isBeforeParent(final BSPTree<Euclidean1D> node) {\n final BSPTree<Euclidean1D> parent = node.getParent();\n if (parent == null) {\n return false;\n } else {\n return node == childBefore(parent);\n }\n }\n 
26	private boolean isAfterParent(final BSPTree<Euclidean1D> node) {\n final BSPTree<Euclidean1D> parent = node.getParent();\n if (parent == null) {\n return false;\n } else {\n return node == childAfter(parent);\n }\n }\n 
27	private BSPTree<Euclidean1D> childBefore(BSPTree<Euclidean1D> node) {\n if (isDirect(node)) {\n // smaller abscissas are on minus side, larger abscissas are on plus side\n return node.getMinus();\n } else {\n // smaller abscissas are on plus side, larger abscissas are on minus side\n return node.getPlus();\n }\n }\n 
28	private BSPTree<Euclidean1D> childAfter(BSPTree<Euclidean1D> node) {\n if (isDirect(node)) {\n // smaller abscissas are on minus side, larger abscissas are on plus side\n return node.getPlus();\n } else {\n // smaller abscissas are on plus side, larger abscissas are on minus side\n return node.getMinus();\n }\n }\n 
29	private boolean isDirect(final BSPTree<Euclidean1D> node) {\n return ((OrientedPoint) node.getCut().getHyperplane()).isDirect();\n }\n 
30	private double getAngle(final BSPTree<Euclidean1D> node) {\n return ((OrientedPoint) node.getCut().getHyperplane()).getLocation().getX();\n }\n 
31	public Iterator<double[]> iterator() {\n return new SubIntervalsIterator();\n }\n 
32	SubIntervalsIterator() {\n current = getFirstIntervalBoundary();\n if (current == null) {\n // all the leaf tree nodes share the same inside/outside status\n if ((Boolean) getFirstLeaf(getTree(false)).getAttribute()) {\n // it is an inside node, it represents the full real line\n pending = new double[] {\n Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY\n };\n } else {\n pending = null;\n }\n } else if (isIntervalEnd(current)) {\n // the first boundary is an interval end,\n // so the first interval starts at infinity\n pending = new double[] {\n Double.NEGATIVE_INFINITY, getAngle(current)\n };\n } else {\n selectPending();\n }\n }\n 
33	private void selectPending() {\n // look for the start of the interval\n BSPTree<Euclidean1D> start = current;\n while (start != null && !isIntervalStart(start)) {\n start = nextInternalNode(start);\n }\n if (start == null) {\n // we have exhausted the iterator\n current = null;\n pending = null;\n return;\n }\n // look for the end of the interval\n BSPTree<Euclidean1D> end = start;\n while (end != null && !isIntervalEnd(end)) {\n end = nextInternalNode(end);\n }\n if (end != null) {\n // we have identified the interval\n pending = new double[] {\n getAngle(start), getAngle(end)\n };\n // prepare search for next interval\n current = end;\n } else {\n // the final interval is open toward infinity\n pending = new double[] {\n getAngle(start), Double.POSITIVE_INFINITY\n };\n // there won't be any other intervals\n current = null;\n }\n }\n 
34	public boolean hasNext() {\n return pending != null;\n }\n 
35	public double[] next() {\n if (pending == null) {\n throw new NoSuchElementException();\n }\n final double[] next = pending;\n selectPending();\n return next;\n }\n 
36	public void remove() {\n throw new UnsupportedOperationException();\n }\n 
37	public PolyhedronsSet(final double tolerance) {\n super(tolerance);\n }\n 
38	public PolyhedronsSet(final BSPTree<Euclidean3D> tree, final double tolerance) {\n super(tree, tolerance);\n }\n 
39	public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary,\n final double tolerance) {\n super(boundary, tolerance);\n }\n 
40	public PolyhedronsSet(final List<Vector3D> vertices, final List<int[]> facets,\n final double tolerance) {\n super(buildBoundary(vertices, facets, tolerance), tolerance);\n }\n 
41	public PolyhedronsSet(final double xMin, final double xMax,\n final double yMin, final double yMax,\n final double zMin, final double zMax,\n final double tolerance) {\n super(buildBoundary(xMin, xMax, yMin, yMax, zMin, zMax, tolerance), tolerance);\n }\n 
42	@Deprecated\n public PolyhedronsSet() {\n this(DEFAULT_TOLERANCE);\n }\n 
43	@Deprecated\n public PolyhedronsSet(final BSPTree<Euclidean3D> tree) {\n this(tree, DEFAULT_TOLERANCE);\n }\n 
44	@Deprecated\n public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary) {\n this(boundary, DEFAULT_TOLERANCE);\n }\n 
45	@Deprecated\n public PolyhedronsSet(final double xMin, final double xMax,\n final double yMin, final double yMax,\n final double zMin, final double zMax) {\n this(xMin, xMax, yMin, yMax, zMin, zMax, DEFAULT_TOLERANCE);\n }\n 
46	private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax,\n final double yMin, final double yMax,\n final double zMin, final double zMax,\n final double tolerance) {\n if ((xMin >= xMax - tolerance) || (yMin >= yMax - tolerance) || (zMin >= zMax - tolerance)) {\n // too thin box, build an empty polygons set\n return new BSPTree<Euclidean3D>(Boolean.FALSE);\n }\n final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I, tolerance);\n final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I,  tolerance);\n final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J, tolerance);\n final Plane pyMax = new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J,  tolerance);\n final Plane pzMin = new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K, tolerance);\n final Plane pzMax = new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K,  tolerance);\n @SuppressWarnings("unchecked")\n final Region<Euclidean3D> boundary =\n new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\n return boundary.getTree(false);\n }\n 
47	private static List<SubHyperplane<Euclidean3D>> buildBoundary(final List<Vector3D> vertices,\n final List<int[]> facets,\n final double tolerance) {\n // check vertices distances\n for (int i = 0; i < vertices.size() - 1; ++i) {\n final Vector3D vi = vertices.get(i);\n for (int j = i + 1; j < vertices.size(); ++j) {\n if (Vector3D.distance(vi, vertices.get(j)) <= tolerance) {\n throw new MathIllegalArgumentException(LocalizedFormats.CLOSE_VERTICES,\n vi.getX(), vi.getY(), vi.getZ());\n }\n }\n }\n // find how vertices are referenced by facets\n final int[][] references = findReferences(vertices, facets);\n // find how vertices are linked together by edges along the facets they belong to\n final int[][] successors = successors(vertices, facets, references);\n // check edges orientations\n for (int vA = 0; vA < vertices.size(); ++vA) {\n for (final int vB : successors[vA]) {\n if (vB >= 0) {\n // when facets are properly oriented, if vB is the successor of vA on facet f1,\n // then there must be an adjacent facet f2 where vA is the successor of vB\n boolean found = false;\n for (final int v : successors[vB]) {\n found = found || (v == vA);\n }\n if (!found) {\n final Vector3D start = vertices.get(vA);\n final Vector3D end   = vertices.get(vB);\n throw new MathIllegalArgumentException(LocalizedFormats.EDGE_CONNECTED_TO_ONE_FACET,\n start.getX(), start.getY(), start.getZ(),\n end.getX(),   end.getY(),   end.getZ());\n }\n }\n }\n }\n final List<SubHyperplane<Euclidean3D>> boundary = new ArrayList<SubHyperplane<Euclidean3D>>();\n for (final int[] facet : facets) {\n // define facet plane from the first 3 points\n Plane plane = new Plane(vertices.get(facet[0]), vertices.get(facet[1]), vertices.get(facet[2]),\n tolerance);\n // check all points are in the plane\n final Vector2D[] two2Points = new Vector2D[facet.length];\n for (int i = 0 ; i < facet.length; ++i) {\n final Vector3D v = vertices.get(facet[i]);\n if (!plane.contains(v)) {\n throw new MathIllegalArgumentException(LocalizedFormats.OUT_OF_PLANE,\n v.getX(), v.getY(), v.getZ());\n }\n two2Points[i] = plane.toSubSpace(v);\n }\n // create the polygonal facet\n boundary.add(new SubPlane(plane, new PolygonsSet(tolerance, two2Points)));\n }\n return boundary;\n }\n 
48	private static int[][] findReferences(final List<Vector3D> vertices, final List<int[]> facets) {\n // find the maximum number of facets a vertex belongs to\n final int[] nbFacets = new int[vertices.size()];\n int maxFacets  = 0;\n for (final int[] facet : facets) {\n if (facet.length < 3) {\n throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS,\n 3, facet.length, true);\n }\n for (final int index : facet) {\n maxFacets = FastMath.max(maxFacets, ++nbFacets[index]);\n }\n }\n // set up the references array\n final int[][] references = new int[vertices.size()][maxFacets];\n for (int[] r : references) {\n Arrays.fill(r, -1);\n }\n for (int f = 0; f < facets.size(); ++f) {\n for (final int v : facets.get(f)) {\n // vertex v is referenced by facet f\n int k = 0;\n while (k < maxFacets && references[v][k] >= 0) {\n ++k;\n }\n references[v][k] = f;\n }\n }\n return references;\n }\n 
49	private static int[][] successors(final List<Vector3D> vertices, final List<int[]> facets,\n final int[][] references) {\n // create an array large enough\n final int[][] successors = new int[vertices.size()][references[0].length];\n for (final int[] s : successors) {\n Arrays.fill(s, -1);\n }\n for (int v = 0; v < vertices.size(); ++v) {\n for (int k = 0; k < successors[v].length && references[v][k] >= 0; ++k) {\n // look for vertex v\n final int[] facet = facets.get(references[v][k]);\n int i = 0;\n while (i < facet.length && facet[i] != v) {\n ++i;\n }\n // we have found vertex v, we deduce its successor on current facet\n successors[v][k] = facet[(i + 1) % facet.length];\n for (int l = 0; l < k; ++l) {\n if (successors[v][l] == successors[v][k]) {\n final Vector3D start = vertices.get(v);\n final Vector3D end   = vertices.get(successors[v][k]);\n throw new MathIllegalArgumentException(LocalizedFormats.FACET_ORIENTATION_MISMATCH,\n start.getX(), start.getY(), start.getZ(),\n end.getX(),   end.getY(),   end.getZ());\n }\n }\n }\n }\n return successors;\n }\n 
50	@Override\n public PolyhedronsSet buildNew(final BSPTree<Euclidean3D> tree) {\n return new PolyhedronsSet(tree, getTolerance());\n }\n 
51	@Override\n protected void computeGeometricalProperties() {\n // compute the contribution of all boundary facets\n getTree(true).visit(new FacetsContributionVisitor());\n if (getSize() < 0) {\n // the polyhedrons set as a finite outside\n // surrounded by an infinite inside\n setSize(Double.POSITIVE_INFINITY);\n setBarycenter((Point<Euclidean3D>) Vector3D.NaN);\n } else {\n // the polyhedrons set is finite, apply the remaining scaling factors\n setSize(getSize() / 3.0);\n setBarycenter((Point<Euclidean3D>) new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n }\n }\n 
52	FacetsContributionVisitor() {\n setSize(0);\n setBarycenter((Point<Euclidean3D>) new Vector3D(0, 0, 0));\n }\n 
53	public Order visitOrder(final BSPTree<Euclidean3D> node) {\n return Order.MINUS_SUB_PLUS;\n }\n 
54	public void visitInternalNode(final BSPTree<Euclidean3D> node) {\n @SuppressWarnings("unchecked")\n final BoundaryAttribute<Euclidean3D> attribute =\n (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n if (attribute.getPlusOutside() != null) {\n addContribution(attribute.getPlusOutside(), false);\n }\n if (attribute.getPlusInside() != null) {\n addContribution(attribute.getPlusInside(), true);\n }\n }\n 
55	public void visitLeafNode(final BSPTree<Euclidean3D> node) {\n }\n 
56	private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) {\n final Region<Euclidean2D> polygon = ((SubPlane) facet).getRemainingRegion();\n final double area    = polygon.getSize();\n if (Double.isInfinite(area)) {\n setSize(Double.POSITIVE_INFINITY);\n setBarycenter((Point<Euclidean3D>) Vector3D.NaN);\n } else {\n final Plane    plane  = (Plane) facet.getHyperplane();\n final Vector3D facetB = plane.toSpace(polygon.getBarycenter());\n double   scaled = area * facetB.dotProduct(plane.getNormal());\n if (reversed) {\n scaled = -scaled;\n }\n setSize(getSize() + scaled);\n setBarycenter((Point<Euclidean3D>) new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB));\n }\n }\n 
57	public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {\n return recurseFirstIntersection(getTree(true), point, line);\n }\n 
58	private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,\n final Vector3D point,\n final Line line) {\n final SubHyperplane<Euclidean3D> cut = node.getCut();\n if (cut == null) {\n return null;\n }\n final BSPTree<Euclidean3D> minus = node.getMinus();\n final BSPTree<Euclidean3D> plus  = node.getPlus();\n final Plane                plane = (Plane) cut.getHyperplane();\n // establish search order\n final double offset = plane.getOffset((Point<Euclidean3D>) point);\n final boolean in    = FastMath.abs(offset) < getTolerance();\n final BSPTree<Euclidean3D> near;\n final BSPTree<Euclidean3D> far;\n if (offset < 0) {\n near = minus;\n far  = plus;\n } else {\n near = plus;\n far  = minus;\n }\n if (in) {\n // search in the cut hyperplane\n final SubHyperplane<Euclidean3D> facet = boundaryFacet(point, node);\n if (facet != null) {\n return facet;\n }\n }\n // search in the near branch\n final SubHyperplane<Euclidean3D> crossed = recurseFirstIntersection(near, point, line);\n if (crossed != null) {\n return crossed;\n }\n if (!in) {\n // search in the cut hyperplane\n final Vector3D hit3D = plane.intersection(line);\n if (hit3D != null && line.getAbscissa(hit3D) > line.getAbscissa(point)) {\n final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);\n if (facet != null) {\n return facet;\n }\n }\n }\n // search in the far branch\n return recurseFirstIntersection(far, point, line);\n }\n 
59	private SubHyperplane<Euclidean3D> boundaryFacet(final Vector3D point,\n final BSPTree<Euclidean3D> node) {\n final Vector2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace((Point<Euclidean3D>) point);\n @SuppressWarnings("unchecked")\n final BoundaryAttribute<Euclidean3D> attribute =\n (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n if ((attribute.getPlusOutside() != null) &&\n (((SubPlane) attribute.getPlusOutside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n return attribute.getPlusOutside();\n }\n if ((attribute.getPlusInside() != null) &&\n (((SubPlane) attribute.getPlusInside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n return attribute.getPlusInside();\n }\n return null;\n }\n 
60	public PolyhedronsSet rotate(final Vector3D center, final Rotation rotation) {\n return (PolyhedronsSet) applyTransform(new RotationTransform(center, rotation));\n }\n 
61	RotationTransform(final Vector3D center, final Rotation rotation) {\n this.center   = center;\n this.rotation = rotation;\n }\n 
62	public Vector3D apply(final Point<Euclidean3D> point) {\n final Vector3D delta = ((Vector3D) point).subtract(center);\n return new Vector3D(1.0, center, 1.0, rotation.applyTo(delta));\n }\n 
63	public Plane apply(final Hyperplane<Euclidean3D> hyperplane) {\n return ((Plane) hyperplane).rotate(center, rotation);\n }\n 
64	public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub,\n final Hyperplane<Euclidean3D> original,\n final Hyperplane<Euclidean3D> transformed) {\n if (original != cachedOriginal) {\n // we have changed hyperplane, reset the in-hyperplane transform\n final Plane    oPlane = (Plane) original;\n final Plane    tPlane = (Plane) transformed;\n final Vector3D p00    = oPlane.getOrigin();\n final Vector3D p10    = oPlane.toSpace((Point<Euclidean2D>) new Vector2D(1.0, 0.0));\n final Vector3D p01    = oPlane.toSpace((Point<Euclidean2D>) new Vector2D(0.0, 1.0));\n final Vector2D tP00   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p00));\n final Vector2D tP10   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p10));\n final Vector2D tP01   = tPlane.toSubSpace((Point<Euclidean3D>) apply(p01));\n cachedOriginal  = (Plane) original;\n cachedTransform =\n org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(tP10.getX() - tP00.getX(),\n tP10.getY() - tP00.getY(),\n tP01.getX() - tP00.getX(),\n tP01.getY() - tP00.getY(),\n tP00.getX(),\n tP00.getY());\n }\n return ((SubLine) sub).applyTransform(cachedTransform);\n }\n 
65	public PolyhedronsSet translate(final Vector3D translation) {\n return (PolyhedronsSet) applyTransform(new TranslationTransform(translation));\n }\n 
66	TranslationTransform(final Vector3D translation) {\n this.translation = translation;\n }\n 
67	public Vector3D apply(final Point<Euclidean3D> point) {\n return new Vector3D(1.0, (Vector3D) point, 1.0, translation);\n }\n 
68	public Plane apply(final Hyperplane<Euclidean3D> hyperplane) {\n return ((Plane) hyperplane).translate(translation);\n }\n 
69	public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub,\n final Hyperplane<Euclidean3D> original,\n final Hyperplane<Euclidean3D> transformed) {\n if (original != cachedOriginal) {\n // we have changed hyperplane, reset the in-hyperplane transform\n final Plane   oPlane = (Plane) original;\n final Plane   tPlane = (Plane) transformed;\n final Vector2D shift  = tPlane.toSubSpace((Point<Euclidean3D>) apply(oPlane.getOrigin()));\n cachedOriginal  = (Plane) original;\n cachedTransform =\n org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(1, 0, 0, 1,\n shift.getX(),\n shift.getY());\n }\n return ((SubLine) sub).applyTransform(cachedTransform);\n }\n 
70	public PolygonsSet(final double tolerance) {\n super(tolerance);\n }\n 
71	public PolygonsSet(final BSPTree<Euclidean2D> tree, final double tolerance) {\n super(tree, tolerance);\n }\n 
72	public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary, final double tolerance) {\n super(boundary, tolerance);\n }\n 
73	public PolygonsSet(final double xMin, final double xMax,\n final double yMin, final double yMax,\n final double tolerance) {\n super(boxBoundary(xMin, xMax, yMin, yMax, tolerance), tolerance);\n }\n 
74	public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices) {\n super(verticesToTree(hyperplaneThickness, vertices), hyperplaneThickness);\n }\n 
75	@Deprecated\n public PolygonsSet() {\n this(DEFAULT_TOLERANCE);\n }\n 
76	@Deprecated\n public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n this(tree, DEFAULT_TOLERANCE);\n }\n 
77	@Deprecated\n public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n this(boundary, DEFAULT_TOLERANCE);\n }\n 
78	@Deprecated\n public PolygonsSet(final double xMin, final double xMax,\n final double yMin, final double yMax) {\n this(xMin, xMax, yMin, yMax, DEFAULT_TOLERANCE);\n }\n 
79	private static Line[] boxBoundary(final double xMin, final double xMax,\n final double yMin, final double yMax,\n final double tolerance) {\n if ((xMin >= xMax - tolerance) || (yMin >= yMax - tolerance)) {\n // too thin box, build an empty polygons set\n return null;\n }\n final Vector2D minMin = new Vector2D(xMin, yMin);\n final Vector2D minMax = new Vector2D(xMin, yMax);\n final Vector2D maxMin = new Vector2D(xMax, yMin);\n final Vector2D maxMax = new Vector2D(xMax, yMax);\n return new Line[] {\n new Line(minMin, maxMin, tolerance),\n new Line(maxMin, maxMax, tolerance),\n new Line(maxMax, minMax, tolerance),\n new Line(minMax, minMin, tolerance)\n };\n }\n 
80	private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness,\n final Vector2D ... vertices) {\n final int n = vertices.length;\n if (n == 0) {\n // the tree represents the whole space\n return new BSPTree<Euclidean2D>(Boolean.TRUE);\n }\n // build the vertices\n final Vertex[] vArray = new Vertex[n];\n for (int i = 0; i < n; ++i) {\n vArray[i] = new Vertex(vertices[i]);\n }\n // build the edges\n List<Edge> edges = new ArrayList<Edge>(n);\n for (int i = 0; i < n; ++i) {\n // get the endpoints of the edge\n final Vertex start = vArray[i];\n final Vertex end   = vArray[(i + 1) % n];\n // get the line supporting the edge, taking care not to recreate it\n // if it was already created earlier due to another edge being aligned\n // with the current one\n Line line = start.sharedLineWith(end);\n if (line == null) {\n line = new Line(start.getLocation(), end.getLocation(), hyperplaneThickness);\n }\n // create the edge and store it\n edges.add(new Edge(start, end, line));\n // check if another vertex also happens to be on this line\n for (final Vertex vertex : vArray) {\n if (vertex != start && vertex != end &&\n FastMath.abs(line.getOffset((Point<Euclidean2D>) vertex.getLocation())) <= hyperplaneThickness) {\n vertex.bindWith(line);\n }\n }\n }\n // build the tree top-down\n final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n insertEdges(hyperplaneThickness, tree, edges);\n return tree;\n }\n 
81	private static void insertEdges(final double hyperplaneThickness,\n final BSPTree<Euclidean2D> node,\n final List<Edge> edges) {\n // find an edge with an hyperplane that can be inserted in the node\n int index = 0;\n Edge inserted =null;\n while (inserted == null && index < edges.size()) {\n inserted = edges.get(index++);\n if (inserted.getNode() == null) {\n if (node.insertCut(inserted.getLine())) {\n inserted.setNode(node);\n } else {\n inserted = null;\n }\n } else {\n inserted = null;\n }\n }\n if (inserted == null) {\n // no suitable edge was found, the node remains a leaf node\n // we need to set its inside/outside boolean indicator\n final BSPTree<Euclidean2D> parent = node.getParent();\n if (parent == null || node == parent.getMinus()) {\n node.setAttribute(Boolean.TRUE);\n } else {\n node.setAttribute(Boolean.FALSE);\n }\n return;\n }\n // we have split the node by inserting an edge as a cut sub-hyperplane\n // distribute the remaining edges in the two sub-trees\n final List<Edge> plusList  = new ArrayList<Edge>();\n final List<Edge> minusList = new ArrayList<Edge>();\n for (final Edge edge : edges) {\n if (edge != inserted) {\n final double startOffset = inserted.getLine().getOffset((Point<Euclidean2D>) edge.getStart().getLocation());\n final double endOffset   = inserted.getLine().getOffset((Point<Euclidean2D>) edge.getEnd().getLocation());\n Side startSide = (FastMath.abs(startOffset) <= hyperplaneThickness) ?\n Side.HYPER : ((startOffset < 0) ? Side.MINUS : Side.PLUS);\n Side endSide   = (FastMath.abs(endOffset) <= hyperplaneThickness) ?\n Side.HYPER : ((endOffset < 0) ? Side.MINUS : Side.PLUS);\n switch (startSide) {\n case PLUS:\n if (endSide == Side.MINUS) {\n // we need to insert a split point on the hyperplane\n final Vertex splitPoint = edge.split(inserted.getLine());\n minusList.add(splitPoint.getOutgoing());\n plusList.add(splitPoint.getIncoming());\n } else {\n plusList.add(edge);\n }\n break;\n case MINUS:\n if (endSide == Side.PLUS) {\n // we need to insert a split point on the hyperplane\n final Vertex splitPoint = edge.split(inserted.getLine());\n minusList.add(splitPoint.getIncoming());\n plusList.add(splitPoint.getOutgoing());\n } else {\n minusList.add(edge);\n }\n break;\n default:\n if (endSide == Side.PLUS) {\n plusList.add(edge);\n } else if (endSide == Side.MINUS) {\n minusList.add(edge);\n }\n break;\n }\n }\n }\n // recurse through lower levels\n if (!plusList.isEmpty()) {\n insertEdges(hyperplaneThickness, node.getPlus(),  plusList);\n } else {\n node.getPlus().setAttribute(Boolean.FALSE);\n }\n if (!minusList.isEmpty()) {\n insertEdges(hyperplaneThickness, node.getMinus(), minusList);\n } else {\n node.getMinus().setAttribute(Boolean.TRUE);\n }\n }\n 
82	Vertex(final Vector2D location) {\n this.location = location;\n this.incoming = null;\n this.outgoing = null;\n this.lines    = new ArrayList<Line>();\n }\n 
83	public Vector2D getLocation() {\n return location;\n }\n 
84	public void bindWith(final Line line) {\n lines.add(line);\n }\n 
85	public Line sharedLineWith(final Vertex vertex) {\n for (final Line line1 : lines) {\n for (final Line line2 : vertex.lines) {\n if (line1 == line2) {\n return line1;\n }\n }\n }\n return null;\n }\n 
86	public void setIncoming(final Edge incoming) {\n this.incoming = incoming;\n bindWith(incoming.getLine());\n }\n 
87	public Edge getIncoming() {\n return incoming;\n }\n 
88	public void setOutgoing(final Edge outgoing) {\n this.outgoing = outgoing;\n bindWith(outgoing.getLine());\n }\n 
89	public Edge getOutgoing() {\n return outgoing;\n }\n 
90	Edge(final Vertex start, final Vertex end, final Line line) {\n this.start = start;\n this.end   = end;\n this.line  = line;\n this.node  = null;\n // connect the vertices back to the edge\n start.setOutgoing(this);\n end.setIncoming(this);\n }\n 
91	public Vertex getStart() {\n return start;\n }\n 
92	public Vertex getEnd() {\n return end;\n }\n 
93	public Line getLine() {\n return line;\n }\n 
94	public void setNode(final BSPTree<Euclidean2D> node) {\n this.node = node;\n }\n 
95	public BSPTree<Euclidean2D> getNode() {\n return node;\n }\n 
96	public Vertex split(final Line splitLine) {\n final Vertex splitVertex = new Vertex(line.intersection(splitLine));\n splitVertex.bindWith(splitLine);\n final Edge startHalf = new Edge(start, splitVertex, line);\n final Edge endHalf   = new Edge(splitVertex, end, line);\n startHalf.node = node;\n endHalf.node   = node;\n return splitVertex;\n }\n 
97	@Override\n public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n return new PolygonsSet(tree, getTolerance());\n }\n 
98	@Override\n protected void computeGeometricalProperties() {\n final Vector2D[][] v = getVertices();\n if (v.length == 0) {\n final BSPTree<Euclidean2D> tree = getTree(false);\n if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n // the instance covers the whole space\n setSize(Double.POSITIVE_INFINITY);\n setBarycenter((Point<Euclidean2D>) Vector2D.NaN);\n } else {\n setSize(0);\n setBarycenter((Point<Euclidean2D>) new Vector2D(0, 0));\n }\n } else if (v[0][0] == null) {\n // there is at least one open-loop: the polygon is infinite\n setSize(Double.POSITIVE_INFINITY);\n setBarycenter((Point<Euclidean2D>) Vector2D.NaN);\n } else {\n // all loops are closed, we compute some integrals around the shape\n double sum  = 0;\n double sumX = 0;\n double sumY = 0;\n for (Vector2D[] loop : v) {\n double x1 = loop[loop.length - 1].getX();\n double y1 = loop[loop.length - 1].getY();\n for (final Vector2D point : loop) {\n final double x0 = x1;\n final double y0 = y1;\n x1 = point.getX();\n y1 = point.getY();\n final double factor = x0 * y1 - y0 * x1;\n sum  += factor;\n sumX += factor * (x0 + x1);\n sumY += factor * (y0 + y1);\n }\n }\n if (sum < 0) {\n // the polygon as a finite outside surrounded by an infinite inside\n setSize(Double.POSITIVE_INFINITY);\n setBarycenter((Point<Euclidean2D>) Vector2D.NaN);\n } else {\n setSize(sum / 2);\n setBarycenter((Point<Euclidean2D>) new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n }\n }\n }\n 
99	public Vector2D[][] getVertices() {\n if (vertices == null) {\n if (getTree(false).getCut() == null) {\n vertices = new Vector2D[0][];\n } else {\n // build the unconnected segments\n final SegmentsBuilder visitor = new SegmentsBuilder(getTolerance());\n getTree(true).visit(visitor);\n final List<ConnectableSegment> segments = visitor.getSegments();\n // connect all segments, using topological criteria first\n // and using Euclidean distance only as a last resort\n int pending = segments.size();\n pending -= naturalFollowerConnections(segments);\n if (pending > 0) {\n pending -= splitEdgeConnections(segments);\n }\n if (pending > 0) {\n pending -= closeVerticesConnections(segments);\n }\n // create the segment loops\n final ArrayList<List<Segment>> loops = new ArrayList<List<Segment>>();\n for (ConnectableSegment s = getUnprocessed(segments); s != null; s = getUnprocessed(segments)) {\n final List<Segment> loop = followLoop(s);\n if (loop != null) {\n if (loop.get(0).getStart() == null) {\n // this is an open loop, we put it on the front\n loops.add(0, loop);\n } else {\n // this is a closed loop, we put it on the back\n loops.add(loop);\n }\n }\n }\n // transform the loops in an array of arrays of points\n vertices = new Vector2D[loops.size()][];\n int i = 0;\n for (final List<Segment> loop : loops) {\n if (loop.size() < 2 ||\n (loop.size() == 2 && loop.get(0).getStart() == null && loop.get(1).getEnd() == null)) {\n // single infinite line\n final Line line = loop.get(0).getLine();\n vertices[i++] = new Vector2D[] {\n null,\n line.toSpace((Point<Euclidean1D>) new Vector1D(-Float.MAX_VALUE)),\n line.toSpace((Point<Euclidean1D>) new Vector1D(+Float.MAX_VALUE))\n };\n } else if (loop.get(0).getStart() == null) {\n // open loop with at least one real point\n final Vector2D[] array = new Vector2D[loop.size() + 2];\n int j = 0;\n for (Segment segment : loop) {\n if (j == 0) {\n // null point and first dummy point\n double x = segment.getLine().toSubSpace((Point<Euclidean2D>) segment.getEnd()).getX();\n x -= FastMath.max(1.0, FastMath.abs(x / 2));\n array[j++] = null;\n array[j++] = segment.getLine().toSpace((Point<Euclidean1D>) new Vector1D(x));\n }\n if (j < (array.length - 1)) {\n // current point\n array[j++] = segment.getEnd();\n }\n if (j == (array.length - 1)) {\n // last dummy point\n double x = segment.getLine().toSubSpace((Point<Euclidean2D>) segment.getStart()).getX();\n x += FastMath.max(1.0, FastMath.abs(x / 2));\n array[j++] = segment.getLine().toSpace((Point<Euclidean1D>) new Vector1D(x));\n }\n }\n vertices[i++] = array;\n } else {\n final Vector2D[] array = new Vector2D[loop.size()];\n int j = 0;\n for (Segment segment : loop) {\n array[j++] = segment.getStart();\n }\n vertices[i++] = array;\n }\n }\n }\n }\n return vertices.clone();\n }\n 
100	private int naturalFollowerConnections(final List<ConnectableSegment> segments) {\n int connected = 0;\n for (final ConnectableSegment segment : segments) {\n if (segment.getNext() == null) {\n final BSPTree<Euclidean2D> node = segment.getNode();\n final BSPTree<Euclidean2D> end  = segment.getEndNode();\n for (final ConnectableSegment candidateNext : segments) {\n if (candidateNext.getPrevious()  == null &&\n candidateNext.getNode()      == end &&\n candidateNext.getStartNode() == node) {\n // connect the two segments\n segment.setNext(candidateNext);\n candidateNext.setPrevious(segment);\n ++connected;\n break;\n }\n }\n }\n }\n return connected;\n }\n 
101	private int splitEdgeConnections(final List<ConnectableSegment> segments) {\n int connected = 0;\n for (final ConnectableSegment segment : segments) {\n if (segment.getNext() == null) {\n final Hyperplane<Euclidean2D> hyperplane = segment.getNode().getCut().getHyperplane();\n final BSPTree<Euclidean2D> end  = segment.getEndNode();\n for (final ConnectableSegment candidateNext : segments) {\n if (candidateNext.getPrevious()                      == null &&\n candidateNext.getNode().getCut().getHyperplane() == hyperplane &&\n candidateNext.getStartNode()                     == end) {\n // connect the two segments\n segment.setNext(candidateNext);\n candidateNext.setPrevious(segment);\n ++connected;\n break;\n }\n }\n }\n }\n return connected;\n }\n 
102	private int closeVerticesConnections(final List<ConnectableSegment> segments) {\n int connected = 0;\n for (final ConnectableSegment segment : segments) {\n if (segment.getNext() == null && segment.getEnd() != null) {\n final Vector2D end = segment.getEnd();\n ConnectableSegment selectedNext = null;\n double min = Double.POSITIVE_INFINITY;\n for (final ConnectableSegment candidateNext : segments) {\n if (candidateNext.getPrevious() == null && candidateNext.getStart() != null) {\n final double distance = Vector2D.distance(end, candidateNext.getStart());\n if (distance < min) {\n selectedNext = candidateNext;\n min          = distance;\n }\n }\n }\n if (min <= getTolerance()) {\n // connect the two segments\n segment.setNext(selectedNext);\n selectedNext.setPrevious(segment);\n ++connected;\n }\n }\n }\n return connected;\n }\n 
103	private ConnectableSegment getUnprocessed(final List<ConnectableSegment> segments) {\n for (final ConnectableSegment segment : segments) {\n if (!segment.isProcessed()) {\n return segment;\n }\n }\n return null;\n }\n 
104	private List<Segment> followLoop(final ConnectableSegment defining) {\n final List<Segment> loop = new ArrayList<Segment>();\n loop.add(defining);\n defining.setProcessed(true);\n // add segments in connection order\n ConnectableSegment next = defining.getNext();\n while (next != defining && next != null) {\n loop.add(next);\n next.setProcessed(true);\n next = next.getNext();\n }\n if (next == null) {\n // the loop is open and we have found its end,\n // we need to find its start too\n ConnectableSegment previous = defining.getPrevious();\n while (previous != null) {\n loop.add(0, previous);\n previous.setProcessed(true);\n previous = previous.getPrevious();\n }\n }\n // filter out spurious vertices\n filterSpuriousVertices(loop);\n if (loop.size() == 2 && loop.get(0).getStart() != null) {\n // this is a degenerated infinitely thin closed loop, we simply ignore it\n return null;\n } else {\n return loop;\n }\n }\n 
105	private void filterSpuriousVertices(final List<Segment> loop) {\n for (int i = 0; i < loop.size(); ++i) {\n final Segment previous = loop.get(i);\n int j = (i + 1) % loop.size();\n final Segment next = loop.get(j);\n if (next != null &&\n Precision.equals(previous.getLine().getAngle(), next.getLine().getAngle(), Precision.EPSILON)) {\n // the vertex between the two edges is a spurious one\n // replace the two segments by a single one\n loop.set(j, new Segment(previous.getStart(), next.getEnd(), previous.getLine()));\n loop.remove(i--);\n }\n }\n }\n 
106	ConnectableSegment(final Vector2D start, final Vector2D end, final Line line,\n final BSPTree<Euclidean2D> node,\n final BSPTree<Euclidean2D> startNode,\n final BSPTree<Euclidean2D> endNode) {\n super(start, end, line);\n this.node      = node;\n this.startNode = startNode;\n this.endNode   = endNode;\n this.previous  = null;\n this.next      = null;\n this.processed = false;\n }\n 
107	public BSPTree<Euclidean2D> getNode() {\n return node;\n }\n 
108	public BSPTree<Euclidean2D> getStartNode() {\n return startNode;\n }\n 
109	public BSPTree<Euclidean2D> getEndNode() {\n return endNode;\n }\n 
110	public ConnectableSegment getPrevious() {\n return previous;\n }\n 
111	public void setPrevious(final ConnectableSegment previous) {\n this.previous = previous;\n }\n 
112	public ConnectableSegment getNext() {\n return next;\n }\n 
113	public void setNext(final ConnectableSegment next) {\n this.next = next;\n }\n 
114	public void setProcessed(final boolean processed) {\n this.processed = processed;\n }\n 
115	public boolean isProcessed() {\n return processed;\n }\n 
116	SegmentsBuilder(final double tolerance) {\n this.tolerance = tolerance;\n this.segments  = new ArrayList<ConnectableSegment>();\n }\n 
117	public Order visitOrder(final BSPTree<Euclidean2D> node) {\n return Order.MINUS_SUB_PLUS;\n }\n 
118	public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n @SuppressWarnings("unchecked")\n final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n final Iterable<BSPTree<Euclidean2D>> splitters = attribute.getSplitters();\n if (attribute.getPlusOutside() != null) {\n addContribution(attribute.getPlusOutside(), node, splitters, false);\n }\n if (attribute.getPlusInside() != null) {\n addContribution(attribute.getPlusInside(), node, splitters, true);\n }\n }\n 
119	public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n }\n 
120	private void addContribution(final SubHyperplane<Euclidean2D> sub,\n final BSPTree<Euclidean2D> node,\n final Iterable<BSPTree<Euclidean2D>> splitters,\n final boolean reversed) {\n @SuppressWarnings("unchecked")\n final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n final Line line      = (Line) sub.getHyperplane();\n final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n for (final Interval i : intervals) {\n // find the 2D points\n final Vector2D startV = Double.isInfinite(i.getInf()) ?\n null : (Vector2D) line.toSpace((Point<Euclidean1D>) new Vector1D(i.getInf()));\n final Vector2D endV   = Double.isInfinite(i.getSup()) ?\n null : (Vector2D) line.toSpace((Point<Euclidean1D>) new Vector1D(i.getSup()));\n // recover the connectivity information\n final BSPTree<Euclidean2D> startN = selectClosest(startV, splitters);\n final BSPTree<Euclidean2D> endN   = selectClosest(endV, splitters);\n if (reversed) {\n segments.add(new ConnectableSegment(endV, startV, line.getReverse(),\n node, endN, startN));\n } else {\n segments.add(new ConnectableSegment(startV, endV, line,\n node, startN, endN));\n }\n }\n }\n 
121	private BSPTree<Euclidean2D> selectClosest(final Vector2D point, final Iterable<BSPTree<Euclidean2D>> candidates) {\n BSPTree<Euclidean2D> selected = null;\n double min = Double.POSITIVE_INFINITY;\n for (final BSPTree<Euclidean2D> node : candidates) {\n final double distance = FastMath.abs(node.getCut().getHyperplane().getOffset(point));\n if (distance < min) {\n selected = node;\n min      = distance;\n }\n }\n return min <= tolerance ? selected : null;\n }\n 
122	public List<ConnectableSegment> getSegments() {\n return segments;\n }\n 
123	public BigReal(BigDecimal val) {\n d =  val;\n }\n 
124	public BigReal(BigInteger val) {\n d = new BigDecimal(val);\n }\n 
125	public BigReal(BigInteger unscaledVal, int scale) {\n d = new BigDecimal(unscaledVal, scale);\n }\n 
126	public BigReal(BigInteger unscaledVal, int scale, MathContext mc) {\n d = new BigDecimal(unscaledVal, scale, mc);\n }\n 
127	public BigReal(BigInteger val, MathContext mc) {\n d = new BigDecimal(val, mc);\n }\n 
128	public BigReal(char[] in) {\n d = new BigDecimal(in);\n }\n 
129	public BigReal(char[] in, int offset, int len) {\n d = new BigDecimal(in, offset, len);\n }\n 
130	public BigReal(char[] in, int offset, int len, MathContext mc) {\n d = new BigDecimal(in, offset, len, mc);\n }\n 
131	public BigReal(char[] in, MathContext mc) {\n d = new BigDecimal(in, mc);\n }\n 
132	public BigReal(double val) {\n d = new BigDecimal(val);\n }\n 
133	public BigReal(double val, MathContext mc) {\n d = new BigDecimal(val, mc);\n }\n 
134	public BigReal(int val) {\n d = new BigDecimal(val);\n }\n 
135	public BigReal(int val, MathContext mc) {\n d = new BigDecimal(val, mc);\n }\n 
136	public BigReal(long val) {\n d = new BigDecimal(val);\n }\n 
137	public BigReal(long val, MathContext mc) {\n d = new BigDecimal(val, mc);\n }\n 
138	public BigReal(String val) {\n d = new BigDecimal(val);\n }\n 
139	public BigReal(String val, MathContext mc)  {\n d = new BigDecimal(val, mc);\n }\n 
140	public RoundingMode getRoundingMode() {\n return roundingMode;\n }\n 
141	public void setRoundingMode(RoundingMode roundingMode) {\n this.roundingMode = roundingMode;\n }\n 
142	public int getScale() {\n return scale;\n }\n 
143	public void setScale(int scale) {\n this.scale = scale;\n }\n 
144	public BigReal add(BigReal a) {\n return new BigReal(d.add(a.d));\n }\n 
145	public BigReal subtract(BigReal a) {\n return new BigReal(d.subtract(a.d));\n }\n 
146	public BigReal negate() {\n return new BigReal(d.negate());\n }\n 
147	public BigReal divide(BigReal a) throws MathArithmeticException {\n try {\n return new BigReal(d.divide(a.d, scale, roundingMode));\n } catch (ArithmeticException e) {\n // Division by zero has occurred\n throw new MathArithmeticException(LocalizedFormats.ZERO_NOT_ALLOWED);\n }\n }\n 
148	public BigReal reciprocal() throws MathArithmeticException {\n try {\n return new BigReal(BigDecimal.ONE.divide(d, scale, roundingMode));\n } catch (ArithmeticException e) {\n // Division by zero has occurred\n throw new MathArithmeticException(LocalizedFormats.ZERO_NOT_ALLOWED);\n }\n }\n 
149	public BigReal multiply(BigReal a) {\n return new BigReal(d.multiply(a.d));\n }\n 
150	public BigReal multiply(final int n) {\n return new BigReal(d.multiply(new BigDecimal(n)));\n }\n 
151	public int compareTo(BigReal a) {\n return d.compareTo(a.d);\n }\n 
152	public double doubleValue() {\n return d.doubleValue();\n }\n 
153	public BigDecimal bigDecimalValue() {\n return d;\n }\n 
154	@Override\n public boolean equals(Object other) {\n if (this == other){\n return true;\n }\n if (other instanceof BigReal){\n return d.equals(((BigReal) other).d);\n }\n return false;\n }\n 
155	@Override\n public int hashCode() {\n return d.hashCode();\n }\n 
156	public Field<BigReal> getField() {\n return BigRealField.getInstance();\n }\n 
157	public IllinoisSolver() {\n super(DEFAULT_ABSOLUTE_ACCURACY, Method.ILLINOIS);\n }\n 
158	public IllinoisSolver(final double absoluteAccuracy) {\n super(absoluteAccuracy, Method.ILLINOIS);\n }\n 
159	public IllinoisSolver(final double relativeAccuracy,\n final double absoluteAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, Method.ILLINOIS);\n }\n 
160	public IllinoisSolver(final double relativeAccuracy,\n final double absoluteAccuracy,\n final double functionValueAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, Method.PEGASUS);\n }\n 
161	public Vector3D(double x, double y, double z) {\n this.x = x;\n this.y = y;\n this.z = z;\n }\n 
162	public Vector3D(double[] v) throws DimensionMismatchException {\n if (v.length != 3) {\n throw new DimensionMismatchException(v.length, 3);\n }\n this.x = v[0];\n this.y = v[1];\n this.z = v[2];\n }\n 
163	public Vector3D(double alpha, double delta) {\n double cosDelta = FastMath.cos(delta);\n this.x = FastMath.cos(alpha) * cosDelta;\n this.y = FastMath.sin(alpha) * cosDelta;\n this.z = FastMath.sin(delta);\n }\n 
164	public Vector3D(double a, Vector3D u) {\n this.x = a * u.x;\n this.y = a * u.y;\n this.z = a * u.z;\n }\n 
165	public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n }\n 
166	public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n double a3, Vector3D u3) {\n this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n }\n 
167	public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n double a3, Vector3D u3, double a4, Vector3D u4) {\n this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);\n this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);\n this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);\n }\n 
168	public double getX() {\n return x;\n }\n 
169	public double getY() {\n return y;\n }\n 
170	public double getZ() {\n return z;\n }\n 
171	public double[] toArray() {\n return new double[] { x, y, z };\n }\n 
172	public Space getSpace() {\n return Euclidean3D.getInstance();\n }\n 
173	public Vector3D getZero() {\n return ZERO;\n }\n 
174	public double getNorm1() {\n return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n }\n 
175	public double getNorm() {\n // there are no cancellation problems here, so we use the straightforward formula\n return FastMath.sqrt (x * x + y * y + z * z);\n }\n 
176	public double getNormSq() {\n // there are no cancellation problems here, so we use the straightforward formula\n return x * x + y * y + z * z;\n }\n 
177	public double getNormInf() {\n return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n }\n 
178	public double getAlpha() {\n return FastMath.atan2(y, x);\n }\n 
179	public double getDelta() {\n return FastMath.asin(z / getNorm());\n }\n 
180	public Vector3D add(final Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n return new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n }\n 
181	public Vector3D add(double factor, final Vector<Euclidean3D> v) {\n return new Vector3D(1, this, factor, (Vector3D) v);\n }\n 
182	public Vector3D subtract(final Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n }\n 
183	public Vector3D subtract(final double factor, final Vector<Euclidean3D> v) {\n return new Vector3D(1, this, -factor, (Vector3D) v);\n }\n 
184	public Vector3D normalize() throws MathArithmeticException {\n double s = getNorm();\n if (s == 0) {\n throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n }\n return scalarMultiply(1 / s);\n }\n 
185	public Vector3D orthogonal() throws MathArithmeticException {\n double threshold = 0.6 * getNorm();\n if (threshold == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n }\n if (FastMath.abs(x) <= threshold) {\n double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n return new Vector3D(0, inverse * z, -inverse * y);\n } else if (FastMath.abs(y) <= threshold) {\n double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n return new Vector3D(-inverse * z, 0, inverse * x);\n }\n double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n return new Vector3D(inverse * y, -inverse * x, 0);\n }\n 
186	public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n double normProduct = v1.getNorm() * v2.getNorm();\n if (normProduct == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n }\n double dot = v1.dotProduct(v2);\n double threshold = normProduct * 0.9999;\n if ((dot < -threshold) || (dot > threshold)) {\n // the vectors are almost aligned, compute using the sine\n Vector3D v3 = crossProduct(v1, v2);\n if (dot >= 0) {\n return FastMath.asin(v3.getNorm() / normProduct);\n }\n return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n }\n // the vectors are sufficiently separated to use the cosine\n return FastMath.acos(dot / normProduct);\n }\n 
187	public Vector3D negate() {\n return new Vector3D(-x, -y, -z);\n }\n 
188	public Vector3D scalarMultiply(double a) {\n return new Vector3D(a * x, a * y, a * z);\n }\n 
189	public boolean isNaN() {\n return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n }\n 
190	public boolean isInfinite() {\n return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n }\n 
191	@Override\n public boolean equals(Object other) {\n if (this == other) {\n return true;\n }\n if (other instanceof Vector3D) {\n final Vector3D rhs = (Vector3D)other;\n if (rhs.isNaN()) {\n return this.isNaN();\n }\n return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n }\n return false;\n }\n 
192	@Override\n public int hashCode() {\n if (isNaN()) {\n return 642;\n }\n return 643 * (164 * MathUtils.hash(x) +  3 * MathUtils.hash(y) +  MathUtils.hash(z));\n }\n 
193	public double dotProduct(final Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n }\n 
194	public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n return new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),\n MathArrays.linearCombination(z, v3.x, -x, v3.z),\n MathArrays.linearCombination(x, v3.y, -y, v3.x));\n }\n 
195	public double distance1(Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n final double dx = FastMath.abs(v3.x - x);\n final double dy = FastMath.abs(v3.y - y);\n final double dz = FastMath.abs(v3.z - z);\n return dx + dy + dz;\n }\n 
196	public double distance(Vector<Euclidean3D> v) {\n return distance((Point<Euclidean3D>) v);\n }\n 
197	public double distance(Point<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n final double dx = v3.x - x;\n final double dy = v3.y - y;\n final double dz = v3.z - z;\n return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n }\n 
198	public double distanceInf(Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n final double dx = FastMath.abs(v3.x - x);\n final double dy = FastMath.abs(v3.y - y);\n final double dz = FastMath.abs(v3.z - z);\n return FastMath.max(FastMath.max(dx, dy), dz);\n }\n 
199	public double distanceSq(Vector<Euclidean3D> v) {\n final Vector3D v3 = (Vector3D) v;\n final double dx = v3.x - x;\n final double dy = v3.y - y;\n final double dz = v3.z - z;\n return dx * dx + dy * dy + dz * dz;\n }\n 
200	public static double dotProduct(Vector3D v1, Vector3D v2) {\n return v1.dotProduct(v2);\n }\n 
201	public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n return v1.crossProduct(v2);\n }\n 
202	public static double distance1(Vector3D v1, Vector3D v2) {\n return v1.distance1(v2);\n }\n 
203	public static double distance(Vector3D v1, Vector3D v2) {\n return v1.distance(v2);\n }\n 
204	public static double distanceInf(Vector3D v1, Vector3D v2) {\n return v1.distanceInf(v2);\n }\n 
205	public static double distanceSq(Vector3D v1, Vector3D v2) {\n return v1.distanceSq(v2);\n }\n 
206	@Override\n public String toString() {\n return Vector3DFormat.getInstance().format(this);\n }\n 
207	public String toString(final NumberFormat format) {\n return new Vector3DFormat(format).format(this);\n }\n 
208	public ExceptionContext(final Throwable throwable) {\n this.throwable = throwable;\n msgPatterns    = new ArrayList<Localizable>();\n msgArguments   = new ArrayList<Object[]>();\n context        = new HashMap<String, Object>();\n }\n 
209	public Throwable getThrowable() {\n return throwable;\n }\n 
210	public void addMessage(Localizable pattern,\n Object ... arguments) {\n msgPatterns.add(pattern);\n msgArguments.add(ArgUtils.flatten(arguments));\n }\n 
211	public void setValue(String key, Object value) {\n context.put(key, value);\n }\n 
212	public Object getValue(String key) {\n return context.get(key);\n }\n 
213	public Set<String> getKeys() {\n return context.keySet();\n }\n 
214	public String getMessage() {\n return getMessage(Locale.US);\n }\n 
215	public String getLocalizedMessage() {\n return getMessage(Locale.getDefault());\n }\n 
216	public String getMessage(final Locale locale) {\n return buildMessage(locale, ": ");\n }\n 
217	public String getMessage(final Locale locale,\n final String separator) {\n return buildMessage(locale, separator);\n }\n 
218	private String buildMessage(Locale locale,\n String separator) {\n final StringBuilder sb = new StringBuilder();\n int count = 0;\n final int len = msgPatterns.size();\n for (int i = 0; i < len; i++) {\n final Localizable pat = msgPatterns.get(i);\n final Object[] args = msgArguments.get(i);\n final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n locale);\n sb.append(fmt.format(args));\n if (++count < len) {\n // Add a separator if there are other messages.\n sb.append(separator);\n }\n }\n return sb.toString();\n }\n 
219	private void writeObject(ObjectOutputStream out)\n throws IOException {\n out.writeObject(throwable);\n serializeMessages(out);\n serializeContext(out);\n }\n 
220	private void readObject(ObjectInputStream in)\n throws IOException,\n ClassNotFoundException {\n throwable = (Throwable) in.readObject();\n deSerializeMessages(in);\n deSerializeContext(in);\n }\n 
221	private void serializeMessages(ObjectOutputStream out)\n throws IOException {\n // Step 1.\n final int len = msgPatterns.size();\n out.writeInt(len);\n // Step 2.\n for (int i = 0; i < len; i++) {\n final Localizable pat = msgPatterns.get(i);\n // Step 3.\n out.writeObject(pat);\n final Object[] args = msgArguments.get(i);\n final int aLen = args.length;\n // Step 4.\n out.writeInt(aLen);\n for (int j = 0; j < aLen; j++) {\n if (args[j] instanceof Serializable) {\n // Step 5a.\n out.writeObject(args[j]);\n } else {\n // Step 5b.\n out.writeObject(nonSerializableReplacement(args[j]));\n }\n }\n }\n }\n 
222	private void deSerializeMessages(ObjectInputStream in)\n throws IOException,\n ClassNotFoundException {\n // Step 1.\n final int len = in.readInt();\n msgPatterns = new ArrayList<Localizable>(len);\n msgArguments = new ArrayList<Object[]>(len);\n // Step 2.\n for (int i = 0; i < len; i++) {\n // Step 3.\n final Localizable pat = (Localizable) in.readObject();\n msgPatterns.add(pat);\n // Step 4.\n final int aLen = in.readInt();\n final Object[] args = new Object[aLen];\n for (int j = 0; j < aLen; j++) {\n // Step 5.\n args[j] = in.readObject();\n }\n msgArguments.add(args);\n }\n }\n 
223	private void serializeContext(ObjectOutputStream out)\n throws IOException {\n // Step 1.\n final int len = context.size();\n out.writeInt(len);\n for (Map.Entry<String, Object> entry : context.entrySet()) {\n // Step 2.\n out.writeObject(entry.getKey());\n final Object value = entry.getValue();\n if (value instanceof Serializable) {\n // Step 3a.\n out.writeObject(value);\n } else {\n // Step 3b.\n out.writeObject(nonSerializableReplacement(value));\n }\n }\n }\n 
224	private void deSerializeContext(ObjectInputStream in)\n throws IOException,\n ClassNotFoundException {\n // Step 1.\n final int len = in.readInt();\n context = new HashMap<String, Object>();\n for (int i = 0; i < len; i++) {\n // Step 2.\n final String key = (String) in.readObject();\n // Step 3.\n final Object value = in.readObject();\n context.put(key, value);\n }\n }\n 
225	private String nonSerializableReplacement(Object obj) {\n return "[Object could not be serialized: " + obj.getClass().getName() + "]";\n }\n 
226	@Override\n public void addToEntry(int index, double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
227	protected void checkVectorDimensions(RealVector v)\n throws DimensionMismatchException {\n checkVectorDimensions(v.getDimension());\n }\n 
228	protected void checkVectorDimensions(int n)\n throws DimensionMismatchException {\n int d = getDimension();\n if (d != n) {\n throw new DimensionMismatchException(d, n);\n }\n }\n 
229	protected void checkIndex(final int index) throws OutOfRangeException {\n if (index < 0 ||\n index >= getDimension()) {\n throw new OutOfRangeException(LocalizedFormats.INDEX,\n index, 0, getDimension() - 1);\n }\n }\n 
230	protected void checkIndices(final int start, final int end)\n throws NumberIsTooSmallException, OutOfRangeException {\n final int dim = getDimension();\n if ((start < 0) || (start >= dim)) {\n throw new OutOfRangeException(LocalizedFormats.INDEX, start, 0,\n dim - 1);\n }\n if ((end < 0) || (end >= dim)) {\n throw new OutOfRangeException(LocalizedFormats.INDEX, end, 0,\n dim - 1);\n }\n if (end < start) {\n // TODO Use more specific error message\n throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n end, start, false);\n }\n }\n 
231	@Override\n public RealVector add(RealVector w)\n throws DimensionMismatchException {\n return v.add(w);\n }\n 
232	@Override\n public RealVector subtract(RealVector w)\n throws DimensionMismatchException {\n return v.subtract(w);\n }\n 
233	@Override\n public RealVector mapAdd(double d) {\n return v.mapAdd(d);\n }\n 
234	@Override\n public RealVector mapAddToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
235	@Override\n public double dotProduct(RealVector w)\n throws DimensionMismatchException {\n return v.dotProduct(w);\n }\n 
236	@Override\n public double cosine(RealVector w)\n throws DimensionMismatchException, MathArithmeticException {\n return v.cosine(w);\n }\n 
237	@Override\n public double getDistance(RealVector w)\n throws DimensionMismatchException {\n return v.getDistance(w);\n }\n 
238	@Override\n public double getNorm() {\n return v.getNorm();\n }\n 
239	@Override\n public double getL1Norm() {\n return v.getL1Norm();\n }\n 
240	@Override\n public double getLInfNorm() {\n return v.getLInfNorm();\n }\n 
241	@Override\n public double getL1Distance(RealVector w)\n throws DimensionMismatchException {\n return v.getL1Distance(w);\n }\n 
242	@Override\n public double getLInfDistance(RealVector w)\n throws DimensionMismatchException {\n return v.getLInfDistance(w);\n }\n 
243	public int getMinIndex() {\n int minIndex    = -1;\n double minValue = Double.POSITIVE_INFINITY;\n Iterator<Entry> iterator = iterator();\n while (iterator.hasNext()) {\n final Entry entry = iterator.next();\n if (entry.getValue() <= minValue) {\n minIndex = entry.getIndex();\n minValue = entry.getValue();\n }\n }\n return minIndex;\n }\n 
244	public double getMinValue() {\n final int minIndex = getMinIndex();\n return minIndex < 0 ? Double.NaN : getEntry(minIndex);\n }\n 
245	public int getMaxIndex() {\n int maxIndex    = -1;\n double maxValue = Double.NEGATIVE_INFINITY;\n Iterator<Entry> iterator = iterator();\n while (iterator.hasNext()) {\n final Entry entry = iterator.next();\n if (entry.getValue() >= maxValue) {\n maxIndex = entry.getIndex();\n maxValue = entry.getValue();\n }\n }\n return maxIndex;\n }\n 
246	public double getMaxValue() {\n final int maxIndex = getMaxIndex();\n return maxIndex < 0 ? Double.NaN : getEntry(maxIndex);\n }\n 
247	@Override\n public RealVector mapMultiply(double d) {\n return v.mapMultiply(d);\n }\n 
248	@Override\n public RealVector mapMultiplyToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
249	@Override\n public RealVector mapSubtract(double d) {\n return v.mapSubtract(d);\n }\n 
250	@Override\n public RealVector mapSubtractToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
251	@Override\n public RealVector mapDivide(double d) {\n return v.mapDivide(d);\n }\n 
252	@Override\n public RealVector mapDivideToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
253	@Override\n public RealMatrix outerProduct(RealVector w) {\n return v.outerProduct(w);\n }\n 
254	public RealVector projection(final RealVector v)\n throws DimensionMismatchException, MathArithmeticException {\n final double norm2 = v.dotProduct(v);\n if (norm2 == 0.0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n }\n return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n }\n 
255	@Override\n public void set(double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
256	@Override\n public double[] toArray() {\n return v.toArray();\n }\n 
257	@Override\n public RealVector unitVector() throws MathArithmeticException {\n return v.unitVector();\n }\n 
258	@Override\n public void unitize() throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
259	@Override\n public Iterator<Entry> sparseIterator() {\n final Iterator<Entry> i = v.sparseIterator();\n return new Iterator<Entry>() {\n /** The current entry. */\n private final UnmodifiableEntry e = new UnmodifiableEntry();\n /** {@inheritDoc} */\n public boolean hasNext() {\n return i.hasNext();\n }\n /** {@inheritDoc} */\n public Entry next() {\n e.setIndex(i.next().getIndex());\n return e;\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n public void remove()\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n };\n }\n 
260	@Override\n public Iterator<Entry> iterator() {\n final Iterator<Entry> i = v.iterator();\n return new Iterator<Entry>() {\n /** The current entry. */\n private final UnmodifiableEntry e = new UnmodifiableEntry();\n /** {@inheritDoc} */\n public boolean hasNext() {\n return i.hasNext();\n }\n /** {@inheritDoc} */\n public Entry next() {\n e.setIndex(i.next().getIndex());\n return e;\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n public void remove() throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n };\n }\n 
261	public boolean hasNext() {\n return i.hasNext();\n }\n 
262	public Entry next() {\n e.setIndex(i.next().getIndex());\n return e;\n }\n 
263	public void remove()\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
264	@Override\n public RealVector map(UnivariateFunction function) {\n return v.map(function);\n }\n 
265	@Override\n public RealVector mapToSelf(UnivariateFunction function)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
266	@Override\n public RealVector combine(double a, double b, RealVector y)\n throws DimensionMismatchException {\n return v.combine(a, b, y);\n }\n 
267	@Override\n public RealVector combineToSelf(double a, double b, RealVector y)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
268	public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor) {\n final int dim = getDimension();\n visitor.start(dim, 0, dim - 1);\n for (int i = 0; i < dim; i++) {\n visitor.visit(i, getEntry(i));\n }\n return visitor.end();\n }\n 
269	public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,\n final int start, final int end)\n throws NumberIsTooSmallException, OutOfRangeException {\n checkIndices(start, end);\n visitor.start(getDimension(), start, end);\n for (int i = start; i <= end; i++) {\n visitor.visit(i, getEntry(i));\n }\n return visitor.end();\n }\n 
270	public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor) {\n return walkInDefaultOrder(visitor);\n }\n 
271	public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor,\n final int start, final int end)\n throws NumberIsTooSmallException, OutOfRangeException {\n return walkInDefaultOrder(visitor, start, end);\n }\n 
272	public double walkInDefaultOrder(final RealVectorChangingVisitor visitor) {\n final int dim = getDimension();\n visitor.start(dim, 0, dim - 1);\n for (int i = 0; i < dim; i++) {\n setEntry(i, visitor.visit(i, getEntry(i)));\n }\n return visitor.end();\n }\n 
273	public double walkInDefaultOrder(final RealVectorChangingVisitor visitor,\n final int start, final int end)\n throws NumberIsTooSmallException, OutOfRangeException {\n checkIndices(start, end);\n visitor.start(getDimension(), start, end);\n for (int i = start; i <= end; i++) {\n setEntry(i, visitor.visit(i, getEntry(i)));\n }\n return visitor.end();\n }\n 
274	public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) {\n return walkInDefaultOrder(visitor);\n }\n 
275	public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor,\n final int start, final int end)\n throws NumberIsTooSmallException, OutOfRangeException {\n return walkInDefaultOrder(visitor, start, end);\n }\n 
276	public Entry() {\n setIndex(0);\n }\n 
277	public double getValue() {\n return getEntry(getIndex());\n }\n 
278	public void setValue(double value) {\n setEntry(getIndex(), value);\n }\n 
279	public int getIndex() {\n return index;\n }\n 
280	public void setIndex(int index) {\n this.index = index;\n }\n 
281	@Override\n public boolean equals(Object other)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
282	@Override\n public int hashCode() throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
283	protected SparseEntryIterator() {\n dim = getDimension();\n current = new Entry();\n next = new Entry();\n if (next.getValue() == 0) {\n advance(next);\n }\n }\n 
284	protected void advance(Entry e) {\n if (e == null) {\n return;\n }\n do {\n e.setIndex(e.getIndex() + 1);\n } while (e.getIndex() < dim && e.getValue() == 0);\n if (e.getIndex() >= dim) {\n e.setIndex(-1);\n }\n }\n 
285	public boolean hasNext() {\n return next.getIndex() >= 0;\n }\n 
286	public Entry next() {\n int index = next.getIndex();\n if (index < 0) {\n throw new NoSuchElementException();\n }\n current.setIndex(index);\n advance(next);\n return current;\n }\n 
287	public void remove() throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
288	public static RealVector unmodifiableRealVector(final RealVector v) {\n /**\n * This anonymous class is an implementation of {@link RealVector}\n * with read-only access.\n * It wraps any {@link RealVector}, and exposes all methods which\n * do not modify it. Invoking methods which should normally result\n * in the modification of the calling {@link RealVector} results in\n * a {@link MathUnsupportedOperationException}. It should be noted\n * that {@link UnmodifiableVector} is <em>not</em> immutable.\n */\n return new RealVector() {\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all circumstances.\n */\n @Override\n public RealVector mapToSelf(UnivariateFunction function)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector map(UnivariateFunction function) {\n return v.map(function);\n }\n /** {@inheritDoc} */\n @Override\n public Iterator<Entry> iterator() {\n final Iterator<Entry> i = v.iterator();\n return new Iterator<Entry>() {\n /** The current entry. */\n private final UnmodifiableEntry e = new UnmodifiableEntry();\n /** {@inheritDoc} */\n public boolean hasNext() {\n return i.hasNext();\n }\n /** {@inheritDoc} */\n public Entry next() {\n e.setIndex(i.next().getIndex());\n return e;\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n public void remove() throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n };\n }\n /** {@inheritDoc} */\n @Override\n public Iterator<Entry> sparseIterator() {\n final Iterator<Entry> i = v.sparseIterator();\n return new Iterator<Entry>() {\n /** The current entry. */\n private final UnmodifiableEntry e = new UnmodifiableEntry();\n /** {@inheritDoc} */\n public boolean hasNext() {\n return i.hasNext();\n }\n /** {@inheritDoc} */\n public Entry next() {\n e.setIndex(i.next().getIndex());\n return e;\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n public void remove()\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n };\n }\n /** {@inheritDoc} */\n @Override\n public RealVector copy() {\n return v.copy();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector add(RealVector w)\n throws DimensionMismatchException {\n return v.add(w);\n }\n /** {@inheritDoc} */\n @Override\n public RealVector subtract(RealVector w)\n throws DimensionMismatchException {\n return v.subtract(w);\n }\n /** {@inheritDoc} */\n @Override\n public RealVector mapAdd(double d) {\n return v.mapAdd(d);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public RealVector mapAddToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector mapSubtract(double d) {\n return v.mapSubtract(d);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public RealVector mapSubtractToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector mapMultiply(double d) {\n return v.mapMultiply(d);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public RealVector mapMultiplyToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector mapDivide(double d) {\n return v.mapDivide(d);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public RealVector mapDivideToSelf(double d)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector ebeMultiply(RealVector w)\n throws DimensionMismatchException {\n return v.ebeMultiply(w);\n }\n /** {@inheritDoc} */\n @Override\n public RealVector ebeDivide(RealVector w)\n throws DimensionMismatchException {\n return v.ebeDivide(w);\n }\n /** {@inheritDoc} */\n @Override\n public double dotProduct(RealVector w)\n throws DimensionMismatchException {\n return v.dotProduct(w);\n }\n /** {@inheritDoc} */\n @Override\n public double cosine(RealVector w)\n throws DimensionMismatchException, MathArithmeticException {\n return v.cosine(w);\n }\n /** {@inheritDoc} */\n @Override\n public double getNorm() {\n return v.getNorm();\n }\n /** {@inheritDoc} */\n @Override\n public double getL1Norm() {\n return v.getL1Norm();\n }\n /** {@inheritDoc} */\n @Override\n public double getLInfNorm() {\n return v.getLInfNorm();\n }\n /** {@inheritDoc} */\n @Override\n public double getDistance(RealVector w)\n throws DimensionMismatchException {\n return v.getDistance(w);\n }\n /** {@inheritDoc} */\n @Override\n public double getL1Distance(RealVector w)\n throws DimensionMismatchException {\n return v.getL1Distance(w);\n }\n /** {@inheritDoc} */\n @Override\n public double getLInfDistance(RealVector w)\n throws DimensionMismatchException {\n return v.getLInfDistance(w);\n }\n /** {@inheritDoc} */\n @Override\n public RealVector unitVector() throws MathArithmeticException {\n return v.unitVector();\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public void unitize() throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public RealMatrix outerProduct(RealVector w) {\n return v.outerProduct(w);\n }\n /** {@inheritDoc} */\n @Override\n public double getEntry(int index) throws OutOfRangeException {\n return v.getEntry(index);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public void setEntry(int index, double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public void addToEntry(int index, double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public int getDimension() {\n return v.getDimension();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector append(RealVector w) {\n return v.append(w);\n }\n /** {@inheritDoc} */\n @Override\n public RealVector append(double d) {\n return v.append(d);\n }\n /** {@inheritDoc} */\n @Override\n public RealVector getSubVector(int index, int n)\n throws OutOfRangeException, NotPositiveException {\n return v.getSubVector(index, n);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public void setSubVector(int index, RealVector w)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public void set(double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** {@inheritDoc} */\n @Override\n public double[] toArray() {\n return v.toArray();\n }\n /** {@inheritDoc} */\n @Override\n public boolean isNaN() {\n return v.isNaN();\n }\n /** {@inheritDoc} */\n @Override\n public boolean isInfinite() {\n return v.isInfinite();\n }\n /** {@inheritDoc} */\n @Override\n public RealVector combine(double a, double b, RealVector y)\n throws DimensionMismatchException {\n return v.combine(a, b, y);\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public RealVector combineToSelf(double a, double b, RealVector y)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n /** An entry in the vector. */\n class UnmodifiableEntry extends Entry {\n /** {@inheritDoc} */\n @Override\n public double getValue() {\n return v.getEntry(getIndex());\n }\n /**\n * {@inheritDoc}\n *\n * @throws MathUnsupportedOperationException in all\n * circumstances.\n */\n @Override\n public void setValue(double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n }\n };\n }\n 
289	@Override\n public RealVector copy() {\n return v.copy();\n }\n 
290	@Override\n public RealVector ebeMultiply(RealVector w)\n throws DimensionMismatchException {\n return v.ebeMultiply(w);\n }\n 
291	@Override\n public RealVector ebeDivide(RealVector w)\n throws DimensionMismatchException {\n return v.ebeDivide(w);\n }\n 
292	@Override\n public double getEntry(int index) throws OutOfRangeException {\n return v.getEntry(index);\n }\n 
293	@Override\n public void setEntry(int index, double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
294	@Override\n public int getDimension() {\n return v.getDimension();\n }\n 
295	@Override\n public RealVector append(RealVector w) {\n return v.append(w);\n }\n 
296	@Override\n public RealVector append(double d) {\n return v.append(d);\n }\n 
297	@Override\n public RealVector getSubVector(int index, int n)\n throws OutOfRangeException, NotPositiveException {\n return v.getSubVector(index, n);\n }\n 
298	@Override\n public void setSubVector(int index, RealVector w)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
299	@Override\n public boolean isNaN() {\n return v.isNaN();\n }\n 
300	@Override\n public boolean isInfinite() {\n return v.isInfinite();\n }\n 
301	@Override\n public double getValue() {\n return v.getEntry(getIndex());\n }\n 
302	@Override\n public void setValue(double value)\n throws MathUnsupportedOperationException {\n throw new MathUnsupportedOperationException();\n }\n 
303	public RealVectorFormat() {\n this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n CompositeFormat.getDefaultNumberFormat());\n }\n 
304	public RealVectorFormat(final NumberFormat format) {\n this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n }\n 
305	public RealVectorFormat(final String prefix, final String suffix,\n final String separator) {\n this(prefix, suffix, separator,\n CompositeFormat.getDefaultNumberFormat());\n }\n 
306	public RealVectorFormat(final String prefix, final String suffix,\n final String separator, final NumberFormat format) {\n this.prefix      = prefix;\n this.suffix      = suffix;\n this.separator   = separator;\n trimmedPrefix    = prefix.trim();\n trimmedSuffix    = suffix.trim();\n trimmedSeparator = separator.trim();\n this.format      = format;\n }\n 
307	public static Locale[] getAvailableLocales() {\n return NumberFormat.getAvailableLocales();\n }\n 
308	public String getPrefix() {\n return prefix;\n }\n 
309	public String getSuffix() {\n return suffix;\n }\n 
310	public String getSeparator() {\n return separator;\n }\n 
311	public NumberFormat getFormat() {\n return format;\n }\n 
312	public static RealVectorFormat getInstance() {\n return getInstance(Locale.getDefault());\n }\n 
313	public static RealVectorFormat getInstance(final Locale locale) {\n return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n }\n 
314	public String format(RealVector v) {\n return format(v, new StringBuffer(), new FieldPosition(0)).toString();\n }\n 
315	public StringBuffer format(RealVector vector, StringBuffer toAppendTo,\n FieldPosition pos) {\n pos.setBeginIndex(0);\n pos.setEndIndex(0);\n // format prefix\n toAppendTo.append(prefix);\n // format components\n for (int i = 0; i < vector.getDimension(); ++i) {\n if (i > 0) {\n toAppendTo.append(separator);\n }\n CompositeFormat.formatDouble(vector.getEntry(i), format, toAppendTo, pos);\n }\n // format suffix\n toAppendTo.append(suffix);\n return toAppendTo;\n }\n 
316	public ArrayRealVector parse(String source) {\n final ParsePosition parsePosition = new ParsePosition(0);\n final ArrayRealVector result = parse(source, parsePosition);\n if (parsePosition.getIndex() == 0) {\n throw new MathParseException(source,\n parsePosition.getErrorIndex(),\n ArrayRealVector.class);\n }\n return result;\n }\n 
317	public ArrayRealVector parse(String source, ParsePosition pos) {\n int initialIndex = pos.getIndex();\n // parse prefix\n CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n return null;\n }\n // parse components\n List<Number> components = new ArrayList<Number>();\n for (boolean loop = true; loop;){\n if (!components.isEmpty()) {\n CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n loop = false;\n }\n }\n if (loop) {\n CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n Number component = CompositeFormat.parseNumber(source, format, pos);\n if (component != null) {\n components.add(component);\n } else {\n // invalid component\n // set index back to initial, error index should already be set\n pos.setIndex(initialIndex);\n return null;\n }\n }\n }\n // parse suffix\n CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n return null;\n }\n // build vector\n double[] data = new double[components.size()];\n for (int i = 0; i < data.length; ++i) {\n data[i] = components.get(i).doubleValue();\n }\n return new ArrayRealVector(data, false);\n }\n 
318	public Fraction(double value) throws FractionConversionException {\n this(value, DEFAULT_EPSILON, 100);\n }\n 
319	public Fraction(double value, double epsilon, int maxIterations)\n throws FractionConversionException\n {\n this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n }\n 
320	public Fraction(double value, int maxDenominator)\n throws FractionConversionException\n {\n this(value, 0, maxDenominator, 100);\n }\n 
321	private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n throws FractionConversionException\n {\n long overflow = Integer.MAX_VALUE;\n double r0 = value;\n long a0 = (long)FastMath.floor(r0);\n if (FastMath.abs(a0) > overflow) {\n throw new FractionConversionException(value, a0, 1l);\n }\n // check for (almost) integer arguments, which should not go to iterations.\n if (FastMath.abs(a0 - value) < epsilon) {\n this.numerator = (int) a0;\n this.denominator = 1;\n return;\n }\n long p0 = 1;\n long q0 = 0;\n long p1 = a0;\n long q1 = 1;\n long p2 = 0;\n long q2 = 1;\n int n = 0;\n boolean stop = false;\n do {\n ++n;\n double r1 = 1.0 / (r0 - a0);\n long a1 = (long)FastMath.floor(r1);\n p2 = (a1 * p1) + p0;\n q2 = (a1 * q1) + q0;\n if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n // in maxDenominator mode, if the last fraction was very close to the actual value\n // q2 may overflow in the next iteration; in this case return the last one.\n if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n break;\n }\n throw new FractionConversionException(value, p2, q2);\n }\n double convergent = (double)p2 / (double)q2;\n if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n p0 = p1;\n p1 = p2;\n q0 = q1;\n q1 = q2;\n a0 = a1;\n r0 = r1;\n } else {\n stop = true;\n }\n } while (!stop);\n if (n >= maxIterations) {\n throw new FractionConversionException(value, maxIterations);\n }\n if (q2 < maxDenominator) {\n this.numerator = (int) p2;\n this.denominator = (int) q2;\n } else {\n this.numerator = (int) p1;\n this.denominator = (int) q1;\n }\n }\n 
322	public Fraction(int num) {\n this(num, 1);\n }\n 
323	public Fraction(int num, int den) {\n if (den == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n num, den);\n }\n if (den < 0) {\n if (num == Integer.MIN_VALUE ||\n den == Integer.MIN_VALUE) {\n throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n num, den);\n }\n num = -num;\n den = -den;\n }\n // reduce numerator and denominator by greatest common denominator.\n final int d = ArithmeticUtils.gcd(num, den);\n if (d > 1) {\n num /= d;\n den /= d;\n }\n // move sign to numerator.\n if (den < 0) {\n num = -num;\n den = -den;\n }\n this.numerator   = num;\n this.denominator = den;\n }\n 
324	public Fraction abs() {\n Fraction ret;\n if (numerator >= 0) {\n ret = this;\n } else {\n ret = negate();\n }\n return ret;\n }\n 
325	public int compareTo(Fraction object) {\n long nOd = ((long) numerator) * object.denominator;\n long dOn = ((long) denominator) * object.numerator;\n return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n }\n 
326	@Override\n public double doubleValue() {\n return (double)numerator / (double)denominator;\n }\n 
327	@Override\n public boolean equals(Object other) {\n if (this == other) {\n return true;\n }\n if (other instanceof Fraction) {\n // since fractions are always in lowest terms, numerators and\n // denominators can be compared directly for equality.\n Fraction rhs = (Fraction)other;\n return (numerator == rhs.numerator) &&\n (denominator == rhs.denominator);\n }\n return false;\n }\n 
328	@Override\n public float floatValue() {\n return (float)doubleValue();\n }\n 
329	public int getDenominator() {\n return denominator;\n }\n 
330	public int getNumerator() {\n return numerator;\n }\n 
331	@Override\n public int hashCode() {\n return 37 * (37 * 17 + numerator) + denominator;\n }\n 
332	@Override\n public int intValue() {\n return (int)doubleValue();\n }\n 
333	@Override\n public long longValue() {\n return (long)doubleValue();\n }\n 
334	public Fraction negate() {\n if (numerator==Integer.MIN_VALUE) {\n throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n }\n return new Fraction(-numerator, denominator);\n }\n 
335	public Fraction reciprocal() {\n return new Fraction(denominator, numerator);\n }\n 
336	public Fraction add(Fraction fraction) {\n return addSub(fraction, true /* add */);\n }\n 
337	public Fraction add(final int i) {\n return new Fraction(numerator + i * denominator, denominator);\n }\n 
338	public Fraction subtract(Fraction fraction) {\n return addSub(fraction, false /* subtract */);\n }\n 
339	public Fraction subtract(final int i) {\n return new Fraction(numerator - i * denominator, denominator);\n }\n 
340	private Fraction addSub(Fraction fraction, boolean isAdd) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n // zero is identity for addition.\n if (numerator == 0) {\n return isAdd ? fraction : fraction.negate();\n }\n if (fraction.numerator == 0) {\n return this;\n }\n // if denominators are randomly distributed, d1 will be 1 about 61%\n // of the time.\n int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n if (d1==1) {\n // result is ( (u*v' +/- u'v) / u'v')\n int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n return new Fraction\n (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n ArithmeticUtils.subAndCheck(uvp, upv),\n ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n }\n // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n // exercise 7.  we're going to use a BigInteger.\n // t = u(v'/d1) +/- v(u'/d1)\n BigInteger uvp = BigInteger.valueOf(numerator)\n .multiply(BigInteger.valueOf(fraction.denominator/d1));\n BigInteger upv = BigInteger.valueOf(fraction.numerator)\n .multiply(BigInteger.valueOf(denominator/d1));\n BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n // but d2 doesn't need extra precision because\n // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n // result is (t/d2) / (u'/d1)(v'/d2)\n BigInteger w = t.divide(BigInteger.valueOf(d2));\n if (w.bitLength() > 31) {\n throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n w);\n }\n return new Fraction (w.intValue(),\n ArithmeticUtils.mulAndCheck(denominator/d1,\n fraction.denominator/d2));\n }\n 
341	public Fraction multiply(Fraction fraction) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (numerator == 0 || fraction.numerator == 0) {\n return ZERO;\n }\n // knuth 4.5.1\n // make sure we don't overflow unless the result *must* overflow.\n int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n return getReducedFraction\n (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n }\n 
342	public Fraction multiply(final int i) {\n return multiply(new Fraction(i));\n }\n 
343	public Fraction divide(Fraction fraction) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (fraction.numerator == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n fraction.numerator, fraction.denominator);\n }\n return multiply(fraction.reciprocal());\n }\n 
344	public Fraction divide(final int i) {\n return divide(new Fraction(i));\n }\n 
345	public double percentageValue() {\n return 100 * doubleValue();\n }\n 
346	public static Fraction getReducedFraction(int numerator, int denominator) {\n if (denominator == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n numerator, denominator);\n }\n if (numerator==0) {\n return ZERO; // normalize zero.\n }\n // allow 2^k/-2^31 as a valid fraction (where k>0)\n if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n numerator/=2; denominator/=2;\n }\n if (denominator < 0) {\n if (numerator==Integer.MIN_VALUE ||\n denominator==Integer.MIN_VALUE) {\n throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n numerator, denominator);\n }\n numerator = -numerator;\n denominator = -denominator;\n }\n // simplify fraction.\n int gcd = ArithmeticUtils.gcd(numerator, denominator);\n numerator /= gcd;\n denominator /= gcd;\n return new Fraction(numerator, denominator);\n }\n 
347	@Override\n public String toString() {\n String str = null;\n if (denominator == 1) {\n str = Integer.toString(numerator);\n } else if (numerator == 0) {\n str = "0";\n } else {\n str = numerator + " / " + denominator;\n }\n return str;\n }\n 
348	public FractionField getField() {\n return FractionField.getInstance();\n }\n 
349	public BicubicSplineInterpolator() {\n this(false);\n }\n 
350	public BicubicSplineInterpolator(boolean initializeDerivatives) {\n this.initializeDerivatives = initializeDerivatives;\n }\n 
351	public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n final double[] yval,\n final double[][] fval)\n throws NoDataException, DimensionMismatchException,\n NonMonotonicSequenceException, NumberIsTooSmallException {\n if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n throw new NoDataException();\n }\n if (xval.length != fval.length) {\n throw new DimensionMismatchException(xval.length, fval.length);\n }\n MathArrays.checkOrder(xval);\n MathArrays.checkOrder(yval);\n final int xLen = xval.length;\n final int yLen = yval.length;\n // Samples (first index is y-coordinate, i.e. subarray variable is x)\n // 0 <= i < xval.length\n // 0 <= j < yval.length\n // fX[j][i] = f(xval[i], yval[j])\n final double[][] fX = new double[yLen][xLen];\n for (int i = 0; i < xLen; i++) {\n if (fval[i].length != yLen) {\n throw new DimensionMismatchException(fval[i].length, yLen);\n }\n for (int j = 0; j < yLen; j++) {\n fX[j][i] = fval[i][j];\n }\n }\n final SplineInterpolator spInterpolator = new SplineInterpolator();\n // For each line y[j] (0 <= j < yLen), construct a 1D spline with\n // respect to variable x\n final PolynomialSplineFunction[] ySplineX = new PolynomialSplineFunction[yLen];\n for (int j = 0; j < yLen; j++) {\n ySplineX[j] = spInterpolator.interpolate(xval, fX[j]);\n }\n // For each line x[i] (0 <= i < xLen), construct a 1D spline with\n // respect to variable y generated by array fY_1[i]\n final PolynomialSplineFunction[] xSplineY = new PolynomialSplineFunction[xLen];\n for (int i = 0; i < xLen; i++) {\n xSplineY[i] = spInterpolator.interpolate(yval, fval[i]);\n }\n // Partial derivatives with respect to x at the grid knots\n final double[][] dFdX = new double[xLen][yLen];\n for (int j = 0; j < yLen; j++) {\n final UnivariateFunction f = ySplineX[j].derivative();\n for (int i = 0; i < xLen; i++) {\n dFdX[i][j] = f.value(xval[i]);\n }\n }\n // Partial derivatives with respect to y at the grid knots\n final double[][] dFdY = new double[xLen][yLen];\n for (int i = 0; i < xLen; i++) {\n final UnivariateFunction f = xSplineY[i].derivative();\n for (int j = 0; j < yLen; j++) {\n dFdY[i][j] = f.value(yval[j]);\n }\n }\n // Cross partial derivatives\n final double[][] d2FdXdY = new double[xLen][yLen];\n for (int i = 0; i < xLen ; i++) {\n final int nI = nextIndex(i, xLen);\n final int pI = previousIndex(i);\n for (int j = 0; j < yLen; j++) {\n final int nJ = nextIndex(j, yLen);\n final int pJ = previousIndex(j);\n d2FdXdY[i][j] = (fval[nI][nJ] - fval[nI][pJ] -\n fval[pI][nJ] + fval[pI][pJ]) /\n ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));\n }\n }\n // Create the interpolating splines\n return new BicubicSplineInterpolatingFunction(xval, yval, fval,\n dFdX, dFdY, d2FdXdY,\n initializeDerivatives);\n }\n 
352	private int nextIndex(int i, int max) {\n final int index = i + 1;\n return index < max ? index : index - 1;\n }\n 
353	private int previousIndex(int i) {\n final int index = i - 1;\n return index >= 0 ? index : 0;\n }\n 
354	private PolynomialsUtils() {\n }\n 
355	public static PolynomialFunction createChebyshevPolynomial(final int degree) {\n return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS,\n new RecurrenceCoefficientsGenerator() {\n /** Fixed recurrence coefficients. */\n private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE };\n /** {@inheritDoc} */\n public BigFraction[] generate(int k) {\n return coeffs;\n }\n });\n }\n 
356	public BigFraction[] generate(int k) {\n k++;\n final int kvw      = k + v + w;\n final int twoKvw   = kvw + k;\n final int twoKvwM1 = twoKvw - 1;\n final int twoKvwM2 = twoKvw - 2;\n final int den      = 2 * k *  kvw * twoKvwM2;\n return new BigFraction[] {\n new BigFraction(twoKvwM1 * (v * v - w * w), den),\n new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den),\n new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den)\n };\n }\n 
357	public static PolynomialFunction createHermitePolynomial(final int degree) {\n return buildPolynomial(degree, HERMITE_COEFFICIENTS,\n new RecurrenceCoefficientsGenerator() {\n /** {@inheritDoc} */\n public BigFraction[] generate(int k) {\n return new BigFraction[] {\n BigFraction.ZERO,\n BigFraction.TWO,\n new BigFraction(2 * k)};\n }\n });\n }\n 
358	public static PolynomialFunction createLaguerrePolynomial(final int degree) {\n return buildPolynomial(degree, LAGUERRE_COEFFICIENTS,\n new RecurrenceCoefficientsGenerator() {\n /** {@inheritDoc} */\n public BigFraction[] generate(int k) {\n final int kP1 = k + 1;\n return new BigFraction[] {\n new BigFraction(2 * k + 1, kP1),\n new BigFraction(-1, kP1),\n new BigFraction(k, kP1)};\n }\n });\n }\n 
359	public static PolynomialFunction createLegendrePolynomial(final int degree) {\n return buildPolynomial(degree, LEGENDRE_COEFFICIENTS,\n new RecurrenceCoefficientsGenerator() {\n /** {@inheritDoc} */\n public BigFraction[] generate(int k) {\n final int kP1 = k + 1;\n return new BigFraction[] {\n BigFraction.ZERO,\n new BigFraction(k + kP1, kP1),\n new BigFraction(k, kP1)};\n }\n });\n }\n 
360	public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w) {\n // select the appropriate list\n final JacobiKey key = new JacobiKey(v, w);\n if (!JACOBI_COEFFICIENTS.containsKey(key)) {\n // allocate a new list for v, w\n final List<BigFraction> list = new ArrayList<BigFraction>();\n JACOBI_COEFFICIENTS.put(key, list);\n // Pv,w,0(x) = 1;\n list.add(BigFraction.ONE);\n // P1(x) = (v - w) / 2 + (2 + v + w) * X / 2\n list.add(new BigFraction(v - w, 2));\n list.add(new BigFraction(2 + v + w, 2));\n }\n return buildPolynomial(degree, JACOBI_COEFFICIENTS.get(key),\n new RecurrenceCoefficientsGenerator() {\n /** {@inheritDoc} */\n public BigFraction[] generate(int k) {\n k++;\n final int kvw      = k + v + w;\n final int twoKvw   = kvw + k;\n final int twoKvwM1 = twoKvw - 1;\n final int twoKvwM2 = twoKvw - 2;\n final int den      = 2 * k *  kvw * twoKvwM2;\n return new BigFraction[] {\n new BigFraction(twoKvwM1 * (v * v - w * w), den),\n new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den),\n new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den)\n };\n }\n });\n }\n 
361	JacobiKey(final int v, final int w) {\n this.v = v;\n this.w = w;\n }\n 
362	@Override\n public int hashCode() {\n return (v << 16) ^ w;\n }\n 
363	@Override\n public boolean equals(final Object key) {\n if ((key == null) || !(key instanceof JacobiKey)) {\n return false;\n }\n final JacobiKey otherK = (JacobiKey) key;\n return (v == otherK.v) && (w == otherK.w);\n }\n 
364	public static double[] shift(final double[] coefficients,\n final double shift) {\n final int dp1 = coefficients.length;\n final double[] newCoefficients = new double[dp1];\n // Pascal triangle.\n final int[][] coeff = new int[dp1][dp1];\n for (int i = 0; i < dp1; i++){\n for(int j = 0; j <= i; j++){\n coeff[i][j] = (int) CombinatoricsUtils.binomialCoefficient(i, j);\n }\n }\n // First polynomial coefficient.\n for (int i = 0; i < dp1; i++){\n newCoefficients[0] += coefficients[i] * FastMath.pow(shift, i);\n }\n // Superior order.\n final int d = dp1 - 1;\n for (int i = 0; i < d; i++) {\n for (int j = i; j < d; j++){\n newCoefficients[i + 1] += coeff[j + 1][j - i] *\n coefficients[j + 1] * FastMath.pow(shift, j - i);\n }\n }\n return newCoefficients;\n }\n 
365	private static PolynomialFunction buildPolynomial(final int degree,\n final List<BigFraction> coefficients,\n final RecurrenceCoefficientsGenerator generator) {\n synchronized (coefficients) {\n final int maxDegree = (int) FastMath.floor(FastMath.sqrt(2 * coefficients.size())) - 1;\n if (degree > maxDegree) {\n computeUpToDegree(degree, maxDegree, generator, coefficients);\n }\n }\n // coefficient  for polynomial 0 is  l [0]\n // coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\n // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\n // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\n // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\n // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\n // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\n // ...\n final int start = degree * (degree + 1) / 2;\n final double[] a = new double[degree + 1];\n for (int i = 0; i <= degree; ++i) {\n a[i] = coefficients.get(start + i).doubleValue();\n }\n // build the polynomial\n return new PolynomialFunction(a);\n }\n 
366	private static void computeUpToDegree(final int degree, final int maxDegree,\n final RecurrenceCoefficientsGenerator generator,\n final List<BigFraction> coefficients) {\n int startK = (maxDegree - 1) * maxDegree / 2;\n for (int k = maxDegree; k < degree; ++k) {\n // start indices of two previous polynomials Pk(X) and Pk-1(X)\n int startKm1 = startK;\n startK += k;\n // Pk+1(X) = (a[0] + a[1] X) Pk(X) - a[2] Pk-1(X)\n BigFraction[] ai = generator.generate(k);\n BigFraction ck     = coefficients.get(startK);\n BigFraction ckm1   = coefficients.get(startKm1);\n // degree 0 coefficient\n coefficients.add(ck.multiply(ai[0]).subtract(ckm1.multiply(ai[2])));\n // degree 1 to degree k-1 coefficients\n for (int i = 1; i < k; ++i) {\n final BigFraction ckPrev = ck;\n ck     = coefficients.get(startK + i);\n ckm1   = coefficients.get(startKm1 + i);\n coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])).subtract(ckm1.multiply(ai[2])));\n }\n // degree k coefficient\n final BigFraction ckPrev = ck;\n ck = coefficients.get(startK + k);\n coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])));\n // degree k+1 coefficient\n coefficients.add(ck.multiply(ai[1]));\n }\n }\n 
367	public Vector3DFormat() {\n super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n CompositeFormat.getDefaultNumberFormat());\n }\n 
368	public Vector3DFormat(final NumberFormat format) {\n super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n }\n 
369	public Vector3DFormat(final String prefix, final String suffix,\n final String separator) {\n super(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n }\n 
370	public Vector3DFormat(final String prefix, final String suffix,\n final String separator, final NumberFormat format) {\n super(prefix, suffix, separator, format);\n }\n 
371	public static Vector3DFormat getInstance() {\n return getInstance(Locale.getDefault());\n }\n 
372	public static Vector3DFormat getInstance(final Locale locale) {\n return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n }\n 
373	@Override\n public StringBuffer format(final Vector<Euclidean3D> vector, final StringBuffer toAppendTo,\n final FieldPosition pos) {\n final Vector3D v3 = (Vector3D) vector;\n return format(toAppendTo, pos, v3.getX(), v3.getY(), v3.getZ());\n }\n 
374	@Override\n public Vector3D parse(final String source) throws MathParseException {\n ParsePosition parsePosition = new ParsePosition(0);\n Vector3D result = parse(source, parsePosition);\n if (parsePosition.getIndex() == 0) {\n throw new MathParseException(source,\n parsePosition.getErrorIndex(),\n Vector3D.class);\n }\n return result;\n }\n 
375	@Override\n public Vector3D parse(final String source, final ParsePosition pos) {\n final double[] coordinates = parseCoordinates(3, source, pos);\n if (coordinates == null) {\n return null;\n }\n return new Vector3D(coordinates[0], coordinates[1], coordinates[2]);\n }\n 
376	public Rotation(double q0, double q1, double q2, double q3,\n boolean needsNormalization) {\n if (needsNormalization) {\n // normalization preprocessing\n double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n q0 *= inv;\n q1 *= inv;\n q2 *= inv;\n q3 *= inv;\n }\n this.q0 = q0;\n this.q1 = q1;\n this.q2 = q2;\n this.q3 = q3;\n }\n 
377	@Deprecated\n public Rotation(Vector3D axis, double angle) throws MathIllegalArgumentException {\n this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n }\n 
378	public Rotation(final Vector3D axis, final double angle, final RotationConvention convention)\n throws MathIllegalArgumentException {\n double norm = axis.getNorm();\n if (norm == 0) {\n throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n }\n double halfAngle = convention == RotationConvention.VECTOR_OPERATOR ? -0.5 * angle : +0.5 * angle;\n double coeff = FastMath.sin(halfAngle) / norm;\n q0 = FastMath.cos (halfAngle);\n q1 = coeff * axis.getX();\n q2 = coeff * axis.getY();\n q3 = coeff * axis.getZ();\n }\n 
379	public Rotation(double[][] m, double threshold)\n throws NotARotationMatrixException {\n // dimension check\n if ((m.length != 3) || (m[0].length != 3) ||\n (m[1].length != 3) || (m[2].length != 3)) {\n throw new NotARotationMatrixException(\n LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n m.length, m[0].length);\n }\n // compute a "close" orthogonal matrix\n double[][] ort = orthogonalizeMatrix(m, threshold);\n // check the sign of the determinant\n double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n if (det < 0.0) {\n throw new NotARotationMatrixException(\n LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n det);\n }\n double[] quat = mat2quat(ort);\n q0 = quat[0];\n q1 = quat[1];\n q2 = quat[2];\n q3 = quat[3];\n }\n 
380	public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n throws MathArithmeticException {\n // build orthonormalized base from u1, u2\n // this fails when vectors are null or collinear, which is forbidden to define a rotation\n final Vector3D u3 = u1.crossProduct(u2).normalize();\n u2 = u3.crossProduct(u1).normalize();\n u1 = u1.normalize();\n // build an orthonormalized base from v1, v2\n // this fails when vectors are null or collinear, which is forbidden to define a rotation\n final Vector3D v3 = v1.crossProduct(v2).normalize();\n v2 = v3.crossProduct(v1).normalize();\n v1 = v1.normalize();\n // buid a matrix transforming the first base into the second one\n final double[][] m = new double[][] {\n {\n MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n },\n {\n MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n },\n {\n MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n }\n };\n double[] quat = mat2quat(m);\n q0 = quat[0];\n q1 = quat[1];\n q2 = quat[2];\n q3 = quat[3];\n }\n 
381	public Rotation(Vector3D u, Vector3D v) throws MathArithmeticException {\n double normProduct = u.getNorm() * v.getNorm();\n if (normProduct == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n }\n double dot = u.dotProduct(v);\n if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n // special case u = -v: we select a PI angle rotation around\n // an arbitrary vector orthogonal to u\n Vector3D w = u.orthogonal();\n q0 = 0.0;\n q1 = -w.getX();\n q2 = -w.getY();\n q3 = -w.getZ();\n } else {\n // general case: (u, v) defines a plane, we select\n // the shortest possible rotation: axis orthogonal to this plane\n q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n double coeff = 1.0 / (2.0 * q0 * normProduct);\n Vector3D q = v.crossProduct(u);\n q1 = coeff * q.getX();\n q2 = coeff * q.getY();\n q3 = coeff * q.getZ();\n }\n }\n 
382	@Deprecated\n public Rotation(RotationOrder order,\n double alpha1, double alpha2, double alpha3) {\n this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n }\n 
383	public Rotation(RotationOrder order, RotationConvention convention,\n double alpha1, double alpha2, double alpha3) {\n Rotation r1 = new Rotation(order.getA1(), alpha1, convention);\n Rotation r2 = new Rotation(order.getA2(), alpha2, convention);\n Rotation r3 = new Rotation(order.getA3(), alpha3, convention);\n Rotation composed = r1.compose(r2.compose(r3, convention), convention);\n q0 = composed.q0;\n q1 = composed.q1;\n q2 = composed.q2;\n q3 = composed.q3;\n }\n 
384	private static double[] mat2quat(final double[][] ort) {\n final double[] quat = new double[4];\n // There are different ways to compute the quaternions elements\n // from the matrix. They all involve computing one element from\n // the diagonal of the matrix, and computing the three other ones\n // using a formula involving a division by the first element,\n // which unfortunately can be zero. Since the norm of the\n // quaternion is 1, we know at least one element has an absolute\n // value greater or equal to 0.5, so it is always possible to\n // select the right formula and avoid division by zero and even\n // numerical inaccuracy. Checking the elements in turn and using\n // the first one greater than 0.45 is safe (this leads to a simple\n // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n double s = ort[0][0] + ort[1][1] + ort[2][2];\n if (s > -0.19) {\n // compute q0 and deduce q1, q2 and q3\n quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n double inv = 0.25 / quat[0];\n quat[1] = inv * (ort[1][2] - ort[2][1]);\n quat[2] = inv * (ort[2][0] - ort[0][2]);\n quat[3] = inv * (ort[0][1] - ort[1][0]);\n } else {\n s = ort[0][0] - ort[1][1] - ort[2][2];\n if (s > -0.19) {\n // compute q1 and deduce q0, q2 and q3\n quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n double inv = 0.25 / quat[1];\n quat[0] = inv * (ort[1][2] - ort[2][1]);\n quat[2] = inv * (ort[0][1] + ort[1][0]);\n quat[3] = inv * (ort[0][2] + ort[2][0]);\n } else {\n s = ort[1][1] - ort[0][0] - ort[2][2];\n if (s > -0.19) {\n // compute q2 and deduce q0, q1 and q3\n quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n double inv = 0.25 / quat[2];\n quat[0] = inv * (ort[2][0] - ort[0][2]);\n quat[1] = inv * (ort[0][1] + ort[1][0]);\n quat[3] = inv * (ort[2][1] + ort[1][2]);\n } else {\n // compute q3 and deduce q0, q1 and q2\n s = ort[2][2] - ort[0][0] - ort[1][1];\n quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n double inv = 0.25 / quat[3];\n quat[0] = inv * (ort[0][1] - ort[1][0]);\n quat[1] = inv * (ort[0][2] + ort[2][0]);\n quat[2] = inv * (ort[2][1] + ort[1][2]);\n }\n }\n }\n return quat;\n }\n 
385	public Rotation revert() {\n return new Rotation(-q0, q1, q2, q3, false);\n }\n 
386	public double getQ0() {\n return q0;\n }\n 
387	public double getQ1() {\n return q1;\n }\n 
388	public double getQ2() {\n return q2;\n }\n 
389	public double getQ3() {\n return q3;\n }\n 
390	@Deprecated\n public Vector3D getAxis() {\n return getAxis(RotationConvention.VECTOR_OPERATOR);\n }\n 
391	public Vector3D getAxis(final RotationConvention convention) {\n final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n if (squaredSine == 0) {\n return convention == RotationConvention.VECTOR_OPERATOR ? Vector3D.PLUS_I : Vector3D.MINUS_I;\n } else {\n final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n if (q0 < 0) {\n final double inverse = sgn / FastMath.sqrt(squaredSine);\n return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n }\n final double inverse = -sgn / FastMath.sqrt(squaredSine);\n return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n }\n }\n 
392	public double getAngle() {\n if ((q0 < -0.1) || (q0 > 0.1)) {\n return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n } else if (q0 < 0) {\n return 2 * FastMath.acos(-q0);\n }\n return 2 * FastMath.acos(q0);\n }\n 
393	@Deprecated\n public double[] getAngles(RotationOrder order)\n throws CardanEulerSingularityException {\n return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n }\n 
394	public double[] getAngles(RotationOrder order, RotationConvention convention)\n throws CardanEulerSingularityException {\n if (convention == RotationConvention.VECTOR_OPERATOR) {\n if (order == RotationOrder.XYZ) {\n // r (Vector3D.plusK) coordinates are :\n //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(-(v1.getY()), v1.getZ()),\n FastMath.asin(v2.getZ()),\n FastMath.atan2(-(v2.getY()), v2.getX())\n };\n } else if (order == RotationOrder.XZY) {\n // r (Vector3D.plusJ) coordinates are :\n // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(v1.getZ(), v1.getY()),\n -FastMath.asin(v2.getY()),\n FastMath.atan2(v2.getZ(), v2.getX())\n };\n } else if (order == RotationOrder.YXZ) {\n // r (Vector3D.plusK) coordinates are :\n //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n // (-r) (Vector3D.plusJ) coordinates are :\n // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(v1.getX(), v1.getZ()),\n -FastMath.asin(v2.getZ()),\n FastMath.atan2(v2.getX(), v2.getY())\n };\n } else if (order == RotationOrder.YZX) {\n // r (Vector3D.plusI) coordinates are :\n // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n // (-r) (Vector3D.plusJ) coordinates are :\n // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(-(v1.getZ()), v1.getX()),\n FastMath.asin(v2.getX()),\n FastMath.atan2(-(v2.getZ()), v2.getY())\n };\n } else if (order == RotationOrder.ZXY) {\n // r (Vector3D.plusJ) coordinates are :\n // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n // (-r) (Vector3D.plusK) coordinates are :\n // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(-(v1.getX()), v1.getY()),\n FastMath.asin(v2.getY()),\n FastMath.atan2(-(v2.getX()), v2.getZ())\n };\n } else if (order == RotationOrder.ZYX) {\n // r (Vector3D.plusI) coordinates are :\n //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n // (-r) (Vector3D.plusK) coordinates are :\n // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(v1.getY(), v1.getX()),\n -FastMath.asin(v2.getX()),\n FastMath.atan2(v2.getY(), v2.getZ())\n };\n } else if (order == RotationOrder.XYX) {\n // r (Vector3D.plusI) coordinates are :\n //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n // and we can choose to have theta in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v1.getY(), -v1.getZ()),\n FastMath.acos(v2.getX()),\n FastMath.atan2(v2.getY(), v2.getZ())\n };\n } else if (order == RotationOrder.XZX) {\n // r (Vector3D.plusI) coordinates are :\n //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n // and we can choose to have psi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v1.getZ(), v1.getY()),\n FastMath.acos(v2.getX()),\n FastMath.atan2(v2.getZ(), -v2.getY())\n };\n } else if (order == RotationOrder.YXY) {\n // r (Vector3D.plusJ) coordinates are :\n //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n // (-r) (Vector3D.plusJ) coordinates are :\n // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n // and we can choose to have phi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v1.getX(), v1.getZ()),\n FastMath.acos(v2.getY()),\n FastMath.atan2(v2.getX(), -v2.getZ())\n };\n } else if (order == RotationOrder.YZY) {\n // r (Vector3D.plusJ) coordinates are :\n //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n // (-r) (Vector3D.plusJ) coordinates are :\n // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n // and we can choose to have psi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v1.getZ(), -v1.getX()),\n FastMath.acos(v2.getY()),\n FastMath.atan2(v2.getZ(), v2.getX())\n };\n } else if (order == RotationOrder.ZXZ) {\n // r (Vector3D.plusK) coordinates are :\n //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n // (-r) (Vector3D.plusK) coordinates are :\n // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n // and we can choose to have phi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v1.getX(), -v1.getY()),\n FastMath.acos(v2.getZ()),\n FastMath.atan2(v2.getX(), v2.getY())\n };\n } else { // last possibility is ZYZ\n // r (Vector3D.plusK) coordinates are :\n //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n // (-r) (Vector3D.plusK) coordinates are :\n // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n // and we can choose to have theta in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v1.getY(), v1.getX()),\n FastMath.acos(v2.getZ()),\n FastMath.atan2(v2.getY(), -v2.getX())\n };\n }\n } else {\n if (order == RotationOrder.XYZ) {\n // r (Vector3D.plusI) coordinates are :\n //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n // (-r) (Vector3D.plusK) coordinates are :\n // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(-v2.getY(), v2.getZ()),\n FastMath.asin(v2.getX()),\n FastMath.atan2(-v1.getY(), v1.getX())\n };\n } else if (order == RotationOrder.XZY) {\n // r (Vector3D.plusI) coordinates are :\n // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n // (-r) (Vector3D.plusJ) coordinates are :\n // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(v2.getZ(), v2.getY()),\n -FastMath.asin(v2.getX()),\n FastMath.atan2(v1.getZ(), v1.getX())\n };\n } else if (order == RotationOrder.YXZ) {\n // r (Vector3D.plusJ) coordinates are :\n // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n // (-r) (Vector3D.plusK) coordinates are :\n // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(v2.getX(), v2.getZ()),\n -FastMath.asin(v2.getY()),\n FastMath.atan2(v1.getX(), v1.getY())\n };\n } else if (order == RotationOrder.YZX) {\n // r (Vector3D.plusJ) coordinates are :\n // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(-v2.getZ(), v2.getX()),\n FastMath.asin(v2.getY()),\n FastMath.atan2(-v1.getZ(), v1.getY())\n };\n } else if (order == RotationOrder.ZXY) {\n // r (Vector3D.plusK) coordinates are :\n //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n // (-r) (Vector3D.plusJ) coordinates are :\n // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(-v2.getX(), v2.getY()),\n FastMath.asin(v2.getZ()),\n FastMath.atan2(-v1.getX(), v1.getZ())\n };\n } else if (order == RotationOrder.ZYX) {\n // r (Vector3D.plusK) coordinates are :\n //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(true);\n }\n return new double[] {\n FastMath.atan2(v2.getY(), v2.getX()),\n -FastMath.asin(v2.getZ()),\n FastMath.atan2(v1.getY(), v1.getZ())\n };\n } else if (order == RotationOrder.XYX) {\n // r (Vector3D.plusI) coordinates are :\n //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n // and we can choose to have theta in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v2.getY(), -v2.getZ()),\n FastMath.acos(v2.getX()),\n FastMath.atan2(v1.getY(), v1.getZ())\n };\n } else if (order == RotationOrder.XZX) {\n // r (Vector3D.plusI) coordinates are :\n //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n // (-r) (Vector3D.plusI) coordinates are :\n // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n // and we can choose to have psi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_I);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v2.getZ(), v2.getY()),\n FastMath.acos(v2.getX()),\n FastMath.atan2(v1.getZ(), -v1.getY())\n };\n } else if (order == RotationOrder.YXY) {\n // r (Vector3D.plusJ) coordinates are :\n // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n // (-r) (Vector3D.plusJ) coordinates are :\n //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n // and we can choose to have phi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v2.getX(), v2.getZ()),\n FastMath.acos(v2.getY()),\n FastMath.atan2(v1.getX(), -v1.getZ())\n };\n } else if (order == RotationOrder.YZY) {\n // r (Vector3D.plusJ) coordinates are :\n // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n // (-r) (Vector3D.plusJ) coordinates are :\n //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n // and we can choose to have psi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_J);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v2.getZ(), -v2.getX()),\n FastMath.acos(v2.getY()),\n FastMath.atan2(v1.getZ(), v1.getX())\n };\n } else if (order == RotationOrder.ZXZ) {\n // r (Vector3D.plusK) coordinates are :\n // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n // (-r) (Vector3D.plusK) coordinates are :\n //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n // and we can choose to have phi in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v2.getX(), -v2.getY()),\n FastMath.acos(v2.getZ()),\n FastMath.atan2(v1.getX(), v1.getY())\n };\n } else { // last possibility is ZYZ\n // r (Vector3D.plusK) coordinates are :\n // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n // (-r) (Vector3D.plusK) coordinates are :\n //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n // and we can choose to have theta in the interval [0 ; PI]\n Vector3D v1 = applyTo(Vector3D.PLUS_K);\n Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n throw new CardanEulerSingularityException(false);\n }\n return new double[] {\n FastMath.atan2(v2.getY(), v2.getX()),\n FastMath.acos(v2.getZ()),\n FastMath.atan2(v1.getY(), -v1.getX())\n };\n }\n }\n }\n 
395	public double[][] getMatrix() {\n // products\n double q0q0  = q0 * q0;\n double q0q1  = q0 * q1;\n double q0q2  = q0 * q2;\n double q0q3  = q0 * q3;\n double q1q1  = q1 * q1;\n double q1q2  = q1 * q2;\n double q1q3  = q1 * q3;\n double q2q2  = q2 * q2;\n double q2q3  = q2 * q3;\n double q3q3  = q3 * q3;\n // create the matrix\n double[][] m = new double[3][];\n m[0] = new double[3];\n m[1] = new double[3];\n m[2] = new double[3];\n m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n m [1][0] = 2.0 * (q1q2 - q0q3);\n m [2][0] = 2.0 * (q1q3 + q0q2);\n m [0][1] = 2.0 * (q1q2 + q0q3);\n m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n m [2][1] = 2.0 * (q2q3 - q0q1);\n m [0][2] = 2.0 * (q1q3 - q0q2);\n m [1][2] = 2.0 * (q2q3 + q0q1);\n m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n return m;\n }\n 
396	public Vector3D applyTo(Vector3D u) {\n double x = u.getX();\n double y = u.getY();\n double z = u.getZ();\n double s = q1 * x + q2 * y + q3 * z;\n return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n }\n 
397	public void applyTo(final double[] in, final double[] out) {\n final double x = in[0];\n final double y = in[1];\n final double z = in[2];\n final double s = q1 * x + q2 * y + q3 * z;\n out[0] = 2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x;\n out[1] = 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y;\n out[2] = 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z;\n }\n 
398	public Vector3D applyInverseTo(Vector3D u) {\n double x = u.getX();\n double y = u.getY();\n double z = u.getZ();\n double s = q1 * x + q2 * y + q3 * z;\n double m0 = -q0;\n return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n 2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n 2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n }\n 
399	public void applyInverseTo(final double[] in, final double[] out) {\n final double x = in[0];\n final double y = in[1];\n final double z = in[2];\n final double s = q1 * x + q2 * y + q3 * z;\n final double m0 = -q0;\n out[0] = 2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x;\n out[1] = 2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y;\n out[2] = 2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z;\n }\n 
400	public Rotation applyTo(Rotation r) {\n return compose(r, RotationConvention.VECTOR_OPERATOR);\n }\n 
401	public Rotation compose(final Rotation r, final RotationConvention convention) {\n return convention == RotationConvention.VECTOR_OPERATOR ?\n composeInternal(r) : r.composeInternal(this);\n }\n 
402	private Rotation composeInternal(final Rotation r) {\n return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n false);\n }\n 
403	public Rotation applyInverseTo(Rotation r) {\n return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n }\n 
404	public Rotation composeInverse(final Rotation r, final RotationConvention convention) {\n return convention == RotationConvention.VECTOR_OPERATOR ?\n composeInverseInternal(r) : r.composeInternal(revert());\n }\n 
405	private Rotation composeInverseInternal(Rotation r) {\n return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n false);\n }\n 
406	private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n throws NotARotationMatrixException {\n double[] m0 = m[0];\n double[] m1 = m[1];\n double[] m2 = m[2];\n double x00 = m0[0];\n double x01 = m0[1];\n double x02 = m0[2];\n double x10 = m1[0];\n double x11 = m1[1];\n double x12 = m1[2];\n double x20 = m2[0];\n double x21 = m2[1];\n double x22 = m2[2];\n double fn = 0;\n double fn1;\n double[][] o = new double[3][3];\n double[] o0 = o[0];\n double[] o1 = o[1];\n double[] o2 = o[2];\n // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n int i = 0;\n while (++i < 11) {\n // Mt.Xn\n double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n // Xn+1\n o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n // correction on each elements\n double corr00 = o0[0] - m0[0];\n double corr01 = o0[1] - m0[1];\n double corr02 = o0[2] - m0[2];\n double corr10 = o1[0] - m1[0];\n double corr11 = o1[1] - m1[1];\n double corr12 = o1[2] - m1[2];\n double corr20 = o2[0] - m2[0];\n double corr21 = o2[1] - m2[1];\n double corr22 = o2[2] - m2[2];\n // Frobenius norm of the correction\n fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n // convergence test\n if (FastMath.abs(fn1 - fn) <= threshold) {\n return o;\n }\n // prepare next iteration\n x00 = o0[0];\n x01 = o0[1];\n x02 = o0[2];\n x10 = o1[0];\n x11 = o1[1];\n x12 = o1[2];\n x20 = o2[0];\n x21 = o2[1];\n x22 = o2[2];\n fn  = fn1;\n }\n // the algorithm did not converge after 10 iterations\n throw new NotARotationMatrixException(\n LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n i - 1);\n }\n 
407	public static double distance(Rotation r1, Rotation r2) {\n return r1.composeInverseInternal(r2).getAngle();\n }\n 
408	private ComplexUtils() {}\n 
409	public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {\n if (r < 0) {\n throw new MathIllegalArgumentException(\n LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n }\n return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n }\n 
410	public static Complex[] convertToComplex(double[] real) {\n final Complex c[] = new Complex[real.length];\n for (int i = 0; i < real.length; i++) {\n c[i] = new Complex(real[i], 0);\n }\n return c;\n }\n 
411	public BigFraction(final BigInteger num) {\n this(num, BigInteger.ONE);\n }\n 
412	public BigFraction(BigInteger num, BigInteger den) {\n MathUtils.checkNotNull(num, LocalizedFormats.NUMERATOR);\n MathUtils.checkNotNull(den, LocalizedFormats.DENOMINATOR);\n if (den.signum() == 0) {\n throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);\n }\n if (num.signum() == 0) {\n numerator   = BigInteger.ZERO;\n denominator = BigInteger.ONE;\n } else {\n // reduce numerator and denominator by greatest common denominator\n final BigInteger gcd = num.gcd(den);\n if (BigInteger.ONE.compareTo(gcd) < 0) {\n num = num.divide(gcd);\n den = den.divide(gcd);\n }\n // move sign to numerator\n if (den.signum() == -1) {\n num = num.negate();\n den = den.negate();\n }\n // store the values in the final fields\n numerator   = num;\n denominator = den;\n }\n }\n 
413	public BigFraction(final double value) throws MathIllegalArgumentException {\n if (Double.isNaN(value)) {\n throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n }\n if (Double.isInfinite(value)) {\n throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_VALUE_CONVERSION);\n }\n // compute m and k such that value = m * 2^k\n final long bits     = Double.doubleToLongBits(value);\n final long sign     = bits & 0x8000000000000000L;\n final long exponent = bits & 0x7ff0000000000000L;\n long m              = bits & 0x000fffffffffffffL;\n if (exponent != 0) {\n // this was a normalized number, add the implicit most significant bit\n m |= 0x0010000000000000L;\n }\n if (sign != 0) {\n m = -m;\n }\n int k = ((int) (exponent >> 52)) - 1075;\n while (((m & 0x001ffffffffffffeL) != 0) && ((m & 0x1) == 0)) {\n m >>= 1;\n ++k;\n }\n if (k < 0) {\n numerator   = BigInteger.valueOf(m);\n denominator = BigInteger.ZERO.flipBit(-k);\n } else {\n numerator   = BigInteger.valueOf(m).multiply(BigInteger.ZERO.flipBit(k));\n denominator = BigInteger.ONE;\n }\n }\n 
414	public BigFraction(final double value, final double epsilon,\n final int maxIterations)\n throws FractionConversionException {\n this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n }\n 
415	private BigFraction(final double value, final double epsilon,\n final int maxDenominator, int maxIterations)\n throws FractionConversionException {\n long overflow = Integer.MAX_VALUE;\n double r0 = value;\n long a0 = (long) FastMath.floor(r0);\n if (FastMath.abs(a0) > overflow) {\n throw new FractionConversionException(value, a0, 1l);\n }\n // check for (almost) integer arguments, which should not go\n // to iterations.\n if (FastMath.abs(a0 - value) < epsilon) {\n numerator = BigInteger.valueOf(a0);\n denominator = BigInteger.ONE;\n return;\n }\n long p0 = 1;\n long q0 = 0;\n long p1 = a0;\n long q1 = 1;\n long p2 = 0;\n long q2 = 1;\n int n = 0;\n boolean stop = false;\n do {\n ++n;\n final double r1 = 1.0 / (r0 - a0);\n final long a1 = (long) FastMath.floor(r1);\n p2 = (a1 * p1) + p0;\n q2 = (a1 * q1) + q0;\n if ((p2 > overflow) || (q2 > overflow)) {\n // in maxDenominator mode, if the last fraction was very close to the actual value\n // q2 may overflow in the next iteration; in this case return the last one.\n if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n break;\n }\n throw new FractionConversionException(value, p2, q2);\n }\n final double convergent = (double) p2 / (double) q2;\n if ((n < maxIterations) &&\n (FastMath.abs(convergent - value) > epsilon) &&\n (q2 < maxDenominator)) {\n p0 = p1;\n p1 = p2;\n q0 = q1;\n q1 = q2;\n a0 = a1;\n r0 = r1;\n } else {\n stop = true;\n }\n } while (!stop);\n if (n >= maxIterations) {\n throw new FractionConversionException(value, maxIterations);\n }\n if (q2 < maxDenominator) {\n numerator   = BigInteger.valueOf(p2);\n denominator = BigInteger.valueOf(q2);\n } else {\n numerator   = BigInteger.valueOf(p1);\n denominator = BigInteger.valueOf(q1);\n }\n }\n 
416	public BigFraction(final double value, final int maxDenominator)\n throws FractionConversionException {\n this(value, 0, maxDenominator, 100);\n }\n 
417	public BigFraction(final int num) {\n this(BigInteger.valueOf(num), BigInteger.ONE);\n }\n 
418	public BigFraction(final int num, final int den) {\n this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n }\n 
419	public BigFraction(final long num) {\n this(BigInteger.valueOf(num), BigInteger.ONE);\n }\n 
420	public BigFraction(final long num, final long den) {\n this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n }\n 
421	public static BigFraction getReducedFraction(final int numerator,\n final int denominator) {\n if (numerator == 0) {\n return ZERO; // normalize zero.\n }\n return new BigFraction(numerator, denominator);\n }\n 
422	public BigFraction abs() {\n return (numerator.signum() == 1) ? this : negate();\n }\n 
423	public BigFraction add(final BigInteger bg) throws NullArgumentException {\n MathUtils.checkNotNull(bg);\n if (numerator.signum() == 0) {\n return new BigFraction(bg);\n }\n if (bg.signum() == 0) {\n return this;\n }\n return new BigFraction(numerator.add(denominator.multiply(bg)), denominator);\n }\n 
424	public BigFraction add(final int i) {\n return add(BigInteger.valueOf(i));\n }\n 
425	public BigFraction add(final long l) {\n return add(BigInteger.valueOf(l));\n }\n 
426	public BigFraction add(final BigFraction fraction) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (fraction.numerator.signum() == 0) {\n return this;\n }\n if (numerator.signum() == 0) {\n return fraction;\n }\n BigInteger num = null;\n BigInteger den = null;\n if (denominator.equals(fraction.denominator)) {\n num = numerator.add(fraction.numerator);\n den = denominator;\n } else {\n num = (numerator.multiply(fraction.denominator)).add((fraction.numerator).multiply(denominator));\n den = denominator.multiply(fraction.denominator);\n }\n if (num.signum() == 0) {\n return ZERO;\n }\n return new BigFraction(num, den);\n }\n 
427	public BigDecimal bigDecimalValue() {\n return new BigDecimal(numerator).divide(new BigDecimal(denominator));\n }\n 
428	public BigDecimal bigDecimalValue(final int roundingMode) {\n return new BigDecimal(numerator).divide(new BigDecimal(denominator), roundingMode);\n }\n 
429	public BigDecimal bigDecimalValue(final int scale, final int roundingMode) {\n return new BigDecimal(numerator).divide(new BigDecimal(denominator), scale, roundingMode);\n }\n 
430	public int compareTo(final BigFraction object) {\n int lhsSigNum = numerator.signum();\n int rhsSigNum = object.numerator.signum();\n if (lhsSigNum != rhsSigNum) {\n return (lhsSigNum > rhsSigNum) ? 1 : -1;\n }\n if (lhsSigNum == 0) {\n return 0;\n }\n BigInteger nOd = numerator.multiply(object.denominator);\n BigInteger dOn = denominator.multiply(object.numerator);\n return nOd.compareTo(dOn);\n }\n 
431	public BigFraction divide(final BigInteger bg) {\n if (bg == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (bg.signum() == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n }\n if (numerator.signum() == 0) {\n return ZERO;\n }\n return new BigFraction(numerator, denominator.multiply(bg));\n }\n 
432	public BigFraction divide(final int i) {\n return divide(BigInteger.valueOf(i));\n }\n 
433	public BigFraction divide(final long l) {\n return divide(BigInteger.valueOf(l));\n }\n 
434	public BigFraction divide(final BigFraction fraction) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (fraction.numerator.signum() == 0) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n }\n if (numerator.signum() == 0) {\n return ZERO;\n }\n return multiply(fraction.reciprocal());\n }\n 
435	@Override\n public double doubleValue() {\n double result = numerator.doubleValue() / denominator.doubleValue();\n if (Double.isNaN(result)) {\n // Numerator and/or denominator must be out of range:\n // Calculate how far to shift them to put them in range.\n int shift = FastMath.max(numerator.bitLength(),\n denominator.bitLength()) - FastMath.getExponent(Double.MAX_VALUE);\n result = numerator.shiftRight(shift).doubleValue() /\n denominator.shiftRight(shift).doubleValue();\n }\n return result;\n }\n 
436	@Override\n public boolean equals(final Object other) {\n boolean ret = false;\n if (this == other) {\n ret = true;\n } else if (other instanceof BigFraction) {\n BigFraction rhs = ((BigFraction) other).reduce();\n BigFraction thisOne = this.reduce();\n ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n }\n return ret;\n }\n 
437	@Override\n public float floatValue() {\n float result = numerator.floatValue() / denominator.floatValue();\n if (Double.isNaN(result)) {\n // Numerator and/or denominator must be out of range:\n // Calculate how far to shift them to put them in range.\n int shift = FastMath.max(numerator.bitLength(),\n denominator.bitLength()) - FastMath.getExponent(Float.MAX_VALUE);\n result = numerator.shiftRight(shift).floatValue() /\n denominator.shiftRight(shift).floatValue();\n }\n return result;\n }\n 
438	public BigInteger getDenominator() {\n return denominator;\n }\n 
439	public int getDenominatorAsInt() {\n return denominator.intValue();\n }\n 
440	public long getDenominatorAsLong() {\n return denominator.longValue();\n }\n 
441	public BigInteger getNumerator() {\n return numerator;\n }\n 
442	public int getNumeratorAsInt() {\n return numerator.intValue();\n }\n 
443	public long getNumeratorAsLong() {\n return numerator.longValue();\n }\n 
444	@Override\n public int hashCode() {\n return 37 * (37 * 17 + numerator.hashCode()) + denominator.hashCode();\n }\n 
445	@Override\n public int intValue() {\n return numerator.divide(denominator).intValue();\n }\n 
446	@Override\n public long longValue() {\n return numerator.divide(denominator).longValue();\n }\n 
447	public BigFraction multiply(final BigInteger bg) {\n if (bg == null) {\n throw new NullArgumentException();\n }\n if (numerator.signum() == 0 || bg.signum() == 0) {\n return ZERO;\n }\n return new BigFraction(bg.multiply(numerator), denominator);\n }\n 
448	public BigFraction multiply(final int i) {\n if (i == 0 || numerator.signum() == 0) {\n return ZERO;\n }\n return multiply(BigInteger.valueOf(i));\n }\n 
449	public BigFraction multiply(final long l) {\n if (l == 0 || numerator.signum() == 0) {\n return ZERO;\n }\n return multiply(BigInteger.valueOf(l));\n }\n 
450	public BigFraction multiply(final BigFraction fraction) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (numerator.signum() == 0 ||\n fraction.numerator.signum() == 0) {\n return ZERO;\n }\n return new BigFraction(numerator.multiply(fraction.numerator),\n denominator.multiply(fraction.denominator));\n }\n 
451	public BigFraction negate() {\n return new BigFraction(numerator.negate(), denominator);\n }\n 
452	public double percentageValue() {\n return multiply(ONE_HUNDRED).doubleValue();\n }\n 
453	public BigFraction pow(final int exponent) {\n if (exponent == 0) {\n return ONE;\n }\n if (numerator.signum() == 0) {\n return this;\n }\n if (exponent < 0) {\n return new BigFraction(denominator.pow(-exponent), numerator.pow(-exponent));\n }\n return new BigFraction(numerator.pow(exponent), denominator.pow(exponent));\n }\n 
454	public BigFraction pow(final long exponent) {\n if (exponent == 0) {\n return ONE;\n }\n if (numerator.signum() == 0) {\n return this;\n }\n if (exponent < 0) {\n return new BigFraction(ArithmeticUtils.pow(denominator, -exponent),\n ArithmeticUtils.pow(numerator,   -exponent));\n }\n return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n ArithmeticUtils.pow(denominator, exponent));\n }\n 
455	public BigFraction pow(final BigInteger exponent) {\n if (exponent.signum() == 0) {\n return ONE;\n }\n if (numerator.signum() == 0) {\n return this;\n }\n if (exponent.signum() == -1) {\n final BigInteger eNeg = exponent.negate();\n return new BigFraction(ArithmeticUtils.pow(denominator, eNeg),\n ArithmeticUtils.pow(numerator,   eNeg));\n }\n return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n ArithmeticUtils.pow(denominator, exponent));\n }\n 
456	public double pow(final double exponent) {\n return FastMath.pow(numerator.doubleValue(),   exponent) /\n FastMath.pow(denominator.doubleValue(), exponent);\n }\n 
457	public BigFraction reciprocal() {\n return new BigFraction(denominator, numerator);\n }\n 
458	public BigFraction reduce() {\n final BigInteger gcd = numerator.gcd(denominator);\n if (BigInteger.ONE.compareTo(gcd) < 0) {\n return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n } else {\n return this;\n }\n }\n 
459	public BigFraction subtract(final BigInteger bg) {\n if (bg == null) {\n throw new NullArgumentException();\n }\n if (bg.signum() == 0) {\n return this;\n }\n if (numerator.signum() == 0) {\n return new BigFraction(bg.negate());\n }\n return new BigFraction(numerator.subtract(denominator.multiply(bg)), denominator);\n }\n 
460	public BigFraction subtract(final int i) {\n return subtract(BigInteger.valueOf(i));\n }\n 
461	public BigFraction subtract(final long l) {\n return subtract(BigInteger.valueOf(l));\n }\n 
462	public BigFraction subtract(final BigFraction fraction) {\n if (fraction == null) {\n throw new NullArgumentException(LocalizedFormats.FRACTION);\n }\n if (fraction.numerator.signum() == 0) {\n return this;\n }\n if (numerator.signum() == 0) {\n return fraction.negate();\n }\n BigInteger num = null;\n BigInteger den = null;\n if (denominator.equals(fraction.denominator)) {\n num = numerator.subtract(fraction.numerator);\n den = denominator;\n } else {\n num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n den = denominator.multiply(fraction.denominator);\n }\n return new BigFraction(num, den);\n }\n 
463	@Override\n public String toString() {\n String str = null;\n if (BigInteger.ONE.equals(denominator)) {\n str = numerator.toString();\n } else if (BigInteger.ZERO.equals(numerator)) {\n str = "0";\n } else {\n str = numerator + " / " + denominator;\n }\n return str;\n }\n 
464	public BigFractionField getField() {\n return BigFractionField.getInstance();\n }\n 
465	public SingularValueDecomposition(final RealMatrix matrix) {\n final double[][] A;\n // "m" is always the largest dimension.\n if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n transposed = true;\n A = matrix.transpose().getData();\n m = matrix.getColumnDimension();\n n = matrix.getRowDimension();\n } else {\n transposed = false;\n A = matrix.getData();\n m = matrix.getRowDimension();\n n = matrix.getColumnDimension();\n }\n singularValues = new double[n];\n final double[][] U = new double[m][n];\n final double[][] V = new double[n][n];\n final double[] e = new double[n];\n final double[] work = new double[m];\n // Reduce A to bidiagonal form, storing the diagonal elements\n // in s and the super-diagonal elements in e.\n final int nct = FastMath.min(m - 1, n);\n final int nrt = FastMath.max(0, n - 2);\n for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n if (k < nct) {\n // Compute the transformation for the k-th column and\n // place the k-th diagonal in s[k].\n // Compute 2-norm of k-th column without under/overflow.\n singularValues[k] = 0;\n for (int i = k; i < m; i++) {\n singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n }\n if (singularValues[k] != 0) {\n if (A[k][k] < 0) {\n singularValues[k] = -singularValues[k];\n }\n for (int i = k; i < m; i++) {\n A[i][k] /= singularValues[k];\n }\n A[k][k] += 1;\n }\n singularValues[k] = -singularValues[k];\n }\n for (int j = k + 1; j < n; j++) {\n if (k < nct &&\n singularValues[k] != 0) {\n // Apply the transformation.\n double t = 0;\n for (int i = k; i < m; i++) {\n t += A[i][k] * A[i][j];\n }\n t = -t / A[k][k];\n for (int i = k; i < m; i++) {\n A[i][j] += t * A[i][k];\n }\n }\n // Place the k-th row of A into e for the\n // subsequent calculation of the row transformation.\n e[j] = A[k][j];\n }\n if (k < nct) {\n // Place the transformation in U for subsequent back\n // multiplication.\n for (int i = k; i < m; i++) {\n U[i][k] = A[i][k];\n }\n }\n if (k < nrt) {\n // Compute the k-th row transformation and place the\n // k-th super-diagonal in e[k].\n // Compute 2-norm without under/overflow.\n e[k] = 0;\n for (int i = k + 1; i < n; i++) {\n e[k] = FastMath.hypot(e[k], e[i]);\n }\n if (e[k] != 0) {\n if (e[k + 1] < 0) {\n e[k] = -e[k];\n }\n for (int i = k + 1; i < n; i++) {\n e[i] /= e[k];\n }\n e[k + 1] += 1;\n }\n e[k] = -e[k];\n if (k + 1 < m &&\n e[k] != 0) {\n // Apply the transformation.\n for (int i = k + 1; i < m; i++) {\n work[i] = 0;\n }\n for (int j = k + 1; j < n; j++) {\n for (int i = k + 1; i < m; i++) {\n work[i] += e[j] * A[i][j];\n }\n }\n for (int j = k + 1; j < n; j++) {\n final double t = -e[j] / e[k + 1];\n for (int i = k + 1; i < m; i++) {\n A[i][j] += t * work[i];\n }\n }\n }\n // Place the transformation in V for subsequent\n // back multiplication.\n for (int i = k + 1; i < n; i++) {\n V[i][k] = e[i];\n }\n }\n }\n // Set up the final bidiagonal matrix or order p.\n int p = n;\n if (nct < n) {\n singularValues[nct] = A[nct][nct];\n }\n if (m < p) {\n singularValues[p - 1] = 0;\n }\n if (nrt + 1 < p) {\n e[nrt] = A[nrt][p - 1];\n }\n e[p - 1] = 0;\n // Generate U.\n for (int j = nct; j < n; j++) {\n for (int i = 0; i < m; i++) {\n U[i][j] = 0;\n }\n U[j][j] = 1;\n }\n for (int k = nct - 1; k >= 0; k--) {\n if (singularValues[k] != 0) {\n for (int j = k + 1; j < n; j++) {\n double t = 0;\n for (int i = k; i < m; i++) {\n t += U[i][k] * U[i][j];\n }\n t = -t / U[k][k];\n for (int i = k; i < m; i++) {\n U[i][j] += t * U[i][k];\n }\n }\n for (int i = k; i < m; i++) {\n U[i][k] = -U[i][k];\n }\n U[k][k] = 1 + U[k][k];\n for (int i = 0; i < k - 1; i++) {\n U[i][k] = 0;\n }\n } else {\n for (int i = 0; i < m; i++) {\n U[i][k] = 0;\n }\n U[k][k] = 1;\n }\n }\n // Generate V.\n for (int k = n - 1; k >= 0; k--) {\n if (k < nrt &&\n e[k] != 0) {\n for (int j = k + 1; j < n; j++) {\n double t = 0;\n for (int i = k + 1; i < n; i++) {\n t += V[i][k] * V[i][j];\n }\n t = -t / V[k + 1][k];\n for (int i = k + 1; i < n; i++) {\n V[i][j] += t * V[i][k];\n }\n }\n }\n for (int i = 0; i < n; i++) {\n V[i][k] = 0;\n }\n V[k][k] = 1;\n }\n // Main iteration loop for the singular values.\n final int pp = p - 1;\n while (p > 0) {\n int k;\n int kase;\n // Here is where a test for too many iterations would go.\n // This section of the program inspects for\n // negligible elements in the s and e arrays.  On\n // completion the variables kase and k are set as follows.\n // kase = 1     if s(p) and e[k-1] are negligible and k<p\n // kase = 2     if s(k) is negligible and k<p\n // kase = 3     if e[k-1] is negligible, k<p, and\n //              s(k), ..., s(p) are not negligible (qr step).\n // kase = 4     if e(p-1) is negligible (convergence).\n for (k = p - 2; k >= 0; k--) {\n final double threshold\n = TINY + EPS * (FastMath.abs(singularValues[k]) +\n FastMath.abs(singularValues[k + 1]));\n // the following condition is written this way in order\n // to break out of the loop when NaN occurs, writing it\n // as "if (FastMath.abs(e[k]) <= threshold)" would loop\n // indefinitely in case of NaNs because comparison on NaNs\n // always return false, regardless of what is checked\n // see issue MATH-947\n if (!(FastMath.abs(e[k]) > threshold)) {\n e[k] = 0;\n break;\n }\n }\n if (k == p - 2) {\n kase = 4;\n } else {\n int ks;\n for (ks = p - 1; ks >= k; ks--) {\n if (ks == k) {\n break;\n }\n final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n singularValues[ks] = 0;\n break;\n }\n }\n if (ks == k) {\n kase = 3;\n } else if (ks == p - 1) {\n kase = 1;\n } else {\n kase = 2;\n k = ks;\n }\n }\n k++;\n // Perform the task indicated by kase.\n switch (kase) {\n // Deflate negligible s(p).\n case 1: {\n double f = e[p - 2];\n e[p - 2] = 0;\n for (int j = p - 2; j >= k; j--) {\n double t = FastMath.hypot(singularValues[j], f);\n final double cs = singularValues[j] / t;\n final double sn = f / t;\n singularValues[j] = t;\n if (j != k) {\n f = -sn * e[j - 1];\n e[j - 1] = cs * e[j - 1];\n }\n for (int i = 0; i < n; i++) {\n t = cs * V[i][j] + sn * V[i][p - 1];\n V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n V[i][j] = t;\n }\n }\n }\n break;\n // Split at negligible s(k).\n case 2: {\n double f = e[k - 1];\n e[k - 1] = 0;\n for (int j = k; j < p; j++) {\n double t = FastMath.hypot(singularValues[j], f);\n final double cs = singularValues[j] / t;\n final double sn = f / t;\n singularValues[j] = t;\n f = -sn * e[j];\n e[j] = cs * e[j];\n for (int i = 0; i < m; i++) {\n t = cs * U[i][j] + sn * U[i][k - 1];\n U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n U[i][j] = t;\n }\n }\n }\n break;\n // Perform one qr step.\n case 3: {\n // Calculate the shift.\n final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n FastMath.abs(singularValues[p - 2]));\n final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n FastMath.abs(e[p - 2])),\n FastMath.abs(singularValues[k])),\n FastMath.abs(e[k]));\n final double sp = singularValues[p - 1] / scale;\n final double spm1 = singularValues[p - 2] / scale;\n final double epm1 = e[p - 2] / scale;\n final double sk = singularValues[k] / scale;\n final double ek = e[k] / scale;\n final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n final double c = (sp * epm1) * (sp * epm1);\n double shift = 0;\n if (b != 0 ||\n c != 0) {\n shift = FastMath.sqrt(b * b + c);\n if (b < 0) {\n shift = -shift;\n }\n shift = c / (b + shift);\n }\n double f = (sk + sp) * (sk - sp) + shift;\n double g = sk * ek;\n // Chase zeros.\n for (int j = k; j < p - 1; j++) {\n double t = FastMath.hypot(f, g);\n double cs = f / t;\n double sn = g / t;\n if (j != k) {\n e[j - 1] = t;\n }\n f = cs * singularValues[j] + sn * e[j];\n e[j] = cs * e[j] - sn * singularValues[j];\n g = sn * singularValues[j + 1];\n singularValues[j + 1] = cs * singularValues[j + 1];\n for (int i = 0; i < n; i++) {\n t = cs * V[i][j] + sn * V[i][j + 1];\n V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n V[i][j] = t;\n }\n t = FastMath.hypot(f, g);\n cs = f / t;\n sn = g / t;\n singularValues[j] = t;\n f = cs * e[j] + sn * singularValues[j + 1];\n singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n g = sn * e[j + 1];\n e[j + 1] = cs * e[j + 1];\n if (j < m - 1) {\n for (int i = 0; i < m; i++) {\n t = cs * U[i][j] + sn * U[i][j + 1];\n U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n U[i][j] = t;\n }\n }\n }\n e[p - 2] = f;\n }\n break;\n // Convergence.\n default: {\n // Make the singular values positive.\n if (singularValues[k] <= 0) {\n singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n for (int i = 0; i <= pp; i++) {\n V[i][k] = -V[i][k];\n }\n }\n // Order the singular values.\n while (k < pp) {\n if (singularValues[k] >= singularValues[k + 1]) {\n break;\n }\n double t = singularValues[k];\n singularValues[k] = singularValues[k + 1];\n singularValues[k + 1] = t;\n if (k < n - 1) {\n for (int i = 0; i < n; i++) {\n t = V[i][k + 1];\n V[i][k + 1] = V[i][k];\n V[i][k] = t;\n }\n }\n if (k < m - 1) {\n for (int i = 0; i < m; i++) {\n t = U[i][k + 1];\n U[i][k + 1] = U[i][k];\n U[i][k] = t;\n }\n }\n k++;\n }\n p--;\n }\n break;\n }\n }\n // Set the small value tolerance used to calculate rank and pseudo-inverse\n tol = FastMath.max(m * singularValues[0] * EPS,\n FastMath.sqrt(Precision.SAFE_MIN));\n if (!transposed) {\n cachedU = MatrixUtils.createRealMatrix(U);\n cachedV = MatrixUtils.createRealMatrix(V);\n } else {\n cachedU = MatrixUtils.createRealMatrix(V);\n cachedV = MatrixUtils.createRealMatrix(U);\n }\n }\n 
466	public RealMatrix getU() {\n // return the cached matrix\n return cachedU;\n }\n 
467	public RealMatrix getUT() {\n if (cachedUt == null) {\n cachedUt = getU().transpose();\n }\n // return the cached matrix\n return cachedUt;\n }\n 
468	public RealMatrix getS() {\n if (cachedS == null) {\n // cache the matrix for subsequent calls\n cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n }\n return cachedS;\n }\n 
469	public double[] getSingularValues() {\n return singularValues.clone();\n }\n 
470	public RealMatrix getV() {\n // return the cached matrix\n return cachedV;\n }\n 
471	public RealMatrix getVT() {\n if (cachedVt == null) {\n cachedVt = getV().transpose();\n }\n // return the cached matrix\n return cachedVt;\n }\n 
472	public RealMatrix getCovariance(final double minSingularValue) {\n // get the number of singular values to consider\n final int p = singularValues.length;\n int dimension = 0;\n while (dimension < p &&\n singularValues[dimension] >= minSingularValue) {\n ++dimension;\n }\n if (dimension == 0) {\n throw new NumberIsTooLargeException(LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,\n minSingularValue, singularValues[0], true);\n }\n final double[][] data = new double[dimension][p];\n getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n /** {@inheritDoc} */\n @Override\n public void visit(final int row, final int column,\n final double value) {\n data[row][column] = value / singularValues[row];\n }\n }, 0, dimension - 1, 0, p - 1);\n RealMatrix jv = new Array2DRowRealMatrix(data, false);\n return jv.transpose().multiply(jv);\n }\n 
473	@Override\n public void visit(final int row, final int column,\n final double value) {\n data[row][column] = value / singularValues[row];\n }\n 
474	public double getNorm() {\n return singularValues[0];\n }\n 
475	public double getConditionNumber() {\n return singularValues[0] / singularValues[n - 1];\n }\n 
476	public double getInverseConditionNumber() {\n return singularValues[n - 1] / singularValues[0];\n }\n 
477	public int getRank() {\n int r = 0;\n for (int i = 0; i < singularValues.length; i++) {\n if (singularValues[i] > tol) {\n r++;\n }\n }\n return r;\n }\n 
478	public DecompositionSolver getSolver() {\n return new Solver(singularValues, getUT(), getV(), getRank() == m, tol);\n }\n 
479	private Solver(final double[] singularValues, final RealMatrix uT,\n final RealMatrix v, final boolean nonSingular, final double tol) {\n final double[][] suT = uT.getData();\n for (int i = 0; i < singularValues.length; ++i) {\n final double a;\n if (singularValues[i] > tol) {\n a = 1 / singularValues[i];\n } else {\n a = 0;\n }\n final double[] suTi = suT[i];\n for (int j = 0; j < suTi.length; ++j) {\n suTi[j] *= a;\n }\n }\n pseudoInverse = v.multiply(new Array2DRowRealMatrix(suT, false));\n this.nonSingular = nonSingular;\n }\n 
480	public RealVector solve(final RealVector b) {\n return pseudoInverse.operate(b);\n }\n 
481	public RealMatrix solve(final RealMatrix b) {\n return pseudoInverse.multiply(b);\n }\n 
482	public boolean isNonSingular() {\n return nonSingular;\n }\n 
483	public RealMatrix getInverse() {\n return pseudoInverse;\n }\n 
484	public Chromosome mutate(final Chromosome original) throws MathIllegalArgumentException {\n if (!(original instanceof RandomKey<?>)) {\n throw new MathIllegalArgumentException(LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS,\n original.getClass().getSimpleName());\n }\n RandomKey<?> originalRk = (RandomKey<?>) original;\n List<Double> repr = originalRk.getRepresentation();\n int rInd = GeneticAlgorithm.getRandomGenerator().nextInt(repr.size());\n List<Double> newRepr = new ArrayList<Double> (repr);\n newRepr.set(rInd, GeneticAlgorithm.getRandomGenerator().nextDouble());\n return originalRk.newFixedLengthChromosome(newRepr);\n }\n 
485	public BracketingNthOrderBrentSolver() {\n this(DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_MAXIMAL_ORDER);\n }\n 
486	public BracketingNthOrderBrentSolver(final double absoluteAccuracy,\n final int maximalOrder)\n throws NumberIsTooSmallException {\n super(absoluteAccuracy);\n if (maximalOrder < 2) {\n throw new NumberIsTooSmallException(maximalOrder, 2, true);\n }\n this.maximalOrder = maximalOrder;\n this.allowed = AllowedSolution.ANY_SIDE;\n }\n 
487	public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n final double absoluteAccuracy,\n final int maximalOrder)\n throws NumberIsTooSmallException {\n super(relativeAccuracy, absoluteAccuracy);\n if (maximalOrder < 2) {\n throw new NumberIsTooSmallException(maximalOrder, 2, true);\n }\n this.maximalOrder = maximalOrder;\n this.allowed = AllowedSolution.ANY_SIDE;\n }\n 
488	public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n final double absoluteAccuracy,\n final double functionValueAccuracy,\n final int maximalOrder)\n throws NumberIsTooSmallException {\n super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n if (maximalOrder < 2) {\n throw new NumberIsTooSmallException(maximalOrder, 2, true);\n }\n this.maximalOrder = maximalOrder;\n this.allowed = AllowedSolution.ANY_SIDE;\n }\n 
489	public int getMaximalOrder() {\n return maximalOrder;\n }\n 
490	@Override\n protected double doSolve()\n throws TooManyEvaluationsException,\n NumberIsTooLargeException,\n NoBracketingException {\n // prepare arrays with the first points\n final double[] x = new double[maximalOrder + 1];\n final double[] y = new double[maximalOrder + 1];\n x[0] = getMin();\n x[1] = getStartValue();\n x[2] = getMax();\n verifySequence(x[0], x[1], x[2]);\n // evaluate initial guess\n y[1] = computeObjectiveValue(x[1]);\n if (Precision.equals(y[1], 0.0, 1)) {\n // return the initial guess if it is a perfect root.\n return x[1];\n }\n // evaluate first  endpoint\n y[0] = computeObjectiveValue(x[0]);\n if (Precision.equals(y[0], 0.0, 1)) {\n // return the first endpoint if it is a perfect root.\n return x[0];\n }\n int nbPoints;\n int signChangeIndex;\n if (y[0] * y[1] < 0) {\n // reduce interval if it brackets the root\n nbPoints        = 2;\n signChangeIndex = 1;\n } else {\n // evaluate second endpoint\n y[2] = computeObjectiveValue(x[2]);\n if (Precision.equals(y[2], 0.0, 1)) {\n // return the second endpoint if it is a perfect root.\n return x[2];\n }\n if (y[1] * y[2] < 0) {\n // use all computed point as a start sampling array for solving\n nbPoints        = 3;\n signChangeIndex = 2;\n } else {\n throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n }\n }\n // prepare a work array for inverse polynomial interpolation\n final double[] tmpX = new double[x.length];\n // current tightest bracketing of the root\n double xA    = x[signChangeIndex - 1];\n double yA    = y[signChangeIndex - 1];\n double absYA = FastMath.abs(yA);\n int agingA   = 0;\n double xB    = x[signChangeIndex];\n double yB    = y[signChangeIndex];\n double absYB = FastMath.abs(yB);\n int agingB   = 0;\n // search loop\n while (true) {\n // check convergence of bracketing interval\n final double xTol = getAbsoluteAccuracy() +\n getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n switch (allowed) {\n case ANY_SIDE :\n return absYA < absYB ? xA : xB;\n case LEFT_SIDE :\n return xA;\n case RIGHT_SIDE :\n return xB;\n case BELOW_SIDE :\n return (yA <= 0) ? xA : xB;\n case ABOVE_SIDE :\n return (yA <  0) ? xB : xA;\n default :\n // this should never happen\n throw new MathInternalError();\n }\n }\n // target for the next evaluation point\n double targetY;\n if (agingA >= MAXIMAL_AGING) {\n // we keep updating the high bracket, try to compensate this\n final int p = agingA - MAXIMAL_AGING;\n final double weightA = (1 << p) - 1;\n final double weightB = p + 1;\n targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n } else if (agingB >= MAXIMAL_AGING) {\n // we keep updating the low bracket, try to compensate this\n final int p = agingB - MAXIMAL_AGING;\n final double weightA = p + 1;\n final double weightB = (1 << p) - 1;\n targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n } else {\n // bracketing is balanced, try to find the root itself\n targetY = 0;\n }\n // make a few attempts to guess a root,\n double nextX;\n int start = 0;\n int end   = nbPoints;\n do {\n // guess a value for current target, using inverse polynomial interpolation\n System.arraycopy(x, start, tmpX, start, end - start);\n nextX = guessX(targetY, tmpX, y, start, end);\n if (!((nextX > xA) && (nextX < xB))) {\n // the guessed root is not strictly inside of the tightest bracketing interval\n // the guessed root is either not strictly inside the interval or it\n // is a NaN (which occurs when some sampling points share the same y)\n // we try again with a lower interpolation order\n if (signChangeIndex - start >= end - signChangeIndex) {\n // we have more points before the sign change, drop the lowest point\n ++start;\n } else {\n // we have more points after sign change, drop the highest point\n --end;\n }\n // we need to do one more attempt\n nextX = Double.NaN;\n }\n } while (Double.isNaN(nextX) && (end - start > 1));\n if (Double.isNaN(nextX)) {\n // fall back to bisection\n nextX = xA + 0.5 * (xB - xA);\n start = signChangeIndex - 1;\n end   = signChangeIndex;\n }\n // evaluate the function at the guessed root\n final double nextY = computeObjectiveValue(nextX);\n if (Precision.equals(nextY, 0.0, 1)) {\n // we have found an exact root, since it is not an approximation\n // we don't need to bother about the allowed solutions setting\n return nextX;\n }\n if ((nbPoints > 2) && (end - start != nbPoints)) {\n // we have been forced to ignore some points to keep bracketing,\n // they are probably too far from the root, drop them from now on\n nbPoints = end - start;\n System.arraycopy(x, start, x, 0, nbPoints);\n System.arraycopy(y, start, y, 0, nbPoints);\n signChangeIndex -= start;\n } else  if (nbPoints == x.length) {\n // we have to drop one point in order to insert the new one\n nbPoints--;\n // keep the tightest bracketing interval as centered as possible\n if (signChangeIndex >= (x.length + 1) / 2) {\n // we drop the lowest point, we have to shift the arrays and the index\n System.arraycopy(x, 1, x, 0, nbPoints);\n System.arraycopy(y, 1, y, 0, nbPoints);\n --signChangeIndex;\n }\n }\n // insert the last computed point\n //(by construction, we know it lies inside the tightest bracketing interval)\n System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n x[signChangeIndex] = nextX;\n System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n y[signChangeIndex] = nextY;\n ++nbPoints;\n // update the bracketing interval\n if (nextY * yA <= 0) {\n // the sign change occurs before the inserted point\n xB = nextX;\n yB = nextY;\n absYB = FastMath.abs(yB);\n ++agingA;\n agingB = 0;\n } else {\n // the sign change occurs after the inserted point\n xA = nextX;\n yA = nextY;\n absYA = FastMath.abs(yA);\n agingA = 0;\n ++agingB;\n // update the sign change index\n signChangeIndex++;\n }\n }\n }\n 
491	private double guessX(final double targetY, final double[] x, final double[] y,\n final int start, final int end) {\n // compute Q Newton coefficients by divided differences\n for (int i = start; i < end - 1; ++i) {\n final int delta = i + 1 - start;\n for (int j = end - 1; j > i; --j) {\n x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n }\n }\n // evaluate Q(targetY)\n double x0 = 0;\n for (int j = end - 1; j >= start; --j) {\n x0 = x[j] + x0 * (targetY - y[j]);\n }\n return x0;\n }\n 
492	public double solve(int maxEval, UnivariateFunction f, double min,\n double max, AllowedSolution allowedSolution)\n throws TooManyEvaluationsException,\n NumberIsTooLargeException,\n NoBracketingException {\n this.allowed = allowedSolution;\n return super.solve(maxEval, f, min, max);\n }\n 
493	public double solve(int maxEval, UnivariateFunction f, double min,\n double max, double startValue,\n AllowedSolution allowedSolution)\n throws TooManyEvaluationsException,\n NumberIsTooLargeException,\n NoBracketingException {\n this.allowed = allowedSolution;\n return super.solve(maxEval, f, min, max, startValue);\n }\n 
494	public PolynomialFunction(double c[])\n throws NullArgumentException, NoDataException {\n super();\n MathUtils.checkNotNull(c);\n int n = c.length;\n if (n == 0) {\n throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n }\n while ((n > 1) && (c[n - 1] == 0)) {\n --n;\n }\n this.coefficients = new double[n];\n System.arraycopy(c, 0, this.coefficients, 0, n);\n }\n 
495	public double value(double x) {\n return evaluate(coefficients, x);\n }\n 
496	public int degree() {\n return coefficients.length - 1;\n }\n 
497	public double[] getCoefficients() {\n return coefficients.clone();\n }\n 
498	protected static double evaluate(double[] coefficients, double argument)\n throws NullArgumentException, NoDataException {\n MathUtils.checkNotNull(coefficients);\n int n = coefficients.length;\n if (n == 0) {\n throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n }\n double result = coefficients[n - 1];\n for (int j = n - 2; j >= 0; j--) {\n result = argument * result + coefficients[j];\n }\n return result;\n }\n 
499	public DerivativeStructure value(final DerivativeStructure t)\n throws NullArgumentException, NoDataException {\n MathUtils.checkNotNull(coefficients);\n int n = coefficients.length;\n if (n == 0) {\n throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n }\n DerivativeStructure result =\n new DerivativeStructure(t.getFreeParameters(), t.getOrder(), coefficients[n - 1]);\n for (int j = n - 2; j >= 0; j--) {\n result = result.multiply(t).add(coefficients[j]);\n }\n return result;\n }\n 
500	public PolynomialFunction add(final PolynomialFunction p) {\n // identify the lowest degree polynomial\n final int lowLength  = FastMath.min(coefficients.length, p.coefficients.length);\n final int highLength = FastMath.max(coefficients.length, p.coefficients.length);\n // build the coefficients array\n double[] newCoefficients = new double[highLength];\n for (int i = 0; i < lowLength; ++i) {\n newCoefficients[i] = coefficients[i] + p.coefficients[i];\n }\n System.arraycopy((coefficients.length < p.coefficients.length) ?\n p.coefficients : coefficients,\n lowLength,\n newCoefficients, lowLength,\n highLength - lowLength);\n return new PolynomialFunction(newCoefficients);\n }\n 
501	public PolynomialFunction subtract(final PolynomialFunction p) {\n // identify the lowest degree polynomial\n int lowLength  = FastMath.min(coefficients.length, p.coefficients.length);\n int highLength = FastMath.max(coefficients.length, p.coefficients.length);\n // build the coefficients array\n double[] newCoefficients = new double[highLength];\n for (int i = 0; i < lowLength; ++i) {\n newCoefficients[i] = coefficients[i] - p.coefficients[i];\n }\n if (coefficients.length < p.coefficients.length) {\n for (int i = lowLength; i < highLength; ++i) {\n newCoefficients[i] = -p.coefficients[i];\n }\n } else {\n System.arraycopy(coefficients, lowLength, newCoefficients, lowLength,\n highLength - lowLength);\n }\n return new PolynomialFunction(newCoefficients);\n }\n 
502	public PolynomialFunction negate() {\n double[] newCoefficients = new double[coefficients.length];\n for (int i = 0; i < coefficients.length; ++i) {\n newCoefficients[i] = -coefficients[i];\n }\n return new PolynomialFunction(newCoefficients);\n }\n 
503	public PolynomialFunction multiply(final PolynomialFunction p) {\n double[] newCoefficients = new double[coefficients.length + p.coefficients.length - 1];\n for (int i = 0; i < newCoefficients.length; ++i) {\n newCoefficients[i] = 0.0;\n for (int j = FastMath.max(0, i + 1 - p.coefficients.length);\n j < FastMath.min(coefficients.length, i + 1);\n ++j) {\n newCoefficients[i] += coefficients[j] * p.coefficients[i-j];\n }\n }\n return new PolynomialFunction(newCoefficients);\n }\n 
504	protected static double[] differentiate(double[] coefficients)\n throws NullArgumentException, NoDataException {\n MathUtils.checkNotNull(coefficients);\n int n = coefficients.length;\n if (n == 0) {\n throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n }\n if (n == 1) {\n return new double[]{0};\n }\n double[] result = new double[n - 1];\n for (int i = n - 1; i > 0; i--) {\n result[i - 1] = i * coefficients[i];\n }\n return result;\n }\n 
505	public PolynomialFunction polynomialDerivative() {\n return new PolynomialFunction(differentiate(coefficients));\n }\n 
506	public UnivariateFunction derivative() {\n return polynomialDerivative();\n }\n 
507	@Override\n public String toString() {\n StringBuilder s = new StringBuilder();\n if (coefficients[0] == 0.0) {\n if (coefficients.length == 1) {\n return "0";\n }\n } else {\n s.append(toString(coefficients[0]));\n }\n for (int i = 1; i < coefficients.length; ++i) {\n if (coefficients[i] != 0) {\n if (s.length() > 0) {\n if (coefficients[i] < 0) {\n s.append(" - ");\n } else {\n s.append(" + ");\n }\n } else {\n if (coefficients[i] < 0) {\n s.append("-");\n }\n }\n double absAi = FastMath.abs(coefficients[i]);\n if ((absAi - 1) != 0) {\n s.append(toString(absAi));\n s.append(' ');\n }\n s.append("x");\n if (i > 1) {\n s.append('^');\n s.append(Integer.toString(i));\n }\n }\n }\n return s.toString();\n }\n 
508	private static String toString(double coeff) {\n final String c = Double.toString(coeff);\n if (c.endsWith(".0")) {\n return c.substring(0, c.length() - 2);\n } else {\n return c;\n }\n }\n 
509	@Override\n public int hashCode() {\n final int prime = 31;\n int result = 1;\n result = prime * result + Arrays.hashCode(coefficients);\n return result;\n }\n 
510	@Override\n public boolean equals(Object obj) {\n if (this == obj) {\n return true;\n }\n if (!(obj instanceof PolynomialFunction)) {\n return false;\n }\n PolynomialFunction other = (PolynomialFunction) obj;\n if (!Arrays.equals(coefficients, other.coefficients)) {\n return false;\n }\n return true;\n }\n 
511	public double[] gradient(double x, double ... parameters) {\n final double[] gradient = new double[parameters.length];\n double xn = 1.0;\n for (int i = 0; i < parameters.length; ++i) {\n gradient[i] = xn;\n xn *= x;\n }\n return gradient;\n }\n 
512	public double value(final double x, final double ... parameters)\n throws NoDataException {\n return PolynomialFunction.evaluate(parameters, x);\n }\n 
513	public GeneticAlgorithm(final CrossoverPolicy crossoverPolicy,\n final double crossoverRate,\n final MutationPolicy mutationPolicy,\n final double mutationRate,\n final SelectionPolicy selectionPolicy) throws OutOfRangeException {\n if (crossoverRate < 0 || crossoverRate > 1) {\n throw new OutOfRangeException(LocalizedFormats.CROSSOVER_RATE,\n crossoverRate, 0, 1);\n }\n if (mutationRate < 0 || mutationRate > 1) {\n throw new OutOfRangeException(LocalizedFormats.MUTATION_RATE,\n mutationRate, 0, 1);\n }\n this.crossoverPolicy = crossoverPolicy;\n this.crossoverRate = crossoverRate;\n this.mutationPolicy = mutationPolicy;\n this.mutationRate = mutationRate;\n this.selectionPolicy = selectionPolicy;\n }\n 
514	public static synchronized void setRandomGenerator(final RandomGenerator random) {\n randomGenerator = random;\n }\n 
515	public static synchronized RandomGenerator getRandomGenerator() {\n return randomGenerator;\n }\n 
516	public Population evolve(final Population initial, final StoppingCondition condition) {\n Population current = initial;\n generationsEvolved = 0;\n while (!condition.isSatisfied(current)) {\n current = nextGeneration(current);\n generationsEvolved++;\n }\n return current;\n }\n 
517	public Population nextGeneration(final Population current) {\n Population nextGeneration = current.nextGeneration();\n RandomGenerator randGen = getRandomGenerator();\n while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n // select parent chromosomes\n ChromosomePair pair = getSelectionPolicy().select(current);\n // crossover?\n if (randGen.nextDouble() < getCrossoverRate()) {\n // apply crossover policy to create two offspring\n pair = getCrossoverPolicy().crossover(pair.getFirst(), pair.getSecond());\n }\n // mutation?\n if (randGen.nextDouble() < getMutationRate()) {\n // apply mutation policy to the chromosomes\n pair = new ChromosomePair(\n getMutationPolicy().mutate(pair.getFirst()),\n getMutationPolicy().mutate(pair.getSecond()));\n }\n // add the first chromosome to the population\n nextGeneration.addChromosome(pair.getFirst());\n // is there still a place for the second chromosome?\n if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n // add the second chromosome to the population\n nextGeneration.addChromosome(pair.getSecond());\n }\n }\n return nextGeneration;\n }\n 
518	public CrossoverPolicy getCrossoverPolicy() {\n return crossoverPolicy;\n }\n 
519	public double getCrossoverRate() {\n return crossoverRate;\n }\n 
520	public MutationPolicy getMutationPolicy() {\n return mutationPolicy;\n }\n 
521	public double getMutationRate() {\n return mutationRate;\n }\n 
522	public SelectionPolicy getSelectionPolicy() {\n return selectionPolicy;\n }\n 
523	public int getGenerationsEvolved() {\n return generationsEvolved;\n }\n 
524	public BlockRealMatrix(final int rows, final int columns)\n throws NotStrictlyPositiveException {\n super(rows, columns);\n this.rows = rows;\n this.columns = columns;\n // number of blocks\n blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n // allocate storage blocks, taking care of smaller ones at right and bottom\n blocks = createBlocksLayout(rows, columns);\n }\n 
525	public BlockRealMatrix(final double[][] rawData)\n throws DimensionMismatchException, NotStrictlyPositiveException {\n this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n }\n 
526	public BlockRealMatrix(final int rows, final int columns,\n final double[][] blockData, final boolean copyArray)\n throws DimensionMismatchException, NotStrictlyPositiveException {\n super(rows, columns);\n this.rows = rows;\n this.columns = columns;\n // number of blocks\n blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n if (copyArray) {\n // allocate storage blocks, taking care of smaller ones at right and bottom\n blocks = new double[blockRows * blockColumns][];\n } else {\n // reference existing array\n blocks = blockData;\n }\n int index = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n throw new DimensionMismatchException(blockData[index].length,\n iHeight * blockWidth(jBlock));\n }\n if (copyArray) {\n blocks[index] = blockData[index].clone();\n }\n }\n }\n }\n 
527	public static double[][] toBlocksLayout(final double[][] rawData)\n throws DimensionMismatchException {\n final int rows = rawData.length;\n final int columns = rawData[0].length;\n final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n // safety checks\n for (int i = 0; i < rawData.length; ++i) {\n final int length = rawData[i].length;\n if (length != columns) {\n throw new DimensionMismatchException(columns, length);\n }\n }\n // convert array\n final double[][] blocks = new double[blockRows * blockColumns][];\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n final int iHeight = pEnd - pStart;\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n final int jWidth = qEnd - qStart;\n // allocate new block\n final double[] block = new double[iHeight * jWidth];\n blocks[blockIndex] = block;\n // copy data\n int index = 0;\n for (int p = pStart; p < pEnd; ++p) {\n System.arraycopy(rawData[p], qStart, block, index, jWidth);\n index += jWidth;\n }\n ++blockIndex;\n }\n }\n return blocks;\n }\n 
528	public static double[][] createBlocksLayout(final int rows, final int columns) {\n final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n final double[][] blocks = new double[blockRows * blockColumns][];\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n final int iHeight = pEnd - pStart;\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n final int jWidth = qEnd - qStart;\n blocks[blockIndex] = new double[iHeight * jWidth];\n ++blockIndex;\n }\n }\n return blocks;\n }\n 
529	@Override\n public BlockRealMatrix createMatrix(final int rowDimension,\n final int columnDimension)\n throws NotStrictlyPositiveException {\n return new BlockRealMatrix(rowDimension, columnDimension);\n }\n 
530	@Override\n public BlockRealMatrix copy() {\n // create an empty matrix\n BlockRealMatrix copied = new BlockRealMatrix(rows, columns);\n // copy the blocks\n for (int i = 0; i < blocks.length; ++i) {\n System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n }\n return copied;\n }\n 
531	@Override\n public BlockRealMatrix add(final RealMatrix m)\n throws MatrixDimensionMismatchException {\n try {\n return add((BlockRealMatrix) m);\n } catch (ClassCastException cce) {\n // safety check\n MatrixUtils.checkAdditionCompatible(this, m);\n final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n // perform addition block-wise, to ensure good cache behavior\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n // perform addition on the current block\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock   = blocks[blockIndex];\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n for (int q = qStart; q < qEnd; ++q) {\n outBlock[k] = tBlock[k] + m.getEntry(p, q);\n ++k;\n }\n }\n // go to next block\n ++blockIndex;\n }\n }\n return out;\n }\n }\n 
532	public BlockRealMatrix add(final BlockRealMatrix m)\n throws MatrixDimensionMismatchException {\n // safety check\n MatrixUtils.checkAdditionCompatible(this, m);\n final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n // perform addition block-wise, to ensure good cache behavior\n for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock = blocks[blockIndex];\n final double[] mBlock = m.blocks[blockIndex];\n for (int k = 0; k < outBlock.length; ++k) {\n outBlock[k] = tBlock[k] + mBlock[k];\n }\n }\n return out;\n }\n 
533	@Override\n public BlockRealMatrix subtract(final RealMatrix m)\n throws MatrixDimensionMismatchException {\n try {\n return subtract((BlockRealMatrix) m);\n } catch (ClassCastException cce) {\n // safety check\n MatrixUtils.checkSubtractionCompatible(this, m);\n final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n // perform subtraction block-wise, to ensure good cache behavior\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n // perform subtraction on the current block\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock = blocks[blockIndex];\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n for (int q = qStart; q < qEnd; ++q) {\n outBlock[k] = tBlock[k] - m.getEntry(p, q);\n ++k;\n }\n }\n // go to next block\n ++blockIndex;\n }\n }\n return out;\n }\n }\n 
534	public BlockRealMatrix subtract(final BlockRealMatrix m)\n throws MatrixDimensionMismatchException {\n // safety check\n MatrixUtils.checkSubtractionCompatible(this, m);\n final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n // perform subtraction block-wise, to ensure good cache behavior\n for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock = blocks[blockIndex];\n final double[] mBlock = m.blocks[blockIndex];\n for (int k = 0; k < outBlock.length; ++k) {\n outBlock[k] = tBlock[k] - mBlock[k];\n }\n }\n return out;\n }\n 
535	@Override\n public BlockRealMatrix scalarAdd(final double d) {\n final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n // perform subtraction block-wise, to ensure good cache behavior\n for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock = blocks[blockIndex];\n for (int k = 0; k < outBlock.length; ++k) {\n outBlock[k] = tBlock[k] + d;\n }\n }\n return out;\n }\n 
536	@Override\n public RealMatrix scalarMultiply(final double d) {\n final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n // perform subtraction block-wise, to ensure good cache behavior\n for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock = blocks[blockIndex];\n for (int k = 0; k < outBlock.length; ++k) {\n outBlock[k] = tBlock[k] * d;\n }\n }\n return out;\n }\n 
537	@Override\n public BlockRealMatrix multiply(final RealMatrix m)\n throws DimensionMismatchException {\n try {\n return multiply((BlockRealMatrix) m);\n } catch (ClassCastException cce) {\n // safety check\n MatrixUtils.checkMultiplicationCompatible(this, m);\n final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n // perform multiplication block-wise, to ensure good cache behavior\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n // select current block\n final double[] outBlock = out.blocks[blockIndex];\n // perform multiplication on current block\n for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n final int kWidth = blockWidth(kBlock);\n final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n final int rStart = kBlock * BLOCK_SIZE;\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n final int lStart = (p - pStart) * kWidth;\n final int lEnd = lStart + kWidth;\n for (int q = qStart; q < qEnd; ++q) {\n double sum = 0;\n int r = rStart;\n for (int l = lStart; l < lEnd; ++l) {\n sum += tBlock[l] * m.getEntry(r, q);\n ++r;\n }\n outBlock[k] += sum;\n ++k;\n }\n }\n }\n // go to next block\n ++blockIndex;\n }\n }\n return out;\n }\n }\n 
538	public BlockRealMatrix multiply(BlockRealMatrix m)\n throws DimensionMismatchException {\n // safety check\n MatrixUtils.checkMultiplicationCompatible(this, m);\n final BlockRealMatrix out = new BlockRealMatrix(rows, m.columns);\n // perform multiplication block-wise, to ensure good cache behavior\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n final int jWidth = out.blockWidth(jBlock);\n final int jWidth2 = jWidth  + jWidth;\n final int jWidth3 = jWidth2 + jWidth;\n final int jWidth4 = jWidth3 + jWidth;\n // select current block\n final double[] outBlock = out.blocks[blockIndex];\n // perform multiplication on current block\n for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n final int kWidth = blockWidth(kBlock);\n final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n final int lStart = (p - pStart) * kWidth;\n final int lEnd = lStart + kWidth;\n for (int nStart = 0; nStart < jWidth; ++nStart) {\n double sum = 0;\n int l = lStart;\n int n = nStart;\n while (l < lEnd - 3) {\n sum += tBlock[l] * mBlock[n] +\n tBlock[l + 1] * mBlock[n + jWidth] +\n tBlock[l + 2] * mBlock[n + jWidth2] +\n tBlock[l + 3] * mBlock[n + jWidth3];\n l += 4;\n n += jWidth4;\n }\n while (l < lEnd) {\n sum += tBlock[l++] * mBlock[n];\n n += jWidth;\n }\n outBlock[k] += sum;\n ++k;\n }\n }\n }\n // go to next block\n ++blockIndex;\n }\n }\n return out;\n }\n 
539	@Override\n public double[][] getData() {\n final double[][] data = new double[getRowDimension()][getColumnDimension()];\n final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n int regularPos = 0;\n int lastPos = 0;\n for (int p = pStart; p < pEnd; ++p) {\n final double[] dataP = data[p];\n int blockIndex = iBlock * blockColumns;\n int dataPos = 0;\n for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n dataPos += BLOCK_SIZE;\n }\n System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n regularPos += BLOCK_SIZE;\n lastPos    += lastColumns;\n }\n }\n return data;\n }\n 
540	@Override\n public double getNorm() {\n final double[] colSums = new double[BLOCK_SIZE];\n double maxColSum = 0;\n for (int jBlock = 0; jBlock < blockColumns; jBlock++) {\n final int jWidth = blockWidth(jBlock);\n Arrays.fill(colSums, 0, jWidth, 0.0);\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int j = 0; j < jWidth; ++j) {\n double sum = 0;\n for (int i = 0; i < iHeight; ++i) {\n sum += FastMath.abs(block[i * jWidth + j]);\n }\n colSums[j] += sum;\n }\n }\n for (int j = 0; j < jWidth; ++j) {\n maxColSum = FastMath.max(maxColSum, colSums[j]);\n }\n }\n return maxColSum;\n }\n 
541	@Override\n public double getFrobeniusNorm() {\n double sum2 = 0;\n for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) {\n for (final double entry : blocks[blockIndex]) {\n sum2 += entry * entry;\n }\n }\n return FastMath.sqrt(sum2);\n }\n 
542	@Override\n public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n final int startColumn,\n final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n // safety checks\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n // create the output matrix\n final BlockRealMatrix out =\n new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n // compute blocks shifts\n final int blockStartRow = startRow / BLOCK_SIZE;\n final int rowsShift = startRow % BLOCK_SIZE;\n final int blockStartColumn = startColumn / BLOCK_SIZE;\n final int columnsShift = startColumn % BLOCK_SIZE;\n // perform extraction block-wise, to ensure good cache behavior\n int pBlock = blockStartRow;\n for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n final int iHeight = out.blockHeight(iBlock);\n int qBlock = blockStartColumn;\n for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n final int jWidth = out.blockWidth(jBlock);\n // handle one block of the output matrix\n final int outIndex = iBlock * out.blockColumns + jBlock;\n final double[] outBlock = out.blocks[outIndex];\n final int index = pBlock * blockColumns + qBlock;\n final int width = blockWidth(qBlock);\n final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n final int widthExcess = jWidth + columnsShift - BLOCK_SIZE;\n if (heightExcess > 0) {\n // the submatrix block spans on two blocks rows from the original matrix\n if (widthExcess > 0) {\n // the submatrix block spans on two blocks columns from the original matrix\n final int width2 = blockWidth(qBlock + 1);\n copyBlockPart(blocks[index], width,\n rowsShift, BLOCK_SIZE,\n columnsShift, BLOCK_SIZE,\n outBlock, jWidth, 0, 0);\n copyBlockPart(blocks[index + 1], width2,\n rowsShift, BLOCK_SIZE,\n 0, widthExcess,\n outBlock, jWidth, 0, jWidth - widthExcess);\n copyBlockPart(blocks[index + blockColumns], width,\n 0, heightExcess,\n columnsShift, BLOCK_SIZE,\n outBlock, jWidth, iHeight - heightExcess, 0);\n copyBlockPart(blocks[index + blockColumns + 1], width2,\n 0, heightExcess,\n 0, widthExcess,\n outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n } else {\n // the submatrix block spans on one block column from the original matrix\n copyBlockPart(blocks[index], width,\n rowsShift, BLOCK_SIZE,\n columnsShift, jWidth + columnsShift,\n outBlock, jWidth, 0, 0);\n copyBlockPart(blocks[index + blockColumns], width,\n 0, heightExcess,\n columnsShift, jWidth + columnsShift,\n outBlock, jWidth, iHeight - heightExcess, 0);\n }\n } else {\n // the submatrix block spans on one block row from the original matrix\n if (widthExcess > 0) {\n // the submatrix block spans on two blocks columns from the original matrix\n final int width2 = blockWidth(qBlock + 1);\n copyBlockPart(blocks[index], width,\n rowsShift, iHeight + rowsShift,\n columnsShift, BLOCK_SIZE,\n outBlock, jWidth, 0, 0);\n copyBlockPart(blocks[index + 1], width2,\n rowsShift, iHeight + rowsShift,\n 0, widthExcess,\n outBlock, jWidth, 0, jWidth - widthExcess);\n } else {\n // the submatrix block spans on one block column from the original matrix\n copyBlockPart(blocks[index], width,\n rowsShift, iHeight + rowsShift,\n columnsShift, jWidth + columnsShift,\n outBlock, jWidth, 0, 0);\n }\n }\n ++qBlock;\n }\n ++pBlock;\n }\n return out;\n }\n 
543	private void copyBlockPart(final double[] srcBlock, final int srcWidth,\n final int srcStartRow, final int srcEndRow,\n final int srcStartColumn, final int srcEndColumn,\n final double[] dstBlock, final int dstWidth,\n final int dstStartRow, final int dstStartColumn) {\n final int length = srcEndColumn - srcStartColumn;\n int srcPos = srcStartRow * srcWidth + srcStartColumn;\n int dstPos = dstStartRow * dstWidth + dstStartColumn;\n for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n srcPos += srcWidth;\n dstPos += dstWidth;\n }\n }\n 
544	@Override\n public void setSubMatrix(final double[][] subMatrix, final int row,\n final int column)\n throws OutOfRangeException, NoDataException, NullArgumentException,\n DimensionMismatchException {\n // safety checks\n MathUtils.checkNotNull(subMatrix);\n final int refLength = subMatrix[0].length;\n if (refLength == 0) {\n throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n }\n final int endRow = row + subMatrix.length - 1;\n final int endColumn = column + refLength - 1;\n MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n for (final double[] subRow : subMatrix) {\n if (subRow.length != refLength) {\n throw new DimensionMismatchException(refLength, subRow.length);\n }\n }\n // compute blocks bounds\n final int blockStartRow = row / BLOCK_SIZE;\n final int blockEndRow = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n final int blockStartColumn = column / BLOCK_SIZE;\n final int blockEndColumn = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n // perform copy block-wise, to ensure good cache behavior\n for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final int firstRow = iBlock * BLOCK_SIZE;\n final int iStart = FastMath.max(row,    firstRow);\n final int iEnd = FastMath.min(endRow + 1, firstRow + iHeight);\n for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int firstColumn = jBlock * BLOCK_SIZE;\n final int jStart = FastMath.max(column,    firstColumn);\n final int jEnd = FastMath.min(endColumn + 1, firstColumn + jWidth);\n final int jLength = jEnd - jStart;\n // handle one block, row by row\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int i = iStart; i < iEnd; ++i) {\n System.arraycopy(subMatrix[i - row], jStart - column,\n block, (i - firstRow) * jWidth + (jStart - firstColumn),\n jLength);\n }\n }\n }\n }\n 
545	@Override\n public BlockRealMatrix getRowMatrix(final int row)\n throws OutOfRangeException {\n MatrixUtils.checkRowIndex(this, row);\n final BlockRealMatrix out = new BlockRealMatrix(1, columns);\n // perform copy block-wise, to ensure good cache behavior\n final int iBlock = row / BLOCK_SIZE;\n final int iRow = row - iBlock * BLOCK_SIZE;\n int outBlockIndex = 0;\n int outIndex = 0;\n double[] outBlock = out.blocks[outBlockIndex];\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n final int available = outBlock.length - outIndex;\n if (jWidth > available) {\n System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n outBlock = out.blocks[++outBlockIndex];\n System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n outIndex = jWidth - available;\n } else {\n System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n outIndex += jWidth;\n }\n }\n return out;\n }\n 
546	@Override\n public void setRowMatrix(final int row, final RealMatrix matrix)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n try {\n setRowMatrix(row, (BlockRealMatrix) matrix);\n } catch (ClassCastException cce) {\n super.setRowMatrix(row, matrix);\n }\n }\n 
547	public void setRowMatrix(final int row, final BlockRealMatrix matrix)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n MatrixUtils.checkRowIndex(this, row);\n final int nCols = getColumnDimension();\n if ((matrix.getRowDimension() != 1) ||\n (matrix.getColumnDimension() != nCols)) {\n throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n matrix.getColumnDimension(),\n 1, nCols);\n }\n // perform copy block-wise, to ensure good cache behavior\n final int iBlock = row / BLOCK_SIZE;\n final int iRow = row - iBlock * BLOCK_SIZE;\n int mBlockIndex = 0;\n int mIndex = 0;\n double[] mBlock = matrix.blocks[mBlockIndex];\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n final int available  = mBlock.length - mIndex;\n if (jWidth > available) {\n System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n mBlock = matrix.blocks[++mBlockIndex];\n System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n mIndex = jWidth - available;\n } else {\n System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n mIndex += jWidth;\n }\n }\n }\n 
548	@Override\n public BlockRealMatrix getColumnMatrix(final int column)\n throws OutOfRangeException {\n MatrixUtils.checkColumnIndex(this, column);\n final BlockRealMatrix out = new BlockRealMatrix(rows, 1);\n // perform copy block-wise, to ensure good cache behavior\n final int jBlock = column / BLOCK_SIZE;\n final int jColumn = column - jBlock * BLOCK_SIZE;\n final int jWidth = blockWidth(jBlock);\n int outBlockIndex = 0;\n int outIndex = 0;\n double[] outBlock = out.blocks[outBlockIndex];\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int i = 0; i < iHeight; ++i) {\n if (outIndex >= outBlock.length) {\n outBlock = out.blocks[++outBlockIndex];\n outIndex = 0;\n }\n outBlock[outIndex++] = block[i * jWidth + jColumn];\n }\n }\n return out;\n }\n 
549	@Override\n public void setColumnMatrix(final int column, final RealMatrix matrix)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n try {\n setColumnMatrix(column, (BlockRealMatrix) matrix);\n } catch (ClassCastException cce) {\n super.setColumnMatrix(column, matrix);\n }\n }\n 
550	void setColumnMatrix(final int column, final BlockRealMatrix matrix)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n MatrixUtils.checkColumnIndex(this, column);\n final int nRows = getRowDimension();\n if ((matrix.getRowDimension() != nRows) ||\n (matrix.getColumnDimension() != 1)) {\n throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n matrix.getColumnDimension(),\n nRows, 1);\n }\n // perform copy block-wise, to ensure good cache behavior\n final int jBlock = column / BLOCK_SIZE;\n final int jColumn = column - jBlock * BLOCK_SIZE;\n final int jWidth = blockWidth(jBlock);\n int mBlockIndex = 0;\n int mIndex = 0;\n double[] mBlock = matrix.blocks[mBlockIndex];\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int i = 0; i < iHeight; ++i) {\n if (mIndex >= mBlock.length) {\n mBlock = matrix.blocks[++mBlockIndex];\n mIndex = 0;\n }\n block[i * jWidth + jColumn] = mBlock[mIndex++];\n }\n }\n }\n 
551	@Override\n public RealVector getRowVector(final int row)\n throws OutOfRangeException {\n MatrixUtils.checkRowIndex(this, row);\n final double[] outData = new double[columns];\n // perform copy block-wise, to ensure good cache behavior\n final int iBlock = row / BLOCK_SIZE;\n final int iRow = row - iBlock * BLOCK_SIZE;\n int outIndex = 0;\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n outIndex += jWidth;\n }\n return new ArrayRealVector(outData, false);\n }\n 
552	@Override\n public void setRowVector(final int row, final RealVector vector)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n try {\n setRow(row, ((ArrayRealVector) vector).getDataRef());\n } catch (ClassCastException cce) {\n super.setRowVector(row, vector);\n }\n }\n 
553	@Override\n public RealVector getColumnVector(final int column)\n throws OutOfRangeException {\n MatrixUtils.checkColumnIndex(this, column);\n final double[] outData = new double[rows];\n // perform copy block-wise, to ensure good cache behavior\n final int jBlock = column / BLOCK_SIZE;\n final int jColumn = column - jBlock * BLOCK_SIZE;\n final int jWidth = blockWidth(jBlock);\n int outIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int i = 0; i < iHeight; ++i) {\n outData[outIndex++] = block[i * jWidth + jColumn];\n }\n }\n return new ArrayRealVector(outData, false);\n }\n 
554	@Override\n public void setColumnVector(final int column, final RealVector vector)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n try {\n setColumn(column, ((ArrayRealVector) vector).getDataRef());\n } catch (ClassCastException cce) {\n super.setColumnVector(column, vector);\n }\n }\n 
555	@Override\n public double[] getRow(final int row) throws OutOfRangeException {\n MatrixUtils.checkRowIndex(this, row);\n final double[] out = new double[columns];\n // perform copy block-wise, to ensure good cache behavior\n final int iBlock = row / BLOCK_SIZE;\n final int iRow = row - iBlock * BLOCK_SIZE;\n int outIndex = 0;\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth     = blockWidth(jBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n outIndex += jWidth;\n }\n return out;\n }\n 
556	@Override\n public void setRow(final int row, final double[] array)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n MatrixUtils.checkRowIndex(this, row);\n final int nCols = getColumnDimension();\n if (array.length != nCols) {\n throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n }\n // perform copy block-wise, to ensure good cache behavior\n final int iBlock = row / BLOCK_SIZE;\n final int iRow = row - iBlock * BLOCK_SIZE;\n int outIndex = 0;\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth     = blockWidth(jBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n outIndex += jWidth;\n }\n }\n 
557	@Override\n public double[] getColumn(final int column) throws OutOfRangeException {\n MatrixUtils.checkColumnIndex(this, column);\n final double[] out = new double[rows];\n // perform copy block-wise, to ensure good cache behavior\n final int jBlock  = column / BLOCK_SIZE;\n final int jColumn = column - jBlock * BLOCK_SIZE;\n final int jWidth  = blockWidth(jBlock);\n int outIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int i = 0; i < iHeight; ++i) {\n out[outIndex++] = block[i * jWidth + jColumn];\n }\n }\n return out;\n }\n 
558	@Override\n public void setColumn(final int column, final double[] array)\n throws OutOfRangeException, MatrixDimensionMismatchException {\n MatrixUtils.checkColumnIndex(this, column);\n final int nRows = getRowDimension();\n if (array.length != nRows) {\n throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n }\n // perform copy block-wise, to ensure good cache behavior\n final int jBlock  = column / BLOCK_SIZE;\n final int jColumn = column - jBlock * BLOCK_SIZE;\n final int jWidth = blockWidth(jBlock);\n int outIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int iHeight = blockHeight(iBlock);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int i = 0; i < iHeight; ++i) {\n block[i * jWidth + jColumn] = array[outIndex++];\n }\n }\n }\n 
559	@Override\n public double getEntry(final int row, final int column)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n final int iBlock = row / BLOCK_SIZE;\n final int jBlock = column / BLOCK_SIZE;\n final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n (column - jBlock * BLOCK_SIZE);\n return blocks[iBlock * blockColumns + jBlock][k];\n }\n 
560	@Override\n public void setEntry(final int row, final int column, final double value)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n final int iBlock = row / BLOCK_SIZE;\n final int jBlock = column / BLOCK_SIZE;\n final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n (column - jBlock * BLOCK_SIZE);\n blocks[iBlock * blockColumns + jBlock][k] = value;\n }\n 
561	@Override\n public void addToEntry(final int row, final int column,\n final double increment)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n final int iBlock = row    / BLOCK_SIZE;\n final int jBlock = column / BLOCK_SIZE;\n final int k = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n (column - jBlock * BLOCK_SIZE);\n blocks[iBlock * blockColumns + jBlock][k] += increment;\n }\n 
562	@Override\n public void multiplyEntry(final int row, final int column,\n final double factor)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n final int iBlock = row / BLOCK_SIZE;\n final int jBlock = column / BLOCK_SIZE;\n final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n (column - jBlock * BLOCK_SIZE);\n blocks[iBlock * blockColumns + jBlock][k] *= factor;\n }\n 
563	@Override\n public BlockRealMatrix transpose() {\n final int nRows = getRowDimension();\n final int nCols = getColumnDimension();\n final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n // perform transpose block-wise, to ensure good cache behavior\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n // transpose current block\n final double[] outBlock = out.blocks[blockIndex];\n final double[] tBlock = blocks[jBlock * blockColumns + iBlock];\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n final int lInc = pEnd - pStart;\n int l = p - pStart;\n for (int q = qStart; q < qEnd; ++q) {\n outBlock[k] = tBlock[l];\n ++k;\n l+= lInc;\n }\n }\n // go to next block\n ++blockIndex;\n }\n }\n return out;\n }\n 
564	@Override\n public int getRowDimension() {\n return rows;\n }\n 
565	@Override\n public int getColumnDimension() {\n return columns;\n }\n 
566	@Override\n public double[] operate(final double[] v)\n throws DimensionMismatchException {\n if (v.length != columns) {\n throw new DimensionMismatchException(v.length, columns);\n }\n final double[] out = new double[rows];\n // perform multiplication block-wise, to ensure good cache behavior\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final double[] block  = blocks[iBlock * blockColumns + jBlock];\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n double sum = 0;\n int q = qStart;\n while (q < qEnd - 3) {\n sum += block[k]     * v[q]     +\n block[k + 1] * v[q + 1] +\n block[k + 2] * v[q + 2] +\n block[k + 3] * v[q + 3];\n k += 4;\n q += 4;\n }\n while (q < qEnd) {\n sum += block[k++] * v[q++];\n }\n out[p] += sum;\n }\n }\n }\n return out;\n }\n 
567	@Override\n public double[] preMultiply(final double[] v)\n throws DimensionMismatchException {\n if (v.length != rows) {\n throw new DimensionMismatchException(v.length, rows);\n }\n final double[] out = new double[columns];\n // perform multiplication block-wise, to ensure good cache behavior\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth  = blockWidth(jBlock);\n final int jWidth2 = jWidth  + jWidth;\n final int jWidth3 = jWidth2 + jWidth;\n final int jWidth4 = jWidth3 + jWidth;\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final double[] block  = blocks[iBlock * blockColumns + jBlock];\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int q = qStart; q < qEnd; ++q) {\n int k = q - qStart;\n double sum = 0;\n int p = pStart;\n while (p < pEnd - 3) {\n sum += block[k]           * v[p]     +\n block[k + jWidth]  * v[p + 1] +\n block[k + jWidth2] * v[p + 2] +\n block[k + jWidth3] * v[p + 3];\n k += jWidth4;\n p += 4;\n }\n while (p < pEnd) {\n sum += block[k] * v[p++];\n k += jWidth;\n }\n out[q] += sum;\n }\n }\n }\n return out;\n }\n 
568	@Override\n public double walkInRowOrder(final RealMatrixChangingVisitor visitor) {\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int p = pStart; p < pEnd; ++p) {\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n int k = (p - pStart) * jWidth;\n for (int q = qStart; q < qEnd; ++q) {\n block[k] = visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n }\n }\n return visitor.end();\n }\n 
569	@Override\n public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int p = pStart; p < pEnd; ++p) {\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n int k = (p - pStart) * jWidth;\n for (int q = qStart; q < qEnd; ++q) {\n visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n }\n }\n return visitor.end();\n }\n 
570	@Override\n public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn, final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n final int p0 = iBlock * BLOCK_SIZE;\n final int pStart = FastMath.max(startRow, p0);\n final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n for (int p = pStart; p < pEnd; ++p) {\n for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int q0 = jBlock * BLOCK_SIZE;\n final int qStart = FastMath.max(startColumn, q0);\n final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n int k = (p - p0) * jWidth + qStart - q0;\n for (int q = qStart; q < qEnd; ++q) {\n block[k] = visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n }\n }\n return visitor.end();\n }\n 
571	@Override\n public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn, final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n final int p0 = iBlock * BLOCK_SIZE;\n final int pStart = FastMath.max(startRow, p0);\n final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n for (int p = pStart; p < pEnd; ++p) {\n for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int q0 = jBlock * BLOCK_SIZE;\n final int qStart = FastMath.max(startColumn, q0);\n final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n int k = (p - p0) * jWidth + qStart - q0;\n for (int q = qStart; q < qEnd; ++q) {\n visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n }\n }\n return visitor.end();\n }\n 
572	@Override\n public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor) {\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n final double[] block = blocks[blockIndex];\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n for (int q = qStart; q < qEnd; ++q) {\n block[k] = visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n ++blockIndex;\n }\n }\n return visitor.end();\n }\n 
573	@Override\n public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n int blockIndex = 0;\n for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n final int pStart = iBlock * BLOCK_SIZE;\n final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n final int qStart = jBlock * BLOCK_SIZE;\n final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n final double[] block = blocks[blockIndex];\n int k = 0;\n for (int p = pStart; p < pEnd; ++p) {\n for (int q = qStart; q < qEnd; ++q) {\n visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n ++blockIndex;\n }\n }\n return visitor.end();\n }\n 
574	@Override\n public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn,\n final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n final int p0 = iBlock * BLOCK_SIZE;\n final int pStart = FastMath.max(startRow, p0);\n final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int q0 = jBlock * BLOCK_SIZE;\n final int qStart = FastMath.max(startColumn, q0);\n final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int p = pStart; p < pEnd; ++p) {\n int k = (p - p0) * jWidth + qStart - q0;\n for (int q = qStart; q < qEnd; ++q) {\n block[k] = visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n }\n }\n return visitor.end();\n }\n 
575	@Override\n public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn,\n final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n final int p0 = iBlock * BLOCK_SIZE;\n final int pStart = FastMath.max(startRow, p0);\n final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n final int jWidth = blockWidth(jBlock);\n final int q0 = jBlock * BLOCK_SIZE;\n final int qStart = FastMath.max(startColumn, q0);\n final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n final double[] block = blocks[iBlock * blockColumns + jBlock];\n for (int p = pStart; p < pEnd; ++p) {\n int k = (p - p0) * jWidth + qStart - q0;\n for (int q = qStart; q < qEnd; ++q) {\n visitor.visit(p, q, block[k]);\n ++k;\n }\n }\n }\n }\n return visitor.end();\n }\n 
576	private int blockHeight(final int blockRow) {\n return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n }\n 
577	private int blockWidth(final int blockColumn) {\n return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n }\n 
578	public BisectionSolver() {\n this(DEFAULT_ABSOLUTE_ACCURACY);\n }\n 
579	public BisectionSolver(double absoluteAccuracy) {\n super(absoluteAccuracy);\n }\n 
580	public BisectionSolver(double relativeAccuracy,\n double absoluteAccuracy) {\n super(relativeAccuracy, absoluteAccuracy);\n }\n 
581	@Override\n protected double doSolve()\n throws TooManyEvaluationsException {\n double min = getMin();\n double max = getMax();\n verifyInterval(min, max);\n final double absoluteAccuracy = getAbsoluteAccuracy();\n double m;\n double fm;\n double fmin;\n while (true) {\n m = UnivariateSolverUtils.midpoint(min, max);\n fmin = computeObjectiveValue(min);\n fm = computeObjectiveValue(m);\n if (fm * fmin > 0) {\n // max and m bracket the root.\n min = m;\n } else {\n // min and m bracket the root.\n max = m;\n }\n if (FastMath.abs(max - min) <= absoluteAccuracy) {\n m = UnivariateSolverUtils.midpoint(min, max);\n return m;\n }\n }\n }\n 
582	public MathIllegalStateException(Localizable pattern,\n Object ... args) {\n context = new ExceptionContext(this);\n context.addMessage(pattern, args);\n }\n 
583	public MathIllegalStateException(Throwable cause,\n Localizable pattern,\n Object ... args) {\n super(cause);\n context = new ExceptionContext(this);\n context.addMessage(pattern, args);\n }\n 
584	public MathIllegalStateException() {\n this(LocalizedFormats.ILLEGAL_STATE);\n }\n 
585	public ExceptionContext getContext() {\n return context;\n }\n 
586	@Override\n public String getMessage() {\n return context.getMessage();\n }\n 
587	@Override\n public String getLocalizedMessage() {\n return context.getLocalizedMessage();\n }\n 
588	public MathArithmeticException() {\n context = new ExceptionContext(this);\n context.addMessage(LocalizedFormats.ARITHMETIC_EXCEPTION);\n }\n 
589	public MathArithmeticException(Localizable pattern,\n Object ... args) {\n context = new ExceptionContext(this);\n context.addMessage(pattern, args);\n }\n 
590	public ExceptionContext getContext() {\n return context;\n }\n 
591	@Override\n public String getMessage() {\n return context.getMessage();\n }\n 
592	@Override\n public String getLocalizedMessage() {\n return context.getLocalizedMessage();\n }\n 
593	public FractionFormat() {\n }\n 
594	public FractionFormat(final NumberFormat format) {\n super(format);\n }\n 
595	public FractionFormat(final NumberFormat numeratorFormat,\n final NumberFormat denominatorFormat) {\n super(numeratorFormat, denominatorFormat);\n }\n 
596	public static Locale[] getAvailableLocales() {\n return NumberFormat.getAvailableLocales();\n }\n 
597	public static String formatFraction(Fraction f) {\n return getImproperInstance().format(f);\n }\n 
598	public static FractionFormat getImproperInstance() {\n return getImproperInstance(Locale.getDefault());\n }\n 
599	public static FractionFormat getImproperInstance(final Locale locale) {\n return new FractionFormat(getDefaultNumberFormat(locale));\n }\n 
600	public static FractionFormat getProperInstance() {\n return getProperInstance(Locale.getDefault());\n }\n 
601	public static FractionFormat getProperInstance(final Locale locale) {\n return new ProperFractionFormat(getDefaultNumberFormat(locale));\n }\n 
602	protected static NumberFormat getDefaultNumberFormat() {\n return getDefaultNumberFormat(Locale.getDefault());\n }\n 
603	public StringBuffer format(final Fraction fraction,\n final StringBuffer toAppendTo, final FieldPosition pos) {\n pos.setBeginIndex(0);\n pos.setEndIndex(0);\n getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);\n toAppendTo.append(" / ");\n getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,\n pos);\n return toAppendTo;\n }\n 
604	@Override\n public StringBuffer format(final Object obj,\n final StringBuffer toAppendTo, final FieldPosition pos)\n throws FractionConversionException, MathIllegalArgumentException {\n StringBuffer ret = null;\n if (obj instanceof Fraction) {\n ret = format((Fraction) obj, toAppendTo, pos);\n } else if (obj instanceof Number) {\n ret = format(new Fraction(((Number) obj).doubleValue()), toAppendTo, pos);\n } else {\n throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n }\n return ret;\n }\n 
605	@Override\n public Fraction parse(final String source) throws MathParseException {\n final ParsePosition parsePosition = new ParsePosition(0);\n final Fraction result = parse(source, parsePosition);\n if (parsePosition.getIndex() == 0) {\n throw new MathParseException(source, parsePosition.getErrorIndex(), Fraction.class);\n }\n return result;\n }\n 
606	@Override\n public Fraction parse(final String source, final ParsePosition pos) {\n final int initialIndex = pos.getIndex();\n // parse whitespace\n parseAndIgnoreWhitespace(source, pos);\n // parse numerator\n final Number num = getNumeratorFormat().parse(source, pos);\n if (num == null) {\n // invalid integer number\n // set index back to initial, error index should already be set\n // character examined.\n pos.setIndex(initialIndex);\n return null;\n }\n // parse '/'\n final int startIndex = pos.getIndex();\n final char c = parseNextCharacter(source, pos);\n switch (c) {\n case 0 :\n // no '/'\n // return num as a fraction\n return new Fraction(num.intValue(), 1);\n case '/' :\n // found '/', continue parsing denominator\n break;\n default :\n // invalid '/'\n // set index back to initial, error index should be the last\n // character examined.\n pos.setIndex(initialIndex);\n pos.setErrorIndex(startIndex);\n return null;\n }\n // parse whitespace\n parseAndIgnoreWhitespace(source, pos);\n // parse denominator\n final Number den = getDenominatorFormat().parse(source, pos);\n if (den == null) {\n // invalid integer number\n // set index back to initial, error index should already be set\n // character examined.\n pos.setIndex(initialIndex);\n return null;\n }\n return new Fraction(num.intValue(), den.intValue());\n }\n 
607	public Complex(double real) {\n this(real, 0.0);\n }\n 
608	public Complex(double real, double imaginary) {\n this.real = real;\n this.imaginary = imaginary;\n isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n isInfinite = !isNaN &&\n (Double.isInfinite(real) || Double.isInfinite(imaginary));\n }\n 
609	public double abs() {\n if (isNaN) {\n return Double.NaN;\n }\n if (isInfinite()) {\n return Double.POSITIVE_INFINITY;\n }\n if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n if (imaginary == 0.0) {\n return FastMath.abs(real);\n }\n double q = real / imaginary;\n return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n } else {\n if (real == 0.0) {\n return FastMath.abs(imaginary);\n }\n double q = imaginary / real;\n return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n }\n }\n 
610	public Complex add(Complex addend) throws NullArgumentException {\n MathUtils.checkNotNull(addend);\n if (isNaN || addend.isNaN) {\n return NaN;\n }\n return createComplex(real + addend.getReal(),\n imaginary + addend.getImaginary());\n }\n 
611	public Complex add(double addend) {\n if (isNaN || Double.isNaN(addend)) {\n return NaN;\n }\n return createComplex(real + addend, imaginary);\n }\n 
612	public Complex conjugate() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(real, -imaginary);\n }\n 
613	public Complex divide(Complex divisor)\n throws NullArgumentException {\n MathUtils.checkNotNull(divisor);\n if (isNaN || divisor.isNaN) {\n return NaN;\n }\n final double c = divisor.getReal();\n final double d = divisor.getImaginary();\n if (c == 0.0 && d == 0.0) {\n return NaN;\n }\n if (divisor.isInfinite() && !isInfinite()) {\n return ZERO;\n }\n if (FastMath.abs(c) < FastMath.abs(d)) {\n double q = c / d;\n double denominator = c * q + d;\n return createComplex((real * q + imaginary) / denominator,\n (imaginary * q - real) / denominator);\n } else {\n double q = d / c;\n double denominator = d * q + c;\n return createComplex((imaginary * q + real) / denominator,\n (imaginary - real * q) / denominator);\n }\n }\n 
614	public Complex divide(double divisor) {\n if (isNaN || Double.isNaN(divisor)) {\n return NaN;\n }\n if (divisor == 0d) {\n return NaN;\n }\n if (Double.isInfinite(divisor)) {\n return !isInfinite() ? ZERO : NaN;\n }\n return createComplex(real / divisor,\n imaginary  / divisor);\n }\n 
615	public Complex reciprocal() {\n if (isNaN) {\n return NaN;\n }\n if (real == 0.0 && imaginary == 0.0) {\n return INF;\n }\n if (isInfinite) {\n return ZERO;\n }\n if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n double q = real / imaginary;\n double scale = 1. / (real * q + imaginary);\n return createComplex(scale * q, -scale);\n } else {\n double q = imaginary / real;\n double scale = 1. / (imaginary * q + real);\n return createComplex(scale, -scale * q);\n }\n }\n 
616	@Override\n public boolean equals(Object other) {\n if (this == other) {\n return true;\n }\n if (other instanceof Complex){\n Complex c = (Complex) other;\n if (c.isNaN) {\n return isNaN;\n } else {\n return MathUtils.equals(real, c.real) &&\n MathUtils.equals(imaginary, c.imaginary);\n }\n }\n return false;\n }\n 
617	public static boolean equals(Complex x, Complex y, int maxUlps) {\n return Precision.equals(x.real, y.real, maxUlps) &&\n Precision.equals(x.imaginary, y.imaginary, maxUlps);\n }\n 
618	public static boolean equals(Complex x, Complex y) {\n return equals(x, y, 1);\n }\n 
619	public static boolean equals(Complex x, Complex y, double eps) {\n return Precision.equals(x.real, y.real, eps) &&\n Precision.equals(x.imaginary, y.imaginary, eps);\n }\n 
620	public static boolean equalsWithRelativeTolerance(Complex x, Complex y,\n double eps) {\n return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) &&\n Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n }\n 
621	@Override\n public int hashCode() {\n if (isNaN) {\n return 7;\n }\n return 37 * (17 * MathUtils.hash(imaginary) +\n MathUtils.hash(real));\n }\n 
622	public double getImaginary() {\n return imaginary;\n }\n 
623	public double getReal() {\n return real;\n }\n 
624	public boolean isNaN() {\n return isNaN;\n }\n 
625	public boolean isInfinite() {\n return isInfinite;\n }\n 
626	public Complex multiply(Complex factor)\n throws NullArgumentException {\n MathUtils.checkNotNull(factor);\n if (isNaN || factor.isNaN) {\n return NaN;\n }\n if (Double.isInfinite(real) ||\n Double.isInfinite(imaginary) ||\n Double.isInfinite(factor.real) ||\n Double.isInfinite(factor.imaginary)) {\n // we don't use isInfinite() to avoid testing for NaN again\n return INF;\n }\n return createComplex(real * factor.real - imaginary * factor.imaginary,\n real * factor.imaginary + imaginary * factor.real);\n }\n 
627	public Complex multiply(final int factor) {\n if (isNaN) {\n return NaN;\n }\n if (Double.isInfinite(real) ||\n Double.isInfinite(imaginary)) {\n return INF;\n }\n return createComplex(real * factor, imaginary * factor);\n }\n 
628	public Complex multiply(double factor) {\n if (isNaN || Double.isNaN(factor)) {\n return NaN;\n }\n if (Double.isInfinite(real) ||\n Double.isInfinite(imaginary) ||\n Double.isInfinite(factor)) {\n // we don't use isInfinite() to avoid testing for NaN again\n return INF;\n }\n return createComplex(real * factor, imaginary * factor);\n }\n 
629	public Complex negate() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(-real, -imaginary);\n }\n 
630	public Complex subtract(Complex subtrahend)\n throws NullArgumentException {\n MathUtils.checkNotNull(subtrahend);\n if (isNaN || subtrahend.isNaN) {\n return NaN;\n }\n return createComplex(real - subtrahend.getReal(),\n imaginary - subtrahend.getImaginary());\n }\n 
631	public Complex subtract(double subtrahend) {\n if (isNaN || Double.isNaN(subtrahend)) {\n return NaN;\n }\n return createComplex(real - subtrahend, imaginary);\n }\n 
632	public Complex acos() {\n if (isNaN) {\n return NaN;\n }\n return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n }\n 
633	public Complex asin() {\n if (isNaN) {\n return NaN;\n }\n return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n }\n 
634	public Complex atan() {\n if (isNaN) {\n return NaN;\n }\n return this.add(I).divide(I.subtract(this)).log()\n .multiply(I.divide(createComplex(2.0, 0.0)));\n }\n 
635	public Complex cos() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary),\n -FastMath.sin(real) * FastMath.sinh(imaginary));\n }\n 
636	public Complex cosh() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary),\n FastMath.sinh(real) * FastMath.sin(imaginary));\n }\n 
637	public Complex exp() {\n if (isNaN) {\n return NaN;\n }\n double expReal = FastMath.exp(real);\n return createComplex(expReal *  FastMath.cos(imaginary),\n expReal * FastMath.sin(imaginary));\n }\n 
638	public Complex log() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(FastMath.log(abs()),\n FastMath.atan2(imaginary, real));\n }\n 
639	public Complex pow(Complex x)\n throws NullArgumentException {\n MathUtils.checkNotNull(x);\n return this.log().multiply(x).exp();\n }\n 
640	public Complex pow(double x) {\n return this.log().multiply(x).exp();\n }\n 
641	public Complex sin() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary),\n FastMath.cos(real) * FastMath.sinh(imaginary));\n }\n 
642	public Complex sinh() {\n if (isNaN) {\n return NaN;\n }\n return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),\n FastMath.cosh(real) * FastMath.sin(imaginary));\n }\n 
643	public Complex sqrt() {\n if (isNaN) {\n return NaN;\n }\n if (real == 0.0 && imaginary == 0.0) {\n return createComplex(0.0, 0.0);\n }\n double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n if (real >= 0.0) {\n return createComplex(t, imaginary / (2.0 * t));\n } else {\n return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n FastMath.copySign(1d, imaginary) * t);\n }\n }\n 
644	public Complex sqrt1z() {\n return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n }\n 
645	public Complex tan() {\n if (isNaN || Double.isInfinite(real)) {\n return NaN;\n }\n if (imaginary > 20.0) {\n return createComplex(0.0, 1.0);\n }\n if (imaginary < -20.0) {\n return createComplex(0.0, -1.0);\n }\n double real2 = 2.0 * real;\n double imaginary2 = 2.0 * imaginary;\n double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n return createComplex(FastMath.sin(real2) / d,\n FastMath.sinh(imaginary2) / d);\n }\n 
646	public Complex tanh() {\n if (isNaN || Double.isInfinite(imaginary)) {\n return NaN;\n }\n if (real > 20.0) {\n return createComplex(1.0, 0.0);\n }\n if (real < -20.0) {\n return createComplex(-1.0, 0.0);\n }\n double real2 = 2.0 * real;\n double imaginary2 = 2.0 * imaginary;\n double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n return createComplex(FastMath.sinh(real2) / d,\n FastMath.sin(imaginary2) / d);\n }\n 
647	public double getArgument() {\n return FastMath.atan2(getImaginary(), getReal());\n }\n 
648	public List<Complex> nthRoot(int n) throws NotPositiveException {\n if (n <= 0) {\n throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n n);\n }\n final List<Complex> result = new ArrayList<Complex>();\n if (isNaN) {\n result.add(NaN);\n return result;\n }\n if (isInfinite()) {\n result.add(INF);\n return result;\n }\n // nth root of abs -- faster / more accurate to use a solver here?\n final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n // Compute nth roots of complex number with k = 0, 1, ... n-1\n final double nthPhi = getArgument() / n;\n final double slice = 2 * FastMath.PI / n;\n double innerPart = nthPhi;\n for (int k = 0; k < n ; k++) {\n // inner part\n final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n result.add(createComplex(realPart, imaginaryPart));\n innerPart += slice;\n }\n return result;\n }\n 
649	protected Complex createComplex(double realPart,\n double imaginaryPart) {\n return new Complex(realPart, imaginaryPart);\n }\n 
650	public static Complex valueOf(double realPart,\n double imaginaryPart) {\n if (Double.isNaN(realPart) ||\n Double.isNaN(imaginaryPart)) {\n return NaN;\n }\n return new Complex(realPart, imaginaryPart);\n }\n 
651	public static Complex valueOf(double realPart) {\n if (Double.isNaN(realPart)) {\n return NaN;\n }\n return new Complex(realPart);\n }\n 
652	protected final Object readResolve() {\n return createComplex(real, imaginary);\n }\n 
653	public ComplexField getField() {\n return ComplexField.getInstance();\n }\n 
654	@Override\n public String toString() {\n return "(" + real + ", " + imaginary + ")";\n }\n 
655	public FiniteDifferencesDifferentiator(final int nbPoints, final double stepSize)\n throws NotPositiveException, NumberIsTooSmallException {\n this(nbPoints, stepSize, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n }\n 
656	public FiniteDifferencesDifferentiator(final int nbPoints, final double stepSize,\n final double tLower, final double tUpper)\n throws NotPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n if (nbPoints <= 1) {\n throw new NumberIsTooSmallException(stepSize, 1, false);\n }\n this.nbPoints = nbPoints;\n if (stepSize <= 0) {\n throw new NotPositiveException(stepSize);\n }\n this.stepSize = stepSize;\n halfSampleSpan = 0.5 * stepSize * (nbPoints - 1);\n if (2 * halfSampleSpan >= tUpper - tLower) {\n throw new NumberIsTooLargeException(2 * halfSampleSpan, tUpper - tLower, false);\n }\n final double safety = FastMath.ulp(halfSampleSpan);\n this.tMin = tLower + halfSampleSpan + safety;\n this.tMax = tUpper - halfSampleSpan - safety;\n }\n 
657	public int getNbPoints() {\n return nbPoints;\n }\n 
658	public double getStepSize() {\n return stepSize;\n }\n 
659	private DerivativeStructure evaluate(final DerivativeStructure t, final double t0,\n final double[] y)\n throws NumberIsTooLargeException {\n // create divided differences diagonal arrays\n final double[] top    = new double[nbPoints];\n final double[] bottom = new double[nbPoints];\n for (int i = 0; i < nbPoints; ++i) {\n // update the bottom diagonal of the divided differences array\n bottom[i] = y[i];\n for (int j = 1; j <= i; ++j) {\n bottom[i - j] = (bottom[i - j + 1] - bottom[i - j]) / (j * stepSize);\n }\n // update the top diagonal of the divided differences array\n top[i] = bottom[0];\n }\n // evaluate interpolation polynomial (represented by top diagonal) at t\n final int order            = t.getOrder();\n final int parameters       = t.getFreeParameters();\n final double[] derivatives = t.getAllDerivatives();\n final double dt0           = t.getValue() - t0;\n DerivativeStructure interpolation = new DerivativeStructure(parameters, order, 0.0);\n DerivativeStructure monomial = null;\n for (int i = 0; i < nbPoints; ++i) {\n if (i == 0) {\n // start with monomial(t) = 1\n monomial = new DerivativeStructure(parameters, order, 1.0);\n } else {\n // monomial(t) = (t - t0) * (t - t1) * ... * (t - t(i-1))\n derivatives[0] = dt0 - (i - 1) * stepSize;\n final DerivativeStructure deltaX = new DerivativeStructure(parameters, order, derivatives);\n monomial = monomial.multiply(deltaX);\n }\n interpolation = interpolation.add(monomial.multiply(top[i]));\n }\n return interpolation;\n }\n 
660	public UnivariateDifferentiableFunction differentiate(final UnivariateFunction function) {\n return new UnivariateDifferentiableFunction() {\n /** {@inheritDoc} */\n public double value(final double x) throws MathIllegalArgumentException {\n return function.value(x);\n }\n /** {@inheritDoc} */\n public DerivativeStructure value(final DerivativeStructure t)\n throws MathIllegalArgumentException {\n // check we can achieve the requested derivation order with the sample\n if (t.getOrder() >= nbPoints) {\n throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n }\n // compute sample position, trying to be centered if possible\n final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n // compute sample points\n final double[] y = new double[nbPoints];\n for (int i = 0; i < nbPoints; ++i) {\n y[i] = function.value(t0 + i * stepSize);\n }\n // evaluate derivatives\n return evaluate(t, t0, y);\n }\n };\n }\n 
661	public double[][]  value(final double x) throws MathIllegalArgumentException {\n return function.value(x);\n }\n 
662	public DerivativeStructure[][]  value(final DerivativeStructure t)\n throws MathIllegalArgumentException {\n // check we can achieve the requested derivation order with the sample\n if (t.getOrder() >= nbPoints) {\n throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n }\n // compute sample position, trying to be centered if possible\n final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n // compute sample points\n double[][][] y = null;\n for (int i = 0; i < nbPoints; ++i) {\n final double[][] v = function.value(t0 + i * stepSize);\n if (i == 0) {\n y = new double[v.length][v[0].length][nbPoints];\n }\n for (int j = 0; j < v.length; ++j) {\n for (int k = 0; k < v[j].length; ++k) {\n y[j][k][i] = v[j][k];\n }\n }\n }\n // evaluate derivatives\n final DerivativeStructure[][] value = new DerivativeStructure[y.length][y[0].length];\n for (int j = 0; j < value.length; ++j) {\n for (int k = 0; k < y[j].length; ++k) {\n value[j][k] = evaluate(t, t0, y[j][k]);\n }\n }\n return value;\n }\n 
663	public UnivariateDifferentiableVectorFunction differentiate(final UnivariateVectorFunction function) {\n return new UnivariateDifferentiableVectorFunction() {\n /** {@inheritDoc} */\n public double[]value(final double x) throws MathIllegalArgumentException {\n return function.value(x);\n }\n /** {@inheritDoc} */\n public DerivativeStructure[] value(final DerivativeStructure t)\n throws MathIllegalArgumentException {\n // check we can achieve the requested derivation order with the sample\n if (t.getOrder() >= nbPoints) {\n throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n }\n // compute sample position, trying to be centered if possible\n final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n // compute sample points\n double[][] y = null;\n for (int i = 0; i < nbPoints; ++i) {\n final double[] v = function.value(t0 + i * stepSize);\n if (i == 0) {\n y = new double[v.length][nbPoints];\n }\n for (int j = 0; j < v.length; ++j) {\n y[j][i] = v[j];\n }\n }\n // evaluate derivatives\n final DerivativeStructure[] value = new DerivativeStructure[y.length];\n for (int j = 0; j < value.length; ++j) {\n value[j] = evaluate(t, t0, y[j]);\n }\n return value;\n }\n };\n }\n 
664	public UnivariateDifferentiableMatrixFunction differentiate(final UnivariateMatrixFunction function) {\n return new UnivariateDifferentiableMatrixFunction() {\n /** {@inheritDoc} */\n public double[][]  value(final double x) throws MathIllegalArgumentException {\n return function.value(x);\n }\n /** {@inheritDoc} */\n public DerivativeStructure[][]  value(final DerivativeStructure t)\n throws MathIllegalArgumentException {\n // check we can achieve the requested derivation order with the sample\n if (t.getOrder() >= nbPoints) {\n throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n }\n // compute sample position, trying to be centered if possible\n final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n // compute sample points\n double[][][] y = null;\n for (int i = 0; i < nbPoints; ++i) {\n final double[][] v = function.value(t0 + i * stepSize);\n if (i == 0) {\n y = new double[v.length][v[0].length][nbPoints];\n }\n for (int j = 0; j < v.length; ++j) {\n for (int k = 0; k < v[j].length; ++k) {\n y[j][k][i] = v[j][k];\n }\n }\n }\n // evaluate derivatives\n final DerivativeStructure[][] value = new DerivativeStructure[y.length][y[0].length];\n for (int j = 0; j < value.length; ++j) {\n for (int k = 0; k < y[j].length; ++k) {\n value[j][k] = evaluate(t, t0, y[j][k]);\n }\n }\n return value;\n }\n };\n }\n 
665	public FixedGenerationCount(final int maxGenerations) throws NumberIsTooSmallException {\n if (maxGenerations <= 0) {\n throw new NumberIsTooSmallException(maxGenerations, 1, true);\n }\n this.maxGenerations = maxGenerations;\n }\n 
666	public boolean isSatisfied(final Population population) {\n if (this.numGenerations < this.maxGenerations) {\n numGenerations++;\n return false;\n }\n return true;\n }\n 
667	public int getNumGenerations() {\n return numGenerations;\n }\n 
668	public ComplexFormat() {\n this.imaginaryCharacter = DEFAULT_IMAGINARY_CHARACTER;\n this.imaginaryFormat = CompositeFormat.getDefaultNumberFormat();\n this.realFormat = imaginaryFormat;\n }\n 
669	public ComplexFormat(NumberFormat format) throws NullArgumentException {\n if (format == null) {\n throw new NullArgumentException(LocalizedFormats.IMAGINARY_FORMAT);\n }\n this.imaginaryCharacter = DEFAULT_IMAGINARY_CHARACTER;\n this.imaginaryFormat = format;\n this.realFormat = format;\n }\n 
670	public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat)\n throws NullArgumentException {\n if (imaginaryFormat == null) {\n throw new NullArgumentException(LocalizedFormats.IMAGINARY_FORMAT);\n }\n if (realFormat == null) {\n throw new NullArgumentException(LocalizedFormats.REAL_FORMAT);\n }\n this.imaginaryCharacter = DEFAULT_IMAGINARY_CHARACTER;\n this.imaginaryFormat = imaginaryFormat;\n this.realFormat = realFormat;\n }\n 
671	public ComplexFormat(String imaginaryCharacter)\n throws NullArgumentException, NoDataException {\n this(imaginaryCharacter, CompositeFormat.getDefaultNumberFormat());\n }\n 
672	public ComplexFormat(String imaginaryCharacter, NumberFormat format)\n throws NullArgumentException, NoDataException {\n this(imaginaryCharacter, format, format);\n }\n 
673	public ComplexFormat(String imaginaryCharacter,\n NumberFormat realFormat,\n NumberFormat imaginaryFormat)\n throws NullArgumentException, NoDataException {\n if (imaginaryCharacter == null) {\n throw new NullArgumentException();\n }\n if (imaginaryCharacter.length() == 0) {\n throw new NoDataException();\n }\n if (imaginaryFormat == null) {\n throw new NullArgumentException(LocalizedFormats.IMAGINARY_FORMAT);\n }\n if (realFormat == null) {\n throw new NullArgumentException(LocalizedFormats.REAL_FORMAT);\n }\n this.imaginaryCharacter = imaginaryCharacter;\n this.imaginaryFormat = imaginaryFormat;\n this.realFormat = realFormat;\n }\n 
674	public static Locale[] getAvailableLocales() {\n return NumberFormat.getAvailableLocales();\n }\n 
675	public String format(Complex c) {\n return format(c, new StringBuffer(), new FieldPosition(0)).toString();\n }\n 
676	public String format(Double c) {\n return format(new Complex(c, 0), new StringBuffer(), new FieldPosition(0)).toString();\n }\n 
677	public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n FieldPosition pos) {\n pos.setBeginIndex(0);\n pos.setEndIndex(0);\n // format real\n double re = complex.getReal();\n CompositeFormat.formatDouble(re, getRealFormat(), toAppendTo, pos);\n // format sign and imaginary\n double im = complex.getImaginary();\n StringBuffer imAppendTo;\n if (im < 0.0) {\n toAppendTo.append(" - ");\n imAppendTo = formatImaginary(-im, new StringBuffer(), pos);\n toAppendTo.append(imAppendTo);\n toAppendTo.append(getImaginaryCharacter());\n } else if (im > 0.0 || Double.isNaN(im)) {\n toAppendTo.append(" + ");\n imAppendTo = formatImaginary(im, new StringBuffer(), pos);\n toAppendTo.append(imAppendTo);\n toAppendTo.append(getImaginaryCharacter());\n }\n return toAppendTo;\n }\n 
678	private StringBuffer formatImaginary(double absIm,\n StringBuffer toAppendTo,\n FieldPosition pos) {\n pos.setBeginIndex(0);\n pos.setEndIndex(0);\n CompositeFormat.formatDouble(absIm, getImaginaryFormat(), toAppendTo, pos);\n if (toAppendTo.toString().equals("1")) {\n // Remove the character "1" if it is the only one.\n toAppendTo.setLength(0);\n }\n return toAppendTo;\n }\n 
679	public StringBuffer format(Object obj, StringBuffer toAppendTo,\n FieldPosition pos)\n throws MathIllegalArgumentException {\n StringBuffer ret = null;\n if (obj instanceof Complex) {\n ret = format( (Complex)obj, toAppendTo, pos);\n } else if (obj instanceof Number) {\n ret = format(new Complex(((Number)obj).doubleValue(), 0.0),\n toAppendTo, pos);\n } else {\n throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX,\n obj.getClass().getName());\n }\n return ret;\n }\n 
680	public String getImaginaryCharacter() {\n return imaginaryCharacter;\n }\n 
681	public NumberFormat getImaginaryFormat() {\n return imaginaryFormat;\n }\n 
682	public static ComplexFormat getInstance() {\n return getInstance(Locale.getDefault());\n }\n 
683	public static ComplexFormat getInstance(Locale locale) {\n NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n return new ComplexFormat(f);\n }\n 
684	public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale)\n throws NullArgumentException, NoDataException {\n NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n return new ComplexFormat(imaginaryCharacter, f);\n }\n 
685	public NumberFormat getRealFormat() {\n return realFormat;\n }\n 
686	public Complex parse(String source) throws MathParseException {\n ParsePosition parsePosition = new ParsePosition(0);\n Complex result = parse(source, parsePosition);\n if (parsePosition.getIndex() == 0) {\n throw new MathParseException(source,\n parsePosition.getErrorIndex(),\n Complex.class);\n }\n return result;\n }\n 
687	public Complex parse(String source, ParsePosition pos) {\n int initialIndex = pos.getIndex();\n // parse whitespace\n CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n // parse real\n Number re = CompositeFormat.parseNumber(source, getRealFormat(), pos);\n if (re == null) {\n // invalid real number\n // set index back to initial, error index should already be set\n pos.setIndex(initialIndex);\n return null;\n }\n // parse sign\n int startIndex = pos.getIndex();\n char c = CompositeFormat.parseNextCharacter(source, pos);\n int sign = 0;\n switch (c) {\n case 0 :\n // no sign\n // return real only complex number\n return new Complex(re.doubleValue(), 0.0);\n case '-' :\n sign = -1;\n break;\n case '+' :\n sign = 1;\n break;\n default :\n // invalid sign\n // set index back to initial, error index should be the last\n // character examined.\n pos.setIndex(initialIndex);\n pos.setErrorIndex(startIndex);\n return null;\n }\n // parse whitespace\n CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n // parse imaginary\n Number im = CompositeFormat.parseNumber(source, getRealFormat(), pos);\n if (im == null) {\n // invalid imaginary number\n // set index back to initial, error index should already be set\n pos.setIndex(initialIndex);\n return null;\n }\n // parse imaginary character\n if (!CompositeFormat.parseFixedstring(source, getImaginaryCharacter(), pos)) {\n return null;\n }\n return new Complex(re.doubleValue(), im.doubleValue() * sign);\n }\n 
688	public RegulaFalsiSolver() {\n super(DEFAULT_ABSOLUTE_ACCURACY, Method.REGULA_FALSI);\n }\n 
689	public RegulaFalsiSolver(final double absoluteAccuracy) {\n super(absoluteAccuracy, Method.REGULA_FALSI);\n }\n 
690	public RegulaFalsiSolver(final double relativeAccuracy,\n final double absoluteAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, Method.REGULA_FALSI);\n }\n 
691	public RegulaFalsiSolver(final double relativeAccuracy,\n final double absoluteAccuracy,\n final double functionValueAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, Method.REGULA_FALSI);\n }\n 
692	@Deprecated\n protected AbstractIntegerDistribution() {\n // Legacy users are only allowed to access the deprecated "randomData".\n // New users are forbidden to use this constructor.\n random = null;\n }\n 
693	protected AbstractIntegerDistribution(RandomGenerator rng) {\n random = rng;\n }\n 
694	public double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException {\n if (x1 < x0) {\n throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n x0, x1, true);\n }\n return cumulativeProbability(x1) - cumulativeProbability(x0);\n }\n 
695	public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n if (p < 0.0 || p > 1.0) {\n throw new OutOfRangeException(p, 0, 1);\n }\n int lower = getSupportLowerBound();\n if (p == 0.0) {\n return lower;\n }\n if (lower == Integer.MIN_VALUE) {\n if (checkedCumulativeProbability(lower) >= p) {\n return lower;\n }\n } else {\n lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n // is important for the solving step\n }\n int upper = getSupportUpperBound();\n if (p == 1.0) {\n return upper;\n }\n // use the one-sided Chebyshev inequality to narrow the bracket\n // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n final double mu = getNumericalMean();\n final double sigma = FastMath.sqrt(getNumericalVariance());\n final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n if (chebyshevApplies) {\n double k = FastMath.sqrt((1.0 - p) / p);\n double tmp = mu - k * sigma;\n if (tmp > lower) {\n lower = ((int) FastMath.ceil(tmp)) - 1;\n }\n k = 1.0 / k;\n tmp = mu + k * sigma;\n if (tmp < upper) {\n upper = ((int) FastMath.ceil(tmp)) - 1;\n }\n }\n return solveInverseCumulativeProbability(p, lower, upper);\n }\n 
696	protected int solveInverseCumulativeProbability(final double p, int lower, int upper) {\n while (lower + 1 < upper) {\n int xm = (lower + upper) / 2;\n if (xm < lower || xm > upper) {\n /*\n * Overflow.\n * There will never be an overflow in both calculation methods\n * for xm at the same time\n */\n xm = lower + (upper - lower) / 2;\n }\n double pm = checkedCumulativeProbability(xm);\n if (pm >= p) {\n upper = xm;\n } else {\n lower = xm;\n }\n }\n return upper;\n }\n 
697	public void reseedRandomGenerator(long seed) {\n random.setSeed(seed);\n randomData.reSeed(seed);\n }\n 
698	public int sample() {\n return inverseCumulativeProbability(random.nextDouble());\n }\n 
699	public int[] sample(int sampleSize) {\n if (sampleSize <= 0) {\n throw new NotStrictlyPositiveException(\n LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\n }\n int[] out = new int[sampleSize];\n for (int i = 0; i < sampleSize; i++) {\n out[i] = sample();\n }\n return out;\n }\n 
700	private double checkedCumulativeProbability(int argument)\n throws MathInternalError {\n double result = Double.NaN;\n result = cumulativeProbability(argument);\n if (Double.isNaN(result)) {\n throw new MathInternalError(LocalizedFormats\n .DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n }\n return result;\n }\n 
701	public double logProbability(int x) {\n return FastMath.log(probability(x));\n }\n 
702	public BrentSolver() {\n this(DEFAULT_ABSOLUTE_ACCURACY);\n }\n 
703	public BrentSolver(double absoluteAccuracy) {\n super(absoluteAccuracy);\n }\n 
704	public BrentSolver(double relativeAccuracy,\n double absoluteAccuracy) {\n super(relativeAccuracy, absoluteAccuracy);\n }\n 
705	public BrentSolver(double relativeAccuracy,\n double absoluteAccuracy,\n double functionValueAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n }\n 
706	@Override\n protected double doSolve()\n throws NoBracketingException,\n TooManyEvaluationsException,\n NumberIsTooLargeException {\n double min = getMin();\n double max = getMax();\n final double initial = getStartValue();\n final double functionValueAccuracy = getFunctionValueAccuracy();\n verifySequence(min, initial, max);\n // Return the initial guess if it is good enough.\n double yInitial = computeObjectiveValue(initial);\n if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n return initial;\n }\n // Return the first endpoint if it is good enough.\n double yMin = computeObjectiveValue(min);\n if (FastMath.abs(yMin) <= functionValueAccuracy) {\n return min;\n }\n // Reduce interval if min and initial bracket the root.\n if (yInitial * yMin < 0) {\n return brent(min, initial, yMin, yInitial);\n }\n // Return the second endpoint if it is good enough.\n double yMax = computeObjectiveValue(max);\n if (FastMath.abs(yMax) <= functionValueAccuracy) {\n return max;\n }\n // Reduce interval if initial and max bracket the root.\n if (yInitial * yMax < 0) {\n return brent(initial, max, yInitial, yMax);\n }\n throw new NoBracketingException(min, max, yMin, yMax);\n }\n 
707	private double brent(double lo, double hi,\n double fLo, double fHi) {\n double a = lo;\n double fa = fLo;\n double b = hi;\n double fb = fHi;\n double c = a;\n double fc = fa;\n double d = b - a;\n double e = d;\n final double t = getAbsoluteAccuracy();\n final double eps = getRelativeAccuracy();\n while (true) {\n if (FastMath.abs(fc) < FastMath.abs(fb)) {\n a = b;\n b = c;\n c = a;\n fa = fb;\n fb = fc;\n fc = fa;\n }\n final double tol = 2 * eps * FastMath.abs(b) + t;\n final double m = 0.5 * (c - b);\n if (FastMath.abs(m) <= tol ||\n Precision.equals(fb, 0))  {\n return b;\n }\n if (FastMath.abs(e) < tol ||\n FastMath.abs(fa) <= FastMath.abs(fb)) {\n // Force bisection.\n d = m;\n e = d;\n } else {\n double s = fb / fa;\n double p;\n double q;\n // The equality test (a == c) is intentional,\n // it is part of the original Brent's method and\n // it should NOT be replaced by proximity test.\n if (a == c) {\n // Linear interpolation.\n p = 2 * m * s;\n q = 1 - s;\n } else {\n // Inverse quadratic interpolation.\n q = fa / fc;\n final double r = fb / fc;\n p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n q = (q - 1) * (r - 1) * (s - 1);\n }\n if (p > 0) {\n q = -q;\n } else {\n p = -p;\n }\n s = e;\n e = d;\n if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n p >= FastMath.abs(0.5 * s * q)) {\n // Inverse quadratic interpolation gives a value\n // in the wrong direction, or progress is slow.\n // Fall back to bisection.\n d = m;\n e = d;\n } else {\n d = p / q;\n }\n }\n a = b;\n fa = fb;\n if (FastMath.abs(d) > tol) {\n b += d;\n } else if (m > 0) {\n b += tol;\n } else {\n b -= tol;\n }\n fb = computeObjectiveValue(b);\n if ((fb > 0 && fc > 0) ||\n (fb <= 0 && fc <= 0)) {\n c = a;\n fc = fa;\n d = b - a;\n e = d;\n }\n }\n }\n 
708	public SmoothingPolynomialBicubicSplineInterpolator() {\n this(3);\n }\n 
709	public SmoothingPolynomialBicubicSplineInterpolator(int degree)\n throws NotPositiveException {\n this(degree, degree);\n }\n 
710	public SmoothingPolynomialBicubicSplineInterpolator(int xDegree, int yDegree)\n throws NotPositiveException {\n if (xDegree < 0) {\n throw new NotPositiveException(xDegree);\n }\n if (yDegree < 0) {\n throw new NotPositiveException(yDegree);\n }\n this.xDegree = xDegree;\n this.yDegree = yDegree;\n final double safeFactor = 1e2;\n final SimpleVectorValueChecker checker\n = new SimpleVectorValueChecker(safeFactor * Precision.EPSILON,\n safeFactor * Precision.SAFE_MIN);\n xFitter = new PolynomialFitter(new GaussNewtonOptimizer(false, checker));\n yFitter = new PolynomialFitter(new GaussNewtonOptimizer(false, checker));\n }\n 
711	@Override\n public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n final double[] yval,\n final double[][] fval)\n throws NoDataException, NullArgumentException,\n DimensionMismatchException, NonMonotonicSequenceException {\n if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n throw new NoDataException();\n }\n if (xval.length != fval.length) {\n throw new DimensionMismatchException(xval.length, fval.length);\n }\n final int xLen = xval.length;\n final int yLen = yval.length;\n for (int i = 0; i < xLen; i++) {\n if (fval[i].length != yLen) {\n throw new DimensionMismatchException(fval[i].length, yLen);\n }\n }\n MathArrays.checkOrder(xval);\n MathArrays.checkOrder(yval);\n // For each line y[j] (0 <= j < yLen), construct a polynomial, with\n // respect to variable x, fitting array fval[][j]\n final PolynomialFunction[] yPolyX = new PolynomialFunction[yLen];\n for (int j = 0; j < yLen; j++) {\n xFitter.clearObservations();\n for (int i = 0; i < xLen; i++) {\n xFitter.addObservedPoint(1, xval[i], fval[i][j]);\n }\n // Initial guess for the fit is zero for each coefficients (of which\n // there are "xDegree" + 1).\n yPolyX[j] = new PolynomialFunction(xFitter.fit(new double[xDegree + 1]));\n }\n // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n // values fval_1\n final double[][] fval_1 = new double[xLen][yLen];\n for (int j = 0; j < yLen; j++) {\n final PolynomialFunction f = yPolyX[j];\n for (int i = 0; i < xLen; i++) {\n fval_1[i][j] = f.value(xval[i]);\n }\n }\n // For each line x[i] (0 <= i < xLen), construct a polynomial, with\n // respect to variable y, fitting array fval_1[i][]\n final PolynomialFunction[] xPolyY = new PolynomialFunction[xLen];\n for (int i = 0; i < xLen; i++) {\n yFitter.clearObservations();\n for (int j = 0; j < yLen; j++) {\n yFitter.addObservedPoint(1, yval[j], fval_1[i][j]);\n }\n // Initial guess for the fit is zero for each coefficients (of which\n // there are "yDegree" + 1).\n xPolyY[i] = new PolynomialFunction(yFitter.fit(new double[yDegree + 1]));\n }\n // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n // values fval_2\n final double[][] fval_2 = new double[xLen][yLen];\n for (int i = 0; i < xLen; i++) {\n final PolynomialFunction f = xPolyY[i];\n for (int j = 0; j < yLen; j++) {\n fval_2[i][j] = f.value(yval[j]);\n }\n }\n return super.interpolate(xval, yval, fval_2);\n }\n 
712	public TricubicSplineInterpolatingFunction interpolate(final double[] xval,\n final double[] yval,\n final double[] zval,\n final double[][][] fval)\n throws NoDataException, NumberIsTooSmallException,\n DimensionMismatchException, NonMonotonicSequenceException {\n if (xval.length == 0 || yval.length == 0 || zval.length == 0 || fval.length == 0) {\n throw new NoDataException();\n }\n if (xval.length != fval.length) {\n throw new DimensionMismatchException(xval.length, fval.length);\n }\n MathArrays.checkOrder(xval);\n MathArrays.checkOrder(yval);\n MathArrays.checkOrder(zval);\n final int xLen = xval.length;\n final int yLen = yval.length;\n final int zLen = zval.length;\n // Samples, re-ordered as (z, x, y) and (y, z, x) tuplets\n // fvalXY[k][i][j] = f(xval[i], yval[j], zval[k])\n // fvalZX[j][k][i] = f(xval[i], yval[j], zval[k])\n final double[][][] fvalXY = new double[zLen][xLen][yLen];\n final double[][][] fvalZX = new double[yLen][zLen][xLen];\n for (int i = 0; i < xLen; i++) {\n if (fval[i].length != yLen) {\n throw new DimensionMismatchException(fval[i].length, yLen);\n }\n for (int j = 0; j < yLen; j++) {\n if (fval[i][j].length != zLen) {\n throw new DimensionMismatchException(fval[i][j].length, zLen);\n }\n for (int k = 0; k < zLen; k++) {\n final double v = fval[i][j][k];\n fvalXY[k][i][j] = v;\n fvalZX[j][k][i] = v;\n }\n }\n }\n final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator(true);\n // For each line x[i] (0 <= i < xLen), construct a 2D spline in y and z\n final BicubicSplineInterpolatingFunction[] xSplineYZ\n = new BicubicSplineInterpolatingFunction[xLen];\n for (int i = 0; i < xLen; i++) {\n xSplineYZ[i] = bsi.interpolate(yval, zval, fval[i]);\n }\n // For each line y[j] (0 <= j < yLen), construct a 2D spline in z and x\n final BicubicSplineInterpolatingFunction[] ySplineZX\n = new BicubicSplineInterpolatingFunction[yLen];\n for (int j = 0; j < yLen; j++) {\n ySplineZX[j] = bsi.interpolate(zval, xval, fvalZX[j]);\n }\n // For each line z[k] (0 <= k < zLen), construct a 2D spline in x and y\n final BicubicSplineInterpolatingFunction[] zSplineXY\n = new BicubicSplineInterpolatingFunction[zLen];\n for (int k = 0; k < zLen; k++) {\n zSplineXY[k] = bsi.interpolate(xval, yval, fvalXY[k]);\n }\n // Partial derivatives wrt x and wrt y\n final double[][][] dFdX = new double[xLen][yLen][zLen];\n final double[][][] dFdY = new double[xLen][yLen][zLen];\n final double[][][] d2FdXdY = new double[xLen][yLen][zLen];\n for (int k = 0; k < zLen; k++) {\n final BicubicSplineInterpolatingFunction f = zSplineXY[k];\n for (int i = 0; i < xLen; i++) {\n final double x = xval[i];\n for (int j = 0; j < yLen; j++) {\n final double y = yval[j];\n dFdX[i][j][k] = f.partialDerivativeX(x, y);\n dFdY[i][j][k] = f.partialDerivativeY(x, y);\n d2FdXdY[i][j][k] = f.partialDerivativeXY(x, y);\n }\n }\n }\n // Partial derivatives wrt y and wrt z\n final double[][][] dFdZ = new double[xLen][yLen][zLen];\n final double[][][] d2FdYdZ = new double[xLen][yLen][zLen];\n for (int i = 0; i < xLen; i++) {\n final BicubicSplineInterpolatingFunction f = xSplineYZ[i];\n for (int j = 0; j < yLen; j++) {\n final double y = yval[j];\n for (int k = 0; k < zLen; k++) {\n final double z = zval[k];\n dFdZ[i][j][k] = f.partialDerivativeY(y, z);\n d2FdYdZ[i][j][k] = f.partialDerivativeXY(y, z);\n }\n }\n }\n // Partial derivatives wrt x and wrt z\n final double[][][] d2FdZdX = new double[xLen][yLen][zLen];\n for (int j = 0; j < yLen; j++) {\n final BicubicSplineInterpolatingFunction f = ySplineZX[j];\n for (int k = 0; k < zLen; k++) {\n final double z = zval[k];\n for (int i = 0; i < xLen; i++) {\n final double x = xval[i];\n d2FdZdX[i][j][k] = f.partialDerivativeXY(z, x);\n }\n }\n }\n // Third partial cross-derivatives\n final double[][][] d3FdXdYdZ = new double[xLen][yLen][zLen];\n for (int i = 0; i < xLen ; i++) {\n final int nI = nextIndex(i, xLen);\n final int pI = previousIndex(i);\n for (int j = 0; j < yLen; j++) {\n final int nJ = nextIndex(j, yLen);\n final int pJ = previousIndex(j);\n for (int k = 0; k < zLen; k++) {\n final int nK = nextIndex(k, zLen);\n final int pK = previousIndex(k);\n // XXX Not sure about this formula\n d3FdXdYdZ[i][j][k] = (fval[nI][nJ][nK] - fval[nI][pJ][nK] -\n fval[pI][nJ][nK] + fval[pI][pJ][nK] -\n fval[nI][nJ][pK] + fval[nI][pJ][pK] +\n fval[pI][nJ][pK] - fval[pI][pJ][pK]) /\n ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]) * (zval[nK] - zval[pK])) ;\n }\n }\n }\n // Create the interpolating splines\n return new TricubicSplineInterpolatingFunction(xval, yval, zval, fval,\n dFdX, dFdY, dFdZ,\n d2FdXdY, d2FdZdX, d2FdYdZ,\n d3FdXdYdZ);\n }\n 
713	private int nextIndex(int i, int max) {\n final int index = i + 1;\n return index < max ? index : index - 1;\n }\n 
714	private int previousIndex(int i) {\n final int index = i - 1;\n return index >= 0 ? index : 0;\n }\n 
715	public MathUnsupportedOperationException() {\n this(LocalizedFormats.UNSUPPORTED_OPERATION);\n }\n 
716	public MathUnsupportedOperationException(Localizable pattern,\n Object ... args) {\n context = new ExceptionContext(this);\n context.addMessage(pattern, args);\n }\n 
717	public ExceptionContext getContext() {\n return context;\n }\n 
718	@Override\n public String getMessage() {\n return context.getMessage();\n }\n 
719	@Override\n public String getLocalizedMessage() {\n return context.getLocalizedMessage();\n }\n 
720	public Array2DRowRealMatrix() {}\n 
721	public Array2DRowRealMatrix(final int rowDimension,\n final int columnDimension)\n throws NotStrictlyPositiveException {\n super(rowDimension, columnDimension);\n data = new double[rowDimension][columnDimension];\n }\n 
722	public Array2DRowRealMatrix(final double[][] d)\n throws DimensionMismatchException, NoDataException, NullArgumentException {\n copyIn(d);\n }\n 
723	public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n throws DimensionMismatchException, NoDataException,\n NullArgumentException {\n if (copyArray) {\n copyIn(d);\n } else {\n if (d == null) {\n throw new NullArgumentException();\n }\n final int nRows = d.length;\n if (nRows == 0) {\n throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n }\n final int nCols = d[0].length;\n if (nCols == 0) {\n throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n }\n for (int r = 1; r < nRows; r++) {\n if (d[r].length != nCols) {\n throw new DimensionMismatchException(d[r].length, nCols);\n }\n }\n data = d;\n }\n }\n 
724	public Array2DRowRealMatrix(final double[] v) {\n final int nRows = v.length;\n data = new double[nRows][1];\n for (int row = 0; row < nRows; row++) {\n data[row][0] = v[row];\n }\n }\n 
725	@Override\n public RealMatrix createMatrix(final int rowDimension,\n final int columnDimension)\n throws NotStrictlyPositiveException {\n return new Array2DRowRealMatrix(rowDimension, columnDimension);\n }\n 
726	@Override\n public RealMatrix copy() {\n return new Array2DRowRealMatrix(copyOut(), false);\n }\n 
727	public Array2DRowRealMatrix add(final Array2DRowRealMatrix m)\n throws MatrixDimensionMismatchException {\n // Safety check.\n MatrixUtils.checkAdditionCompatible(this, m);\n final int rowCount    = getRowDimension();\n final int columnCount = getColumnDimension();\n final double[][] outData = new double[rowCount][columnCount];\n for (int row = 0; row < rowCount; row++) {\n final double[] dataRow    = data[row];\n final double[] mRow       = m.data[row];\n final double[] outDataRow = outData[row];\n for (int col = 0; col < columnCount; col++) {\n outDataRow[col] = dataRow[col] + mRow[col];\n }\n }\n return new Array2DRowRealMatrix(outData, false);\n }\n 
728	public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)\n throws MatrixDimensionMismatchException {\n MatrixUtils.checkSubtractionCompatible(this, m);\n final int rowCount    = getRowDimension();\n final int columnCount = getColumnDimension();\n final double[][] outData = new double[rowCount][columnCount];\n for (int row = 0; row < rowCount; row++) {\n final double[] dataRow    = data[row];\n final double[] mRow       = m.data[row];\n final double[] outDataRow = outData[row];\n for (int col = 0; col < columnCount; col++) {\n outDataRow[col] = dataRow[col] - mRow[col];\n }\n }\n return new Array2DRowRealMatrix(outData, false);\n }\n 
729	public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n throws DimensionMismatchException {\n MatrixUtils.checkMultiplicationCompatible(this, m);\n final int nRows = this.getRowDimension();\n final int nCols = m.getColumnDimension();\n final int nSum = this.getColumnDimension();\n final double[][] outData = new double[nRows][nCols];\n // Will hold a column of "m".\n final double[] mCol = new double[nSum];\n final double[][] mData = m.data;\n // Multiply.\n for (int col = 0; col < nCols; col++) {\n // Copy all elements of column "col" of "m" so that\n // will be in contiguous memory.\n for (int mRow = 0; mRow < nSum; mRow++) {\n mCol[mRow] = mData[mRow][col];\n }\n for (int row = 0; row < nRows; row++) {\n final double[] dataRow = data[row];\n double sum = 0;\n for (int i = 0; i < nSum; i++) {\n sum += dataRow[i] * mCol[i];\n }\n outData[row][col] = sum;\n }\n }\n return new Array2DRowRealMatrix(outData, false);\n }\n 
730	@Override\n public double[][] getData() {\n return copyOut();\n }\n 
731	public double[][] getDataRef() {\n return data;\n }\n 
732	@Override\n public void setSubMatrix(final double[][] subMatrix, final int row,\n final int column)\n throws NoDataException, OutOfRangeException,\n DimensionMismatchException, NullArgumentException {\n if (data == null) {\n if (row > 0) {\n throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n }\n if (column > 0) {\n throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n }\n MathUtils.checkNotNull(subMatrix);\n final int nRows = subMatrix.length;\n if (nRows == 0) {\n throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n }\n final int nCols = subMatrix[0].length;\n if (nCols == 0) {\n throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n }\n data = new double[subMatrix.length][nCols];\n for (int i = 0; i < data.length; ++i) {\n if (subMatrix[i].length != nCols) {\n throw new DimensionMismatchException(subMatrix[i].length, nCols);\n }\n System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n }\n } else {\n super.setSubMatrix(subMatrix, row, column);\n }\n }\n 
733	@Override\n public double getEntry(final int row, final int column)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n return data[row][column];\n }\n 
734	@Override\n public void setEntry(final int row, final int column, final double value)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n data[row][column] = value;\n }\n 
735	@Override\n public void addToEntry(final int row, final int column,\n final double increment)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n data[row][column] += increment;\n }\n 
736	@Override\n public void multiplyEntry(final int row, final int column,\n final double factor)\n throws OutOfRangeException {\n MatrixUtils.checkMatrixIndex(this, row, column);\n data[row][column] *= factor;\n }\n 
737	@Override\n public int getRowDimension() {\n return (data == null) ? 0 : data.length;\n }\n 
738	@Override\n public int getColumnDimension() {\n return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n }\n 
739	@Override\n public double[] operate(final double[] v)\n throws DimensionMismatchException {\n final int nRows = this.getRowDimension();\n final int nCols = this.getColumnDimension();\n if (v.length != nCols) {\n throw new DimensionMismatchException(v.length, nCols);\n }\n final double[] out = new double[nRows];\n for (int row = 0; row < nRows; row++) {\n final double[] dataRow = data[row];\n double sum = 0;\n for (int i = 0; i < nCols; i++) {\n sum += dataRow[i] * v[i];\n }\n out[row] = sum;\n }\n return out;\n }\n 
740	@Override\n public double[] preMultiply(final double[] v)\n throws DimensionMismatchException {\n final int nRows = getRowDimension();\n final int nCols = getColumnDimension();\n if (v.length != nRows) {\n throw new DimensionMismatchException(v.length, nRows);\n }\n final double[] out = new double[nCols];\n for (int col = 0; col < nCols; ++col) {\n double sum = 0;\n for (int i = 0; i < nRows; ++i) {\n sum += data[i][col] * v[i];\n }\n out[col] = sum;\n }\n return out;\n }\n 
741	@Override\n public double walkInRowOrder(final RealMatrixChangingVisitor visitor) {\n final int rows    = getRowDimension();\n final int columns = getColumnDimension();\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n for (int i = 0; i < rows; ++i) {\n final double[] rowI = data[i];\n for (int j = 0; j < columns; ++j) {\n rowI[j] = visitor.visit(i, j, rowI[j]);\n }\n }\n return visitor.end();\n }\n 
742	@Override\n public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n final int rows    = getRowDimension();\n final int columns = getColumnDimension();\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n for (int i = 0; i < rows; ++i) {\n final double[] rowI = data[i];\n for (int j = 0; j < columns; ++j) {\n visitor.visit(i, j, rowI[j]);\n }\n }\n return visitor.end();\n }\n 
743	@Override\n public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn, final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(getRowDimension(), getColumnDimension(),\n startRow, endRow, startColumn, endColumn);\n for (int i = startRow; i <= endRow; ++i) {\n final double[] rowI = data[i];\n for (int j = startColumn; j <= endColumn; ++j) {\n rowI[j] = visitor.visit(i, j, rowI[j]);\n }\n }\n return visitor.end();\n }\n 
744	@Override\n public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn, final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(getRowDimension(), getColumnDimension(),\n startRow, endRow, startColumn, endColumn);\n for (int i = startRow; i <= endRow; ++i) {\n final double[] rowI = data[i];\n for (int j = startColumn; j <= endColumn; ++j) {\n visitor.visit(i, j, rowI[j]);\n }\n }\n return visitor.end();\n }\n 
745	@Override\n public double walkInColumnOrder(final RealMatrixChangingVisitor visitor) {\n final int rows    = getRowDimension();\n final int columns = getColumnDimension();\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n for (int j = 0; j < columns; ++j) {\n for (int i = 0; i < rows; ++i) {\n final double[] rowI = data[i];\n rowI[j] = visitor.visit(i, j, rowI[j]);\n }\n }\n return visitor.end();\n }\n 
746	@Override\n public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor) {\n final int rows    = getRowDimension();\n final int columns = getColumnDimension();\n visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n for (int j = 0; j < columns; ++j) {\n for (int i = 0; i < rows; ++i) {\n visitor.visit(i, j, data[i][j]);\n }\n }\n return visitor.end();\n }\n 
747	@Override\n public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn, final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(getRowDimension(), getColumnDimension(),\n startRow, endRow, startColumn, endColumn);\n for (int j = startColumn; j <= endColumn; ++j) {\n for (int i = startRow; i <= endRow; ++i) {\n final double[] rowI = data[i];\n rowI[j] = visitor.visit(i, j, rowI[j]);\n }\n }\n return visitor.end();\n }\n 
748	@Override\n public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n final int startRow, final int endRow,\n final int startColumn, final int endColumn)\n throws OutOfRangeException, NumberIsTooSmallException {\n MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n visitor.start(getRowDimension(), getColumnDimension(),\n startRow, endRow, startColumn, endColumn);\n for (int j = startColumn; j <= endColumn; ++j) {\n for (int i = startRow; i <= endRow; ++i) {\n visitor.visit(i, j, data[i][j]);\n }\n }\n return visitor.end();\n }\n 
749	private double[][] copyOut() {\n final int nRows = this.getRowDimension();\n final double[][] out = new double[nRows][this.getColumnDimension()];\n // can't copy 2-d array in one shot, otherwise get row references\n for (int i = 0; i < nRows; i++) {\n System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n }\n return out;\n }\n 
750	private void copyIn(final double[][] in)\n throws DimensionMismatchException, NoDataException, NullArgumentException {\n setSubMatrix(in, 0, 0);\n }\n 
751	public HermiteInterpolator() {\n this.abscissae      = new ArrayList<Double>();\n this.topDiagonal    = new ArrayList<double[]>();\n this.bottomDiagonal = new ArrayList<double[]>();\n }\n 
752	public void addSamplePoint(final double x, final double[] ... value)\n throws ZeroException, MathArithmeticException {\n for (int i = 0; i < value.length; ++i) {\n final double[] y = value[i].clone();\n if (i > 1) {\n double inv = 1.0 / CombinatoricsUtils.factorial(i);\n for (int j = 0; j < y.length; ++j) {\n y[j] *= inv;\n }\n }\n // update the bottom diagonal of the divided differences array\n final int n = abscissae.size();\n bottomDiagonal.add(n - i, y);\n double[] bottom0 = y;\n for (int j = i; j < n; ++j) {\n final double[] bottom1 = bottomDiagonal.get(n - (j + 1));\n final double inv = 1.0 / (x - abscissae.get(n - (j + 1)));\n if (Double.isInfinite(inv)) {\n throw new ZeroException(LocalizedFormats.DUPLICATED_ABSCISSA_DIVISION_BY_ZERO, x);\n }\n for (int k = 0; k < y.length; ++k) {\n bottom1[k] = inv * (bottom0[k] - bottom1[k]);\n }\n bottom0 = bottom1;\n }\n // update the top diagonal of the divided differences array\n topDiagonal.add(bottom0.clone());\n // update the abscissae array\n abscissae.add(x);\n }\n }\n 
753	public PolynomialFunction[] getPolynomials()\n throws NoDataException {\n // safety check\n checkInterpolation();\n // iteration initialization\n final PolynomialFunction zero = polynomial(0);\n PolynomialFunction[] polynomials = new PolynomialFunction[topDiagonal.get(0).length];\n for (int i = 0; i < polynomials.length; ++i) {\n polynomials[i] = zero;\n }\n PolynomialFunction coeff = polynomial(1);\n // build the polynomials by iterating on the top diagonal of the divided differences array\n for (int i = 0; i < topDiagonal.size(); ++i) {\n double[] tdi = topDiagonal.get(i);\n for (int k = 0; k < polynomials.length; ++k) {\n polynomials[k] = polynomials[k].add(coeff.multiply(polynomial(tdi[k])));\n }\n coeff = coeff.multiply(polynomial(-abscissae.get(i), 1.0));\n }\n return polynomials;\n }\n 
754	public double[] value(double x)\n throws NoDataException {\n // safety check\n checkInterpolation();\n final double[] value = new double[topDiagonal.get(0).length];\n double valueCoeff = 1;\n for (int i = 0; i < topDiagonal.size(); ++i) {\n double[] dividedDifference = topDiagonal.get(i);\n for (int k = 0; k < value.length; ++k) {\n value[k] += dividedDifference[k] * valueCoeff;\n }\n final double deltaX = x - abscissae.get(i);\n valueCoeff *= deltaX;\n }\n return value;\n }\n 
755	public DerivativeStructure[] value(final DerivativeStructure x)\n throws NoDataException {\n // safety check\n checkInterpolation();\n final DerivativeStructure[] value = new DerivativeStructure[topDiagonal.get(0).length];\n Arrays.fill(value, x.getField().getZero());\n DerivativeStructure valueCoeff = x.getField().getOne();\n for (int i = 0; i < topDiagonal.size(); ++i) {\n double[] dividedDifference = topDiagonal.get(i);\n for (int k = 0; k < value.length; ++k) {\n value[k] = value[k].add(valueCoeff.multiply(dividedDifference[k]));\n }\n final DerivativeStructure deltaX = x.subtract(abscissae.get(i));\n valueCoeff = valueCoeff.multiply(deltaX);\n }\n return value;\n }\n 
756	private void checkInterpolation() throws NoDataException {\n if (abscissae.isEmpty()) {\n throw new NoDataException(LocalizedFormats.EMPTY_INTERPOLATION_SAMPLE);\n }\n }\n 
757	private PolynomialFunction polynomial(double ... c) {\n return new PolynomialFunction(c);\n }\n 
758	public MathIllegalArgumentException(Localizable pattern,\n Object ... args) {\n context = new ExceptionContext(this);\n context.addMessage(pattern, args);\n }\n 
759	public ExceptionContext getContext() {\n return context;\n }\n 
760	@Override\n public String getMessage() {\n return context.getMessage();\n }\n 
761	@Override\n public String getLocalizedMessage() {\n return context.getLocalizedMessage();\n }\n 
762	private DerivativeStructure(final DSCompiler compiler) {\n this.compiler = compiler;\n this.data     = new double[compiler.getSize()];\n }\n 
763	public DerivativeStructure(final int parameters, final int order)\n throws NumberIsTooLargeException {\n this(DSCompiler.getCompiler(parameters, order));\n }\n 
764	public DerivativeStructure(final int parameters, final int order, final double value)\n throws NumberIsTooLargeException {\n this(parameters, order);\n this.data[0] = value;\n }\n 
765	public DerivativeStructure(final int parameters, final int order,\n final int index, final double value)\n throws NumberIsTooLargeException {\n this(parameters, order, value);\n if (index >= parameters) {\n throw new NumberIsTooLargeException(index, parameters, false);\n }\n if (order > 0) {\n // the derivative of the variable with respect to itself is 1.\n data[DSCompiler.getCompiler(index, order).getSize()] = 1.0;\n }\n }\n 
766	public DerivativeStructure(final double a1, final DerivativeStructure ds1,\n final double a2, final DerivativeStructure ds2)\n throws DimensionMismatchException {\n this(ds1.compiler);\n compiler.checkCompatibility(ds2.compiler);\n compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0, data, 0);\n }\n 
767	public DerivativeStructure(final double a1, final DerivativeStructure ds1,\n final double a2, final DerivativeStructure ds2,\n final double a3, final DerivativeStructure ds3)\n throws DimensionMismatchException {\n this(ds1.compiler);\n compiler.checkCompatibility(ds2.compiler);\n compiler.checkCompatibility(ds3.compiler);\n compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0, a3, ds3.data, 0, data, 0);\n }\n 
768	public DerivativeStructure(final double a1, final DerivativeStructure ds1,\n final double a2, final DerivativeStructure ds2,\n final double a3, final DerivativeStructure ds3,\n final double a4, final DerivativeStructure ds4)\n throws DimensionMismatchException {\n this(ds1.compiler);\n compiler.checkCompatibility(ds2.compiler);\n compiler.checkCompatibility(ds3.compiler);\n compiler.checkCompatibility(ds4.compiler);\n compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0,\n a3, ds3.data, 0, a4, ds4.data, 0,\n data, 0);\n }\n 
769	public DerivativeStructure(final int parameters, final int order, final double ... derivatives)\n throws DimensionMismatchException, NumberIsTooLargeException {\n this(parameters, order);\n if (derivatives.length != data.length) {\n throw new DimensionMismatchException(derivatives.length, data.length);\n }\n System.arraycopy(derivatives, 0, data, 0, data.length);\n }\n 
770	private DerivativeStructure(final DerivativeStructure ds) {\n this.compiler = ds.compiler;\n this.data     = ds.data.clone();\n }\n 
771	public int getFreeParameters() {\n return compiler.getFreeParameters();\n }\n 
772	public int getOrder() {\n return compiler.getOrder();\n }\n 
773	public DerivativeStructure createConstant(final double c) {\n return new DerivativeStructure(getFreeParameters(), getOrder(), c);\n }\n 
774	public double getReal() {\n return data[0];\n }\n 
775	public double getValue() {\n return data[0];\n }\n 
776	public double getPartialDerivative(final int ... orders)\n throws DimensionMismatchException, NumberIsTooLargeException {\n return data[compiler.getPartialDerivativeIndex(orders)];\n }\n 
777	public double[] getAllDerivatives() {\n return data.clone();\n }\n 
778	public DerivativeStructure add(final double a) {\n final DerivativeStructure ds = new DerivativeStructure(this);\n ds.data[0] += a;\n return ds;\n }\n 
779	public DerivativeStructure add(final DerivativeStructure a)\n throws DimensionMismatchException {\n compiler.checkCompatibility(a.compiler);\n final DerivativeStructure ds = new DerivativeStructure(this);\n compiler.add(data, 0, a.data, 0, ds.data, 0);\n return ds;\n }\n 
780	public DerivativeStructure subtract(final double a) {\n return add(-a);\n }\n 
781	public DerivativeStructure subtract(final DerivativeStructure a)\n throws DimensionMismatchException {\n compiler.checkCompatibility(a.compiler);\n final DerivativeStructure ds = new DerivativeStructure(this);\n compiler.subtract(data, 0, a.data, 0, ds.data, 0);\n return ds;\n }\n 
782	public DerivativeStructure multiply(final int n) {\n return multiply((double) n);\n }\n 
783	public DerivativeStructure multiply(final double a) {\n final DerivativeStructure ds = new DerivativeStructure(this);\n for (int i = 0; i < ds.data.length; ++i) {\n ds.data[i] *= a;\n }\n return ds;\n }\n 
784	public DerivativeStructure multiply(final DerivativeStructure a)\n throws DimensionMismatchException {\n compiler.checkCompatibility(a.compiler);\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.multiply(data, 0, a.data, 0, result.data, 0);\n return result;\n }\n 
785	public DerivativeStructure divide(final double a) {\n final DerivativeStructure ds = new DerivativeStructure(this);\n for (int i = 0; i < ds.data.length; ++i) {\n ds.data[i] /= a;\n }\n return ds;\n }\n 
786	public DerivativeStructure divide(final DerivativeStructure a)\n throws DimensionMismatchException {\n compiler.checkCompatibility(a.compiler);\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.divide(data, 0, a.data, 0, result.data, 0);\n return result;\n }\n 
787	public DerivativeStructure remainder(final double a) {\n final DerivativeStructure ds = new DerivativeStructure(this);\n ds.data[0] = FastMath.IEEEremainder(ds.data[0], a);\n return ds;\n }\n 
788	public DerivativeStructure remainder(final DerivativeStructure a)\n throws DimensionMismatchException {\n compiler.checkCompatibility(a.compiler);\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.remainder(data, 0, a.data, 0, result.data, 0);\n return result;\n }\n 
789	public DerivativeStructure negate() {\n final DerivativeStructure ds = new DerivativeStructure(compiler);\n for (int i = 0; i < ds.data.length; ++i) {\n ds.data[i] = -data[i];\n }\n return ds;\n }\n 
790	public DerivativeStructure abs() {\n if (Double.doubleToLongBits(data[0]) < 0) {\n // we use the bits representation to also handle -0.0\n return negate();\n } else {\n return this;\n }\n }\n 
791	public DerivativeStructure ceil() {\n return new DerivativeStructure(compiler.getFreeParameters(),\n compiler.getOrder(),\n FastMath.ceil(data[0]));\n }\n 
792	public DerivativeStructure floor() {\n return new DerivativeStructure(compiler.getFreeParameters(),\n compiler.getOrder(),\n FastMath.floor(data[0]));\n }\n 
793	public DerivativeStructure rint() {\n return new DerivativeStructure(compiler.getFreeParameters(),\n compiler.getOrder(),\n FastMath.rint(data[0]));\n }\n 
794	public long round() {\n return FastMath.round(data[0]);\n }\n 
795	public DerivativeStructure signum() {\n return new DerivativeStructure(compiler.getFreeParameters(),\n compiler.getOrder(),\n FastMath.signum(data[0]));\n }\n 
796	public DerivativeStructure copySign(final DerivativeStructure sign){\n long m = Double.doubleToLongBits(data[0]);\n long s = Double.doubleToLongBits(sign.data[0]);\n if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\n return this;\n }\n return negate(); // flip sign\n }\n 
797	public DerivativeStructure copySign(final double sign) {\n long m = Double.doubleToLongBits(data[0]);\n long s = Double.doubleToLongBits(sign);\n if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\n return this;\n }\n return negate(); // flip sign\n }\n 
798	public int getExponent() {\n return FastMath.getExponent(data[0]);\n }\n 
799	public DerivativeStructure scalb(final int n) {\n final DerivativeStructure ds = new DerivativeStructure(compiler);\n for (int i = 0; i < ds.data.length; ++i) {\n ds.data[i] = FastMath.scalb(data[i], n);\n }\n return ds;\n }\n 
800	public DerivativeStructure hypot(final DerivativeStructure y)\n throws DimensionMismatchException {\n compiler.checkCompatibility(y.compiler);\n if (Double.isInfinite(data[0]) || Double.isInfinite(y.data[0])) {\n return new DerivativeStructure(compiler.getFreeParameters(),\n compiler.getFreeParameters(),\n Double.POSITIVE_INFINITY);\n } else if (Double.isNaN(data[0]) || Double.isNaN(y.data[0])) {\n return new DerivativeStructure(compiler.getFreeParameters(),\n compiler.getFreeParameters(),\n Double.NaN);\n } else {\n final int expX = getExponent();\n final int expY = y.getExponent();\n if (expX > expY + 27) {\n // y is neglectible with respect to x\n return abs();\n } else if (expY > expX + 27) {\n // x is neglectible with respect to y\n return y.abs();\n } else {\n // find an intermediate scale to avoid both overflow and underflow\n final int middleExp = (expX + expY) / 2;\n // scale parameters without losing precision\n final DerivativeStructure scaledX = scalb(-middleExp);\n final DerivativeStructure scaledY = y.scalb(-middleExp);\n // compute scaled hypotenuse\n final DerivativeStructure scaledH =\n scaledX.multiply(scaledX).add(scaledY.multiply(scaledY)).sqrt();\n // remove scaling\n return scaledH.scalb(middleExp);\n }\n }\n }\n 
801	public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y)\n throws DimensionMismatchException {\n return x.hypot(y);\n }\n 
802	public DerivativeStructure compose(final double ... f)\n throws DimensionMismatchException {\n if (f.length != getOrder() + 1) {\n throw new DimensionMismatchException(f.length, getOrder() + 1);\n }\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.compose(data, 0, f, result.data, 0);\n return result;\n }\n 
803	public DerivativeStructure reciprocal() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.pow(data, 0, -1, result.data, 0);\n return result;\n }\n 
804	public DerivativeStructure sqrt() {\n return rootN(2);\n }\n 
805	public DerivativeStructure cbrt() {\n return rootN(3);\n }\n 
806	public DerivativeStructure rootN(final int n) {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.rootN(data, 0, n, result.data, 0);\n return result;\n }\n 
807	public Field<DerivativeStructure> getField() {\n return new Field<DerivativeStructure>() {\n /** {@inheritDoc} */\n public DerivativeStructure getZero() {\n return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 0.0);\n }\n /** {@inheritDoc} */\n public DerivativeStructure getOne() {\n return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 1.0);\n }\n /** {@inheritDoc} */\n public Class<? extends FieldElement<DerivativeStructure>> getRuntimeClass() {\n return DerivativeStructure.class;\n }\n };\n }\n 
808	public DerivativeStructure getZero() {\n return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 0.0);\n }\n 
809	public DerivativeStructure getOne() {\n return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 1.0);\n }\n 
810	public Class<? extends FieldElement<DerivativeStructure>> getRuntimeClass() {\n return DerivativeStructure.class;\n }\n 
811	public static DerivativeStructure pow(final double a, final DerivativeStructure x) {\n final DerivativeStructure result = new DerivativeStructure(x.compiler);\n x.compiler.pow(a, x.data, 0, result.data, 0);\n return result;\n }\n 
812	public DerivativeStructure pow(final double p) {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.pow(data, 0, p, result.data, 0);\n return result;\n }\n 
813	public DerivativeStructure pow(final int n) {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.pow(data, 0, n, result.data, 0);\n return result;\n }\n 
814	public DerivativeStructure pow(final DerivativeStructure e)\n throws DimensionMismatchException {\n compiler.checkCompatibility(e.compiler);\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.pow(data, 0, e.data, 0, result.data, 0);\n return result;\n }\n 
815	public DerivativeStructure exp() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.exp(data, 0, result.data, 0);\n return result;\n }\n 
816	public DerivativeStructure expm1() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.expm1(data, 0, result.data, 0);\n return result;\n }\n 
817	public DerivativeStructure log() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.log(data, 0, result.data, 0);\n return result;\n }\n 
818	public DerivativeStructure log1p() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.log1p(data, 0, result.data, 0);\n return result;\n }\n 
819	public DerivativeStructure log10() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.log10(data, 0, result.data, 0);\n return result;\n }\n 
820	public DerivativeStructure cos() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.cos(data, 0, result.data, 0);\n return result;\n }\n 
821	public DerivativeStructure sin() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.sin(data, 0, result.data, 0);\n return result;\n }\n 
822	public DerivativeStructure tan() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.tan(data, 0, result.data, 0);\n return result;\n }\n 
823	public DerivativeStructure acos() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.acos(data, 0, result.data, 0);\n return result;\n }\n 
824	public DerivativeStructure asin() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.asin(data, 0, result.data, 0);\n return result;\n }\n 
825	public DerivativeStructure atan() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.atan(data, 0, result.data, 0);\n return result;\n }\n 
826	public DerivativeStructure atan2(final DerivativeStructure x)\n throws DimensionMismatchException {\n compiler.checkCompatibility(x.compiler);\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.atan2(data, 0, x.data, 0, result.data, 0);\n return result;\n }\n 
827	public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)\n throws DimensionMismatchException {\n return y.atan2(x);\n }\n 
828	public DerivativeStructure cosh() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.cosh(data, 0, result.data, 0);\n return result;\n }\n 
829	public DerivativeStructure sinh() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.sinh(data, 0, result.data, 0);\n return result;\n }\n 
830	public DerivativeStructure tanh() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.tanh(data, 0, result.data, 0);\n return result;\n }\n 
831	public DerivativeStructure acosh() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.acosh(data, 0, result.data, 0);\n return result;\n }\n 
832	public DerivativeStructure asinh() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.asinh(data, 0, result.data, 0);\n return result;\n }\n 
833	public DerivativeStructure atanh() {\n final DerivativeStructure result = new DerivativeStructure(compiler);\n compiler.atanh(data, 0, result.data, 0);\n return result;\n }\n 
834	public DerivativeStructure toDegrees() {\n final DerivativeStructure ds = new DerivativeStructure(compiler);\n for (int i = 0; i < ds.data.length; ++i) {\n ds.data[i] = FastMath.toDegrees(data[i]);\n }\n return ds;\n }\n 
835	public DerivativeStructure toRadians() {\n final DerivativeStructure ds = new DerivativeStructure(compiler);\n for (int i = 0; i < ds.data.length; ++i) {\n ds.data[i] = FastMath.toRadians(data[i]);\n }\n return ds;\n }\n 
836	public double taylor(final double ... delta) throws MathArithmeticException {\n return compiler.taylor(data, 0, delta);\n }\n 
837	public DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double[] aDouble = new double[a.length];\n for (int i = 0; i < a.length; ++i) {\n aDouble[i] = a[i].getValue();\n }\n final double[] bDouble = new double[b.length];\n for (int i = 0; i < b.length; ++i) {\n bDouble[i] = b[i].getValue();\n }\n final double accurateValue = MathArrays.linearCombination(aDouble, bDouble);\n // compute a simple value, with all partial derivatives\n DerivativeStructure simpleValue = a[0].getField().getZero();\n for (int i = 0; i < a.length; ++i) {\n simpleValue = simpleValue.add(a[i].multiply(b[i]));\n }\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), all);\n }\n 
838	public DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double[] bDouble = new double[b.length];\n for (int i = 0; i < b.length; ++i) {\n bDouble[i] = b[i].getValue();\n }\n final double accurateValue = MathArrays.linearCombination(a, bDouble);\n // compute a simple value, with all partial derivatives\n DerivativeStructure simpleValue = b[0].getField().getZero();\n for (int i = 0; i < a.length; ++i) {\n simpleValue = simpleValue.add(b[i].multiply(a[i]));\n }\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), all);\n }\n 
839	public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n final DerivativeStructure a2, final DerivativeStructure b2)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n a2.getValue(), b2.getValue());\n // compute a simple value, with all partial derivatives\n final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2));\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(getFreeParameters(), getOrder(), all);\n }\n 
840	public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n final double a2, final DerivativeStructure b2)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n a2, b2.getValue());\n // compute a simple value, with all partial derivatives\n final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2));\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(getFreeParameters(), getOrder(), all);\n }\n 
841	public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n final DerivativeStructure a2, final DerivativeStructure b2,\n final DerivativeStructure a3, final DerivativeStructure b3)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n a2.getValue(), b2.getValue(),\n a3.getValue(), b3.getValue());\n // compute a simple value, with all partial derivatives\n final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3));\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(getFreeParameters(), getOrder(), all);\n }\n 
842	public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n final double a2, final DerivativeStructure b2,\n final double a3, final DerivativeStructure b3)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n a2, b2.getValue(),\n a3, b3.getValue());\n // compute a simple value, with all partial derivatives\n final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3));\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(getFreeParameters(), getOrder(), all);\n }\n 
843	public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n final DerivativeStructure a2, final DerivativeStructure b2,\n final DerivativeStructure a3, final DerivativeStructure b3,\n final DerivativeStructure a4, final DerivativeStructure b4)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n a2.getValue(), b2.getValue(),\n a3.getValue(), b3.getValue(),\n a4.getValue(), b4.getValue());\n // compute a simple value, with all partial derivatives\n final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4));\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(getFreeParameters(), getOrder(), all);\n }\n 
844	public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n final double a2, final DerivativeStructure b2,\n final double a3, final DerivativeStructure b3,\n final double a4, final DerivativeStructure b4)\n throws DimensionMismatchException {\n // compute an accurate value, taking care of cancellations\n final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n a2, b2.getValue(),\n a3, b3.getValue(),\n a4, b4.getValue());\n // compute a simple value, with all partial derivatives\n final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4));\n // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n final double[] all = simpleValue.getAllDerivatives();\n all[0] = accurateValue;\n return new DerivativeStructure(getFreeParameters(), getOrder(), all);\n }\n 
845	@Override\n public boolean equals(Object other) {\n if (this == other) {\n return true;\n }\n if (other instanceof DerivativeStructure) {\n final DerivativeStructure rhs = (DerivativeStructure)other;\n return (getFreeParameters() == rhs.getFreeParameters()) &&\n (getOrder() == rhs.getOrder()) &&\n MathArrays.equals(data, rhs.data);\n }\n return false;\n }\n 
846	@Override\n public int hashCode() {\n return 227 + 229 * getFreeParameters() + 233 * getOrder() + 239 * MathUtils.hash(data);\n }\n 
847	private Object writeReplace() {\n return new DataTransferObject(compiler.getFreeParameters(), compiler.getOrder(), data);\n }\n 
848	DataTransferObject(final int variables, final int order, final double[] data) {\n this.variables = variables;\n this.order     = order;\n this.data      = data;\n }\n 
849	private Object readResolve() {\n return new DerivativeStructure(variables, order, data);\n }\n 
850	public Interval(final double lower, final double upper) {\n if (upper < lower) {\n throw new NumberIsTooSmallException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n upper, lower, true);\n }\n this.lower = lower;\n this.upper = upper;\n }\n 
851	public double getInf() {\n return lower;\n }\n 
852	@Deprecated\n public double getLower() {\n return getInf();\n }\n 
853	public double getSup() {\n return upper;\n }\n 
854	@Deprecated\n public double getUpper() {\n return getSup();\n }\n 
855	public double getSize() {\n return upper - lower;\n }\n 
856	@Deprecated\n public double getLength() {\n return getSize();\n }\n 
857	public double getBarycenter() {\n return 0.5 * (lower + upper);\n }\n 
858	@Deprecated\n public double getMidPoint() {\n return getBarycenter();\n }\n 
859	public Location checkPoint(final double point, final double tolerance) {\n if (point < lower - tolerance || point > upper + tolerance) {\n return Location.OUTSIDE;\n } else if (point > lower + tolerance && point < upper - tolerance) {\n return Location.INSIDE;\n } else {\n return Location.BOUNDARY;\n }\n }\n 
860	public PegasusSolver() {\n super(DEFAULT_ABSOLUTE_ACCURACY, Method.PEGASUS);\n }\n 
861	public PegasusSolver(final double absoluteAccuracy) {\n super(absoluteAccuracy, Method.PEGASUS);\n }\n 
862	public PegasusSolver(final double relativeAccuracy,\n final double absoluteAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, Method.PEGASUS);\n }\n 
863	public PegasusSolver(final double relativeAccuracy,\n final double absoluteAccuracy,\n final double functionValueAccuracy) {\n super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, Method.PEGASUS);\n }\n 
864	public ConvergenceException() {\n this(LocalizedFormats.CONVERGENCE_FAILED);\n }\n 
865	public ConvergenceException(Localizable pattern,\n Object ... args) {\n getContext().addMessage(pattern, args);\n }\n 
866	public KalmanFilter(final ProcessModel process, final MeasurementModel measurement)\n throws NullArgumentException, NonSquareMatrixException, DimensionMismatchException,\n MatrixDimensionMismatchException {\n MathUtils.checkNotNull(process);\n MathUtils.checkNotNull(measurement);\n this.processModel = process;\n this.measurementModel = measurement;\n transitionMatrix = processModel.getStateTransitionMatrix();\n MathUtils.checkNotNull(transitionMatrix);\n transitionMatrixT = transitionMatrix.transpose();\n // create an empty matrix if no control matrix was given\n if (processModel.getControlMatrix() == null) {\n controlMatrix = new Array2DRowRealMatrix();\n } else {\n controlMatrix = processModel.getControlMatrix();\n }\n measurementMatrix = measurementModel.getMeasurementMatrix();\n MathUtils.checkNotNull(measurementMatrix);\n measurementMatrixT = measurementMatrix.transpose();\n // check that the process and measurement noise matrices are not null\n // they will be directly accessed from the model as they may change\n // over time\n RealMatrix processNoise = processModel.getProcessNoise();\n MathUtils.checkNotNull(processNoise);\n RealMatrix measNoise = measurementModel.getMeasurementNoise();\n MathUtils.checkNotNull(measNoise);\n // set the initial state estimate to a zero vector if it is not\n // available from the process model\n if (processModel.getInitialStateEstimate() == null) {\n stateEstimation = new ArrayRealVector(transitionMatrix.getColumnDimension());\n } else {\n stateEstimation = processModel.getInitialStateEstimate();\n }\n if (transitionMatrix.getColumnDimension() != stateEstimation.getDimension()) {\n throw new DimensionMismatchException(transitionMatrix.getColumnDimension(),\n stateEstimation.getDimension());\n }\n // initialize the error covariance to the process noise if it is not\n // available from the process model\n if (processModel.getInitialErrorCovariance() == null) {\n errorCovariance = processNoise.copy();\n } else {\n errorCovariance = processModel.getInitialErrorCovariance();\n }\n // sanity checks, the control matrix B may be null\n // A must be a square matrix\n if (!transitionMatrix.isSquare()) {\n throw new NonSquareMatrixException(\n transitionMatrix.getRowDimension(),\n transitionMatrix.getColumnDimension());\n }\n // row dimension of B must be equal to A\n // if no control matrix is available, the row and column dimension will be 0\n if (controlMatrix != null &&\n controlMatrix.getRowDimension() > 0 &&\n controlMatrix.getColumnDimension() > 0 &&\n controlMatrix.getRowDimension() != transitionMatrix.getRowDimension()) {\n throw new MatrixDimensionMismatchException(controlMatrix.getRowDimension(),\n controlMatrix.getColumnDimension(),\n transitionMatrix.getRowDimension(),\n controlMatrix.getColumnDimension());\n }\n // Q must be equal to A\n MatrixUtils.checkAdditionCompatible(transitionMatrix, processNoise);\n // column dimension of H must be equal to row dimension of A\n if (measurementMatrix.getColumnDimension() != transitionMatrix.getRowDimension()) {\n throw new MatrixDimensionMismatchException(measurementMatrix.getRowDimension(),\n measurementMatrix.getColumnDimension(),\n measurementMatrix.getRowDimension(),\n transitionMatrix.getRowDimension());\n }\n // row dimension of R must be equal to row dimension of H\n if (measNoise.getRowDimension() != measurementMatrix.getRowDimension()) {\n throw new MatrixDimensionMismatchException(measNoise.getRowDimension(),\n measNoise.getColumnDimension(),\n measurementMatrix.getRowDimension(),\n measNoise.getColumnDimension());\n }\n }\n 
867	public int getStateDimension() {\n return stateEstimation.getDimension();\n }\n 
868	public int getMeasurementDimension() {\n return measurementMatrix.getRowDimension();\n }\n 
869	public double[] getStateEstimation() {\n return stateEstimation.toArray();\n }\n 
870	public RealVector getStateEstimationVector() {\n return stateEstimation.copy();\n }\n 
871	public double[][] getErrorCovariance() {\n return errorCovariance.getData();\n }\n 
872	public RealMatrix getErrorCovarianceMatrix() {\n return errorCovariance.copy();\n }\n 
873	public void predict() {\n predict((RealVector) null);\n }\n 
874	public void predict(final double[] u) throws DimensionMismatchException {\n predict(new ArrayRealVector(u, false));\n }\n 
875	public void predict(final RealVector u) throws DimensionMismatchException {\n // sanity checks\n if (u != null &&\n u.getDimension() != controlMatrix.getColumnDimension()) {\n throw new DimensionMismatchException(u.getDimension(),\n controlMatrix.getColumnDimension());\n }\n // project the state estimation ahead (a priori state)\n // xHat(k)- = A * xHat(k-1) + B * u(k-1)\n stateEstimation = transitionMatrix.operate(stateEstimation);\n // add control input if it is available\n if (u != null) {\n stateEstimation = stateEstimation.add(controlMatrix.operate(u));\n }\n // project the error covariance ahead\n // P(k)- = A * P(k-1) * A' + Q\n errorCovariance = transitionMatrix.multiply(errorCovariance)\n .multiply(transitionMatrixT)\n .add(processModel.getProcessNoise());\n }\n 
876	public void correct(final double[] z)\n throws NullArgumentException, DimensionMismatchException, SingularMatrixException {\n correct(new ArrayRealVector(z, false));\n }\n 
877	public void correct(final RealVector z)\n throws NullArgumentException, DimensionMismatchException, SingularMatrixException {\n // sanity checks\n MathUtils.checkNotNull(z);\n if (z.getDimension() != measurementMatrix.getRowDimension()) {\n throw new DimensionMismatchException(z.getDimension(),\n measurementMatrix.getRowDimension());\n }\n // S = H * P(k) * H' + R\n RealMatrix s = measurementMatrix.multiply(errorCovariance)\n .multiply(measurementMatrixT)\n .add(measurementModel.getMeasurementNoise());\n // Inn = z(k) - H * xHat(k)-\n RealVector innovation = z.subtract(measurementMatrix.operate(stateEstimation));\n // calculate gain matrix\n // K(k) = P(k)- * H' * (H * P(k)- * H' + R)^-1\n // K(k) = P(k)- * H' * S^-1\n // instead of calculating the inverse of S we can rearrange the formula,\n // and then solve the linear equation A x X = B with A = S', X = K' and B = (H * P)'\n // K(k) * S = P(k)- * H'\n // S' * K(k)' = H * P(k)-'\n RealMatrix kalmanGain = new CholeskyDecomposition(s).getSolver()\n .solve(measurementMatrix.multiply(errorCovariance.transpose()))\n .transpose();\n // update estimate with measurement z(k)\n // xHat(k) = xHat(k)- + K * Inn\n stateEstimation = stateEstimation.add(kalmanGain.operate(innovation));\n // update covariance of prediction error\n // P(k) = (I - K * H) * P(k)-\n RealMatrix identity = MatrixUtils.createRealIdentityMatrix(kalmanGain.getRowDimension());\n errorCovariance = identity.subtract(kalmanGain.multiply(measurementMatrix)).multiply(errorCovariance);\n }\n 
878	public EigenDecomposition(final RealMatrix matrix)\n throws MathArithmeticException {\n final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\n isSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\n if (isSymmetric) {\n transformToTridiagonal(matrix);\n findEigenVectors(transformer.getQ().getData());\n } else {\n final SchurTransformer t = transformToSchur(matrix);\n findEigenVectorsFromSchur(t);\n }\n }\n 
879	@Deprecated\n public EigenDecomposition(final RealMatrix matrix,\n final double splitTolerance)\n throws MathArithmeticException {\n this(matrix);\n }\n 
880	public EigenDecomposition(final double[] main, final double[] secondary) {\n isSymmetric = true;\n this.main      = main.clone();\n this.secondary = secondary.clone();\n transformer    = null;\n final int size = main.length;\n final double[][] z = new double[size][size];\n for (int i = 0; i < size; i++) {\n z[i][i] = 1.0;\n }\n findEigenVectors(z);\n }\n 
881	@Deprecated\n public EigenDecomposition(final double[] main, final double[] secondary,\n final double splitTolerance) {\n this(main, secondary);\n }\n 
882	public RealMatrix getV() {\n if (cachedV == null) {\n final int m = eigenvectors.length;\n cachedV = MatrixUtils.createRealMatrix(m, m);\n for (int k = 0; k < m; ++k) {\n cachedV.setColumnVector(k, eigenvectors[k]);\n }\n }\n // return the cached matrix\n return cachedV;\n }\n 
883	public RealMatrix getD() {\n if (cachedD == null) {\n // cache the matrix for subsequent calls\n cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n for (int i = 0; i < imagEigenvalues.length; i++) {\n if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n }\n }\n }\n return cachedD;\n }\n 
884	public RealMatrix getVT() {\n if (cachedVt == null) {\n final int m = eigenvectors.length;\n cachedVt = MatrixUtils.createRealMatrix(m, m);\n for (int k = 0; k < m; ++k) {\n cachedVt.setRowVector(k, eigenvectors[k]);\n }\n }\n // return the cached matrix\n return cachedVt;\n }\n 
885	public boolean hasComplexEigenvalues() {\n for (int i = 0; i < imagEigenvalues.length; i++) {\n if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\n return true;\n }\n }\n return false;\n }\n 
886	public double[] getRealEigenvalues() {\n return realEigenvalues.clone();\n }\n 
887	public double getRealEigenvalue(final int i) {\n return realEigenvalues[i];\n }\n 
888	public double[] getImagEigenvalues() {\n return imagEigenvalues.clone();\n }\n 
889	public double getImagEigenvalue(final int i) {\n return imagEigenvalues[i];\n }\n 
890	public RealVector getEigenvector(final int i) {\n return eigenvectors[i].copy();\n }\n 
891	public double getDeterminant() {\n double determinant = 1;\n for (double lambda : realEigenvalues) {\n determinant *= lambda;\n }\n return determinant;\n }\n 
892	public RealMatrix getSquareRoot() {\n if (!isSymmetric) {\n throw new MathUnsupportedOperationException();\n }\n final double[] sqrtEigenValues = new double[realEigenvalues.length];\n for (int i = 0; i < realEigenvalues.length; i++) {\n final double eigen = realEigenvalues[i];\n if (eigen <= 0) {\n throw new MathUnsupportedOperationException();\n }\n sqrtEigenValues[i] = FastMath.sqrt(eigen);\n }\n final RealMatrix sqrtEigen = MatrixUtils.createRealDiagonalMatrix(sqrtEigenValues);\n final RealMatrix v = getV();\n final RealMatrix vT = getVT();\n return v.multiply(sqrtEigen).multiply(vT);\n }\n 
893	public DecompositionSolver getSolver() {\n if (hasComplexEigenvalues()) {\n throw new MathUnsupportedOperationException();\n }\n return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n }\n 
894	private Solver(final double[] realEigenvalues,\n final double[] imagEigenvalues,\n final ArrayRealVector[] eigenvectors) {\n this.realEigenvalues = realEigenvalues;\n this.imagEigenvalues = imagEigenvalues;\n this.eigenvectors = eigenvectors;\n }\n 
895	public RealVector solve(final RealVector b) {\n if (!isNonSingular()) {\n throw new SingularMatrixException();\n }\n final int m = realEigenvalues.length;\n if (b.getDimension() != m) {\n throw new DimensionMismatchException(b.getDimension(), m);\n }\n final double[] bp = new double[m];\n for (int i = 0; i < m; ++i) {\n final ArrayRealVector v = eigenvectors[i];\n final double[] vData = v.getDataRef();\n final double s = v.dotProduct(b) / realEigenvalues[i];\n for (int j = 0; j < m; ++j) {\n bp[j] += s * vData[j];\n }\n }\n return new ArrayRealVector(bp, false);\n }\n 
896	public RealMatrix solve(RealMatrix b) {\n if (!isNonSingular()) {\n throw new SingularMatrixException();\n }\n final int m = realEigenvalues.length;\n if (b.getRowDimension() != m) {\n throw new DimensionMismatchException(b.getRowDimension(), m);\n }\n final int nColB = b.getColumnDimension();\n final double[][] bp = new double[m][nColB];\n final double[] tmpCol = new double[m];\n for (int k = 0; k < nColB; ++k) {\n for (int i = 0; i < m; ++i) {\n tmpCol[i] = b.getEntry(i, k);\n bp[i][k]  = 0;\n }\n for (int i = 0; i < m; ++i) {\n final ArrayRealVector v = eigenvectors[i];\n final double[] vData = v.getDataRef();\n double s = 0;\n for (int j = 0; j < m; ++j) {\n s += v.getEntry(j) * tmpCol[j];\n }\n s /= realEigenvalues[i];\n for (int j = 0; j < m; ++j) {\n bp[j][k] += s * vData[j];\n }\n }\n }\n return new Array2DRowRealMatrix(bp, false);\n }\n 
897	public boolean isNonSingular() {\n double largestEigenvalueNorm = 0.0;\n // Looping over all values (in case they are not sorted in decreasing\n // order of their norm).\n for (int i = 0; i < realEigenvalues.length; ++i) {\n largestEigenvalueNorm = FastMath.max(largestEigenvalueNorm, eigenvalueNorm(i));\n }\n // Corner case: zero matrix, all exactly 0 eigenvalues\n if (largestEigenvalueNorm == 0.0) {\n return false;\n }\n for (int i = 0; i < realEigenvalues.length; ++i) {\n // Looking for eigenvalues that are 0, where we consider anything much much smaller\n // than the largest eigenvalue to be effectively 0.\n if (Precision.equals(eigenvalueNorm(i) / largestEigenvalueNorm, 0, EPSILON)) {\n return false;\n }\n }\n return true;\n }\n 
898	private double eigenvalueNorm(int i) {\n final double re = realEigenvalues[i];\n final double im = imagEigenvalues[i];\n return FastMath.sqrt(re * re + im * im);\n }\n 
899	public RealMatrix getInverse() {\n if (!isNonSingular()) {\n throw new SingularMatrixException();\n }\n final int m = realEigenvalues.length;\n final double[][] invData = new double[m][m];\n for (int i = 0; i < m; ++i) {\n final double[] invI = invData[i];\n for (int j = 0; j < m; ++j) {\n double invIJ = 0;\n for (int k = 0; k < m; ++k) {\n final double[] vK = eigenvectors[k].getDataRef();\n invIJ += vK[i] * vK[j] / realEigenvalues[k];\n }\n invI[j] = invIJ;\n }\n }\n return MatrixUtils.createRealMatrix(invData);\n }\n 
900	private void transformToTridiagonal(final RealMatrix matrix) {\n // transform the matrix to tridiagonal\n transformer = new TriDiagonalTransformer(matrix);\n main = transformer.getMainDiagonalRef();\n secondary = transformer.getSecondaryDiagonalRef();\n }\n 
901	private void findEigenVectors(final double[][] householderMatrix) {\n final double[][]z = householderMatrix.clone();\n final int n = main.length;\n realEigenvalues = new double[n];\n imagEigenvalues = new double[n];\n final double[] e = new double[n];\n for (int i = 0; i < n - 1; i++) {\n realEigenvalues[i] = main[i];\n e[i] = secondary[i];\n }\n realEigenvalues[n - 1] = main[n - 1];\n e[n - 1] = 0;\n // Determine the largest main and secondary value in absolute term.\n double maxAbsoluteValue = 0;\n for (int i = 0; i < n; i++) {\n if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n }\n if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n maxAbsoluteValue = FastMath.abs(e[i]);\n }\n }\n // Make null any main and secondary value too small to be significant\n if (maxAbsoluteValue != 0) {\n for (int i=0; i < n; i++) {\n if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n realEigenvalues[i] = 0;\n }\n if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n e[i]=0;\n }\n }\n }\n for (int j = 0; j < n; j++) {\n int its = 0;\n int m;\n do {\n for (m = j; m < n - 1; m++) {\n double delta = FastMath.abs(realEigenvalues[m]) +\n FastMath.abs(realEigenvalues[m + 1]);\n if (FastMath.abs(e[m]) + delta == delta) {\n break;\n }\n }\n if (m != j) {\n if (its == maxIter) {\n throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n maxIter);\n }\n its++;\n double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n double t = FastMath.sqrt(1 + q * q);\n if (q < 0.0) {\n q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n } else {\n q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n }\n double u = 0.0;\n double s = 1.0;\n double c = 1.0;\n int i;\n for (i = m - 1; i >= j; i--) {\n double p = s * e[i];\n double h = c * e[i];\n if (FastMath.abs(p) >= FastMath.abs(q)) {\n c = q / p;\n t = FastMath.sqrt(c * c + 1.0);\n e[i + 1] = p * t;\n s = 1.0 / t;\n c *= s;\n } else {\n s = p / q;\n t = FastMath.sqrt(s * s + 1.0);\n e[i + 1] = q * t;\n c = 1.0 / t;\n s *= c;\n }\n if (e[i + 1] == 0.0) {\n realEigenvalues[i + 1] -= u;\n e[m] = 0.0;\n break;\n }\n q = realEigenvalues[i + 1] - u;\n t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n u = s * t;\n realEigenvalues[i + 1] = q + u;\n q = c * t - h;\n for (int ia = 0; ia < n; ia++) {\n p = z[ia][i + 1];\n z[ia][i + 1] = s * z[ia][i] + c * p;\n z[ia][i] = c * z[ia][i] - s * p;\n }\n }\n if (t == 0.0 && i >= j) {\n continue;\n }\n realEigenvalues[j] -= u;\n e[j] = q;\n e[m] = 0.0;\n }\n } while (m != j);\n }\n //Sort the eigen values (and vectors) in increase order\n for (int i = 0; i < n; i++) {\n int k = i;\n double p = realEigenvalues[i];\n for (int j = i + 1; j < n; j++) {\n if (realEigenvalues[j] > p) {\n k = j;\n p = realEigenvalues[j];\n }\n }\n if (k != i) {\n realEigenvalues[k] = realEigenvalues[i];\n realEigenvalues[i] = p;\n for (int j = 0; j < n; j++) {\n p = z[j][i];\n z[j][i] = z[j][k];\n z[j][k] = p;\n }\n }\n }\n // Determine the largest eigen value in absolute term.\n maxAbsoluteValue = 0;\n for (int i = 0; i < n; i++) {\n if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n }\n }\n // Make null any eigen value too small to be significant\n if (maxAbsoluteValue != 0.0) {\n for (int i=0; i < n; i++) {\n if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n realEigenvalues[i] = 0;\n }\n }\n }\n eigenvectors = new ArrayRealVector[n];\n final double[] tmp = new double[n];\n for (int i = 0; i < n; i++) {\n for (int j = 0; j < n; j++) {\n tmp[j] = z[j][i];\n }\n eigenvectors[i] = new ArrayRealVector(tmp);\n }\n }\n 
902	private SchurTransformer transformToSchur(final RealMatrix matrix) {\n final SchurTransformer schurTransform = new SchurTransformer(matrix);\n final double[][] matT = schurTransform.getT().getData();\n realEigenvalues = new double[matT.length];\n imagEigenvalues = new double[matT.length];\n for (int i = 0; i < realEigenvalues.length; i++) {\n if (i == (realEigenvalues.length - 1) ||\n Precision.equals(matT[i + 1][i], 0.0, EPSILON)) {\n realEigenvalues[i] = matT[i][i];\n } else {\n final double x = matT[i + 1][i + 1];\n final double p = 0.5 * (matT[i][i] - x);\n final double z = FastMath.sqrt(FastMath.abs(p * p + matT[i + 1][i] * matT[i][i + 1]));\n realEigenvalues[i] = x + p;\n imagEigenvalues[i] = z;\n realEigenvalues[i + 1] = x + p;\n imagEigenvalues[i + 1] = -z;\n i++;\n }\n }\n return schurTransform;\n }\n 
903	private Complex cdiv(final double xr, final double xi,\n final double yr, final double yi) {\n return new Complex(xr, xi).divide(new Complex(yr, yi));\n }\n 
904	private void findEigenVectorsFromSchur(final SchurTransformer schur)\n throws MathArithmeticException {\n final double[][] matrixT = schur.getT().getData();\n final double[][] matrixP = schur.getP().getData();\n final int n = matrixT.length;\n // compute matrix norm\n double norm = 0.0;\n for (int i = 0; i < n; i++) {\n for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n norm += FastMath.abs(matrixT[i][j]);\n }\n }\n // we can not handle a matrix with zero norm\n if (Precision.equals(norm, 0.0, EPSILON)) {\n throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n }\n // Backsubstitute to find vectors of upper triangular form\n double r = 0.0;\n double s = 0.0;\n double z = 0.0;\n for (int idx = n - 1; idx >= 0; idx--) {\n double p = realEigenvalues[idx];\n double q = imagEigenvalues[idx];\n if (Precision.equals(q, 0.0)) {\n // Real vector\n int l = idx;\n matrixT[idx][idx] = 1.0;\n for (int i = idx - 1; i >= 0; i--) {\n double w = matrixT[i][i] - p;\n r = 0.0;\n for (int j = l; j <= idx; j++) {\n r += matrixT[i][j] * matrixT[j][idx];\n }\n if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n z = w;\n s = r;\n } else {\n l = i;\n if (Precision.equals(imagEigenvalues[i], 0.0)) {\n if (w != 0.0) {\n matrixT[i][idx] = -r / w;\n } else {\n matrixT[i][idx] = -r / (Precision.EPSILON * norm);\n }\n } else {\n // Solve real equations\n double x = matrixT[i][i + 1];\n double y = matrixT[i + 1][i];\n q = (realEigenvalues[i] - p) * (realEigenvalues[i] - p) +\n imagEigenvalues[i] * imagEigenvalues[i];\n double t = (x * s - z * r) / q;\n matrixT[i][idx] = t;\n if (FastMath.abs(x) > FastMath.abs(z)) {\n matrixT[i + 1][idx] = (-r - w * t) / x;\n } else {\n matrixT[i + 1][idx] = (-s - y * t) / z;\n }\n }\n // Overflow control\n double t = FastMath.abs(matrixT[i][idx]);\n if ((Precision.EPSILON * t) * t > 1) {\n for (int j = i; j <= idx; j++) {\n matrixT[j][idx] /= t;\n }\n }\n }\n }\n } else if (q < 0.0) {\n // Complex vector\n int l = idx - 1;\n // Last vector component imaginary so matrix is triangular\n if (FastMath.abs(matrixT[idx][idx - 1]) > FastMath.abs(matrixT[idx - 1][idx])) {\n matrixT[idx - 1][idx - 1] = q / matrixT[idx][idx - 1];\n matrixT[idx - 1][idx]     = -(matrixT[idx][idx] - p) / matrixT[idx][idx - 1];\n } else {\n final Complex result = cdiv(0.0, -matrixT[idx - 1][idx],\n matrixT[idx - 1][idx - 1] - p, q);\n matrixT[idx - 1][idx - 1] = result.getReal();\n matrixT[idx - 1][idx]     = result.getImaginary();\n }\n matrixT[idx][idx - 1] = 0.0;\n matrixT[idx][idx]     = 1.0;\n for (int i = idx - 2; i >= 0; i--) {\n double ra = 0.0;\n double sa = 0.0;\n for (int j = l; j <= idx; j++) {\n ra += matrixT[i][j] * matrixT[j][idx - 1];\n sa += matrixT[i][j] * matrixT[j][idx];\n }\n double w = matrixT[i][i] - p;\n if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n z = w;\n r = ra;\n s = sa;\n } else {\n l = i;\n if (Precision.equals(imagEigenvalues[i], 0.0)) {\n final Complex c = cdiv(-ra, -sa, w, q);\n matrixT[i][idx - 1] = c.getReal();\n matrixT[i][idx] = c.getImaginary();\n } else {\n // Solve complex equations\n double x = matrixT[i][i + 1];\n double y = matrixT[i + 1][i];\n double vr = (realEigenvalues[i] - p) * (realEigenvalues[i] - p) +\n imagEigenvalues[i] * imagEigenvalues[i] - q * q;\n final double vi = (realEigenvalues[i] - p) * 2.0 * q;\n if (Precision.equals(vr, 0.0) && Precision.equals(vi, 0.0)) {\n vr = Precision.EPSILON * norm *\n (FastMath.abs(w) + FastMath.abs(q) + FastMath.abs(x) +\n FastMath.abs(y) + FastMath.abs(z));\n }\n final Complex c     = cdiv(x * r - z * ra + q * sa,\n x * s - z * sa - q * ra, vr, vi);\n matrixT[i][idx - 1] = c.getReal();\n matrixT[i][idx]     = c.getImaginary();\n if (FastMath.abs(x) > (FastMath.abs(z) + FastMath.abs(q))) {\n matrixT[i + 1][idx - 1] = (-ra - w * matrixT[i][idx - 1] +\n q * matrixT[i][idx]) / x;\n matrixT[i + 1][idx]     = (-sa - w * matrixT[i][idx] -\n q * matrixT[i][idx - 1]) / x;\n } else {\n final Complex c2        = cdiv(-r - y * matrixT[i][idx - 1],\n -s - y * matrixT[i][idx], z, q);\n matrixT[i + 1][idx - 1] = c2.getReal();\n matrixT[i + 1][idx]     = c2.getImaginary();\n }\n }\n // Overflow control\n double t = FastMath.max(FastMath.abs(matrixT[i][idx - 1]),\n FastMath.abs(matrixT[i][idx]));\n if ((Precision.EPSILON * t) * t > 1) {\n for (int j = i; j <= idx; j++) {\n matrixT[j][idx - 1] /= t;\n matrixT[j][idx] /= t;\n }\n }\n }\n }\n }\n }\n // Back transformation to get eigenvectors of original matrix\n for (int j = n - 1; j >= 0; j--) {\n for (int i = 0; i <= n - 1; i++) {\n z = 0.0;\n for (int k = 0; k <= FastMath.min(j, n - 1); k++) {\n z += matrixP[i][k] * matrixT[k][j];\n }\n matrixP[i][j] = z;\n }\n }\n eigenvectors = new ArrayRealVector[n];\n final double[] tmp = new double[n];\n for (int i = 0; i < n; i++) {\n for (int j = 0; j < n; j++) {\n tmp[j] = matrixP[j][i];\n }\n eigenvectors[i] = new ArrayRealVector(tmp);\n }\n }\n 
905	public TournamentSelection(final int arity) {\n this.arity = arity;\n }\n 
906	public ChromosomePair select(final Population population) throws MathIllegalArgumentException {\n return new ChromosomePair(tournament((ListPopulation) population),\n tournament((ListPopulation) population));\n }\n 
907	private Chromosome tournament(final ListPopulation population) throws MathIllegalArgumentException {\n if (population.getPopulationSize() < this.arity) {\n throw new MathIllegalArgumentException(LocalizedFormats.TOO_LARGE_TOURNAMENT_ARITY,\n arity, population.getPopulationSize());\n }\n // auxiliary population\n ListPopulation tournamentPopulation = new ListPopulation(this.arity) {\n /** {@inheritDoc} */\n public Population nextGeneration() {\n // not useful here\n return null;\n }\n };\n // create a copy of the chromosome list\n List<Chromosome> chromosomes = new ArrayList<Chromosome> (population.getChromosomes());\n for (int i=0; i<this.arity; i++) {\n // select a random individual and add it to the tournament\n int rind = GeneticAlgorithm.getRandomGenerator().nextInt(chromosomes.size());\n tournamentPopulation.addChromosome(chromosomes.get(rind));\n // do not select it again\n chromosomes.remove(rind);\n }\n // the winner takes it all\n return tournamentPopulation.getFittestChromosome();\n }\n 
908	public Population nextGeneration() {\n // not useful here\n return null;\n }\n 
909	public int getArity() {\n return arity;\n }\n 
910	public void setArity(final int arity) {\n this.arity = arity;\n }\n 
911	@SuppressWarnings("unchecked") // OK because of instanceof checks\n public ChromosomePair crossover(final Chromosome first, final Chromosome second)\n throws DimensionMismatchException, MathIllegalArgumentException {\n if (! (first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n }\n return crossover((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n }\n 
912	private ChromosomePair crossover(final AbstractListChromosome<T> first,\n final AbstractListChromosome<T> second) throws DimensionMismatchException {\n final int length = first.getLength();\n if (length != second.getLength()) {\n throw new DimensionMismatchException(second.getLength(), length);\n }\n // array representations of the parents\n final List<T> parent1Rep = first.getRepresentation();\n final List<T> parent2Rep = second.getRepresentation();\n // and of the children\n final List<T> child1Rep = new ArrayList<T>(length);\n final List<T> child2Rep = new ArrayList<T>(length);\n // select a crossover point at random (0 and length makes no sense)\n final int crossoverIndex = 1 + (GeneticAlgorithm.getRandomGenerator().nextInt(length-2));\n // copy the first part\n for (int i = 0; i < crossoverIndex; i++) {\n child1Rep.add(parent1Rep.get(i));\n child2Rep.add(parent2Rep.get(i));\n }\n // and switch the second part\n for (int i = crossoverIndex; i < length; i++) {\n child1Rep.add(parent2Rep.get(i));\n child2Rep.add(parent1Rep.get(i));\n }\n return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n second.newFixedLengthChromosome(child2Rep));\n }\n 
913	public SecantSolver() {\n super(DEFAULT_ABSOLUTE_ACCURACY);\n }\n 
914	public SecantSolver(final double absoluteAccuracy) {\n super(absoluteAccuracy);\n }\n 
915	public SecantSolver(final double relativeAccuracy,\n final double absoluteAccuracy) {\n super(relativeAccuracy, absoluteAccuracy);\n }\n 
916	@Override\n protected final double doSolve()\n throws TooManyEvaluationsException,\n NoBracketingException {\n // Get initial solution\n double x0 = getMin();\n double x1 = getMax();\n double f0 = computeObjectiveValue(x0);\n double f1 = computeObjectiveValue(x1);\n // If one of the bounds is the exact root, return it. Since these are\n // not under-approximations or over-approximations, we can return them\n // regardless of the allowed solutions.\n if (f0 == 0.0) {\n return x0;\n }\n if (f1 == 0.0) {\n return x1;\n }\n // Verify bracketing of initial solution.\n verifyBracketing(x0, x1);\n // Get accuracies.\n final double ftol = getFunctionValueAccuracy();\n final double atol = getAbsoluteAccuracy();\n final double rtol = getRelativeAccuracy();\n // Keep finding better approximations.\n while (true) {\n // Calculate the next approximation.\n final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n final double fx = computeObjectiveValue(x);\n // If the new approximation is the exact root, return it. Since\n // this is not an under-approximation or an over-approximation,\n // we can return it regardless of the allowed solutions.\n if (fx == 0.0) {\n return x;\n }\n // Update the bounds with the new approximation.\n x0 = x1;\n f0 = f1;\n x1 = x;\n f1 = fx;\n // If the function value of the last approximation is too small,\n // given the function value accuracy, then we can't get closer to\n // the root than we already are.\n if (FastMath.abs(f1) <= ftol) {\n return x1;\n }\n // If the current interval is within the given accuracies, we\n // are satisfied with the current approximation.\n if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n return x1;\n }\n }\n }\n 
