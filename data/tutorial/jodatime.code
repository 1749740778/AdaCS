1	public static PeriodType standard() {\n PeriodType type = cStandard;\n if (type == null) {\n type = new PeriodType(\n "Standard",\n new DurationFieldType[] {\n DurationFieldType.years(), DurationFieldType.months(),\n DurationFieldType.weeks(), DurationFieldType.days(),\n DurationFieldType.hours(), DurationFieldType.minutes(),\n DurationFieldType.seconds(), DurationFieldType.millis(),\n },\n new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n );\n cStandard = type;\n }\n return type;\n }\n 
2	public static PeriodType yearMonthDayTime() {\n PeriodType type = cYMDTime;\n if (type == null) {\n type = new PeriodType(\n "YearMonthDayTime",\n new DurationFieldType[] {\n DurationFieldType.years(), DurationFieldType.months(),\n DurationFieldType.days(),\n DurationFieldType.hours(), DurationFieldType.minutes(),\n DurationFieldType.seconds(), DurationFieldType.millis(),\n },\n new int[] { 0, 1, -1, 2, 3, 4, 5, 6, }\n );\n cYMDTime = type;\n }\n return type;\n }\n 
3	public static PeriodType yearMonthDay() {\n PeriodType type = cYMD;\n if (type == null) {\n type = new PeriodType(\n "YearMonthDay",\n new DurationFieldType[] {\n DurationFieldType.years(), DurationFieldType.months(),\n DurationFieldType.days(),\n },\n new int[] { 0, 1, -1, 2, -1, -1, -1, -1, }\n );\n cYMD = type;\n }\n return type;\n }\n 
4	public static PeriodType yearWeekDayTime() {\n PeriodType type = cYWDTime;\n if (type == null) {\n type = new PeriodType(\n "YearWeekDayTime",\n new DurationFieldType[] {\n DurationFieldType.years(),\n DurationFieldType.weeks(), DurationFieldType.days(),\n DurationFieldType.hours(), DurationFieldType.minutes(),\n DurationFieldType.seconds(), DurationFieldType.millis(),\n },\n new int[] { 0, -1, 1, 2, 3, 4, 5, 6, }\n );\n cYWDTime = type;\n }\n return type;\n }\n 
5	public static PeriodType yearWeekDay() {\n PeriodType type = cYWD;\n if (type == null) {\n type = new PeriodType(\n "YearWeekDay",\n new DurationFieldType[] {\n DurationFieldType.years(),\n DurationFieldType.weeks(), DurationFieldType.days(),\n },\n new int[] { 0, -1, 1, 2, -1, -1, -1, -1, }\n );\n cYWD = type;\n }\n return type;\n }\n 
6	public static PeriodType yearDayTime() {\n PeriodType type = cYDTime;\n if (type == null) {\n type = new PeriodType(\n "YearDayTime",\n new DurationFieldType[] {\n DurationFieldType.years(), DurationFieldType.days(),\n DurationFieldType.hours(), DurationFieldType.minutes(),\n DurationFieldType.seconds(), DurationFieldType.millis(),\n },\n new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n );\n cYDTime = type;\n }\n return type;\n }\n 
7	public static PeriodType yearDay() {\n PeriodType type = cYD;\n if (type == null) {\n type = new PeriodType(\n "YearDay",\n new DurationFieldType[] {\n DurationFieldType.years(), DurationFieldType.days(),\n },\n new int[] { 0, -1, -1, 1, -1, -1, -1, -1, }\n );\n cYD = type;\n }\n return type;\n }\n 
8	public static PeriodType dayTime() {\n PeriodType type = cDTime;\n if (type == null) {\n type = new PeriodType(\n "DayTime",\n new DurationFieldType[] {\n DurationFieldType.days(),\n DurationFieldType.hours(), DurationFieldType.minutes(),\n DurationFieldType.seconds(), DurationFieldType.millis(),\n },\n new int[] { -1, -1, -1, 0, 1, 2, 3, 4, }\n );\n cDTime = type;\n }\n return type;\n }\n 
9	public static PeriodType time() {\n PeriodType type = cTime;\n if (type == null) {\n type = new PeriodType(\n "Time",\n new DurationFieldType[] {\n DurationFieldType.hours(), DurationFieldType.minutes(),\n DurationFieldType.seconds(), DurationFieldType.millis(),\n },\n new int[] { -1, -1, -1, -1, 0, 1, 2, 3, }\n );\n cTime = type;\n }\n return type;\n }\n 
10	public static PeriodType years() {\n PeriodType type = cYears;\n if (type == null) {\n type = new PeriodType(\n "Years",\n new DurationFieldType[] { DurationFieldType.years() },\n new int[] { 0, -1, -1, -1, -1, -1, -1, -1, }\n );\n cYears = type;\n }\n return type;\n }\n 
11	public static PeriodType months() {\n PeriodType type = cMonths;\n if (type == null) {\n type = new PeriodType(\n "Months",\n new DurationFieldType[] { DurationFieldType.months() },\n new int[] { -1, 0, -1, -1, -1, -1, -1, -1, }\n );\n cMonths = type;\n }\n return type;\n }\n 
12	public static PeriodType weeks() {\n PeriodType type = cWeeks;\n if (type == null) {\n type = new PeriodType(\n "Weeks",\n new DurationFieldType[] { DurationFieldType.weeks() },\n new int[] { -1, -1, 0, -1, -1, -1, -1, -1, }\n );\n cWeeks = type;\n }\n return type;\n }\n 
13	public static PeriodType days() {\n PeriodType type = cDays;\n if (type == null) {\n type = new PeriodType(\n "Days",\n new DurationFieldType[] { DurationFieldType.days() },\n new int[] { -1, -1, -1, 0, -1, -1, -1, -1, }\n );\n cDays = type;\n }\n return type;\n }\n 
14	public static PeriodType hours() {\n PeriodType type = cHours;\n if (type == null) {\n type = new PeriodType(\n "Hours",\n new DurationFieldType[] { DurationFieldType.hours() },\n new int[] { -1, -1, -1, -1, 0, -1, -1, -1, }\n );\n cHours = type;\n }\n return type;\n }\n 
15	public static PeriodType minutes() {\n PeriodType type = cMinutes;\n if (type == null) {\n type = new PeriodType(\n "Minutes",\n new DurationFieldType[] { DurationFieldType.minutes() },\n new int[] { -1, -1, -1, -1, -1, 0, -1, -1, }\n );\n cMinutes = type;\n }\n return type;\n }\n 
16	public static PeriodType seconds() {\n PeriodType type = cSeconds;\n if (type == null) {\n type = new PeriodType(\n "Seconds",\n new DurationFieldType[] { DurationFieldType.seconds() },\n new int[] { -1, -1, -1, -1, -1, -1, 0, -1, }\n );\n cSeconds = type;\n }\n return type;\n }\n 
17	public static PeriodType millis() {\n PeriodType type = cMillis;\n if (type == null) {\n type = new PeriodType(\n "Millis",\n new DurationFieldType[] { DurationFieldType.millis() },\n new int[] { -1, -1, -1, -1, -1, -1, -1, 0, }\n );\n cMillis = type;\n }\n return type;\n }\n 
18	public static synchronized PeriodType forFields(DurationFieldType[] types) {\n if (types == null || types.length == 0) {\n throw new IllegalArgumentException("Types array must not be null or empty");\n }\n for (int i = 0; i < types.length; i++) {\n if (types[i] == null) {\n throw new IllegalArgumentException("Types array must not contain null");\n }\n }\n Map<PeriodType, Object> cache = cTypes;\n if (cache.isEmpty()) {\n cache.put(standard(), standard());\n cache.put(yearMonthDayTime(), yearMonthDayTime());\n cache.put(yearMonthDay(), yearMonthDay());\n cache.put(yearWeekDayTime(), yearWeekDayTime());\n cache.put(yearWeekDay(), yearWeekDay());\n cache.put(yearDayTime(), yearDayTime());\n cache.put(yearDay(), yearDay());\n cache.put(dayTime(), dayTime());\n cache.put(time(), time());\n cache.put(years(), years());\n cache.put(months(), months());\n cache.put(weeks(), weeks());\n cache.put(days(), days());\n cache.put(hours(), hours());\n cache.put(minutes(), minutes());\n cache.put(seconds(), seconds());\n cache.put(millis(), millis());\n }\n PeriodType inPartType = new PeriodType(null, types, null);\n Object cached = cache.get(inPartType);\n if (cached instanceof PeriodType) {\n return (PeriodType) cached;\n }\n if (cached != null) {\n throw new IllegalArgumentException("PeriodType does not support fields: " + cached);\n }\n PeriodType type = standard();\n List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\n if (list.remove(DurationFieldType.years()) == false) {\n type = type.withYearsRemoved();\n }\n if (list.remove(DurationFieldType.months()) == false) {\n type = type.withMonthsRemoved();\n }\n if (list.remove(DurationFieldType.weeks()) == false) {\n type = type.withWeeksRemoved();\n }\n if (list.remove(DurationFieldType.days()) == false) {\n type = type.withDaysRemoved();\n }\n if (list.remove(DurationFieldType.hours()) == false) {\n type = type.withHoursRemoved();\n }\n if (list.remove(DurationFieldType.minutes()) == false) {\n type = type.withMinutesRemoved();\n }\n if (list.remove(DurationFieldType.seconds()) == false) {\n type = type.withSecondsRemoved();\n }\n if (list.remove(DurationFieldType.millis()) == false) {\n type = type.withMillisRemoved();\n }\n if (list.size() > 0) {\n cache.put(inPartType, list);\n throw new IllegalArgumentException("PeriodType does not support fields: " + list);\n }\n // recheck cache in case initial array order was wrong\n PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\n PeriodType checkedType = (PeriodType) cache.get(checkPartType);\n if (checkedType != null) {\n cache.put(checkPartType, checkedType);\n return checkedType;\n }\n cache.put(checkPartType, type);\n return type;\n }\n 
19	protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n super();\n iName = name;\n iTypes = types;\n iIndices = indices;\n }\n 
20	public String getName() {\n return iName;\n }\n 
21	public int size() {\n return iTypes.length;\n }\n 
22	public DurationFieldType getFieldType(int index) {\n return iTypes[index];\n }\n 
23	public boolean isSupported(DurationFieldType type) {\n return (indexOf(type) >= 0);\n }\n 
24	public int indexOf(DurationFieldType type) {\n for (int i = 0, isize = size(); i < isize; i++) {\n if (iTypes[i] == type) {\n return i;\n }\n }\n return -1;\n }\n 
25	public String toString() {\n return "PeriodType[" + getName() + "]";\n }\n 
26	int getIndexedField(ReadablePeriod period, int index) {\n int realIndex = iIndices[index];\n return (realIndex == -1 ? 0 : period.getValue(realIndex));\n }\n 
27	boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\n int realIndex = iIndices[index];\n if (realIndex == -1) {\n throw new UnsupportedOperationException("Field is not supported");\n }\n values[realIndex] = newValue;\n return true;\n }\n 
28	boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) {\n if (valueToAdd == 0) {\n return false;\n }\n int realIndex = iIndices[index];\n if (realIndex == -1) {\n throw new UnsupportedOperationException("Field is not supported");\n }\n values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd);\n return true;\n }\n 
29	public PeriodType withYearsRemoved() {\n return withFieldRemoved(0, "NoYears");\n }\n 
30	public PeriodType withMonthsRemoved() {\n return withFieldRemoved(1, "NoMonths");\n }\n 
31	public PeriodType withWeeksRemoved() {\n return withFieldRemoved(2, "NoWeeks");\n }\n 
32	public PeriodType withDaysRemoved() {\n return withFieldRemoved(3, "NoDays");\n }\n 
33	public PeriodType withHoursRemoved() {\n return withFieldRemoved(4, "NoHours");\n }\n 
34	public PeriodType withMinutesRemoved() {\n return withFieldRemoved(5, "NoMinutes");\n }\n 
35	public PeriodType withSecondsRemoved() {\n return withFieldRemoved(6, "NoSeconds");\n }\n 
36	public PeriodType withMillisRemoved() {\n return withFieldRemoved(7, "NoMillis");\n }\n 
37	private PeriodType withFieldRemoved(int indicesIndex, String name) {\n int fieldIndex = iIndices[indicesIndex];\n if (fieldIndex == -1) {\n return this;\n }\n \n DurationFieldType[] types = new DurationFieldType[size() - 1];\n for (int i = 0; i < iTypes.length; i++) {\n if (i < fieldIndex) {\n types[i] = iTypes[i];\n } else if (i > fieldIndex) {\n types[i - 1] = iTypes[i];\n }\n }\n \n int[] indices = new int[8];\n for (int i = 0; i < indices.length; i++) {\n if (i < indicesIndex) {\n indices[i] = iIndices[i];\n } else if (i > indicesIndex) {\n indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\n } else {\n indices[i] = -1;\n }\n }\n return new PeriodType(getName() + name, types, indices);\n }\n 
38	public boolean equals(Object obj) {\n if (this == obj) {\n return true;\n }\n if (obj instanceof PeriodType == false) {\n return false;\n }\n PeriodType other = (PeriodType) obj;\n return (Arrays.equals(iTypes, other.iTypes));\n }\n 
39	public int hashCode() {\n int hash = 0;\n for (int i = 0; i < iTypes.length; i++) {\n hash += iTypes[i].hashCode();\n }\n return hash;\n }\n 
40	public static MutableInterval parse(String str) {\n return new MutableInterval(str);\n }\n 
41	public MutableInterval() {\n super(0L, 0L, null);\n }\n 
42	public MutableInterval(long startInstant, long endInstant) {\n super(startInstant, endInstant, null);\n }\n 
43	public MutableInterval(long startInstant, long endInstant, Chronology chronology) {\n super(startInstant, endInstant, chronology);\n }\n 
44	public MutableInterval(ReadableInstant start, ReadableInstant end) {\n super(start, end);\n }\n 
45	public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n super(start, duration);\n }\n 
46	public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n super(duration, end);\n }\n 
47	public MutableInterval(ReadableInstant start, ReadablePeriod period) {\n super(start, period);\n }\n 
48	public MutableInterval(ReadablePeriod period, ReadableInstant end) {\n super(period, end);\n }\n 
49	public MutableInterval(Object interval) {\n super(interval, null);\n }\n 
50	public MutableInterval(Object interval, Chronology chronology) {\n super(interval, chronology);\n }\n 
51	public void setInterval(long startInstant, long endInstant) {\n super.setInterval(startInstant, endInstant, getChronology());\n }\n 
52	public void setInterval(ReadableInterval interval) {\n if (interval == null) {\n throw new IllegalArgumentException("Interval must not be null");\n }\n long startMillis = interval.getStartMillis();\n long endMillis = interval.getEndMillis();\n Chronology chrono = interval.getChronology();\n super.setInterval(startMillis, endMillis, chrono);\n }\n 
53	public void setInterval(ReadableInstant start, ReadableInstant end) {\n if (start == null && end == null) {\n long now = DateTimeUtils.currentTimeMillis();\n setInterval(now, now);\n } else {\n long startMillis = DateTimeUtils.getInstantMillis(start);\n long endMillis = DateTimeUtils.getInstantMillis(end);\n Chronology chrono = DateTimeUtils.getInstantChronology(start);\n super.setInterval(startMillis, endMillis, chrono);\n }\n }\n 
54	public void setChronology(Chronology chrono) {\n super.setInterval(getStartMillis(), getEndMillis(), chrono);\n }\n 
55	public void setStartMillis(long startInstant) {\n super.setInterval(startInstant, getEndMillis(), getChronology());\n }\n 
56	public void setStart(ReadableInstant start) {\n long startMillis = DateTimeUtils.getInstantMillis(start);\n super.setInterval(startMillis, getEndMillis(), getChronology());\n }\n 
57	public void setEndMillis(long endInstant) {\n super.setInterval(getStartMillis(), endInstant, getChronology());\n }\n 
58	public void setEnd(ReadableInstant end) {\n long endMillis = DateTimeUtils.getInstantMillis(end);\n super.setInterval(getStartMillis(), endMillis, getChronology());\n }\n 
59	public void setDurationAfterStart(long duration) {\n setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration));\n }\n 
60	public void setDurationBeforeEnd(long duration) {\n setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration));\n }\n 
61	public void setDurationAfterStart(ReadableDuration duration) {\n long durationMillis = DateTimeUtils.getDurationMillis(duration);\n setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis));\n }\n 
62	public void setDurationBeforeEnd(ReadableDuration duration) {\n long durationMillis = DateTimeUtils.getDurationMillis(duration);\n setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis));\n }\n 
63	public void setPeriodAfterStart(ReadablePeriod period) {\n if (period == null) {\n setEndMillis(getStartMillis());\n } else {\n setEndMillis(getChronology().add(period, getStartMillis(), 1));\n }\n }\n 
64	public void setPeriodBeforeEnd(ReadablePeriod period) {\n if (period == null) {\n setStartMillis(getEndMillis());\n } else {\n setStartMillis(getChronology().add(period, getEndMillis(), -1));\n }\n }\n 
65	public MutableInterval copy() {\n return (MutableInterval) clone();\n }\n 
66	public Object clone() {\n try {\n return super.clone();\n } catch (CloneNotSupportedException ex) {\n throw new InternalError("Clone error");\n }\n }\n 
67	public static MutableDateTime now() {\n return new MutableDateTime();\n }\n 
68	public static MutableDateTime now(DateTimeZone zone) {\n if (zone == null) {\n throw new NullPointerException("Zone must not be null");\n }\n return new MutableDateTime(zone);\n }\n 
69	public static MutableDateTime now(Chronology chronology) {\n if (chronology == null) {\n throw new NullPointerException("Chronology must not be null");\n }\n return new MutableDateTime(chronology);\n }\n 
70	@FromString\n public static MutableDateTime parse(String str) {\n return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());\n }\n 
71	public static MutableDateTime parse(String str, DateTimeFormatter formatter) {\n return formatter.parseDateTime(str).toMutableDateTime();\n }\n 
72	public MutableDateTime() {\n super();\n }\n 
73	public MutableDateTime(DateTimeZone zone) {\n super(zone);\n }\n 
74	public MutableDateTime(Chronology chronology) {\n super(chronology);\n }\n 
75	public MutableDateTime(long instant) {\n super(instant);\n }\n 
76	public MutableDateTime(long instant, DateTimeZone zone) {\n super(instant, zone);\n }\n 
77	public MutableDateTime(long instant, Chronology chronology) {\n super(instant, chronology);\n }\n 
78	public MutableDateTime(Object instant) {\n super(instant, (Chronology) null);\n }\n 
79	public MutableDateTime(Object instant, DateTimeZone zone) {\n super(instant, zone);\n }\n 
80	public MutableDateTime(Object instant, Chronology chronology) {\n super(instant, DateTimeUtils.getChronology(chronology));\n }\n 
81	public MutableDateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n int millisOfSecond) {\n super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n }\n 
82	public MutableDateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n int millisOfSecond,\n DateTimeZone zone) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n }\n 
83	public MutableDateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n int millisOfSecond,\n Chronology chronology) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n }\n 
84	public DateTimeField getRoundingField() {\n return iRoundingField;\n }\n 
85	public int getRoundingMode() {\n return iRoundingMode;\n }\n 
86	public void setRounding(DateTimeField field) {\n setRounding(field, MutableDateTime.ROUND_FLOOR);\n }\n 
87	public void setRounding(DateTimeField field, int mode) {\n if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {\n throw new IllegalArgumentException("Illegal rounding mode: " + mode);\n }\n iRoundingField = (mode == ROUND_NONE ? null : field);\n iRoundingMode = (field == null ? ROUND_NONE : mode);\n setMillis(getMillis());\n }\n 
88	public void setMillis(long instant) {\n switch (iRoundingMode) {\n case ROUND_NONE:\n break;\n case ROUND_FLOOR:\n instant = iRoundingField.roundFloor(instant);\n break;\n case ROUND_CEILING:\n instant = iRoundingField.roundCeiling(instant);\n break;\n case ROUND_HALF_FLOOR:\n instant = iRoundingField.roundHalfFloor(instant);\n break;\n case ROUND_HALF_CEILING:\n instant = iRoundingField.roundHalfCeiling(instant);\n break;\n case ROUND_HALF_EVEN:\n instant = iRoundingField.roundHalfEven(instant);\n break;\n }\n super.setMillis(instant);\n }\n 
89	public void setMillis(ReadableInstant instant) {\n long instantMillis = DateTimeUtils.getInstantMillis(instant);\n setMillis(instantMillis);  // set via this class not super\n }\n 
90	public void add(long duration) {\n setMillis(FieldUtils.safeAdd(getMillis(), duration));  // set via this class not super\n }\n 
91	public void add(ReadableDuration duration) {\n add(duration, 1);\n }\n 
92	public void add(ReadableDuration duration, int scalar) {\n if (duration != null) {\n add(FieldUtils.safeMultiply(duration.getMillis(), scalar));\n }\n }\n 
93	public void add(ReadablePeriod period) {\n add(period, 1);\n }\n 
94	public void add(ReadablePeriod period, int scalar) {\n if (period != null) {\n setMillis(getChronology().add(period, getMillis(), scalar));  // set via this class not super\n }\n }\n 
95	public void setChronology(Chronology chronology) {\n super.setChronology(chronology);\n }\n 
96	public void setZone(DateTimeZone newZone) {\n newZone = DateTimeUtils.getZone(newZone);\n Chronology chrono = getChronology();\n if (chrono.getZone() != newZone) {\n setChronology(chrono.withZone(newZone));  // set via this class not super\n }\n }\n 
97	public void setZoneRetainFields(DateTimeZone newZone) {\n newZone = DateTimeUtils.getZone(newZone);\n DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n if (newZone == originalZone) {\n return;\n }\n \n long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n setChronology(getChronology().withZone(newZone));  // set via this class not super\n setMillis(millis);\n }\n 
98	public void set(DateTimeFieldType type, int value) {\n if (type == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n setMillis(type.getField(getChronology()).set(getMillis(), value));\n }\n 
99	public void add(DurationFieldType type, int amount) {\n if (type == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n if (amount != 0) {\n setMillis(type.getField(getChronology()).add(getMillis(), amount));\n }\n }\n 
100	public void setYear(final int year) {\n setMillis(getChronology().year().set(getMillis(), year));\n }\n 
101	public void addYears(final int years) {\n if (years != 0) {\n setMillis(getChronology().years().add(getMillis(), years));\n }\n }\n 
102	public void setWeekyear(final int weekyear) {\n setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n }\n 
103	public void addWeekyears(final int weekyears) {\n if (weekyears != 0) {\n setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n }\n }\n 
104	public void setMonthOfYear(final int monthOfYear) {\n setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n }\n 
105	public void addMonths(final int months) {\n if (months != 0) {\n setMillis(getChronology().months().add(getMillis(), months));\n }\n }\n 
106	public void setWeekOfWeekyear(final int weekOfWeekyear) {\n setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n }\n 
107	public void addWeeks(final int weeks) {\n if (weeks != 0) {\n setMillis(getChronology().weeks().add(getMillis(), weeks));\n }\n }\n 
108	public void setDayOfYear(final int dayOfYear) {\n setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n }\n 
109	public void setDayOfMonth(final int dayOfMonth) {\n setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n }\n 
110	public void setDayOfWeek(final int dayOfWeek) {\n setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n }\n 
111	public void addDays(final int days) {\n if (days != 0) {\n setMillis(getChronology().days().add(getMillis(), days));\n }\n }\n 
112	public void setHourOfDay(final int hourOfDay) {\n setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n }\n 
113	public void addHours(final int hours) {\n if (hours != 0) {\n setMillis(getChronology().hours().add(getMillis(), hours));\n }\n }\n 
114	public void setMinuteOfDay(final int minuteOfDay) {\n setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n }\n 
115	public void setMinuteOfHour(final int minuteOfHour) {\n setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n }\n 
116	public void addMinutes(final int minutes) {\n if (minutes != 0) {\n setMillis(getChronology().minutes().add(getMillis(), minutes));\n }\n }\n 
117	public void setSecondOfDay(final int secondOfDay) {\n setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n }\n 
118	public void setSecondOfMinute(final int secondOfMinute) {\n setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n }\n 
119	public void addSeconds(final int seconds) {\n if (seconds != 0) {\n setMillis(getChronology().seconds().add(getMillis(), seconds));\n }\n }\n 
120	public void setMillisOfDay(final int millisOfDay) {\n setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n }\n 
121	public void setMillisOfSecond(final int millisOfSecond) {\n setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n }\n 
122	public void addMillis(final int millis) {\n if (millis != 0) {\n setMillis(getChronology().millis().add(getMillis(), millis));\n }\n }\n 
123	public void setDate(final long instant) {\n setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));\n }\n 
124	public void setDate(final ReadableInstant instant) {\n long instantMillis = DateTimeUtils.getInstantMillis(instant);\n if (instant instanceof ReadableDateTime) {\n ReadableDateTime rdt = (ReadableDateTime) instant;\n Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology());\n DateTimeZone zone = instantChrono.getZone();\n if (zone != null) {\n instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis);\n }\n }\n setDate(instantMillis);\n }\n 
125	public void setDate(\n final int year,\n final int monthOfYear,\n final int dayOfMonth) {\n Chronology c = getChronology();\n long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n setDate(instantMidnight);\n }\n 
126	public void setTime(final long millis) {\n int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);\n setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n }\n 
127	public void setTime(final ReadableInstant instant) {\n long instantMillis = DateTimeUtils.getInstantMillis(instant);\n Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);\n DateTimeZone zone = instantChrono.getZone();\n if (zone != null) {\n instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);\n }\n setTime(instantMillis);\n }\n 
128	public void setTime(\n final int hour,\n final int minuteOfHour,\n final int secondOfMinute,\n final int millisOfSecond) {\n long instant = getChronology().getDateTimeMillis(\n getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n setMillis(instant);\n }\n 
129	public void setDateTime(\n final int year,\n final int monthOfYear,\n final int dayOfMonth,\n final int hourOfDay,\n final int minuteOfHour,\n final int secondOfMinute,\n final int millisOfSecond) {\n long instant = getChronology().getDateTimeMillis(\n year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n setMillis(instant);\n }\n 
130	public Property property(DateTimeFieldType type) {\n if (type == null) {\n throw new IllegalArgumentException("The DateTimeFieldType must not be null");\n }\n DateTimeField field = type.getField(getChronology());\n if (field.isSupported() == false) {\n throw new IllegalArgumentException("Field '" + type + "' is not supported");\n }\n return new Property(this, field);\n }\n 
131	public Property era() {\n return new Property(this, getChronology().era());\n }\n 
132	public Property centuryOfEra() {\n return new Property(this, getChronology().centuryOfEra());\n }\n 
133	public Property yearOfCentury() {\n return new Property(this, getChronology().yearOfCentury());\n }\n 
134	public Property yearOfEra() {\n return new Property(this, getChronology().yearOfEra());\n }\n 
135	public Property year() {\n return new Property(this, getChronology().year());\n }\n 
136	public Property weekyear() {\n return new Property(this, getChronology().weekyear());\n }\n 
137	public Property monthOfYear() {\n return new Property(this, getChronology().monthOfYear());\n }\n 
138	public Property weekOfWeekyear() {\n return new Property(this, getChronology().weekOfWeekyear());\n }\n 
139	public Property dayOfYear() {\n return new Property(this, getChronology().dayOfYear());\n }\n 
140	public Property dayOfMonth() {\n return new Property(this, getChronology().dayOfMonth());\n }\n 
141	public Property dayOfWeek() {\n return new Property(this, getChronology().dayOfWeek());\n }\n 
142	public Property hourOfDay() {\n return new Property(this, getChronology().hourOfDay());\n }\n 
143	public Property minuteOfDay() {\n return new Property(this, getChronology().minuteOfDay());\n }\n 
144	public Property minuteOfHour() {\n return new Property(this, getChronology().minuteOfHour());\n }\n 
145	public Property secondOfDay() {\n return new Property(this, getChronology().secondOfDay());\n }\n 
146	public Property secondOfMinute() {\n return new Property(this, getChronology().secondOfMinute());\n }\n 
147	public Property millisOfDay() {\n return new Property(this, getChronology().millisOfDay());\n }\n 
148	public Property millisOfSecond() {\n return new Property(this, getChronology().millisOfSecond());\n }\n 
149	public MutableDateTime copy() {\n return (MutableDateTime) clone();\n }\n 
150	public Object clone() {\n try {\n return super.clone();\n } catch (CloneNotSupportedException ex) {\n throw new InternalError("Clone error");\n }\n }\n 
151	Property(MutableDateTime instant, DateTimeField field) {\n super();\n iInstant = instant;\n iField = field;\n }\n 
152	private void writeObject(ObjectOutputStream oos) throws IOException {\n oos.writeObject(iInstant);\n oos.writeObject(iField.getType());\n }\n 
153	private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n iInstant = (MutableDateTime) oos.readObject();\n DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n iField = type.getField(iInstant.getChronology());\n }\n 
154	public DateTimeField getField() {\n return iField;\n }\n 
155	protected long getMillis() {\n return iInstant.getMillis();\n }\n 
156	protected Chronology getChronology() {\n return iInstant.getChronology();\n }\n 
157	public MutableDateTime getMutableDateTime() {\n return iInstant;\n }\n 
158	public MutableDateTime add(int value) {\n iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n return iInstant;\n }\n 
159	public MutableDateTime add(long value) {\n iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n return iInstant;\n }\n 
160	public MutableDateTime addWrapField(int value) {\n iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n return iInstant;\n }\n 
161	public MutableDateTime set(int value) {\n iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n return iInstant;\n }\n 
162	public MutableDateTime set(String text, Locale locale) {\n iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n return iInstant;\n }\n 
163	public MutableDateTime set(String text) {\n set(text, null);\n return iInstant;\n }\n 
164	public MutableDateTime roundFloor() {\n iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n return iInstant;\n }\n 
165	public MutableDateTime roundCeiling() {\n iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n return iInstant;\n }\n 
166	public MutableDateTime roundHalfFloor() {\n iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n return iInstant;\n }\n 
167	public MutableDateTime roundHalfCeiling() {\n iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n return iInstant;\n }\n 
168	public MutableDateTime roundHalfEven() {\n iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n return iInstant;\n }\n 
169	public static DateTime now() {\n return new DateTime();\n }\n 
170	public static DateTime now(DateTimeZone zone) {\n if (zone == null) {\n throw new NullPointerException("Zone must not be null");\n }\n return new DateTime(zone);\n }\n 
171	public static DateTime now(Chronology chronology) {\n if (chronology == null) {\n throw new NullPointerException("Chronology must not be null");\n }\n return new DateTime(chronology);\n }\n 
172	@FromString\n public static DateTime parse(String str) {\n return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());\n }\n 
173	public static DateTime parse(String str, DateTimeFormatter formatter) {\n return formatter.parseDateTime(str);\n }\n 
174	public DateTime() {\n super();\n }\n 
175	public DateTime(DateTimeZone zone) {\n super(zone);\n }\n 
176	public DateTime(Chronology chronology) {\n super(chronology);\n }\n 
177	public DateTime(long instant) {\n super(instant);\n }\n 
178	public DateTime(long instant, DateTimeZone zone) {\n super(instant, zone);\n }\n 
179	public DateTime(long instant, Chronology chronology) {\n super(instant, chronology);\n }\n 
180	public DateTime(Object instant) {\n super(instant, (Chronology) null);\n }\n 
181	public DateTime(Object instant, DateTimeZone zone) {\n super(instant, zone);\n }\n 
182	public DateTime(Object instant, Chronology chronology) {\n super(instant, DateTimeUtils.getChronology(chronology));\n }\n 
183	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour) {\n super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0);\n }\n 
184	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n DateTimeZone zone) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, 0, 0, zone);\n }\n 
185	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n Chronology chronology) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, 0, 0, chronology);\n }\n 
186	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute) {\n super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0);\n }\n 
187	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n DateTimeZone zone) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, secondOfMinute, 0, zone);\n }\n 
188	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n Chronology chronology) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);\n }\n 
189	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n int millisOfSecond) {\n super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n }\n 
190	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n int millisOfSecond,\n DateTimeZone zone) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n }\n 
191	public DateTime(\n int year,\n int monthOfYear,\n int dayOfMonth,\n int hourOfDay,\n int minuteOfHour,\n int secondOfMinute,\n int millisOfSecond,\n Chronology chronology) {\n super(year, monthOfYear, dayOfMonth,\n hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n }\n 
192	public DateTime toDateTime() {\n return this;\n }\n 
193	public DateTime toDateTimeISO() {\n if (getChronology() == ISOChronology.getInstance()) {\n return this;\n }\n return super.toDateTimeISO();\n }\n 
194	public DateTime toDateTime(DateTimeZone zone) {\n zone = DateTimeUtils.getZone(zone);\n if (getZone() == zone) {\n return this;\n }\n return super.toDateTime(zone);\n }\n 
195	public DateTime toDateTime(Chronology chronology) {\n chronology = DateTimeUtils.getChronology(chronology);\n if (getChronology() == chronology) {\n return this;\n }\n return super.toDateTime(chronology);\n }\n 
196	public DateTime withMillis(long newMillis) {\n return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n }\n 
197	public DateTime withChronology(Chronology newChronology) {\n newChronology = DateTimeUtils.getChronology(newChronology);\n return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n }\n 
198	public DateTime withZone(DateTimeZone newZone) {\n return withChronology(getChronology().withZone(newZone));\n }\n 
199	public DateTime withZoneRetainFields(DateTimeZone newZone) {\n newZone = DateTimeUtils.getZone(newZone);\n DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n if (newZone == originalZone) {\n return this;\n }\n \n long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n return new DateTime(millis, getChronology().withZone(newZone));\n }\n 
200	public DateTime withEarlierOffsetAtOverlap() {\n long newMillis = getZone().adjustOffset(getMillis(), false);\n return withMillis(newMillis);\n }\n 
201	public DateTime withLaterOffsetAtOverlap() {\n long newMillis = getZone().adjustOffset(getMillis(), true);\n return withMillis(newMillis);\n }\n 
202	public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n Chronology chrono = getChronology();\n long instant = getMillis();\n instant = chrono.year().set(instant, year);\n instant = chrono.monthOfYear().set(instant, monthOfYear);\n instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n return withMillis(instant);\n }\n 
203	public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n Chronology chrono = getChronology();\n long instant = getMillis();\n instant = chrono.hourOfDay().set(instant, hourOfDay);\n instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n return withMillis(instant);\n }\n 
204	public DateTime withTimeAtStartOfDay() {\n return toLocalDate().toDateTimeAtStartOfDay(getZone());\n }\n 
205	public DateTime withFields(ReadablePartial partial) {\n if (partial == null) {\n return this;\n }\n return withMillis(getChronology().set(partial, getMillis()));\n }\n 
206	public DateTime withField(DateTimeFieldType fieldType, int value) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n return withMillis(instant);\n }\n 
207	public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n if (amount == 0) {\n return this;\n }\n long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n return withMillis(instant);\n }\n 
208	public DateTime withDurationAdded(long durationToAdd, int scalar) {\n if (durationToAdd == 0 || scalar == 0) {\n return this;\n }\n long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n return withMillis(instant);\n }\n 
209	public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n if (durationToAdd == null || scalar == 0) {\n return this;\n }\n return withDurationAdded(durationToAdd.getMillis(), scalar);\n }\n 
210	public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n if (period == null || scalar == 0) {\n return this;\n }\n long instant = getChronology().add(period, getMillis(), scalar);\n return withMillis(instant);\n }\n 
211	public DateTime plus(long duration) {\n return withDurationAdded(duration, 1);\n }\n 
212	public DateTime plus(ReadableDuration duration) {\n return withDurationAdded(duration, 1);\n }\n 
213	public DateTime plus(ReadablePeriod period) {\n return withPeriodAdded(period, 1);\n }\n 
214	public DateTime plusYears(int years) {\n if (years == 0) {\n return this;\n }\n long instant = getChronology().years().add(getMillis(), years);\n return withMillis(instant);\n }\n 
215	public DateTime plusMonths(int months) {\n if (months == 0) {\n return this;\n }\n long instant = getChronology().months().add(getMillis(), months);\n return withMillis(instant);\n }\n 
216	public DateTime plusWeeks(int weeks) {\n if (weeks == 0) {\n return this;\n }\n long instant = getChronology().weeks().add(getMillis(), weeks);\n return withMillis(instant);\n }\n 
217	public DateTime plusDays(int days) {\n if (days == 0) {\n return this;\n }\n long instant = getChronology().days().add(getMillis(), days);\n return withMillis(instant);\n }\n 
218	public DateTime plusHours(int hours) {\n if (hours == 0) {\n return this;\n }\n long instant = getChronology().hours().add(getMillis(), hours);\n return withMillis(instant);\n }\n 
219	public DateTime plusMinutes(int minutes) {\n if (minutes == 0) {\n return this;\n }\n long instant = getChronology().minutes().add(getMillis(), minutes);\n return withMillis(instant);\n }\n 
220	public DateTime plusSeconds(int seconds) {\n if (seconds == 0) {\n return this;\n }\n long instant = getChronology().seconds().add(getMillis(), seconds);\n return withMillis(instant);\n }\n 
221	public DateTime plusMillis(int millis) {\n if (millis == 0) {\n return this;\n }\n long instant = getChronology().millis().add(getMillis(), millis);\n return withMillis(instant);\n }\n 
222	public DateTime minus(long duration) {\n return withDurationAdded(duration, -1);\n }\n 
223	public DateTime minus(ReadableDuration duration) {\n return withDurationAdded(duration, -1);\n }\n 
224	public DateTime minus(ReadablePeriod period) {\n return withPeriodAdded(period, -1);\n }\n 
225	public DateTime minusYears(int years) {\n if (years == 0) {\n return this;\n }\n long instant = getChronology().years().subtract(getMillis(), years);\n return withMillis(instant);\n }\n 
226	public DateTime minusMonths(int months) {\n if (months == 0) {\n return this;\n }\n long instant = getChronology().months().subtract(getMillis(), months);\n return withMillis(instant);\n }\n 
227	public DateTime minusWeeks(int weeks) {\n if (weeks == 0) {\n return this;\n }\n long instant = getChronology().weeks().subtract(getMillis(), weeks);\n return withMillis(instant);\n }\n 
228	public DateTime minusDays(int days) {\n if (days == 0) {\n return this;\n }\n long instant = getChronology().days().subtract(getMillis(), days);\n return withMillis(instant);\n }\n 
229	public DateTime minusHours(int hours) {\n if (hours == 0) {\n return this;\n }\n long instant = getChronology().hours().subtract(getMillis(), hours);\n return withMillis(instant);\n }\n 
230	public DateTime minusMinutes(int minutes) {\n if (minutes == 0) {\n return this;\n }\n long instant = getChronology().minutes().subtract(getMillis(), minutes);\n return withMillis(instant);\n }\n 
231	public DateTime minusSeconds(int seconds) {\n if (seconds == 0) {\n return this;\n }\n long instant = getChronology().seconds().subtract(getMillis(), seconds);\n return withMillis(instant);\n }\n 
232	public DateTime minusMillis(int millis) {\n if (millis == 0) {\n return this;\n }\n long instant = getChronology().millis().subtract(getMillis(), millis);\n return withMillis(instant);\n }\n 
233	public Property property(DateTimeFieldType type) {\n if (type == null) {\n throw new IllegalArgumentException("The DateTimeFieldType must not be null");\n }\n DateTimeField field = type.getField(getChronology());\n if (field.isSupported() == false) {\n throw new IllegalArgumentException("Field '" + type + "' is not supported");\n }\n return new Property(this, field);\n }\n 
234	@Deprecated\n public DateMidnight toDateMidnight() {\n return new DateMidnight(getMillis(), getChronology());\n }\n 
235	@Deprecated\n public YearMonthDay toYearMonthDay() {\n return new YearMonthDay(getMillis(), getChronology());\n }\n 
236	@Deprecated\n public TimeOfDay toTimeOfDay() {\n return new TimeOfDay(getMillis(), getChronology());\n }\n 
237	public LocalDateTime toLocalDateTime() {\n return new LocalDateTime(getMillis(), getChronology());\n }\n 
238	public LocalDate toLocalDate() {\n return new LocalDate(getMillis(), getChronology());\n }\n 
239	public LocalTime toLocalTime() {\n return new LocalTime(getMillis(), getChronology());\n }\n 
240	public DateTime withEra(int era) {\n return withMillis(getChronology().era().set(getMillis(), era));\n }\n 
241	public DateTime withCenturyOfEra(int centuryOfEra) {\n return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n }\n 
242	public DateTime withYearOfEra(int yearOfEra) {\n return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n }\n 
243	public DateTime withYearOfCentury(int yearOfCentury) {\n return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n }\n 
244	public DateTime withYear(int year) {\n return withMillis(getChronology().year().set(getMillis(), year));\n }\n 
245	public DateTime withWeekyear(int weekyear) {\n return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n }\n 
246	public DateTime withMonthOfYear(int monthOfYear) {\n return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n }\n 
247	public DateTime withWeekOfWeekyear(int weekOfWeekyear) {\n return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n }\n 
248	public DateTime withDayOfYear(int dayOfYear) {\n return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n }\n 
249	public DateTime withDayOfMonth(int dayOfMonth) {\n return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n }\n 
250	public DateTime withDayOfWeek(int dayOfWeek) {\n return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n }\n 
251	public DateTime withHourOfDay(int hour) {\n return withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n }\n 
252	public DateTime withMinuteOfHour(int minute) {\n return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\n }\n 
253	public DateTime withSecondOfMinute(int second) {\n return withMillis(getChronology().secondOfMinute().set(getMillis(), second));\n }\n 
254	public DateTime withMillisOfSecond(int millis) {\n return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n }\n 
255	public DateTime withMillisOfDay(int millis) {\n return withMillis(getChronology().millisOfDay().set(getMillis(), millis));\n }\n 
256	public Property era() {\n return new Property(this, getChronology().era());\n }\n 
257	public Property centuryOfEra() {\n return new Property(this, getChronology().centuryOfEra());\n }\n 
258	public Property yearOfCentury() {\n return new Property(this, getChronology().yearOfCentury());\n }\n 
259	public Property yearOfEra() {\n return new Property(this, getChronology().yearOfEra());\n }\n 
260	public Property year() {\n return new Property(this, getChronology().year());\n }\n 
261	public Property weekyear() {\n return new Property(this, getChronology().weekyear());\n }\n 
262	public Property monthOfYear() {\n return new Property(this, getChronology().monthOfYear());\n }\n 
263	public Property weekOfWeekyear() {\n return new Property(this, getChronology().weekOfWeekyear());\n }\n 
264	public Property dayOfYear() {\n return new Property(this, getChronology().dayOfYear());\n }\n 
265	public Property dayOfMonth() {\n return new Property(this, getChronology().dayOfMonth());\n }\n 
266	public Property dayOfWeek() {\n return new Property(this, getChronology().dayOfWeek());\n }\n 
267	public Property hourOfDay() {\n return new Property(this, getChronology().hourOfDay());\n }\n 
268	public Property minuteOfDay() {\n return new Property(this, getChronology().minuteOfDay());\n }\n 
269	public Property minuteOfHour() {\n return new Property(this, getChronology().minuteOfHour());\n }\n 
270	public Property secondOfDay() {\n return new Property(this, getChronology().secondOfDay());\n }\n 
271	public Property secondOfMinute() {\n return new Property(this, getChronology().secondOfMinute());\n }\n 
272	public Property millisOfDay() {\n return new Property(this, getChronology().millisOfDay());\n }\n 
273	public Property millisOfSecond() {\n return new Property(this, getChronology().millisOfSecond());\n }\n 
274	Property(DateTime instant, DateTimeField field) {\n super();\n iInstant = instant;\n iField = field;\n }\n 
275	private void writeObject(ObjectOutputStream oos) throws IOException {\n oos.writeObject(iInstant);\n oos.writeObject(iField.getType());\n }\n 
276	private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n iInstant = (DateTime) oos.readObject();\n DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n iField = type.getField(iInstant.getChronology());\n }\n 
277	public DateTimeField getField() {\n return iField;\n }\n 
278	protected long getMillis() {\n return iInstant.getMillis();\n }\n 
279	protected Chronology getChronology() {\n return iInstant.getChronology();\n }\n 
280	public DateTime getDateTime() {\n return iInstant;\n }\n 
281	public DateTime addToCopy(int value) {\n return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n }\n 
282	public DateTime addToCopy(long value) {\n return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n }\n 
283	public DateTime addWrapFieldToCopy(int value) {\n return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n }\n 
284	public DateTime setCopy(int value) {\n return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n }\n 
285	public DateTime setCopy(String text, Locale locale) {\n return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n }\n 
286	public DateTime setCopy(String text) {\n return setCopy(text, null);\n }\n 
287	public DateTime withMaximumValue() {\n try {\n return setCopy(getMaximumValue());\n } catch (RuntimeException ex) {\n if (IllegalInstantException.isIllegalInstant(ex)) {\n // adding MILLIS_PER_DAY is not perfect, but will work in almost all situations\n long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);\n return new DateTime(beforeGap, getChronology());\n }\n throw ex;\n }\n }\n 
288	public DateTime withMinimumValue() {\n try {\n return setCopy(getMinimumValue());\n } catch (RuntimeException ex) {\n if (IllegalInstantException.isIllegalInstant(ex)) {\n // subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations\n long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);\n return new DateTime(afterGap, getChronology());\n }\n throw ex;\n }\n }\n 
289	public DateTime roundFloorCopy() {\n return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n }\n 
290	public DateTime roundCeilingCopy() {\n return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n }\n 
291	public DateTime roundHalfFloorCopy() {\n return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n }\n 
292	public DateTime roundHalfCeilingCopy() {\n return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n }\n 
293	public DateTime roundHalfEvenCopy() {\n return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n }\n 
294	public static DateMidnight now() {\n return new DateMidnight();\n }\n 
295	public static DateMidnight now(DateTimeZone zone) {\n if (zone == null) {\n throw new NullPointerException("Zone must not be null");\n }\n return new DateMidnight(zone);\n }\n 
296	public static DateMidnight now(Chronology chronology) {\n if (chronology == null) {\n throw new NullPointerException("Chronology must not be null");\n }\n return new DateMidnight(chronology);\n }\n 
297	@FromString\n public static DateMidnight parse(String str) {\n return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());\n }\n 
298	public static DateMidnight parse(String str, DateTimeFormatter formatter) {\n return formatter.parseDateTime(str).toDateMidnight();\n }\n 
299	public DateMidnight() {\n super();\n }\n 
300	public DateMidnight(DateTimeZone zone) {\n super(zone);\n }\n 
301	public DateMidnight(Chronology chronology) {\n super(chronology);\n }\n 
302	public DateMidnight(long instant) {\n super(instant);\n }\n 
303	public DateMidnight(long instant, DateTimeZone zone) {\n super(instant, zone);\n }\n 
304	public DateMidnight(long instant, Chronology chronology) {\n super(instant, chronology);\n }\n 
305	public DateMidnight(Object instant) {\n super(instant, (Chronology) null);\n }\n 
306	public DateMidnight(Object instant, DateTimeZone zone) {\n super(instant, zone);\n }\n 
307	public DateMidnight(Object instant, Chronology chronology) {\n super(instant, DateTimeUtils.getChronology(chronology));\n }\n 
308	public DateMidnight(int year, int monthOfYear, int dayOfMonth) {\n super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);\n }\n 
309	public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {\n super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);\n }\n 
310	public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);\n }\n 
311	protected long checkInstant(long instant, Chronology chronology) {\n return chronology.dayOfMonth().roundFloor(instant);\n }\n 
312	public DateMidnight withMillis(long newMillis) {\n Chronology chrono = getChronology();\n newMillis = checkInstant(newMillis, chrono);\n return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n }\n 
313	public DateMidnight withChronology(Chronology newChronology) {\n return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));\n }\n 
314	public DateMidnight withZoneRetainFields(DateTimeZone newZone) {\n newZone = DateTimeUtils.getZone(newZone);\n DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n if (newZone == originalZone) {\n return this;\n }\n \n long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n return new DateMidnight(millis, getChronology().withZone(newZone));\n }\n 
315	public DateMidnight withFields(ReadablePartial partial) {\n if (partial == null) {\n return this;\n }\n return withMillis(getChronology().set(partial, getMillis()));\n }\n 
316	public DateMidnight withField(DateTimeFieldType fieldType, int value) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n return withMillis(instant);\n }\n 
317	public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n if (amount == 0) {\n return this;\n }\n long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n return withMillis(instant);\n }\n 
318	public DateMidnight withDurationAdded(long durationToAdd, int scalar) {\n if (durationToAdd == 0 || scalar == 0) {\n return this;\n }\n long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n return withMillis(instant);\n }\n 
319	public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n if (durationToAdd == null || scalar == 0) {\n return this;\n }\n return withDurationAdded(durationToAdd.getMillis(), scalar);\n }\n 
320	public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {\n if (period == null || scalar == 0) {\n return this;\n }\n long instant = getChronology().add(period, getMillis(), scalar);\n return withMillis(instant);\n }\n 
321	public DateMidnight plus(long duration) {\n return withDurationAdded(duration, 1);\n }\n 
322	public DateMidnight plus(ReadableDuration duration) {\n return withDurationAdded(duration, 1);\n }\n 
323	public DateMidnight plus(ReadablePeriod period) {\n return withPeriodAdded(period, 1);\n }\n 
324	public DateMidnight plusYears(int years) {\n if (years == 0) {\n return this;\n }\n long instant = getChronology().years().add(getMillis(), years);\n return withMillis(instant);\n }\n 
325	public DateMidnight plusMonths(int months) {\n if (months == 0) {\n return this;\n }\n long instant = getChronology().months().add(getMillis(), months);\n return withMillis(instant);\n }\n 
326	public DateMidnight plusWeeks(int weeks) {\n if (weeks == 0) {\n return this;\n }\n long instant = getChronology().weeks().add(getMillis(), weeks);\n return withMillis(instant);\n }\n 
327	public DateMidnight plusDays(int days) {\n if (days == 0) {\n return this;\n }\n long instant = getChronology().days().add(getMillis(), days);\n return withMillis(instant);\n }\n 
328	public DateMidnight minus(long duration) {\n return withDurationAdded(duration, -1);\n }\n 
329	public DateMidnight minus(ReadableDuration duration) {\n return withDurationAdded(duration, -1);\n }\n 
330	public DateMidnight minus(ReadablePeriod period) {\n return withPeriodAdded(period, -1);\n }\n 
331	public DateMidnight minusYears(int years) {\n if (years == 0) {\n return this;\n }\n long instant = getChronology().years().subtract(getMillis(), years);\n return withMillis(instant);\n }\n 
332	public DateMidnight minusMonths(int months) {\n if (months == 0) {\n return this;\n }\n long instant = getChronology().months().subtract(getMillis(), months);\n return withMillis(instant);\n }\n 
333	public DateMidnight minusWeeks(int weeks) {\n if (weeks == 0) {\n return this;\n }\n long instant = getChronology().weeks().subtract(getMillis(), weeks);\n return withMillis(instant);\n }\n 
334	public DateMidnight minusDays(int days) {\n if (days == 0) {\n return this;\n }\n long instant = getChronology().days().subtract(getMillis(), days);\n return withMillis(instant);\n }\n 
335	public Property property(DateTimeFieldType type) {\n if (type == null) {\n throw new IllegalArgumentException("The DateTimeFieldType must not be null");\n }\n DateTimeField field = type.getField(getChronology());\n if (field.isSupported() == false) {\n throw new IllegalArgumentException("Field '" + type + "' is not supported");\n }\n return new Property(this, field);\n }\n 
336	@Deprecated\n public YearMonthDay toYearMonthDay() {\n return new YearMonthDay(getMillis(), getChronology());\n }\n 
337	public LocalDate toLocalDate() {\n return new LocalDate(getMillis(), getChronology());\n }\n 
338	public Interval toInterval() {\n Chronology chrono = getChronology();\n long start = getMillis();\n long end = DurationFieldType.days().getField(chrono).add(start, 1);\n return new Interval(start, end, chrono);\n }\n 
339	public DateMidnight withEra(int era) {\n return withMillis(getChronology().era().set(getMillis(), era));\n }\n 
340	public DateMidnight withCenturyOfEra(int centuryOfEra) {\n return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n }\n 
341	public DateMidnight withYearOfEra(int yearOfEra) {\n return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n }\n 
342	public DateMidnight withYearOfCentury(int yearOfCentury) {\n return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n }\n 
343	public DateMidnight withYear(int year) {\n return withMillis(getChronology().year().set(getMillis(), year));\n }\n 
344	public DateMidnight withWeekyear(int weekyear) {\n return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n }\n 
345	public DateMidnight withMonthOfYear(int monthOfYear) {\n return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n }\n 
346	public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {\n return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n }\n 
347	public DateMidnight withDayOfYear(int dayOfYear) {\n return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n }\n 
348	public DateMidnight withDayOfMonth(int dayOfMonth) {\n return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n }\n 
349	public DateMidnight withDayOfWeek(int dayOfWeek) {\n return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n }\n 
350	public Property era() {\n return new Property(this, getChronology().era());\n }\n 
351	public Property centuryOfEra() {\n return new Property(this, getChronology().centuryOfEra());\n }\n 
352	public Property yearOfCentury() {\n return new Property(this, getChronology().yearOfCentury());\n }\n 
353	public Property yearOfEra() {\n return new Property(this, getChronology().yearOfEra());\n }\n 
354	public Property year() {\n return new Property(this, getChronology().year());\n }\n 
355	public Property weekyear() {\n return new Property(this, getChronology().weekyear());\n }\n 
356	public Property monthOfYear() {\n return new Property(this, getChronology().monthOfYear());\n }\n 
357	public Property weekOfWeekyear() {\n return new Property(this, getChronology().weekOfWeekyear());\n }\n 
358	public Property dayOfYear() {\n return new Property(this, getChronology().dayOfYear());\n }\n 
359	public Property dayOfMonth() {\n return new Property(this, getChronology().dayOfMonth());\n }\n 
360	public Property dayOfWeek() {\n return new Property(this, getChronology().dayOfWeek());\n }\n 
361	Property(DateMidnight instant, DateTimeField field) {\n super();\n iInstant = instant;\n iField = field;\n }\n 
362	private void writeObject(ObjectOutputStream oos) throws IOException {\n oos.writeObject(iInstant);\n oos.writeObject(iField.getType());\n }\n 
363	private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n iInstant = (DateMidnight) oos.readObject();\n DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n iField = type.getField(iInstant.getChronology());\n }\n 
364	public DateTimeField getField() {\n return iField;\n }\n 
365	protected long getMillis() {\n return iInstant.getMillis();\n }\n 
366	protected Chronology getChronology() {\n return iInstant.getChronology();\n }\n 
367	public DateMidnight getDateMidnight() {\n return iInstant;\n }\n 
368	public DateMidnight addToCopy(int value) {\n return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n }\n 
369	public DateMidnight addToCopy(long value) {\n return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n }\n 
370	public DateMidnight addWrapFieldToCopy(int value) {\n return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n }\n 
371	public DateMidnight setCopy(int value) {\n return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n }\n 
372	public DateMidnight setCopy(String text, Locale locale) {\n return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n }\n 
373	public DateMidnight setCopy(String text) {\n return setCopy(text, null);\n }\n 
374	public DateMidnight withMaximumValue() {\n return setCopy(getMaximumValue());\n }\n 
375	public DateMidnight withMinimumValue() {\n return setCopy(getMinimumValue());\n }\n 
376	public DateMidnight roundFloorCopy() {\n return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n }\n 
377	public DateMidnight roundCeilingCopy() {\n return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n }\n 
378	public DateMidnight roundHalfFloorCopy() {\n return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n }\n 
379	public DateMidnight roundHalfCeilingCopy() {\n return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n }\n 
380	public DateMidnight roundHalfEvenCopy() {\n return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n }\n 
381	public static BuddhistChronology getInstanceUTC() {\n return INSTANCE_UTC;\n }\n 
382	public static BuddhistChronology getInstance() {\n return getInstance(DateTimeZone.getDefault());\n }\n 
383	public static BuddhistChronology getInstance(DateTimeZone zone) {\n if (zone == null) {\n zone = DateTimeZone.getDefault();\n }\n BuddhistChronology chrono = cCache.get(zone);\n if (chrono == null) {\n // First create without a lower limit.\n chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n // Impose lower limit and make another BuddhistChronology.\n DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");\n BuddhistChronology oldChrono = cCache.putIfAbsent(zone, chrono);\n if (oldChrono != null) {\n chrono = oldChrono;\n }\n }\n return chrono;\n }\n 
384	private BuddhistChronology(Chronology base, Object param) {\n super(base, param);\n }\n 
385	private Object readResolve() {\n Chronology base = getBase();\n return base == null ? getInstanceUTC() : getInstance(base.getZone());\n }\n 
386	public Chronology withUTC() {\n return INSTANCE_UTC;\n }\n 
387	public Chronology withZone(DateTimeZone zone) {\n if (zone == null) {\n zone = DateTimeZone.getDefault();\n }\n if (zone == getZone()) {\n return this;\n }\n return getInstance(zone);\n }\n 
388	public boolean equals(Object obj) {\n if (this == obj) {\n return true;\n }\n if (obj instanceof BuddhistChronology) {\n BuddhistChronology chrono = (BuddhistChronology) obj;\n return getZone().equals(chrono.getZone());\n }\n return false;\n }\n 
389	public int hashCode() {\n return "Buddhist".hashCode() * 11 + getZone().hashCode();\n }\n 
390	public String toString() {\n String str = "BuddhistChronology";\n DateTimeZone zone = getZone();\n if (zone != null) {\n str = str + '[' + zone.getID() + ']';\n }\n return str;\n }\n 
391	protected void assemble(Fields fields) {\n if (getParam() == null) {\n // force init as used below\n fields.eras = UnsupportedDurationField.getInstance(DurationFieldType.eras());\n \n // julian chrono removed zero, but we need to put it back\n DateTimeField field = fields.year;\n fields.year = new OffsetDateTimeField(\n new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n \n // one era, so yearOfEra is the same\n field = fields.yearOfEra;\n fields.yearOfEra = new DelegatedDateTimeField(\n fields.year, fields.eras, DateTimeFieldType.yearOfEra());\n \n // julian chrono removed zero, but we need to put it back\n field = fields.weekyear;\n fields.weekyear = new OffsetDateTimeField(\n new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n \n field = new OffsetDateTimeField(fields.yearOfEra, 99);\n fields.centuryOfEra = new DividedDateTimeField(\n field, fields.eras, DateTimeFieldType.centuryOfEra(), 100);\n fields.centuries = fields.centuryOfEra.getDurationField();\n \n field = new RemainderDateTimeField(\n (DividedDateTimeField) fields.centuryOfEra);\n fields.yearOfCentury = new OffsetDateTimeField(\n field, DateTimeFieldType.yearOfCentury(), 1);\n \n field = new RemainderDateTimeField(\n fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);\n fields.weekyearOfCentury = new OffsetDateTimeField(\n field, DateTimeFieldType.weekyearOfCentury(), 1);\n \n fields.era = ERA_FIELD;\n }\n }\n 
392	protected DateTimeConstants() {\n }\n 
393	public DateTimeFormatterBuilder() {\n super();\n iElementPairs = new ArrayList<Object>();\n }\n 
394	public DateTimeFormatter toFormatter() {\n Object f = getFormatter();\n InternalPrinter printer = null;\n if (isPrinter(f)) {\n printer = (InternalPrinter) f;\n }\n InternalParser parser = null;\n if (isParser(f)) {\n parser = (InternalParser) f;\n }\n if (printer != null || parser != null) {\n return new DateTimeFormatter(printer, parser);\n }\n throw new UnsupportedOperationException("Both printing and parsing not supported");\n }\n 
395	public DateTimePrinter toPrinter() {\n Object f = getFormatter();\n if (isPrinter(f)) {\n InternalPrinter ip = (InternalPrinter) f;\n return InternalPrinterDateTimePrinter.of(ip);\n }\n throw new UnsupportedOperationException("Printing is not supported");\n }\n 
396	public DateTimeParser toParser() {\n Object f = getFormatter();\n if (isParser(f)) {\n InternalParser ip = (InternalParser) f;\n return InternalParserDateTimeParser.of(ip);\n }\n throw new UnsupportedOperationException("Parsing is not supported");\n }\n 
397	public boolean canBuildFormatter() {\n return isFormatter(getFormatter());\n }\n 
398	public boolean canBuildPrinter() {\n return isPrinter(getFormatter());\n }\n 
399	public boolean canBuildParser() {\n return isParser(getFormatter());\n }\n 
400	public void clear() {\n iFormatter = null;\n iElementPairs.clear();\n }\n 
401	public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n if (formatter == null) {\n throw new IllegalArgumentException("No formatter supplied");\n }\n return append0(formatter.getPrinter0(), formatter.getParser0());\n }\n 
402	public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n checkPrinter(printer);\n return append0(DateTimePrinterInternalPrinter.of(printer), null);\n }\n 
403	public DateTimeFormatterBuilder append(DateTimeParser parser) {\n checkParser(parser);\n return append0(null, DateTimeParserInternalParser.of(parser));\n }\n 
404	public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n checkPrinter(printer);\n checkParser(parser);\n return append0(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parser));\n }\n 
405	public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n if (printer != null) {\n checkPrinter(printer);\n }\n if (parsers == null) {\n throw new IllegalArgumentException("No parsers supplied");\n }\n int length = parsers.length;\n if (length == 1) {\n if (parsers[0] == null) {\n throw new IllegalArgumentException("No parser supplied");\n }\n return append0(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parsers[0]));\n }\n InternalParser[] copyOfParsers = new InternalParser[length];\n int i;\n for (i = 0; i < length - 1; i++) {\n if ((copyOfParsers[i] = DateTimeParserInternalParser.of(parsers[i])) == null) {\n throw new IllegalArgumentException("Incomplete parser array");\n }\n }\n copyOfParsers[i] = DateTimeParserInternalParser.of(parsers[i]);\n return append0(DateTimePrinterInternalPrinter.of(printer), new MatchingParser(copyOfParsers));\n }\n 
406	public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n checkParser(parser);\n InternalParser[] parsers = new InternalParser[] {DateTimeParserInternalParser.of(parser), null};\n return append0(null, new MatchingParser(parsers));\n }\n 
407	private void checkParser(DateTimeParser parser) {\n if (parser == null) {\n throw new IllegalArgumentException("No parser supplied");\n }\n }\n 
408	private void checkPrinter(DateTimePrinter printer) {\n if (printer == null) {\n throw new IllegalArgumentException("No printer supplied");\n }\n }\n 
409	private DateTimeFormatterBuilder append0(Object element) {\n iFormatter = null;\n // Add the element as both a printer and parser.\n iElementPairs.add(element);\n iElementPairs.add(element);\n return this;\n }\n 
410	private DateTimeFormatterBuilder append0(\n InternalPrinter printer, InternalParser parser) {\n iFormatter = null;\n iElementPairs.add(printer);\n iElementPairs.add(parser);\n return this;\n }\n 
411	public DateTimeFormatterBuilder appendLiteral(char c) {\n return append0(new CharacterLiteral(c));\n }\n 
412	public DateTimeFormatterBuilder appendLiteral(String text) {\n if (text == null) {\n throw new IllegalArgumentException("Literal must not be null");\n }\n switch (text.length()) {\n case 0:\n return this;\n case 1:\n return append0(new CharacterLiteral(text.charAt(0)));\n default:\n return append0(new StringLiteral(text));\n }\n }\n 
413	public DateTimeFormatterBuilder appendDecimal(\n DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n if (maxDigits < minDigits) {\n maxDigits = minDigits;\n }\n if (minDigits < 0 || maxDigits <= 0) {\n throw new IllegalArgumentException();\n }\n if (minDigits <= 1) {\n return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n } else {\n return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n }\n }\n 
414	public DateTimeFormatterBuilder appendFixedDecimal(\n DateTimeFieldType fieldType, int numDigits) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n if (numDigits <= 0) {\n throw new IllegalArgumentException("Illegal number of digits: " + numDigits);\n }\n return append0(new FixedNumber(fieldType, numDigits, false));\n }\n 
415	public DateTimeFormatterBuilder appendSignedDecimal(\n DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n if (maxDigits < minDigits) {\n maxDigits = minDigits;\n }\n if (minDigits < 0 || maxDigits <= 0) {\n throw new IllegalArgumentException();\n }\n if (minDigits <= 1) {\n return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n } else {\n return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n }\n }\n 
416	public DateTimeFormatterBuilder appendFixedSignedDecimal(\n DateTimeFieldType fieldType, int numDigits) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n if (numDigits <= 0) {\n throw new IllegalArgumentException("Illegal number of digits: " + numDigits);\n }\n return append0(new FixedNumber(fieldType, numDigits, true));\n }\n 
417	public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n return append0(new TextField(fieldType, false));\n }\n 
418	public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n return append0(new TextField(fieldType, true));\n }\n 
419	public DateTimeFormatterBuilder appendFraction(\n DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n if (fieldType == null) {\n throw new IllegalArgumentException("Field type must not be null");\n }\n if (maxDigits < minDigits) {\n maxDigits = minDigits;\n }\n if (minDigits < 0 || maxDigits <= 0) {\n throw new IllegalArgumentException();\n }\n return append0(new Fraction(fieldType, minDigits, maxDigits));\n }\n 
420	public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n }\n 
421	public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n }\n 
422	public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n }\n 
423	public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n }\n 
424	public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n }\n 
425	public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n }\n 
426	public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n }\n 
427	public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n }\n 
428	public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n }\n 
429	public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n }\n 
430	public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n }\n 
431	public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n }\n 
432	public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n }\n 
433	public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n }\n 
434	public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n }\n 
435	public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n }\n 
436	public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n }\n 
437	public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n }\n 
438	public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n }\n 
439	public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n }\n 
440	public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n }\n 
441	public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n return appendTwoDigitYear(pivot, false);\n }\n 
442	public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n }\n 
443	public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n return appendTwoDigitWeekyear(pivot, false);\n }\n 
444	public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n }\n 
445	public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n }\n 
446	public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n }\n 
447	public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n }\n 
448	public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n return appendText(DateTimeFieldType.halfdayOfDay());\n }\n 
449	public DateTimeFormatterBuilder appendDayOfWeekText() {\n return appendText(DateTimeFieldType.dayOfWeek());\n }\n 
450	public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n return appendShortText(DateTimeFieldType.dayOfWeek());\n }\n 
451	public DateTimeFormatterBuilder appendMonthOfYearText() {\n return appendText(DateTimeFieldType.monthOfYear());\n }\n 
452	public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n return appendShortText(DateTimeFieldType.monthOfYear());\n }\n 
453	public DateTimeFormatterBuilder appendEraText() {\n return appendText(DateTimeFieldType.era());\n }\n 
454	public DateTimeFormatterBuilder appendTimeZoneName() {\n return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n }\n 
455	public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n return append0(pp, pp);\n }\n 
456	public DateTimeFormatterBuilder appendTimeZoneShortName() {\n return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n }\n 
457	public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n return append0(pp, pp);\n }\n 
458	public DateTimeFormatterBuilder appendTimeZoneId() {\n return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n }\n 
459	public DateTimeFormatterBuilder appendTimeZoneOffset(\n String zeroOffsetText, boolean showSeparators,\n int minFields, int maxFields) {\n return append0(new TimeZoneOffset\n (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n }\n 
460	public DateTimeFormatterBuilder appendTimeZoneOffset(\n String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n int minFields, int maxFields) {\n return append0(new TimeZoneOffset\n (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n }\n 
461	public DateTimeFormatterBuilder appendPattern(String pattern) {\n DateTimeFormat.appendPatternTo(this, pattern);\n return this;\n }\n 
462	private Object getFormatter() {\n Object f = iFormatter;\n if (f == null) {\n if (iElementPairs.size() == 2) {\n Object printer = iElementPairs.get(0);\n Object parser = iElementPairs.get(1);\n if (printer != null) {\n if (printer == parser || parser == null) {\n f = printer;\n }\n } else {\n f = parser;\n }\n }\n if (f == null) {\n f = new Composite(iElementPairs);\n }\n iFormatter = f;\n }\n return f;\n }\n 
463	private boolean isPrinter(Object f) {\n if (f instanceof InternalPrinter) {\n if (f instanceof Composite) {\n return ((Composite)f).isPrinter();\n }\n return true;\n }\n return false;\n }\n 
464	private boolean isParser(Object f) {\n if (f instanceof InternalParser) {\n if (f instanceof Composite) {\n return ((Composite)f).isParser();\n }\n return true;\n }\n return false;\n }\n 
465	private boolean isFormatter(Object f) {\n return (isPrinter(f) || isParser(f));\n }\n 
466	static void appendUnknownString(Appendable appendable, int len) throws IOException {\n for (int i = len; --i >= 0;) {\n appendable.append('\ufffd');\n }\n }\n 
467	CharacterLiteral(char value) {\n super();\n iValue = value;\n }\n 
468	public int estimatePrintedLength() {\n return 1;\n }\n 
469	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n appendable.append(iValue);\n }\n 
470	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n appendable.append(iValue);\n }\n 
471	public int estimateParsedLength() {\n return 1;\n }\n 
472	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n if (position >= text.length()) {\n return ~position;\n }\n char a = text.charAt(position);\n char b = iValue;\n if (a != b) {\n a = Character.toUpperCase(a);\n b = Character.toUpperCase(b);\n if (a != b) {\n a = Character.toLowerCase(a);\n b = Character.toLowerCase(b);\n if (a != b) {\n return ~position;\n }\n }\n }\n return position + 1;\n }\n 
473	StringLiteral(String value) {\n super();\n iValue = value;\n }\n 
474	public int estimatePrintedLength() {\n return iValue.length();\n }\n 
475	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n appendable.append(iValue);\n }\n 
476	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n appendable.append(iValue);\n }\n 
477	public int estimateParsedLength() {\n return iValue.length();\n }\n 
478	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n if (csStartsWithIgnoreCase(text, position, iValue)) {\n return position + iValue.length();\n }\n return ~position;\n }\n 
479	NumberFormatter(DateTimeFieldType fieldType,\n int maxParsedDigits, boolean signed) {\n super();\n iFieldType = fieldType;\n iMaxParsedDigits = maxParsedDigits;\n iSigned = signed;\n }\n 
480	public int estimateParsedLength() {\n return iMaxParsedDigits;\n }\n 
481	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n int limit = Math.min(iMaxParsedDigits, text.length() - position);\n boolean negative = false;\n int length = 0;\n while (length < limit) {\n char c = text.charAt(position + length);\n if (length == 0 && (c == '-' || c == '+') && iSigned) {\n negative = c == '-';\n // Next character must be a digit.\n if (length + 1 >= limit ||\n (c = text.charAt(position + length + 1)) < '0' || c > '9')\n {\n break;\n }\n if (negative) {\n length++;\n } else {\n // Skip the '+' for parseInt to succeed.\n position++;\n }\n // Expand the limit to disregard the sign character.\n limit = Math.min(limit + 1, text.length() - position);\n continue;\n }\n if (c < '0' || c > '9') {\n break;\n }\n length++;\n }\n if (length == 0) {\n return ~position;\n }\n int value;\n if (length >= 9) {\n // Since value may exceed integer limits, use stock parser\n // which checks for this.\n value = Integer.parseInt(text.subSequence(position, position += length).toString());\n } else {\n int i = position;\n if (negative) {\n i++;\n }\n try {\n value = text.charAt(i++) - '0';\n } catch (StringIndexOutOfBoundsException e) {\n return ~position;\n }\n position += length;\n while (i < position) {\n value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n }\n if (negative) {\n value = -value;\n }\n }\n bucket.saveField(iFieldType, value);\n return position;\n }\n 
482	protected UnpaddedNumber(DateTimeFieldType fieldType,\n int maxParsedDigits, boolean signed)\n {\n super(fieldType, maxParsedDigits, signed);\n }\n 
483	public int estimatePrintedLength() {\n return iMaxParsedDigits;\n }\n 
484	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n try {\n DateTimeField field = iFieldType.getField(chrono);\n FormatUtils.appendUnpaddedInteger(appendable, field.get(instant));\n } catch (RuntimeException e) {\n appendable.append('\ufffd');\n }\n }\n 
485	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n if (partial.isSupported(iFieldType)) {\n try {\n FormatUtils.appendUnpaddedInteger(appendable, partial.get(iFieldType));\n } catch (RuntimeException e) {\n appendable.append('\ufffd');\n }\n } else {\n appendable.append('\ufffd');\n }\n }\n 
486	protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n boolean signed, int minPrintedDigits)\n {\n super(fieldType, maxParsedDigits, signed);\n iMinPrintedDigits = minPrintedDigits;\n }\n 
487	public int estimatePrintedLength() {\n return iMaxParsedDigits;\n }\n 
488	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n try {\n DateTimeField field = iFieldType.getField(chrono);\n FormatUtils.appendPaddedInteger(appendable, field.get(instant), iMinPrintedDigits);\n } catch (RuntimeException e) {\n appendUnknownString(appendable, iMinPrintedDigits);\n }\n }\n 
489	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n if (partial.isSupported(iFieldType)) {\n try {\n FormatUtils.appendPaddedInteger(appendable, partial.get(iFieldType), iMinPrintedDigits);\n } catch (RuntimeException e) {\n appendUnknownString(appendable, iMinPrintedDigits);\n }\n } else {\n appendUnknownString(appendable, iMinPrintedDigits);\n }\n }\n 
490	protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n super(fieldType, numDigits, signed, numDigits);\n }\n 
491	@Override\n public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n int newPos = super.parseInto(bucket, text, position);\n if (newPos < 0) {\n return newPos;\n }\n int expectedPos = position + iMaxParsedDigits;\n if (newPos != expectedPos) {\n if (iSigned) {\n char c = text.charAt(position);\n if (c == '-' || c == '+') {\n expectedPos++;\n }\n }\n if (newPos > expectedPos) {\n // The failure is at the position of the first extra digit.\n return ~(expectedPos + 1);\n } else if (newPos < expectedPos) {\n // The failure is at the position where the next digit should be.\n return ~newPos;\n }\n }\n return newPos;\n }\n 
492	TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n super();\n iType = type;\n iPivot = pivot;\n iLenientParse = lenientParse;\n }\n 
493	public int estimateParsedLength() {\n return iLenientParse ? 4 : 2;\n }\n 
494	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n int limit = text.length() - position;\n if (!iLenientParse) {\n limit = Math.min(2, limit);\n if (limit < 2) {\n return ~position;\n }\n } else {\n boolean hasSignChar = false;\n boolean negative = false;\n int length = 0;\n while (length < limit) {\n char c = text.charAt(position + length);\n if (length == 0 && (c == '-' || c == '+')) {\n hasSignChar = true;\n negative = c == '-';\n if (negative) {\n length++;\n } else {\n // Skip the '+' for parseInt to succeed.\n position++;\n limit--;\n }\n continue;\n }\n if (c < '0' || c > '9') {\n break;\n }\n length++;\n }\n \n if (length == 0) {\n return ~position;\n }\n if (hasSignChar || length != 2) {\n int value;\n if (length >= 9) {\n // Since value may exceed integer limits, use stock\n // parser which checks for this.\n value = Integer.parseInt(text.subSequence(position, position += length).toString());\n } else {\n int i = position;\n if (negative) {\n i++;\n }\n try {\n value = text.charAt(i++) - '0';\n } catch (StringIndexOutOfBoundsException e) {\n return ~position;\n }\n position += length;\n while (i < position) {\n value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n }\n if (negative) {\n value = -value;\n }\n }\n \n bucket.saveField(iType, value);\n return position;\n }\n }\n int year;\n char c = text.charAt(position);\n if (c < '0' || c > '9') {\n return ~position;\n }\n year = c - '0';\n c = text.charAt(position + 1);\n if (c < '0' || c > '9') {\n return ~position;\n }\n year = ((year << 3) + (year << 1)) + c - '0';\n int pivot = iPivot;\n // If the bucket pivot year is non-null, use that when parsing\n if (bucket.getPivotYear() != null) {\n pivot = bucket.getPivotYear().intValue();\n }\n int low = pivot - 50;\n int t;\n if (low >= 0) {\n t = low % 100;\n } else {\n t = 99 + ((low + 1) % 100);\n }\n year += low + ((year < t) ? 100 : 0) - t;\n bucket.saveField(iType, year);\n return position + 2;\n }\n 
495	public int estimatePrintedLength() {\n return 2;\n }\n 
496	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n int year = getTwoDigitYear(instant, chrono);\n if (year < 0) {\n appendable.append('\ufffd');\n appendable.append('\ufffd');\n } else {\n FormatUtils.appendPaddedInteger(appendable, year, 2);\n }\n }\n 
497	private int getTwoDigitYear(long instant, Chronology chrono) {\n try {\n int year = iType.getField(chrono).get(instant);\n if (year < 0) {\n year = -year;\n }\n return year % 100;\n } catch (RuntimeException e) {\n return -1;\n }\n }\n 
498	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n int year = getTwoDigitYear(partial);\n if (year < 0) {\n appendable.append('\ufffd');\n appendable.append('\ufffd');\n } else {\n FormatUtils.appendPaddedInteger(appendable, year, 2);\n }\n }\n 
499	private int getTwoDigitYear(ReadablePartial partial) {\n if (partial.isSupported(iType)) {\n try {\n int year = partial.get(iType);\n if (year < 0) {\n year = -year;\n }\n return year % 100;\n } catch (RuntimeException e) {}\n }\n return -1;\n }\n 
500	TextField(DateTimeFieldType fieldType, boolean isShort) {\n super();\n iFieldType = fieldType;\n iShort = isShort;\n }\n 
501	public int estimatePrintedLength() {\n return iShort ? 6 : 20;\n }\n 
502	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n try {\n appendable.append(print(instant, chrono, locale));\n } catch (RuntimeException e) {\n appendable.append('\ufffd');\n }\n }\n 
503	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n try {\n appendable.append(print(partial, locale));\n } catch (RuntimeException e) {\n appendable.append('\ufffd');\n }\n }\n 
504	private String print(long instant, Chronology chrono, Locale locale) {\n DateTimeField field = iFieldType.getField(chrono);\n if (iShort) {\n return field.getAsShortText(instant, locale);\n } else {\n return field.getAsText(instant, locale);\n }\n }\n 
505	private String print(ReadablePartial partial, Locale locale) {\n if (partial.isSupported(iFieldType)) {\n DateTimeField field = iFieldType.getField(partial.getChronology());\n if (iShort) {\n return field.getAsShortText(partial, locale);\n } else {\n return field.getAsText(partial, locale);\n }\n } else {\n return "\ufffd";\n }\n }\n 
506	public int estimateParsedLength() {\n return estimatePrintedLength();\n }\n 
507	@SuppressWarnings("unchecked")\n public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n Locale locale = bucket.getLocale();\n // handle languages which might have non ASCII A-Z or punctuation\n // bug 1788282\n Map<String, Boolean> validValues = null;\n int maxLength = 0;\n Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n if (innerMap == null) {\n innerMap = new ConcurrentHashMap<DateTimeFieldType, Object[]>();\n cParseCache.put(locale, innerMap);\n }\n Object[] array = innerMap.get(iFieldType);\n if (array == null) {\n validValues = new ConcurrentHashMap<String, Boolean>(32);  // use map as no concurrent Set\n MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n Property property = dt.property(iFieldType);\n int min = property.getMinimumValueOverall();\n int max = property.getMaximumValueOverall();\n if (max - min > 32) {  // protect against invalid fields\n return ~position;\n }\n maxLength = property.getMaximumTextLength(locale);\n for (int i = min; i <= max; i++) {\n property.set(i);\n validValues.put(property.getAsShortText(locale), Boolean.TRUE);\n validValues.put(property.getAsShortText(locale).toLowerCase(locale), Boolean.TRUE);\n validValues.put(property.getAsShortText(locale).toUpperCase(locale), Boolean.TRUE);\n validValues.put(property.getAsText(locale), Boolean.TRUE);\n validValues.put(property.getAsText(locale).toLowerCase(locale), Boolean.TRUE);\n validValues.put(property.getAsText(locale).toUpperCase(locale), Boolean.TRUE);\n }\n if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n // hack to support for parsing "BCE" and "CE" if the language is English\n validValues.put("BCE", Boolean.TRUE);\n validValues.put("bce", Boolean.TRUE);\n validValues.put("CE", Boolean.TRUE);\n validValues.put("ce", Boolean.TRUE);\n maxLength = 3;\n }\n array = new Object[] {validValues, Integer.valueOf(maxLength)};\n innerMap.put(iFieldType, array);\n } else {\n validValues = (Map<String, Boolean>) array[0];\n maxLength = ((Integer) array[1]).intValue();\n }\n // match the longest string first using our knowledge of the max length\n int limit = Math.min(text.length(), position + maxLength);\n for (int i = limit; i > position; i--) {\n String match = text.subSequence(position, i).toString();\n if (validValues.containsKey(match)) {\n bucket.saveField(iFieldType, match, locale);\n return i;\n }\n }\n return ~position;\n }\n 
508	protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n super();\n iFieldType = fieldType;\n // Limit the precision requirements.\n if (maxDigits > 18) {\n maxDigits = 18;\n }\n iMinDigits = minDigits;\n iMaxDigits = maxDigits;\n }\n 
509	public int estimatePrintedLength() {\n return iMaxDigits;\n }\n 
510	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n printTo(appendable, instant, chrono);\n }\n 
511	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n // removed check whether field is supported, as input field is typically\n // secondOfDay which is unsupported by TimeOfDay\n long millis = partial.getChronology().set(partial, 0L);\n printTo(appendable, millis, partial.getChronology());\n }\n 
512	protected void printTo(Appendable appendable, long instant, Chronology chrono)\n throws IOException\n {\n DateTimeField field = iFieldType.getField(chrono);\n int minDigits = iMinDigits;\n long fraction;\n try {\n fraction = field.remainder(instant);\n } catch (RuntimeException e) {\n appendUnknownString(appendable, minDigits);\n return;\n }\n if (fraction == 0) {\n while (--minDigits >= 0) {\n appendable.append('0');\n }\n return;\n }\n String str;\n long[] fractionData = getFractionData(fraction, field);\n long scaled = fractionData[0];\n int maxDigits = (int) fractionData[1];\n \n if ((scaled & 0x7fffffff) == scaled) {\n str = Integer.toString((int) scaled);\n } else {\n str = Long.toString(scaled);\n }\n int length = str.length();\n int digits = maxDigits;\n while (length < digits) {\n appendable.append('0');\n minDigits--;\n digits--;\n }\n if (minDigits < digits) {\n // Chop off as many trailing zero digits as necessary.\n while (minDigits < digits) {\n if (length <= 1 || str.charAt(length - 1) != '0') {\n break;\n }\n digits--;\n length--;\n }\n if (length < str.length()) {\n for (int i=0; i<length; i++) {\n appendable.append(str.charAt(i));\n }\n return;\n }\n }\n appendable.append(str);\n }\n 
513	private long[] getFractionData(long fraction, DateTimeField field) {\n long rangeMillis = field.getDurationField().getUnitMillis();\n long scalar;\n int maxDigits = iMaxDigits;\n while (true) {\n switch (maxDigits) {\n default: scalar = 1L; break;\n case 1:  scalar = 10L; break;\n case 2:  scalar = 100L; break;\n case 3:  scalar = 1000L; break;\n case 4:  scalar = 10000L; break;\n case 5:  scalar = 100000L; break;\n case 6:  scalar = 1000000L; break;\n case 7:  scalar = 10000000L; break;\n case 8:  scalar = 100000000L; break;\n case 9:  scalar = 1000000000L; break;\n case 10: scalar = 10000000000L; break;\n case 11: scalar = 100000000000L; break;\n case 12: scalar = 1000000000000L; break;\n case 13: scalar = 10000000000000L; break;\n case 14: scalar = 100000000000000L; break;\n case 15: scalar = 1000000000000000L; break;\n case 16: scalar = 10000000000000000L; break;\n case 17: scalar = 100000000000000000L; break;\n case 18: scalar = 1000000000000000000L; break;\n }\n if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n break;\n }\n // Overflowed: scale down.\n maxDigits--;\n }\n \n return new long[] {fraction * scalar / rangeMillis, maxDigits};\n }\n 
514	public int estimateParsedLength() {\n return iMaxDigits;\n }\n 
515	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n DateTimeField field = iFieldType.getField(bucket.getChronology());\n \n int limit = Math.min(iMaxDigits, text.length() - position);\n long value = 0;\n long n = field.getDurationField().getUnitMillis() * 10;\n int length = 0;\n while (length < limit) {\n char c = text.charAt(position + length);\n if (c < '0' || c > '9') {\n break;\n }\n length++;\n long nn = n / 10;\n value += (c - '0') * nn;\n n = nn;\n }\n value /= 10;\n if (length == 0) {\n return ~position;\n }\n if (value > Integer.MAX_VALUE) {\n return ~position;\n }\n DateTimeField parseField = new PreciseDateTimeField(\n DateTimeFieldType.millisOfSecond(),\n MillisDurationField.INSTANCE,\n field.getDurationField());\n bucket.saveField(parseField, (int) value);\n return position + length;\n }\n 
516	TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n boolean showSeparators,\n int minFields, int maxFields)\n {\n super();\n iZeroOffsetPrintText = zeroOffsetPrintText;\n iZeroOffsetParseText = zeroOffsetParseText;\n iShowSeparators = showSeparators;\n if (minFields <= 0 || maxFields < minFields) {\n throw new IllegalArgumentException();\n }\n if (minFields > 4) {\n minFields = 4;\n maxFields = 4;\n }\n iMinFields = minFields;\n iMaxFields = maxFields;\n }\n 
517	public int estimatePrintedLength() {\n int est = 1 + iMinFields << 1;\n if (iShowSeparators) {\n est += iMinFields - 1;\n }\n if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n est = iZeroOffsetPrintText.length();\n }\n return est;\n }\n 
518	public void printTo(\n Appendable buf, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n if (displayZone == null) {\n return;  // no zone\n }\n if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n buf.append(iZeroOffsetPrintText);\n return;\n }\n if (displayOffset >= 0) {\n buf.append('+');\n } else {\n buf.append('-');\n displayOffset = -displayOffset;\n }\n int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n FormatUtils.appendPaddedInteger(buf, hours, 2);\n if (iMaxFields == 1) {\n return;\n }\n displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n if (displayOffset == 0 && iMinFields <= 1) {\n return;\n }\n int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n if (iShowSeparators) {\n buf.append(':');\n }\n FormatUtils.appendPaddedInteger(buf, minutes, 2);\n if (iMaxFields == 2) {\n return;\n }\n displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n if (displayOffset == 0 && iMinFields <= 2) {\n return;\n }\n int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n if (iShowSeparators) {\n buf.append(':');\n }\n FormatUtils.appendPaddedInteger(buf, seconds, 2);\n if (iMaxFields == 3) {\n return;\n }\n displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n if (displayOffset == 0 && iMinFields <= 3) {\n return;\n }\n if (iShowSeparators) {\n buf.append('.');\n }\n FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n }\n 
519	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n // no zone info\n }\n 
520	public int estimateParsedLength() {\n return estimatePrintedLength();\n }\n 
521	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n int limit = text.length() - position;\n zeroOffset:\n if (iZeroOffsetParseText != null) {\n if (iZeroOffsetParseText.length() == 0) {\n // Peek ahead, looking for sign character.\n if (limit > 0) {\n char c = text.charAt(position);\n if (c == '-' || c == '+') {\n break zeroOffset;\n }\n }\n bucket.setOffset(Integer.valueOf(0));\n return position;\n }\n if (csStartsWithIgnoreCase(text, position, iZeroOffsetParseText)) {\n bucket.setOffset(Integer.valueOf(0));\n return position + iZeroOffsetParseText.length();\n }\n }\n // Format to expect is sign character followed by at least one digit.\n if (limit <= 1) {\n return ~position;\n }\n boolean negative;\n char c = text.charAt(position);\n if (c == '-') {\n negative = true;\n } else if (c == '+') {\n negative = false;\n } else {\n return ~position;\n }\n limit--;\n position++;\n // Format following sign is one of:\n //\n // hh\n // hhmm\n // hhmmss\n // hhmmssSSS\n // hh:mm\n // hh:mm:ss\n // hh:mm:ss.SSS\n // First parse hours.\n if (digitCount(text, position, 2) < 2) {\n // Need two digits for hour.\n return ~position;\n }\n int offset;\n int hours = FormatUtils.parseTwoDigits(text, position);\n if (hours > 23) {\n return ~position;\n }\n offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n limit -= 2;\n position += 2;\n parse: {\n // Need to decide now if separators are expected or parsing\n // stops at hour field.\n if (limit <= 0) {\n break parse;\n }\n boolean expectSeparators;\n c = text.charAt(position);\n if (c == ':') {\n expectSeparators = true;\n limit--;\n position++;\n } else if (c >= '0' && c <= '9') {\n expectSeparators = false;\n } else {\n break parse;\n }\n // Proceed to parse minutes.\n int count = digitCount(text, position, 2);\n if (count == 0 && !expectSeparators) {\n break parse;\n } else if (count < 2) {\n // Need two digits for minute.\n return ~position;\n }\n int minutes = FormatUtils.parseTwoDigits(text, position);\n if (minutes > 59) {\n return ~position;\n }\n offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n limit -= 2;\n position += 2;\n // Proceed to parse seconds.\n if (limit <= 0) {\n break parse;\n }\n if (expectSeparators) {\n if (text.charAt(position) != ':') {\n break parse;\n }\n limit--;\n position++;\n }\n count = digitCount(text, position, 2);\n if (count == 0 && !expectSeparators) {\n break parse;\n } else if (count < 2) {\n // Need two digits for second.\n return ~position;\n }\n int seconds = FormatUtils.parseTwoDigits(text, position);\n if (seconds > 59) {\n return ~position;\n }\n offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n limit -= 2;\n position += 2;\n // Proceed to parse fraction of second.\n if (limit <= 0) {\n break parse;\n }\n if (expectSeparators) {\n if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n break parse;\n }\n limit--;\n position++;\n }\n \n count = digitCount(text, position, 3);\n if (count == 0 && !expectSeparators) {\n break parse;\n } else if (count < 1) {\n // Need at least one digit for fraction of second.\n return ~position;\n }\n offset += (text.charAt(position++) - '0') * 100;\n if (count > 1) {\n offset += (text.charAt(position++) - '0') * 10;\n if (count > 2) {\n offset += text.charAt(position++) - '0';\n }\n }\n }\n bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n return position;\n }\n 
522	private int digitCount(CharSequence text, int position, int amount) {\n int limit = Math.min(text.length() - position, amount);\n amount = 0;\n for (; limit > 0; limit--) {\n char c = text.charAt(position + amount);\n if (c < '0' || c > '9') {\n break;\n }\n amount++;\n }\n return amount;\n }\n 
523	TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n super();\n iType = type;\n iParseLookup = parseLookup;\n }\n 
524	public int estimatePrintedLength() {\n return (iType == SHORT_NAME ? 4 : 20);\n }\n 
525	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n appendable.append(print(instant - displayOffset, displayZone, locale));\n }\n 
526	private String print(long instant, DateTimeZone displayZone, Locale locale) {\n if (displayZone == null) {\n return "";  // no zone\n }\n switch (iType) {\n case LONG_NAME:\n return displayZone.getName(instant, locale);\n case SHORT_NAME:\n return displayZone.getShortName(instant, locale);\n }\n return "";\n }\n 
527	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n // no zone info\n }\n 
528	public int estimateParsedLength() {\n return (iType == SHORT_NAME ? 4 : 20);\n }\n 
529	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n Map<String, DateTimeZone> parseLookup = iParseLookup;\n parseLookup = (parseLookup != null ? parseLookup : DateTimeUtils.getDefaultTimeZoneNames());\n String matched = null;\n for (String name : parseLookup.keySet()) {\n if (csStartsWith(text, position, name)) {\n if (matched == null || name.length() > matched.length()) {\n matched = name;\n }\n }\n }\n if (matched != null) {\n bucket.setZone(parseLookup.get(matched));\n return position + matched.length();\n }\n return ~position;\n }\n 
530	public int estimatePrintedLength() {\n return MAX_LENGTH;\n }\n 
531	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n appendable.append(displayZone != null ? displayZone.getID() : "");\n }\n 
532	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n // no zone info\n }\n 
533	public int estimateParsedLength() {\n return MAX_LENGTH;\n }\n 
534	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n String best = null;\n for (String id : ALL_IDS) {\n if (csStartsWith(text, position, id)) {\n if (best == null || id.length() > best.length()) {\n best = id;\n }\n }\n }\n if (best != null) {\n bucket.setZone(DateTimeZone.forID(best));\n return position + best.length();\n }\n return ~position;\n }\n 
535	Composite(List<Object> elementPairs) {\n super();\n List<Object> printerList = new ArrayList<Object>();\n List<Object> parserList = new ArrayList<Object>();\n decompose(elementPairs, printerList, parserList);\n if (printerList.contains(null) || printerList.isEmpty()) {\n iPrinters = null;\n iPrintedLengthEstimate = 0;\n } else {\n int size = printerList.size();\n iPrinters = new InternalPrinter[size];\n int printEst = 0;\n for (int i=0; i<size; i++) {\n InternalPrinter printer = (InternalPrinter) printerList.get(i);\n printEst += printer.estimatePrintedLength();\n iPrinters[i] = printer;\n }\n iPrintedLengthEstimate = printEst;\n }\n if (parserList.contains(null) || parserList.isEmpty()) {\n iParsers = null;\n iParsedLengthEstimate = 0;\n } else {\n int size = parserList.size();\n iParsers = new InternalParser[size];\n int parseEst = 0;\n for (int i=0; i<size; i++) {\n InternalParser parser = (InternalParser) parserList.get(i);\n parseEst += parser.estimateParsedLength();\n iParsers[i] = parser;\n }\n iParsedLengthEstimate = parseEst;\n }\n }\n 
536	public int estimatePrintedLength() {\n return iPrintedLengthEstimate;\n }\n 
537	public void printTo(\n Appendable appendable, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n InternalPrinter[] elements = iPrinters;\n if (elements == null) {\n throw new UnsupportedOperationException();\n }\n if (locale == null) {\n // Guard against default locale changing concurrently.\n locale = Locale.getDefault();\n }\n int len = elements.length;\n for (int i = 0; i < len; i++) {\n elements[i].printTo(appendable, instant, chrono, displayOffset, displayZone, locale);\n }\n }\n 
538	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n InternalPrinter[] elements = iPrinters;\n if (elements == null) {\n throw new UnsupportedOperationException();\n }\n if (locale == null) {\n // Guard against default locale changing concurrently.\n locale = Locale.getDefault();\n }\n int len = elements.length;\n for (int i=0; i<len; i++) {\n elements[i].printTo(appendable, partial, locale);\n }\n }\n 
539	public int estimateParsedLength() {\n return iParsedLengthEstimate;\n }\n 
540	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n InternalParser[] elements = iParsers;\n if (elements == null) {\n throw new UnsupportedOperationException();\n }\n int len = elements.length;\n for (int i=0; i<len && position >= 0; i++) {\n position = elements[i].parseInto(bucket, text, position);\n }\n return position;\n }\n 
541	boolean isPrinter() {\n return iPrinters != null;\n }\n 
542	boolean isParser() {\n return iParsers != null;\n }\n 
543	private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n int size = elementPairs.size();\n for (int i=0; i<size; i+=2) {\n Object element = elementPairs.get(i);\n if (element instanceof Composite) {\n addArrayToList(printerList, ((Composite)element).iPrinters);\n } else {\n printerList.add(element);\n }\n element = elementPairs.get(i + 1);\n if (element instanceof Composite) {\n addArrayToList(parserList, ((Composite)element).iParsers);\n } else {\n parserList.add(element);\n }\n }\n }\n 
544	private void addArrayToList(List<Object> list, Object[] array) {\n if (array != null) {\n for (int i=0; i<array.length; i++) {\n list.add(array[i]);\n }\n }\n }\n 
545	MatchingParser(InternalParser[] parsers) {\n super();\n iParsers = parsers;\n int est = 0;\n for (int i=parsers.length; --i>=0 ;) {\n InternalParser parser = parsers[i];\n if (parser != null) {\n int len = parser.estimateParsedLength();\n if (len > est) {\n est = len;\n }\n }\n }\n iParsedLengthEstimate = est;\n }\n 
546	public int estimateParsedLength() {\n return iParsedLengthEstimate;\n }\n 
547	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n InternalParser[] parsers = iParsers;\n int length = parsers.length;\n final Object originalState = bucket.saveState();\n boolean isOptional = false;\n int bestValidPos = position;\n Object bestValidState = null;\n int bestInvalidPos = position;\n for (int i=0; i<length; i++) {\n InternalParser parser = parsers[i];\n if (parser == null) {\n // The empty parser wins only if nothing is better.\n if (bestValidPos <= position) {\n return position;\n }\n isOptional = true;\n break;\n }\n int parsePos = parser.parseInto(bucket, text, position);\n if (parsePos >= position) {\n if (parsePos > bestValidPos) {\n if (parsePos >= text.length() ||\n (i + 1) >= length || parsers[i + 1] == null) {\n // Completely parsed text or no more parsers to\n // check. Skip the rest.\n return parsePos;\n }\n bestValidPos = parsePos;\n bestValidState = bucket.saveState();\n }\n } else {\n if (parsePos < 0) {\n parsePos = ~parsePos;\n if (parsePos > bestInvalidPos) {\n bestInvalidPos = parsePos;\n }\n }\n }\n bucket.restoreState(originalState);\n }\n if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n // Restore the state to the best valid parse.\n if (bestValidState != null) {\n bucket.restoreState(bestValidState);\n }\n return bestValidPos;\n }\n return ~bestInvalidPos;\n }\n 
548	static boolean csStartsWith(CharSequence text, int position, String search) {\n int searchLen = search.length();\n if ((text.length() - position) < searchLen) {\n return false;\n }\n for (int i = 0; i < searchLen; i++) {\n if (text.charAt(position + i) != search.charAt(i)) {\n return false;\n }\n }\n return true;\n }\n 
549	static boolean csStartsWithIgnoreCase(CharSequence text, int position, String search) {\n int searchLen = search.length();\n if ((text.length() - position) < searchLen) {\n return false;\n }\n for (int i = 0; i < searchLen; i++) {\n char ch1 = text.charAt(position + i);\n char ch2 = search.charAt(i);\n if (ch1 != ch2) {\n char u1 = Character.toUpperCase(ch1);\n char u2 = Character.toUpperCase(ch2);\n if (u1 != u2 && Character.toLowerCase(u1) != Character.toLowerCase(u2)) {\n return false;\n }\n }\n }\n return true;\n }\n 
550	public static Instant now() {\n return new Instant();\n }\n 
551	@FromString\n public static Instant parse(String str) {\n return parse(str, ISODateTimeFormat.dateTimeParser());\n }\n 
552	public static Instant parse(String str, DateTimeFormatter formatter) {\n return formatter.parseDateTime(str).toInstant();\n }\n 
553	public Instant() {\n super();\n iMillis = DateTimeUtils.currentTimeMillis();\n }\n 
554	public Instant(long instant) {\n super();\n iMillis = instant;\n }\n 
555	public Instant(Object instant) {\n super();\n InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());\n }\n 
556	public Instant toInstant() {\n return this;\n }\n 
557	public Instant withMillis(long newMillis) {\n return (newMillis == iMillis ? this : new Instant(newMillis));\n }\n 
558	public Instant withDurationAdded(long durationToAdd, int scalar) {\n if (durationToAdd == 0 || scalar == 0) {\n return this;\n }\n long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n return withMillis(instant);\n }\n 
559	public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n if (durationToAdd == null || scalar == 0) {\n return this;\n }\n return withDurationAdded(durationToAdd.getMillis(), scalar);\n }\n 
560	public Instant plus(long duration) {\n return withDurationAdded(duration, 1);\n }\n 
561	public Instant plus(ReadableDuration duration) {\n return withDurationAdded(duration, 1);\n }\n 
562	public Instant minus(long duration) {\n return withDurationAdded(duration, -1);\n }\n 
563	public Instant minus(ReadableDuration duration) {\n return withDurationAdded(duration, -1);\n }\n 
564	public long getMillis() {\n return iMillis;\n }\n 
565	public Chronology getChronology() {\n return ISOChronology.getInstanceUTC();\n }\n 
566	public DateTime toDateTime() {\n return new DateTime(getMillis(), ISOChronology.getInstance());\n }\n 
567	@Deprecated\n public DateTime toDateTimeISO() {\n return toDateTime();\n }\n 
568	public MutableDateTime toMutableDateTime() {\n return new MutableDateTime(getMillis(), ISOChronology.getInstance());\n }\n 
569	@Deprecated\n public MutableDateTime toMutableDateTimeISO() {\n return toMutableDateTime();\n }\n 
570	@FromString\n public static Period parse(String str) {\n return parse(str, ISOPeriodFormat.standard());\n }\n 
571	public static Period parse(String str, PeriodFormatter formatter) {\n return formatter.parsePeriod(str);\n }\n 
572	public static Period years(int years) {\n return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n }\n 
573	public static Period months(int months) {\n return new Period(new int[] {0, months, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n }\n 
574	public static Period weeks(int weeks) {\n return new Period(new int[] {0, 0, weeks, 0, 0, 0, 0, 0}, PeriodType.standard());\n }\n 
575	public static Period days(int days) {\n return new Period(new int[] {0, 0, 0, days, 0, 0, 0, 0}, PeriodType.standard());\n }\n 
576	public static Period hours(int hours) {\n return new Period(new int[] {0, 0, 0, 0, hours, 0, 0, 0}, PeriodType.standard());\n }\n 
577	public static Period minutes(int minutes) {\n return new Period(new int[] {0, 0, 0, 0, 0, minutes, 0, 0}, PeriodType.standard());\n }\n 
578	public static Period seconds(int seconds) {\n return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n }\n 
579	public static Period millis(int millis) {\n return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n }\n 
580	public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {\n if (start == null || end == null) {\n throw new IllegalArgumentException("ReadablePartial objects must not be null");\n }\n if (start.size() != end.size()) {\n throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");\n }\n DurationFieldType[] types = new DurationFieldType[start.size()];\n int[] values = new int[start.size()];\n for (int i = 0, isize = start.size(); i < isize; i++) {\n if (start.getFieldType(i) != end.getFieldType(i)) {\n throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");\n }\n types[i] = start.getFieldType(i).getDurationType();\n if (i > 0 && types[i - 1] == types[i]) {\n throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields");\n }\n values[i] = end.getValue(i) - start.getValue(i);\n }\n return new Period(values, PeriodType.forFields(types));\n }\n 
581	public Period() {\n super(0L, null, null);\n }\n 
582	public Period(int hours, int minutes, int seconds, int millis) {\n super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n }\n 
583	public Period(int years, int months, int weeks, int days,\n int hours, int minutes, int seconds, int millis) {\n super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n }\n 
584	public Period(int years, int months, int weeks, int days,\n int hours, int minutes, int seconds, int millis, PeriodType type) {\n super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n }\n 
585	public Period(long duration) {\n super(duration);\n }\n 
586	public Period(long duration, PeriodType type) {\n super(duration, type, null);\n }\n 
587	public Period(long duration, Chronology chronology) {\n super(duration, null, chronology);\n }\n 
588	public Period(long duration, PeriodType type, Chronology chronology) {\n super(duration, type, chronology);\n }\n 
589	public Period(long startInstant, long endInstant) {\n super(startInstant, endInstant, null, null);\n }\n 
590	public Period(long startInstant, long endInstant, PeriodType type) {\n super(startInstant, endInstant, type, null);\n }\n 
591	public Period(long startInstant, long endInstant, Chronology chrono) {\n super(startInstant, endInstant, null, chrono);\n }\n 
592	public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n super(startInstant, endInstant, type, chrono);\n }\n 
593	public Period(ReadableInstant startInstant, ReadableInstant endInstant) {\n super(startInstant, endInstant, null);\n }\n 
594	public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n super(startInstant, endInstant, type);\n }\n 
595	public Period(ReadablePartial start, ReadablePartial end) {\n super(start, end, null);\n }\n 
596	public Period(ReadablePartial start, ReadablePartial end, PeriodType type) {\n super(start, end, type);\n }\n 
597	public Period(ReadableInstant startInstant, ReadableDuration duration) {\n super(startInstant, duration, null);\n }\n 
598	public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n super(startInstant, duration, type);\n }\n 
599	public Period(ReadableDuration duration, ReadableInstant endInstant) {\n super(duration, endInstant, null);\n }\n 
600	public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n super(duration, endInstant, type);\n }\n 
601	public Period(Object period) {\n super(period, null, null);\n }\n 
602	public Period(Object period, PeriodType type) {\n super(period, type, null);\n }\n 
603	public Period(Object period, Chronology chrono) {\n super(period, null, chrono);\n }\n 
604	public Period(Object period, PeriodType type, Chronology chrono) {\n super(period, type, chrono);\n }\n 
605	private Period(int[] values, PeriodType type) {\n super(values, type);\n }\n 
606	public Period toPeriod() {\n return this;\n }\n 
607	public int getYears() {\n return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n }\n 
608	public int getMonths() {\n return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n }\n 
609	public int getWeeks() {\n return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n }\n 
610	public int getDays() {\n return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n }\n 
611	public int getHours() {\n return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n }\n 
612	public int getMinutes() {\n return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n }\n 
613	public int getSeconds() {\n return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n }\n 
614	public int getMillis() {\n return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n }\n 
615	public Period withPeriodType(PeriodType type) {\n type = DateTimeUtils.getPeriodType(type);\n if (type.equals(getPeriodType())) {\n return this;\n }\n return new Period(this, type);\n }\n 
616	public Period withFields(ReadablePeriod period) {\n if (period == null) {\n return this;\n }\n int[] newValues = getValues();  // cloned\n newValues = super.mergePeriodInto(newValues, period);\n return new Period(newValues, getPeriodType());\n }\n 
617	public Period withField(DurationFieldType field, int value) {\n if (field == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n int[] newValues = getValues();  // cloned\n super.setFieldInto(newValues, field, value);\n return new Period(newValues, getPeriodType());\n }\n 
618	public Period withFieldAdded(DurationFieldType field, int value) {\n if (field == null) {\n throw new IllegalArgumentException("Field must not be null");\n }\n if (value == 0) {\n return this;\n }\n int[] newValues = getValues();  // cloned\n super.addFieldInto(newValues, field, value);\n return new Period(newValues, getPeriodType());\n }\n 
619	public Period withYears(int years) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n return new Period(values, getPeriodType());\n }\n 
620	public Period withMonths(int months) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n return new Period(values, getPeriodType());\n }\n 
621	public Period withWeeks(int weeks) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n return new Period(values, getPeriodType());\n }\n 
622	public Period withDays(int days) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n return new Period(values, getPeriodType());\n }\n 
623	public Period withHours(int hours) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n return new Period(values, getPeriodType());\n }\n 
624	public Period withMinutes(int minutes) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n return new Period(values, getPeriodType());\n }\n 
625	public Period withSeconds(int seconds) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n return new Period(values, getPeriodType());\n }\n 
626	public Period withMillis(int millis) {\n int[] values = getValues();  // cloned\n getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n return new Period(values, getPeriodType());\n }\n 
627	public Period plus(ReadablePeriod period) {\n if (period == null) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n return new Period(values, getPeriodType());\n }\n 
628	public Period plusYears(int years) {\n if (years == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n return new Period(values, getPeriodType());\n }\n 
629	public Period plusMonths(int months) {\n if (months == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n return new Period(values, getPeriodType());\n }\n 
630	public Period plusWeeks(int weeks) {\n if (weeks == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n return new Period(values, getPeriodType());\n }\n 
631	public Period plusDays(int days) {\n if (days == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n return new Period(values, getPeriodType());\n }\n 
632	public Period plusHours(int hours) {\n if (hours == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n return new Period(values, getPeriodType());\n }\n 
633	public Period plusMinutes(int minutes) {\n if (minutes == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n return new Period(values, getPeriodType());\n }\n 
634	public Period plusSeconds(int seconds) {\n if (seconds == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n return new Period(values, getPeriodType());\n }\n 
635	public Period plusMillis(int millis) {\n if (millis == 0) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n return new Period(values, getPeriodType());\n }\n 
636	public Period minus(ReadablePeriod period) {\n if (period == null) {\n return this;\n }\n int[] values = getValues();  // cloned\n getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n return new Period(values, getPeriodType());\n }\n 
637	public Period minusYears(int years) {\n return plusYears(-years);\n }\n 
638	public Period minusMonths(int months) {\n return plusMonths(-months);\n }\n 
639	public Period minusWeeks(int weeks) {\n return plusWeeks(-weeks);\n }\n 
640	public Period minusDays(int days) {\n return plusDays(-days);\n }\n 
641	public Period minusHours(int hours) {\n return plusHours(-hours);\n }\n 
642	public Period minusMinutes(int minutes) {\n return plusMinutes(-minutes);\n }\n 
643	public Period minusSeconds(int seconds) {\n return plusSeconds(-seconds);\n }\n 
644	public Period minusMillis(int millis) {\n return plusMillis(-millis);\n }\n 
645	public Period multipliedBy(int scalar) {\n if (this == ZERO || scalar == 1) {\n return this;\n }\n int[] values = getValues();  // cloned\n for (int i = 0; i < values.length; i++) {\n values[i] = FieldUtils.safeMultiply(values[i], scalar);\n }\n return new Period(values, getPeriodType());\n }\n 
646	public Period negated() {\n return multipliedBy(-1);\n }\n 
647	public Weeks toStandardWeeks() {\n checkYearsAndMonths("Weeks");\n long millis = getMillis();  // assign to a long\n millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n return Weeks.weeks(FieldUtils.safeToInt(weeks));\n }\n 
648	public Days toStandardDays() {\n checkYearsAndMonths("Days");\n long millis = getMillis();  // assign to a long\n millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n days = FieldUtils.safeAdd(days, getDays());\n days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n return Days.days(FieldUtils.safeToInt(days));\n }\n 
649	public Hours toStandardHours() {\n checkYearsAndMonths("Hours");\n long millis = getMillis();  // assign to a long\n millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n hours = FieldUtils.safeAdd(hours, getHours());\n hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n return Hours.hours(FieldUtils.safeToInt(hours));\n }\n 
650	public Minutes toStandardMinutes() {\n checkYearsAndMonths("Minutes");\n long millis = getMillis();  // assign to a long\n millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n minutes = FieldUtils.safeAdd(minutes, getMinutes());\n minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n return Minutes.minutes(FieldUtils.safeToInt(minutes));\n }\n 
651	public Seconds toStandardSeconds() {\n checkYearsAndMonths("Seconds");\n long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n seconds = FieldUtils.safeAdd(seconds, getSeconds());\n seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n return Seconds.seconds(FieldUtils.safeToInt(seconds));\n }\n 
652	public Duration toStandardDuration() {\n checkYearsAndMonths("Duration");\n long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n return new Duration(millis);\n }\n 
653	private void checkYearsAndMonths(String destintionType) {\n if (getMonths() != 0) {\n throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length");\n }\n if (getYears() != 0) {\n throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length");\n }\n }\n 
654	public Period normalizedStandard() {\n return normalizedStandard(PeriodType.standard());\n }\n 
655	public Period normalizedStandard(PeriodType type) {\n type = DateTimeUtils.getPeriodType(type);\n long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n int years = getYears();\n int months = getMonths();\n if (years != 0 || months != 0) {\n long totalMonths = years * 12L + months;\n if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n result = result.withYears(normalizedYears);\n totalMonths = totalMonths - (normalizedYears * 12);\n }\n if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n result = result.withMonths(normalizedMonths);\n totalMonths = totalMonths - normalizedMonths;\n }\n if (totalMonths != 0) {\n throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString());\n }\n }\n return result;\n }\n 
656	public AbstractReadableInstantFieldProperty() {\n super();\n }\n 
657	public DateTimeFieldType getFieldType() {\n return getField().getType();\n }\n 
658	public String getName() {\n return getField().getName();\n }\n 
659	protected Chronology getChronology() {\n throw new UnsupportedOperationException(\n "The method getChronology() was added in v1.4 and needs " +\n "to be implemented by subclasses of AbstractReadableInstantFieldProperty");\n }\n 
660	public int get() {\n return getField().get(getMillis());\n }\n 
661	public String getAsString() {\n return Integer.toString(get());\n }\n 
662	public String getAsText() {\n return getAsText(null);\n }\n 
663	public String getAsText(Locale locale) {\n return getField().getAsText(getMillis(), locale);\n }\n 
664	public String getAsShortText() {\n return getAsShortText(null);\n }\n 
665	public String getAsShortText(Locale locale) {\n return getField().getAsShortText(getMillis(), locale);\n }\n 
666	public int getDifference(ReadableInstant instant) {\n if (instant == null) {\n return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis());\n }\n return getField().getDifference(getMillis(), instant.getMillis());\n }\n 
667	public long getDifferenceAsLong(ReadableInstant instant) {\n if (instant == null) {\n return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());\n }\n return getField().getDifferenceAsLong(getMillis(), instant.getMillis());\n }\n 
668	public DurationField getDurationField() {\n return getField().getDurationField();\n }\n 
669	public DurationField getRangeDurationField() {\n return getField().getRangeDurationField();\n }\n 
670	public boolean isLeap() {\n return getField().isLeap(getMillis());\n }\n 
671	public int getLeapAmount() {\n return getField().getLeapAmount(getMillis());\n }\n 
672	public DurationField getLeapDurationField() {\n return getField().getLeapDurationField();\n }\n 
673	public int getMinimumValueOverall() {\n return getField().getMinimumValue();\n }\n 
674	public int getMinimumValue() {\n return getField().getMinimumValue(getMillis());\n }\n 
675	public int getMaximumValueOverall() {\n return getField().getMaximumValue();\n }\n 
676	public int getMaximumValue() {\n return getField().getMaximumValue(getMillis());\n }\n 
677	public int getMaximumTextLength(Locale locale) {\n return getField().getMaximumTextLength(locale);\n }\n 
678	public int getMaximumShortTextLength(Locale locale) {\n return getField().getMaximumShortTextLength(locale);\n }\n 
679	public long remainder() {\n return getField().remainder(getMillis());\n }\n 
680	public Interval toInterval() {\n DateTimeField field = getField();\n long start = field.roundFloor(getMillis());\n long end = field.add(start, 1);\n Interval interval = new Interval(start, end);\n return interval;\n }\n 
681	public int compareTo(ReadableInstant instant) {\n if (instant == null) {\n throw new IllegalArgumentException("The instant must not be null");\n }\n int thisValue = get();\n int otherValue = instant.get(getFieldType());\n if (thisValue < otherValue) {\n return -1;\n } else if (thisValue > otherValue) {\n return 1;\n } else {\n return 0;\n }\n }\n 
682	public int compareTo(ReadablePartial partial) {\n if (partial == null) {\n throw new IllegalArgumentException("The partial must not be null");\n }\n int thisValue = get();\n int otherValue = partial.get(getFieldType());\n if (thisValue < otherValue) {\n return -1;\n } else if (thisValue > otherValue) {\n return 1;\n } else {\n return 0;\n }\n }\n 
683	public boolean equals(Object object) {\n if (this == object) {\n return true;\n }\n if (object instanceof AbstractReadableInstantFieldProperty == false) {\n return false;\n }\n AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n return\n get() == other.get() &&\n getFieldType().equals(other.getFieldType()) &&\n FieldUtils.equals(getChronology(), other.getChronology());\n }\n 
684	public int hashCode() {\n return get() * 17 + getFieldType().hashCode() + getChronology().hashCode();\n }\n 
685	public String toString() {\n return "Property[" + getName() + "]";\n }\n 
686	protected ISODateTimeFormat() {\n super();\n }\n 
687	public static DateTimeFormatter forFields(\n Collection<DateTimeFieldType> fields,\n boolean extended,\n boolean strictISO) {\n \n if (fields == null || fields.size() == 0) {\n throw new IllegalArgumentException("The fields must not be null or empty");\n }\n Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields);\n int inputSize = workingFields.size();\n boolean reducedPrec = false;\n DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n // date\n if (workingFields.contains(DateTimeFieldType.monthOfYear())) {\n reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {\n reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO);\n } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {\n reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {\n reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {\n reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n } else if (workingFields.remove(DateTimeFieldType.year())) {\n bld.append(Constants.ye);\n reducedPrec = true;\n } else if (workingFields.remove(DateTimeFieldType.weekyear())) {\n bld.append(Constants.we);\n reducedPrec = true;\n }\n boolean datePresent = (workingFields.size() < inputSize);\n \n // time\n time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);\n \n // result\n if (bld.canBuildFormatter() == false) {\n throw new IllegalArgumentException("No valid format for fields: " + fields);\n }\n \n // side effect the input collection to indicate the processed fields\n // handling unmodifiable collections with no side effect\n try {\n fields.retainAll(workingFields);\n } catch (UnsupportedOperationException ex) {\n // ignore, so we can handle unmodifiable collections\n }\n return bld.toFormatter();\n }\n 
688	private static boolean dateByMonth(\n DateTimeFormatterBuilder bld,\n Collection<DateTimeFieldType> fields,\n boolean extended,\n boolean strictISO) {\n \n boolean reducedPrec = false;\n if (fields.remove(DateTimeFieldType.year())) {\n bld.append(Constants.ye);\n if (fields.remove(DateTimeFieldType.monthOfYear())) {\n if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n // YYYY-MM-DD/YYYYMMDD\n appendSeparator(bld, extended);\n bld.appendMonthOfYear(2);\n appendSeparator(bld, extended);\n bld.appendDayOfMonth(2);\n } else {\n // YYYY-MM/YYYY-MM\n bld.appendLiteral('-');\n bld.appendMonthOfYear(2);\n reducedPrec = true;\n }\n } else {\n if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n // YYYY--DD/YYYY--DD (non-iso)\n checkNotStrictISO(fields, strictISO);\n bld.appendLiteral('-');\n bld.appendLiteral('-');\n bld.appendDayOfMonth(2);\n } else {\n // YYYY/YYYY\n reducedPrec = true;\n }\n }\n \n } else if (fields.remove(DateTimeFieldType.monthOfYear())) {\n bld.appendLiteral('-');\n bld.appendLiteral('-');\n bld.appendMonthOfYear(2);\n if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n // --MM-DD/--MMDD\n appendSeparator(bld, extended);\n bld.appendDayOfMonth(2);\n } else {\n // --MM/--MM\n reducedPrec = true;\n }\n } else if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n // ---DD/---DD\n bld.appendLiteral('-');\n bld.appendLiteral('-');\n bld.appendLiteral('-');\n bld.appendDayOfMonth(2);\n }\n return reducedPrec;\n }\n 
689	private static boolean dateByOrdinal(\n DateTimeFormatterBuilder bld,\n Collection<DateTimeFieldType> fields,\n boolean extended,\n boolean strictISO) {\n \n boolean reducedPrec = false;\n if (fields.remove(DateTimeFieldType.year())) {\n bld.append(Constants.ye);\n if (fields.remove(DateTimeFieldType.dayOfYear())) {\n // YYYY-DDD/YYYYDDD\n appendSeparator(bld, extended);\n bld.appendDayOfYear(3);\n } else {\n // YYYY/YYYY\n reducedPrec = true;\n }\n \n } else if (fields.remove(DateTimeFieldType.dayOfYear())) {\n // -DDD/-DDD\n bld.appendLiteral('-');\n bld.appendDayOfYear(3);\n }\n return reducedPrec;\n }\n 
690	private static boolean dateByWeek(\n DateTimeFormatterBuilder bld,\n Collection<DateTimeFieldType> fields,\n boolean extended,\n boolean strictISO) {\n \n boolean reducedPrec = false;\n if (fields.remove(DateTimeFieldType.weekyear())) {\n bld.append(Constants.we);\n if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n appendSeparator(bld, extended);\n bld.appendLiteral('W');\n bld.appendWeekOfWeekyear(2);\n if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n // YYYY-WWW-D/YYYYWWWD\n appendSeparator(bld, extended);\n bld.appendDayOfWeek(1);\n } else {\n // YYYY-WWW/YYYY-WWW\n reducedPrec = true;\n }\n } else {\n if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n // YYYY-W-D/YYYYW-D (non-iso)\n checkNotStrictISO(fields, strictISO);\n appendSeparator(bld, extended);\n bld.appendLiteral('W');\n bld.appendLiteral('-');\n bld.appendDayOfWeek(1);\n } else {\n // YYYY/YYYY\n reducedPrec = true;\n }\n }\n \n } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n bld.appendLiteral('-');\n bld.appendLiteral('W');\n bld.appendWeekOfWeekyear(2);\n if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n // -WWW-D/-WWWD\n appendSeparator(bld, extended);\n bld.appendDayOfWeek(1);\n } else {\n // -WWW/-WWW\n reducedPrec = true;\n }\n } else if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n // -W-D/-W-D\n bld.appendLiteral('-');\n bld.appendLiteral('W');\n bld.appendLiteral('-');\n bld.appendDayOfWeek(1);\n }\n return reducedPrec;\n }\n 
691	private static void time(\n DateTimeFormatterBuilder bld,\n Collection<DateTimeFieldType> fields,\n boolean extended,\n boolean strictISO,\n boolean reducedPrec,\n boolean datePresent) {\n \n boolean hour = fields.remove(DateTimeFieldType.hourOfDay());\n boolean minute = fields.remove(DateTimeFieldType.minuteOfHour());\n boolean second = fields.remove(DateTimeFieldType.secondOfMinute());\n boolean milli = fields.remove(DateTimeFieldType.millisOfSecond());\n if (!hour && !minute && !second && !milli) {\n return;\n }\n if (hour || minute || second || milli) {\n if (strictISO && reducedPrec) {\n throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields);\n }\n if (datePresent) {\n bld.appendLiteral('T');\n }\n }\n if (hour && minute && second || (hour && !second && !milli)) {\n // OK - HMSm/HMS/HM/H - valid in combination with date\n } else {\n if (strictISO && datePresent) {\n throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields);\n }\n if (!hour && (minute && second || (minute && !milli) || second)) {\n // OK - MSm/MS/M/Sm/S - valid ISO formats\n } else {\n if (strictISO) {\n throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields);\n }\n }\n }\n if (hour) {\n bld.appendHourOfDay(2);\n } else if (minute || second || milli) {\n bld.appendLiteral('-');\n }\n if (extended && hour && minute) {\n bld.appendLiteral(':');\n }\n if (minute) {\n bld.appendMinuteOfHour(2);\n } else if (second || milli) {\n bld.appendLiteral('-');\n }\n if (extended && minute && second) {\n bld.appendLiteral(':');\n }\n if (second) {\n bld.appendSecondOfMinute(2);\n } else if (milli) {\n bld.appendLiteral('-');\n }\n if (milli) {\n bld.appendLiteral('.');\n bld.appendMillisOfSecond(3);\n }\n }\n 
692	private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) {\n if (strictISO) {\n throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields);\n }\n }\n 
693	private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) {\n if (extended) {\n bld.appendLiteral('-');\n }\n }\n 
694	public static DateTimeFormatter dateParser() {\n return Constants.dp;\n }\n 
695	public static DateTimeFormatter localDateParser() {\n return Constants.ldp;\n }\n 
696	public static DateTimeFormatter dateElementParser() {\n return Constants.dpe;\n }\n 
697	public static DateTimeFormatter timeParser() {\n return Constants.tp;\n }\n 
698	public static DateTimeFormatter localTimeParser() {\n return Constants.ltp;\n }\n 
699	public static DateTimeFormatter timeElementParser() {\n return Constants.tpe;\n }\n 
700	public static DateTimeFormatter dateTimeParser() {\n return Constants.dtp;\n }\n 
701	public static DateTimeFormatter dateOptionalTimeParser() {\n return Constants.dotp;\n }\n 
702	public static DateTimeFormatter localDateOptionalTimeParser() {\n return Constants.ldotp;\n }\n 
703	public static DateTimeFormatter date() {\n return yearMonthDay();\n }\n 
704	public static DateTimeFormatter time() {\n return Constants.t;\n }\n 
705	public static DateTimeFormatter timeNoMillis() {\n return Constants.tx;\n }\n 
706	public static DateTimeFormatter tTime() {\n return Constants.tt;\n }\n 
707	public static DateTimeFormatter tTimeNoMillis() {\n return Constants.ttx;\n }\n 
708	public static DateTimeFormatter dateTime() {\n return Constants.dt;\n }\n 
709	public static DateTimeFormatter dateTimeNoMillis() {\n return Constants.dtx;\n }\n 
710	public static DateTimeFormatter ordinalDate() {\n return Constants.od;\n }\n 
711	public static DateTimeFormatter ordinalDateTime() {\n return Constants.odt;\n }\n 
712	public static DateTimeFormatter ordinalDateTimeNoMillis() {\n return Constants.odtx;\n }\n 
713	public static DateTimeFormatter weekDate() {\n return Constants.wwd;\n }\n 
714	public static DateTimeFormatter weekDateTime() {\n return Constants.wdt;\n }\n 
715	public static DateTimeFormatter weekDateTimeNoMillis() {\n return Constants.wdtx;\n }\n 
716	public static DateTimeFormatter basicDate() {\n return Constants.bd;\n }\n 
717	public static DateTimeFormatter basicTime() {\n return Constants.bt;\n }\n 
718	public static DateTimeFormatter basicTimeNoMillis() {\n return Constants.btx;\n }\n 
719	public static DateTimeFormatter basicTTime() {\n return Constants.btt;\n }\n 
720	public static DateTimeFormatter basicTTimeNoMillis() {\n return Constants.bttx;\n }\n 
721	public static DateTimeFormatter basicDateTime() {\n return Constants.bdt;\n }\n 
722	public static DateTimeFormatter basicDateTimeNoMillis() {\n return Constants.bdtx;\n }\n 
723	public static DateTimeFormatter basicOrdinalDate() {\n return Constants.bod;\n }\n 
724	public static DateTimeFormatter basicOrdinalDateTime() {\n return Constants.bodt;\n }\n 
725	public static DateTimeFormatter basicOrdinalDateTimeNoMillis() {\n return Constants.bodtx;\n }\n 
726	public static DateTimeFormatter basicWeekDate() {\n return Constants.bwd;\n }\n 
727	public static DateTimeFormatter basicWeekDateTime() {\n return Constants.bwdt;\n }\n 
728	public static DateTimeFormatter basicWeekDateTimeNoMillis() {\n return Constants.bwdtx;\n }\n 
729	public static DateTimeFormatter year() {\n return Constants.ye;\n }\n 
730	public static DateTimeFormatter yearMonth() {\n return Constants.ym;\n }\n 
731	public static DateTimeFormatter yearMonthDay() {\n return Constants.ymd;\n }\n 
732	public static DateTimeFormatter weekyear() {\n return Constants.we;\n }\n 
733	public static DateTimeFormatter weekyearWeek() {\n return Constants.ww;\n }\n 
734	public static DateTimeFormatter weekyearWeekDay() {\n return Constants.wwd;\n }\n 
735	public static DateTimeFormatter hour() {\n return Constants.hde;\n }\n 
736	public static DateTimeFormatter hourMinute() {\n return Constants.hm;\n }\n 
737	public static DateTimeFormatter hourMinuteSecond() {\n return Constants.hms;\n }\n 
738	public static DateTimeFormatter hourMinuteSecondMillis() {\n return Constants.hmsl;\n }\n 
739	public static DateTimeFormatter hourMinuteSecondFraction() {\n return Constants.hmsf;\n }\n 
740	public static DateTimeFormatter dateHour() {\n return Constants.dh;\n }\n 
741	public static DateTimeFormatter dateHourMinute() {\n return Constants.dhm;\n }\n 
742	public static DateTimeFormatter dateHourMinuteSecond() {\n return Constants.dhms;\n }\n 
743	public static DateTimeFormatter dateHourMinuteSecondMillis() {\n return Constants.dhmsl;\n }\n 
744	public static DateTimeFormatter dateHourMinuteSecondFraction() {\n return Constants.dhmsf;\n }\n 
745	private static DateTimeFormatter dateParser() {\n if (dp == null) {\n DateTimeParser tOffset = new DateTimeFormatterBuilder()\n .appendLiteral('T')\n .append(offsetElement()).toParser();\n return new DateTimeFormatterBuilder()\n .append(dateElementParser())\n .appendOptional(tOffset)\n .toFormatter();\n }\n return dp;\n }\n 
746	private static DateTimeFormatter localDateParser() {\n if (ldp == null) {\n return dateElementParser().withZoneUTC();\n }\n return ldp;\n }\n 
747	private static DateTimeFormatter dateElementParser() {\n if (dpe == null) {\n return new DateTimeFormatterBuilder()\n .append(null, new DateTimeParser[] {\n new DateTimeFormatterBuilder()\n .append(yearElement())\n .appendOptional\n (new DateTimeFormatterBuilder()\n .append(monthElement())\n .appendOptional(dayOfMonthElement().getParser())\n .toParser())\n .toParser(),\n new DateTimeFormatterBuilder()\n .append(weekyearElement())\n .append(weekElement())\n .appendOptional(dayOfWeekElement().getParser())\n .toParser(),\n new DateTimeFormatterBuilder()\n .append(yearElement())\n .append(dayOfYearElement())\n .toParser()\n })\n .toFormatter();\n }\n return dpe;\n }\n 
748	private static DateTimeFormatter timeParser() {\n if (tp == null) {\n return new DateTimeFormatterBuilder()\n .appendOptional(literalTElement().getParser())\n .append(timeElementParser())\n .appendOptional(offsetElement().getParser())\n .toFormatter();\n }\n return tp;\n }\n 
749	private static DateTimeFormatter localTimeParser() {\n if (ltp == null) {\n return new DateTimeFormatterBuilder()\n .appendOptional(literalTElement().getParser())\n .append(timeElementParser())\n .toFormatter().withZoneUTC();\n }\n return ltp;\n }\n 
750	private static DateTimeFormatter timeElementParser() {\n if (tpe == null) {\n // Decimal point can be either '.' or ','\n DateTimeParser decimalPoint = new DateTimeFormatterBuilder()\n .append(null, new DateTimeParser[] {\n new DateTimeFormatterBuilder()\n .appendLiteral('.')\n .toParser(),\n new DateTimeFormatterBuilder()\n .appendLiteral(',')\n .toParser()\n })\n .toParser();\n return new DateTimeFormatterBuilder()\n // time-element\n .append(hourElement())\n .append\n (null, new DateTimeParser[] {\n new DateTimeFormatterBuilder()\n // minute-element\n .append(minuteElement())\n .append\n (null, new DateTimeParser[] {\n new DateTimeFormatterBuilder()\n // second-element\n .append(secondElement())\n // second fraction\n .appendOptional(new DateTimeFormatterBuilder()\n .append(decimalPoint)\n .appendFractionOfSecond(1, 9)\n .toParser())\n .toParser(),\n // minute fraction\n new DateTimeFormatterBuilder()\n .append(decimalPoint)\n .appendFractionOfMinute(1, 9)\n .toParser(),\n null\n })\n .toParser(),\n // hour fraction\n new DateTimeFormatterBuilder()\n .append(decimalPoint)\n .appendFractionOfHour(1, 9)\n .toParser(),\n null\n })\n .toFormatter();\n }\n return tpe;\n }\n 
751	private static DateTimeFormatter dateTimeParser() {\n if (dtp == null) {\n // This is different from the general time parser in that the 'T'\n // is required.\n DateTimeParser time = new DateTimeFormatterBuilder()\n .appendLiteral('T')\n .append(timeElementParser())\n .appendOptional(offsetElement().getParser())\n .toParser();\n return new DateTimeFormatterBuilder()\n .append(null, new DateTimeParser[] {time, dateOptionalTimeParser().getParser()})\n .toFormatter();\n }\n return dtp;\n }\n 
752	private static DateTimeFormatter dateOptionalTimeParser() {\n if (dotp == null) {\n DateTimeParser timeOrOffset = new DateTimeFormatterBuilder()\n .appendLiteral('T')\n .appendOptional(timeElementParser().getParser())\n .appendOptional(offsetElement().getParser())\n .toParser();\n return new DateTimeFormatterBuilder()\n .append(dateElementParser())\n .appendOptional(timeOrOffset)\n .toFormatter();\n }\n return dotp;\n }\n 
753	private static DateTimeFormatter localDateOptionalTimeParser() {\n if (ldotp == null) {\n DateTimeParser time = new DateTimeFormatterBuilder()\n .appendLiteral('T')\n .append(timeElementParser())\n .toParser();\n return new DateTimeFormatterBuilder()\n .append(dateElementParser())\n .appendOptional(time)\n .toFormatter().withZoneUTC();\n }\n return ldotp;\n }\n 
754	private static DateTimeFormatter time() {\n if (t == null) {\n return new DateTimeFormatterBuilder()\n .append(hourMinuteSecondFraction())\n .append(offsetElement())\n .toFormatter();\n }\n return t;\n }\n 
755	private static DateTimeFormatter timeNoMillis() {\n if (tx == null) {\n return new DateTimeFormatterBuilder()\n .append(hourMinuteSecond())\n .append(offsetElement())\n .toFormatter();\n }\n return tx;\n }\n 
756	private static DateTimeFormatter tTime() {\n if (tt == null) {\n return new DateTimeFormatterBuilder()\n .append(literalTElement())\n .append(time())\n .toFormatter();\n }\n return tt;\n }\n 
757	private static DateTimeFormatter tTimeNoMillis() {\n if (ttx == null) {\n return new DateTimeFormatterBuilder()\n .append(literalTElement())\n .append(timeNoMillis())\n .toFormatter();\n }\n return ttx;\n }\n 
758	private static DateTimeFormatter dateTime() {\n if (dt == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(tTime())\n .toFormatter();\n }\n return dt;\n }\n 
759	private static DateTimeFormatter dateTimeNoMillis() {\n if (dtx == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(tTimeNoMillis())\n .toFormatter();\n }\n return dtx;\n }\n 
760	private static DateTimeFormatter ordinalDate() {\n if (od == null) {\n return new DateTimeFormatterBuilder()\n .append(yearElement())\n .append(dayOfYearElement())\n .toFormatter();\n }\n return od;\n }\n 
761	private static DateTimeFormatter ordinalDateTime() {\n if (odt == null) {\n return new DateTimeFormatterBuilder()\n .append(ordinalDate())\n .append(tTime())\n .toFormatter();\n }\n return odt;\n }\n 
762	private static DateTimeFormatter ordinalDateTimeNoMillis() {\n if (odtx == null) {\n return new DateTimeFormatterBuilder()\n .append(ordinalDate())\n .append(tTimeNoMillis())\n .toFormatter();\n }\n return odtx;\n }\n 
763	private static DateTimeFormatter weekDateTime() {\n if (wdt == null) {\n return new DateTimeFormatterBuilder()\n .append(weekDate())\n .append(tTime())\n .toFormatter();\n }\n return wdt;\n }\n 
764	private static DateTimeFormatter weekDateTimeNoMillis() {\n if (wdtx == null) {\n return new DateTimeFormatterBuilder()\n .append(weekDate())\n .append(tTimeNoMillis())\n .toFormatter();\n }\n return wdtx;\n }\n 
765	private static DateTimeFormatter basicDate() {\n if (bd == null) {\n return new DateTimeFormatterBuilder()\n .appendYear(4, 4)\n .appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2)\n .appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2)\n .toFormatter();\n }\n return bd;\n }\n 
766	private static DateTimeFormatter basicTime() {\n if (bt == null) {\n return new DateTimeFormatterBuilder()\n .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n .appendLiteral('.')\n .appendFractionOfSecond(3, 9)\n .appendTimeZoneOffset("Z", false, 2, 2)\n .toFormatter();\n }\n return bt;\n }\n 
767	private static DateTimeFormatter basicTimeNoMillis() {\n if (btx == null) {\n return new DateTimeFormatterBuilder()\n .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n .appendTimeZoneOffset("Z", false, 2, 2)\n .toFormatter();\n }\n return btx;\n }\n 
768	private static DateTimeFormatter basicTTime() {\n if (btt == null) {\n return new DateTimeFormatterBuilder()\n .append(literalTElement())\n .append(basicTime())\n .toFormatter();\n }\n return btt;\n }\n 
769	private static DateTimeFormatter basicTTimeNoMillis() {\n if (bttx == null) {\n return new DateTimeFormatterBuilder()\n .append(literalTElement())\n .append(basicTimeNoMillis())\n .toFormatter();\n }\n return bttx;\n }\n 
770	private static DateTimeFormatter basicDateTime() {\n if (bdt == null) {\n return new DateTimeFormatterBuilder()\n .append(basicDate())\n .append(basicTTime())\n .toFormatter();\n }\n return bdt;\n }\n 
771	private static DateTimeFormatter basicDateTimeNoMillis() {\n if (bdtx == null) {\n return new DateTimeFormatterBuilder()\n .append(basicDate())\n .append(basicTTimeNoMillis())\n .toFormatter();\n }\n return bdtx;\n }\n 
772	private static DateTimeFormatter basicOrdinalDate() {\n if (bod == null) {\n return new DateTimeFormatterBuilder()\n .appendYear(4, 4)\n .appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3)\n .toFormatter();\n }\n return bod;\n }\n 
773	private static DateTimeFormatter basicOrdinalDateTime() {\n if (bodt == null) {\n return new DateTimeFormatterBuilder()\n .append(basicOrdinalDate())\n .append(basicTTime())\n .toFormatter();\n }\n return bodt;\n }\n 
774	private static DateTimeFormatter basicOrdinalDateTimeNoMillis() {\n if (bodtx == null) {\n return new DateTimeFormatterBuilder()\n .append(basicOrdinalDate())\n .append(basicTTimeNoMillis())\n .toFormatter();\n }\n return bodtx;\n }\n 
775	private static DateTimeFormatter basicWeekDate() {\n if (bwd == null) {\n return new DateTimeFormatterBuilder()\n .appendWeekyear(4, 4)\n .appendLiteral('W')\n .appendFixedDecimal(DateTimeFieldType.weekOfWeekyear(), 2)\n .appendFixedDecimal(DateTimeFieldType.dayOfWeek(), 1)\n .toFormatter();\n }\n return bwd;\n }\n 
776	private static DateTimeFormatter basicWeekDateTime() {\n if (bwdt == null) {\n return new DateTimeFormatterBuilder()\n .append(basicWeekDate())\n .append(basicTTime())\n .toFormatter();\n }\n return bwdt;\n }\n 
777	private static DateTimeFormatter basicWeekDateTimeNoMillis() {\n if (bwdtx == null) {\n return new DateTimeFormatterBuilder()\n .append(basicWeekDate())\n .append(basicTTimeNoMillis())\n .toFormatter();\n }\n return bwdtx;\n }\n 
778	private static DateTimeFormatter yearMonth() {\n if (ym == null) {\n return new DateTimeFormatterBuilder()\n .append(yearElement())\n .append(monthElement())\n .toFormatter();\n }\n return ym;\n }\n 
779	private static DateTimeFormatter yearMonthDay() {\n if (ymd == null) {\n return new DateTimeFormatterBuilder()\n .append(yearElement())\n .append(monthElement())\n .append(dayOfMonthElement())\n .toFormatter();\n }\n return ymd;\n }\n 
780	private static DateTimeFormatter weekyearWeek() {\n if (ww == null) {\n return new DateTimeFormatterBuilder()\n .append(weekyearElement())\n .append(weekElement())\n .toFormatter();\n }\n return ww;\n }\n 
781	private static DateTimeFormatter weekyearWeekDay() {\n if (wwd == null) {\n return new DateTimeFormatterBuilder()\n .append(weekyearElement())\n .append(weekElement())\n .append(dayOfWeekElement())\n .toFormatter();\n }\n return wwd;\n }\n 
782	private static DateTimeFormatter hourMinute() {\n if (hm == null) {\n return new DateTimeFormatterBuilder()\n .append(hourElement())\n .append(minuteElement())\n .toFormatter();\n }\n return hm;\n }\n 
783	private static DateTimeFormatter hourMinuteSecond() {\n if (hms == null) {\n return new DateTimeFormatterBuilder()\n .append(hourElement())\n .append(minuteElement())\n .append(secondElement())\n .toFormatter();\n }\n return hms;\n }\n 
784	private static DateTimeFormatter hourMinuteSecondMillis() {\n if (hmsl == null) {\n return new DateTimeFormatterBuilder()\n .append(hourElement())\n .append(minuteElement())\n .append(secondElement())\n .appendLiteral('.')\n .appendFractionOfSecond(3, 3)\n .toFormatter();\n }\n return hmsl;\n }\n 
785	private static DateTimeFormatter hourMinuteSecondFraction() {\n if (hmsf == null) {\n return new DateTimeFormatterBuilder()\n .append(hourElement())\n .append(minuteElement())\n .append(secondElement())\n .append(fractionElement())\n .toFormatter();\n }\n return hmsf;\n }\n 
786	private static DateTimeFormatter dateHour() {\n if (dh == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(literalTElement())\n .append(hour())\n .toFormatter();\n }\n return dh;\n }\n 
787	private static DateTimeFormatter dateHourMinute() {\n if (dhm == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(literalTElement())\n .append(hourMinute())\n .toFormatter();\n }\n return dhm;\n }\n 
788	private static DateTimeFormatter dateHourMinuteSecond() {\n if (dhms == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(literalTElement())\n .append(hourMinuteSecond())\n .toFormatter();\n }\n return dhms;\n }\n 
789	private static DateTimeFormatter dateHourMinuteSecondMillis() {\n if (dhmsl == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(literalTElement())\n .append(hourMinuteSecondMillis())\n .toFormatter();\n }\n return dhmsl;\n }\n 
790	private static DateTimeFormatter dateHourMinuteSecondFraction() {\n if (dhmsf == null) {\n return new DateTimeFormatterBuilder()\n .append(date())\n .append(literalTElement())\n .append(hourMinuteSecondFraction())\n .toFormatter();\n }\n return dhmsf;\n }\n 
791	private static DateTimeFormatter yearElement() {\n if (ye == null) {\n return new DateTimeFormatterBuilder()\n .appendYear(4, 9)\n .toFormatter();\n }\n return ye;\n }\n 
792	private static DateTimeFormatter monthElement() {\n if (mye == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral('-')\n .appendMonthOfYear(2)\n .toFormatter();\n }\n return mye;\n }\n 
793	private static DateTimeFormatter dayOfMonthElement() {\n if (dme == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral('-')\n .appendDayOfMonth(2)\n .toFormatter();\n }\n return dme;\n }\n 
794	private static DateTimeFormatter weekyearElement() {\n if (we == null) {\n return new DateTimeFormatterBuilder()\n .appendWeekyear(4, 9)\n .toFormatter();\n }\n return we;\n }\n 
795	private static DateTimeFormatter weekElement() {\n if (wwe == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral("-W")\n .appendWeekOfWeekyear(2)\n .toFormatter();\n }\n return wwe;\n }\n 
796	private static DateTimeFormatter dayOfWeekElement() {\n if (dwe == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral('-')\n .appendDayOfWeek(1)\n .toFormatter();\n }\n return dwe;\n }\n 
797	private static DateTimeFormatter dayOfYearElement() {\n if (dye == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral('-')\n .appendDayOfYear(3)\n .toFormatter();\n }\n return dye;\n }\n 
798	private static DateTimeFormatter literalTElement() {\n if (lte == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral('T')\n .toFormatter();\n }\n return lte;\n }\n 
799	private static DateTimeFormatter hourElement() {\n if (hde == null) {\n return new DateTimeFormatterBuilder()\n .appendHourOfDay(2)\n .toFormatter();\n }\n return hde;\n }\n 
800	private static DateTimeFormatter minuteElement() {\n if (mhe == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral(':')\n .appendMinuteOfHour(2)\n .toFormatter();\n }\n return mhe;\n }\n 
801	private static DateTimeFormatter secondElement() {\n if (sme == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral(':')\n .appendSecondOfMinute(2)\n .toFormatter();\n }\n return sme;\n }\n 
802	private static DateTimeFormatter fractionElement() {\n if (fse == null) {\n return new DateTimeFormatterBuilder()\n .appendLiteral('.')\n // Support parsing up to nanosecond precision even though\n // those extra digits will be dropped.\n .appendFractionOfSecond(3, 9)\n .toFormatter();\n }\n return fse;\n }\n 
803	private static DateTimeFormatter offsetElement() {\n if (ze == null) {\n return new DateTimeFormatterBuilder()\n .appendTimeZoneOffset("Z", true, 2, 4)\n .toFormatter();\n }\n return ze;\n }\n 
804	@FromString\n public static Duration parse(String str) {\n return new Duration(str);\n }\n 
805	public static Duration standardDays(long days) {\n if (days == 0) {\n return ZERO;\n }\n return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY));\n }\n 
806	public static Duration standardHours(long hours) {\n if (hours == 0) {\n return ZERO;\n }\n return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR));\n }\n 
807	public static Duration standardMinutes(long minutes) {\n if (minutes == 0) {\n return ZERO;\n }\n return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE));\n }\n 
808	public static Duration standardSeconds(long seconds) {\n if (seconds == 0) {\n return ZERO;\n }\n return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND));\n }\n 
809	public static Duration millis(long millis) {\n if (millis == 0) {\n return ZERO;\n }\n return new Duration(millis);\n }\n 
810	public Duration(long duration) {\n super(duration);\n }\n 
811	public Duration(long startInstant, long endInstant) {\n super(startInstant, endInstant);\n }\n 
812	public Duration(ReadableInstant start, ReadableInstant end) {\n super(start, end);\n }\n 
813	public Duration(Object duration) {\n super(duration);\n }\n 
814	public long getStandardDays() {\n return getMillis() / DateTimeConstants.MILLIS_PER_DAY;\n }\n 
815	public long getStandardHours() {\n return getMillis() / DateTimeConstants.MILLIS_PER_HOUR;\n }\n 
816	public long getStandardMinutes() {\n return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE;\n }\n 
817	public long getStandardSeconds() {\n return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n }\n 
818	public Duration toDuration() {\n return this;\n }\n 
819	public Days toStandardDays() {\n long days = getStandardDays();\n return Days.days(FieldUtils.safeToInt(days));\n }\n 
820	public Hours toStandardHours() {\n long hours = getStandardHours();\n return Hours.hours(FieldUtils.safeToInt(hours));\n }\n 
821	public Minutes toStandardMinutes() {\n long minutes = getStandardMinutes();\n return Minutes.minutes(FieldUtils.safeToInt(minutes));\n }\n 
822	public Seconds toStandardSeconds() {\n long seconds = getStandardSeconds();\n return Seconds.seconds(FieldUtils.safeToInt(seconds));\n }\n 
823	public Duration withMillis(long duration) {\n if (duration == getMillis()) {\n return this;\n }\n return new Duration(duration);\n }\n 
824	public Duration withDurationAdded(long durationToAdd, int scalar) {\n if (durationToAdd == 0 || scalar == 0) {\n return this;\n }\n long add = FieldUtils.safeMultiply(durationToAdd, scalar);\n long duration = FieldUtils.safeAdd(getMillis(), add);\n return new Duration(duration);\n }\n 
825	public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n if (durationToAdd == null || scalar == 0) {\n return this;\n }\n return withDurationAdded(durationToAdd.getMillis(), scalar);\n }\n 
826	public Duration plus(long amount) {\n return withDurationAdded(amount, 1);\n }\n 
827	public Duration plus(ReadableDuration amount) {\n if (amount == null) {\n return this;\n }\n return withDurationAdded(amount.getMillis(), 1);\n }\n 
828	public Duration minus(long amount) {\n return withDurationAdded(amount, -1);\n }\n 
829	public Duration minus(ReadableDuration amount) {\n if (amount == null) {\n return this;\n }\n return withDurationAdded(amount.getMillis(), -1);\n }\n 
830	public Duration multipliedBy(long multiplicand) {\n if (multiplicand == 1) {\n return this;\n }\n return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));\n }\n 
831	public Duration dividedBy(long divisor) {\n if (divisor == 1) {\n return this;\n }\n return new Duration(FieldUtils.safeDivide(getMillis(), divisor));\n }\n 
832	public Duration negated() {\n if (getMillis() == Long.MIN_VALUE) {\n throw new ArithmeticException("Negation of this duration would overflow");\n }\n return new Duration(-getMillis());\n }\n 
833	public static DateTimeZone getDefault() {\n DateTimeZone zone = cDefault;\n if (zone == null) {\n synchronized(DateTimeZone.class) {\n zone = cDefault;\n if (zone == null) {\n DateTimeZone temp = null;\n try {\n try {\n String id = System.getProperty("user.timezone");\n if (id != null) {  // null check avoids stack overflow\n temp = forID(id);\n }\n } catch (RuntimeException ex) {\n // ignored\n }\n if (temp == null) {\n temp = forTimeZone(TimeZone.getDefault());\n }\n } catch (IllegalArgumentException ex) {\n // ignored\n }\n if (temp == null) {\n temp = UTC;\n }\n cDefault = zone = temp;\n }\n }\n }\n return zone;\n }\n 
834	public static void setDefault(DateTimeZone zone) throws SecurityException {\n SecurityManager sm = System.getSecurityManager();\n if (sm != null) {\n sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault"));\n }\n if (zone == null) {\n throw new IllegalArgumentException("The datetime zone must not be null");\n }\n synchronized(DateTimeZone.class) {\n cDefault = zone;\n }\n }\n 
835	@FromString\n public static DateTimeZone forID(String id) {\n if (id == null) {\n return getDefault();\n }\n if (id.equals("UTC")) {\n return DateTimeZone.UTC;\n }\n DateTimeZone zone = cProvider.getZone(id);\n if (zone != null) {\n return zone;\n }\n if (id.startsWith("+") || id.startsWith("-")) {\n int offset = parseOffset(id);\n if (offset == 0L) {\n return DateTimeZone.UTC;\n } else {\n id = printOffset(offset);\n return fixedOffsetZone(id, offset);\n }\n }\n throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised");\n }\n 
836	public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n return forOffsetHoursMinutes(hoursOffset, 0);\n }\n 
837	public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n if (hoursOffset == 0 && minutesOffset == 0) {\n return DateTimeZone.UTC;\n }\n if (hoursOffset < -23 || hoursOffset > 23) {\n throw new IllegalArgumentException("Hours out of range: " + hoursOffset);\n }\n if (minutesOffset < -59 || minutesOffset > 59) {\n throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);\n }\n if (hoursOffset > 0 && minutesOffset < 0) {\n throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset);\n }\n int offset = 0;\n try {\n int hoursInMinutes = hoursOffset * 60;\n if (hoursInMinutes < 0) {\n minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n } else {\n minutesOffset = hoursInMinutes + minutesOffset;\n }\n offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n } catch (ArithmeticException ex) {\n throw new IllegalArgumentException("Offset is too large");\n }\n return forOffsetMillis(offset);\n }\n 
838	public static DateTimeZone forOffsetMillis(int millisOffset) {\n if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n throw new IllegalArgumentException("Millis out of range: " + millisOffset);\n }\n String id = printOffset(millisOffset);\n return fixedOffsetZone(id, millisOffset);\n }\n 
839	public static DateTimeZone forTimeZone(TimeZone zone) {\n if (zone == null) {\n return getDefault();\n }\n final String id = zone.getID();\n if (id == null) {\n throw new IllegalArgumentException("The TimeZone id must not be null");\n }\n if (id.equals("UTC")) {\n return DateTimeZone.UTC;\n }\n // Convert from old alias before consulting provider since they may differ.\n DateTimeZone dtz = null;\n String convId = getConvertedId(id);\n if (convId != null) {\n dtz = cProvider.getZone(convId);\n }\n if (dtz == null) {\n dtz = cProvider.getZone(id);\n }\n if (dtz != null) {\n return dtz;\n }\n // Support GMT+/-hh:mm formats\n if (convId == null) {\n convId = id;\n if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {\n convId = convId.substring(3);\n int offset = parseOffset(convId);\n if (offset == 0L) {\n return DateTimeZone.UTC;\n } else {\n convId = printOffset(offset);\n return fixedOffsetZone(convId, offset);\n }\n }\n }\n throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised");\n }\n 
840	private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n if (offset == 0) {\n return DateTimeZone.UTC;\n }\n if (iFixedOffsetCache == null) {\n iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n }\n DateTimeZone zone;\n Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n if (ref != null) {\n zone = ref.get();\n if (zone != null) {\n return zone;\n }\n }\n zone = new FixedDateTimeZone(id, null, offset, offset);\n iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n return zone;\n }\n 
841	public static Set<String> getAvailableIDs() {\n return cAvailableIDs;\n }\n 
842	public static Provider getProvider() {\n return cProvider;\n }\n 
843	public static void setProvider(Provider provider) throws SecurityException {\n SecurityManager sm = System.getSecurityManager();\n if (sm != null) {\n sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider"));\n }\n setProvider0(provider);\n }\n 
844	private static void setProvider0(Provider provider) {\n if (provider == null) {\n provider = getDefaultProvider();\n }\n Set<String> ids = provider.getAvailableIDs();\n if (ids == null || ids.size() == 0) {\n throw new IllegalArgumentException\n ("The provider doesn't have any available ids");\n }\n if (!ids.contains("UTC")) {\n throw new IllegalArgumentException("The provider doesn't support UTC");\n }\n if (!UTC.equals(provider.getZone("UTC"))) {\n throw new IllegalArgumentException("Invalid UTC zone provided");\n }\n cProvider = provider;\n cAvailableIDs = ids;\n }\n 
845	private static Provider getDefaultProvider() {\n Provider provider = null;\n try {\n String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider");\n if (providerClass != null) {\n try {\n provider = (Provider) Class.forName(providerClass).newInstance();\n } catch (Exception ex) {\n throw new RuntimeException(ex);\n }\n }\n } catch (SecurityException ex) {\n // ignored\n }\n if (provider == null) {\n try {\n provider = new ZoneInfoProvider("org/joda/time/tz/data");\n } catch (Exception ex) {\n ex.printStackTrace();\n }\n }\n if (provider == null) {\n provider = new UTCProvider();\n }\n return provider;\n }\n 
846	public static NameProvider getNameProvider() {\n return cNameProvider;\n }\n 
847	public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n SecurityManager sm = System.getSecurityManager();\n if (sm != null) {\n sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider"));\n }\n setNameProvider0(nameProvider);\n }\n 
848	private static void setNameProvider0(NameProvider nameProvider) {\n if (nameProvider == null) {\n nameProvider = getDefaultNameProvider();\n }\n cNameProvider = nameProvider;\n }\n 
849	private static NameProvider getDefaultNameProvider() {\n NameProvider nameProvider = null;\n try {\n String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider");\n if (providerClass != null) {\n try {\n nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n } catch (Exception ex) {\n throw new RuntimeException(ex);\n }\n }\n } catch (SecurityException ex) {\n // ignore\n }\n if (nameProvider == null) {\n nameProvider = new DefaultNameProvider();\n }\n return nameProvider;\n }\n 
850	private static synchronized String getConvertedId(String id) {\n Map<String, String> map = cZoneIdConversion;\n if (map == null) {\n // Backwards compatibility with TimeZone.\n map = new HashMap<String, String>();\n map.put("GMT", "UTC");\n map.put("WET", "WET");\n map.put("CET", "CET");\n map.put("MET", "CET");\n map.put("ECT", "CET");\n map.put("EET", "EET");\n map.put("MIT", "Pacific/Apia");\n map.put("HST", "Pacific/Honolulu");  // JDK 1.1 compatible\n map.put("AST", "America/Anchorage");\n map.put("PST", "America/Los_Angeles");\n map.put("MST", "America/Denver");  // JDK 1.1 compatible\n map.put("PNT", "America/Phoenix");\n map.put("CST", "America/Chicago");\n map.put("EST", "America/New_York");  // JDK 1.1 compatible\n map.put("IET", "America/Indiana/Indianapolis");\n map.put("PRT", "America/Puerto_Rico");\n map.put("CNT", "America/St_Johns");\n map.put("AGT", "America/Argentina/Buenos_Aires");\n map.put("BET", "America/Sao_Paulo");\n map.put("ART", "Africa/Cairo");\n map.put("CAT", "Africa/Harare");\n map.put("EAT", "Africa/Addis_Ababa");\n map.put("NET", "Asia/Yerevan");\n map.put("PLT", "Asia/Karachi");\n map.put("IST", "Asia/Kolkata");\n map.put("BST", "Asia/Dhaka");\n map.put("VST", "Asia/Ho_Chi_Minh");\n map.put("CTT", "Asia/Shanghai");\n map.put("JST", "Asia/Tokyo");\n map.put("ACT", "Australia/Darwin");\n map.put("AET", "Australia/Sydney");\n map.put("SST", "Pacific/Guadalcanal");\n map.put("NST", "Pacific/Auckland");\n cZoneIdConversion = map;\n }\n return map.get(id);\n }\n 
851	private static int parseOffset(String str) {\n // Can't use a real chronology if called during class\n // initialization. Offset parser doesn't need it anyhow.\n Chronology chrono = new BaseChronology() {\n private static final long serialVersionUID = -3128740902654445468L;\n public DateTimeZone getZone() {\n return null;\n }\n public Chronology withUTC() {\n return this;\n }\n public Chronology withZone(DateTimeZone zone) {\n return this;\n }\n public String toString() {\n return getClass().getName();\n }\n };\n return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n }\n 
852	public DateTimeZone getZone() {\n return null;\n }\n 
853	public Chronology withUTC() {\n return this;\n }\n 
854	public Chronology withZone(DateTimeZone zone) {\n return this;\n }\n 
855	public String toString() {\n return getID();\n }\n 
856	private static String printOffset(int offset) {\n StringBuffer buf = new StringBuffer();\n if (offset >= 0) {\n buf.append('+');\n } else {\n buf.append('-');\n offset = -offset;\n }\n int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n FormatUtils.appendPaddedInteger(buf, hours, 2);\n offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n buf.append(':');\n FormatUtils.appendPaddedInteger(buf, minutes, 2);\n offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n if (offset == 0) {\n return buf.toString();\n }\n int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n buf.append(':');\n FormatUtils.appendPaddedInteger(buf, seconds, 2);\n offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n if (offset == 0) {\n return buf.toString();\n }\n buf.append('.');\n FormatUtils.appendPaddedInteger(buf, offset, 3);\n return buf.toString();\n }\n 
857	private static synchronized DateTimeFormatter offsetFormatter() {\n if (cOffsetFormatter == null) {\n cOffsetFormatter = new DateTimeFormatterBuilder()\n .appendTimeZoneOffset(null, true, 2, 4)\n .toFormatter();\n }\n return cOffsetFormatter;\n }\n 
858	protected DateTimeZone(String id) {\n if (id == null) {\n throw new IllegalArgumentException("Id must not be null");\n }\n iID = id;\n }\n 
859	@ToString\n public final String getID() {\n return iID;\n }\n 
860	public final String getShortName(long instant) {\n return getShortName(instant, null);\n }\n 
861	public String getShortName(long instant, Locale locale) {\n if (locale == null) {\n locale = Locale.getDefault();\n }\n String nameKey = getNameKey(instant);\n if (nameKey == null) {\n return iID;\n }\n String name = cNameProvider.getShortName(locale, iID, nameKey);\n if (name != null) {\n return name;\n }\n return printOffset(getOffset(instant));\n }\n 
862	public final String getName(long instant) {\n return getName(instant, null);\n }\n 
863	public String getName(long instant, Locale locale) {\n if (locale == null) {\n locale = Locale.getDefault();\n }\n String nameKey = getNameKey(instant);\n if (nameKey == null) {\n return iID;\n }\n String name = cNameProvider.getName(locale, iID, nameKey);\n if (name != null) {\n return name;\n }\n return printOffset(getOffset(instant));\n }\n 
864	public final int getOffset(ReadableInstant instant) {\n if (instant == null) {\n return getOffset(DateTimeUtils.currentTimeMillis());\n }\n return getOffset(instant.getMillis());\n }\n 
865	public boolean isStandardOffset(long instant) {\n return getOffset(instant) == getStandardOffset(instant);\n }\n 
866	public int getOffsetFromLocal(long instantLocal) {\n // get the offset at instantLocal (first estimate)\n final int offsetLocal = getOffset(instantLocal);\n // adjust instantLocal using the estimate and recalc the offset\n final long instantAdjusted = instantLocal - offsetLocal;\n final int offsetAdjusted = getOffset(instantAdjusted);\n // if the offsets differ, we must be near a DST boundary\n if (offsetLocal != offsetAdjusted) {\n // we need to ensure that time is always after the DST gap\n // this happens naturally for positive offsets, but not for negative\n if ((offsetLocal - offsetAdjusted) < 0) {\n // if we just return offsetAdjusted then the time is pushed\n // back before the transition, whereas it should be\n // on or after the transition\n long nextLocal = nextTransition(instantAdjusted);\n if (nextLocal == (instantLocal - offsetLocal)) {\n nextLocal = Long.MAX_VALUE;\n }\n long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n if (nextAdjusted == (instantLocal - offsetAdjusted)) {\n nextAdjusted = Long.MAX_VALUE;\n }\n if (nextLocal != nextAdjusted) {\n return offsetLocal;\n }\n }\n } else if (offsetLocal >= 0) {\n long prev = previousTransition(instantAdjusted);\n if (prev < instantAdjusted) {\n int offsetPrev = getOffset(prev);\n int diff = offsetPrev - offsetLocal;\n if (instantAdjusted - prev <= diff) {\n return offsetPrev;\n }\n }\n }\n return offsetAdjusted;\n }\n 
867	public long convertUTCToLocal(long instantUTC) {\n int offset = getOffset(instantUTC);\n long instantLocal = instantUTC + offset;\n // If there is a sign change, but the two values have the same sign...\n if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n throw new ArithmeticException("Adding time zone offset caused overflow");\n }\n return instantLocal;\n }\n 
868	public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n int offsetOriginal = getOffset(originalInstantUTC);\n long instantUTC = instantLocal - offsetOriginal;\n int offsetLocalFromOriginal = getOffset(instantUTC);\n if (offsetLocalFromOriginal == offsetOriginal) {\n return instantUTC;\n }\n return convertLocalToUTC(instantLocal, strict);\n }\n 
869	public long convertLocalToUTC(long instantLocal, boolean strict) {\n // get the offset at instantLocal (first estimate)\n int offsetLocal = getOffset(instantLocal);\n // adjust instantLocal using the estimate and recalc the offset\n int offset = getOffset(instantLocal - offsetLocal);\n // if the offsets differ, we must be near a DST boundary\n if (offsetLocal != offset) {\n // if strict then always check if in DST gap\n // otherwise only check if zone in Western hemisphere (as the\n // value of offset is already correct for Eastern hemisphere)\n if (strict || offsetLocal < 0) {\n // determine if we are in the DST gap\n long nextLocal = nextTransition(instantLocal - offsetLocal);\n if (nextLocal == (instantLocal - offsetLocal)) {\n nextLocal = Long.MAX_VALUE;\n }\n long nextAdjusted = nextTransition(instantLocal - offset);\n if (nextAdjusted == (instantLocal - offset)) {\n nextAdjusted = Long.MAX_VALUE;\n }\n if (nextLocal != nextAdjusted) {\n // yes we are in the DST gap\n if (strict) {\n // DST gap is not acceptable\n throw new IllegalInstantException(instantLocal, getID());\n } else {\n // DST gap is acceptable, but for the Western hemisphere\n // the offset is wrong and will result in local times\n // before the cutover so use the offsetLocal instead\n offset = offsetLocal;\n }\n }\n }\n }\n // check for overflow\n long instantUTC = instantLocal - offset;\n // If there is a sign change, but the two values have different signs...\n if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n throw new ArithmeticException("Subtracting time zone offset caused overflow");\n }\n return instantUTC;\n }\n 
870	public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n if (newZone == null) {\n newZone = DateTimeZone.getDefault();\n }\n if (newZone == this) {\n return oldInstant;\n }\n long instantLocal = convertUTCToLocal(oldInstant);\n return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n }\n 
871	public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n if (isFixed()) {\n return false;\n }\n try {\n localDateTime.toDateTime(this);\n return false;\n } catch (IllegalInstantException ex) {\n return true;\n }\n }\n 
872	public long adjustOffset(long instant, boolean earlierOrLater) {\n // a bit messy, but will work in all non-pathological cases\n \n // evaluate 3 hours before and after to work out if anything is happening\n long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n long offsetBefore = getOffset(instantBefore);\n long offsetAfter = getOffset(instantAfter);\n if (offsetBefore <= offsetAfter) {\n return instant;  // not an overlap (less than is a gap, equal is normal case)\n }\n \n // work out range of instants that have duplicate local times\n long diff = offsetBefore - offsetAfter;\n long transition = nextTransition(instantBefore);\n long overlapStart = transition - diff;\n long overlapEnd = transition + diff;\n if (instant < overlapStart || instant >= overlapEnd) {\n return instant;  // not an overlap\n }\n \n // calculate result\n long afterStart = instant - overlapStart;\n if (afterStart >= diff) {\n // currently in later offset\n return earlierOrLater ? instant : instant - diff;\n } else {\n // currently in earlier offset\n return earlierOrLater ? instant + diff : instant;\n }\n }\n 
873	public java.util.TimeZone toTimeZone() {\n return java.util.TimeZone.getTimeZone(iID);\n }\n 
874	public int hashCode() {\n return 57 + getID().hashCode();\n }\n 
875	protected Object writeReplace() throws ObjectStreamException {\n return new Stub(iID);\n }\n 
876	Stub(String id) {\n iID = id;\n }\n 
877	private void writeObject(ObjectOutputStream out) throws IOException {\n out.writeUTF(iID);\n }\n 
878	private void readObject(ObjectInputStream in) throws IOException {\n iID = in.readUTF();\n }\n 
879	private Object readResolve() throws ObjectStreamException {\n return forID(iID);\n }\n 
880	public static ISOChronology getInstanceUTC() {\n return INSTANCE_UTC;\n }\n 
881	public static ISOChronology getInstance() {\n return getInstance(DateTimeZone.getDefault());\n }\n 
882	public static ISOChronology getInstance(DateTimeZone zone) {\n if (zone == null) {\n zone = DateTimeZone.getDefault();\n }\n ISOChronology chrono = cCache.get(zone);\n if (chrono == null) {\n chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n ISOChronology oldChrono = cCache.putIfAbsent(zone, chrono);\n if (oldChrono != null) {\n chrono = oldChrono;\n }\n }\n return chrono;\n }\n 
883	private ISOChronology(Chronology base) {\n super(base, null);\n }\n 
884	public Chronology withUTC() {\n return INSTANCE_UTC;\n }\n 
885	public Chronology withZone(DateTimeZone zone) {\n if (zone == null) {\n zone = DateTimeZone.getDefault();\n }\n if (zone == getZone()) {\n return this;\n }\n return getInstance(zone);\n }\n 
886	public String toString() {\n String str = "ISOChronology";\n DateTimeZone zone = getZone();\n if (zone != null) {\n str = str + '[' + zone.getID() + ']';\n }\n return str;\n }\n 
887	protected void assemble(Fields fields) {\n if (getBase().getZone() == DateTimeZone.UTC) {\n // Use zero based century and year of century.\n fields.centuryOfEra = new DividedDateTimeField(\n ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n fields.centuries = fields.centuryOfEra.getDurationField();\n \n fields.yearOfCentury = new RemainderDateTimeField(\n (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n fields.weekyearOfCentury = new RemainderDateTimeField(\n (DividedDateTimeField) fields.centuryOfEra, fields.weekyears, DateTimeFieldType.weekyearOfCentury());\n }\n }\n 
888	public boolean equals(Object obj) {\n if (this == obj) {\n return true;\n }\n if (obj instanceof ISOChronology) {\n ISOChronology chrono = (ISOChronology) obj;\n return getZone().equals(chrono.getZone());\n }\n return false;\n }\n 
889	public int hashCode() {\n return "ISO".hashCode() * 11 + getZone().hashCode();\n }\n 
890	private Object writeReplace() {\n return new Stub(getZone());\n }\n 
891	Stub(DateTimeZone zone) {\n iZone = zone;\n }\n 
892	private Object readResolve() {\n return ISOChronology.getInstance(iZone);\n }\n 
893	private void writeObject(ObjectOutputStream out) throws IOException {\n out.writeObject(iZone);\n }\n 
894	private void readObject(ObjectInputStream in)\n throws IOException, ClassNotFoundException\n {\n iZone = (DateTimeZone)in.readObject();\n }\n 
895	public JodaTimePermission(String name) {\n super(name);\n }\n 
896	@FromString\n public static MutablePeriod parse(String str) {\n return parse(str, ISOPeriodFormat.standard());\n }\n 
897	public static MutablePeriod parse(String str, PeriodFormatter formatter) {\n return formatter.parsePeriod(str).toMutablePeriod();\n }\n 
898	public MutablePeriod() {\n super(0L, null, null);\n }\n 
899	public MutablePeriod(PeriodType type) {\n super(0L, type, null);\n }\n 
900	public MutablePeriod(int hours, int minutes, int seconds, int millis) {\n super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n }\n 
901	public MutablePeriod(int years, int months, int weeks, int days,\n int hours, int minutes, int seconds, int millis) {\n super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n }\n 
902	public MutablePeriod(int years, int months, int weeks, int days,\n int hours, int minutes, int seconds, int millis, PeriodType type) {\n super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n }\n 
903	public MutablePeriod(long duration) {\n super(duration);\n }\n 
904	public MutablePeriod(long duration, PeriodType type) {\n super(duration, type, null);\n }\n 
905	public MutablePeriod(long duration, Chronology chronology) {\n super(duration, null, chronology);\n }\n 
906	public MutablePeriod(long duration, PeriodType type, Chronology chronology) {\n super(duration, type, chronology);\n }\n 
907	public MutablePeriod(long startInstant, long endInstant) {\n super(startInstant, endInstant, null, null);\n }\n 
908	public MutablePeriod(long startInstant, long endInstant, PeriodType type) {\n super(startInstant, endInstant, type, null);\n }\n 
909	public MutablePeriod(long startInstant, long endInstant, Chronology chrono) {\n super(startInstant, endInstant, null, chrono);\n }\n 
910	public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n super(startInstant, endInstant, type, chrono);\n }\n 
911	public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {\n super(startInstant, endInstant, null);\n }\n 
912	public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n super(startInstant, endInstant, type);\n }\n 
913	public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) {\n super(startInstant, duration, null);\n }\n 
914	public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n super(startInstant, duration, type);\n }\n 
915	public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant) {\n super(duration, endInstant, null);\n }\n 
916	public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n super(duration, endInstant, type);\n }\n 
917	public MutablePeriod(Object period) {\n super(period, null, null);\n }\n 
918	public MutablePeriod(Object period, PeriodType type) {\n super(period, type, null);\n }\n 
919	public MutablePeriod(Object period, Chronology chrono) {\n super(period, null, chrono);\n }\n 
920	public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\n super(period, type, chrono);\n }\n 
921	public void clear() {\n super.setValues(new int[size()]);\n }\n 
922	public void setValue(int index, int value) {\n super.setValue(index, value);\n }\n 
923	public void set(DurationFieldType field, int value) {\n super.setField(field, value);\n }\n 
924	public void setPeriod(ReadablePeriod period) {\n super.setPeriod(period);\n }\n 
925	public void setPeriod(int years, int months, int weeks, int days,\n int hours, int minutes, int seconds, int millis) {\n super.setPeriod(years, months, weeks, days, hours, minutes, seconds, millis);\n }\n 
926	public void setPeriod(ReadableInterval interval) {\n if (interval == null) {\n setPeriod(0L);\n } else {\n Chronology chrono = DateTimeUtils.getChronology(interval.getChronology());\n setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono);\n }\n }\n 
927	public void setPeriod(ReadableInstant start, ReadableInstant end) {\n if (start == end) {\n setPeriod(0L);\n } else {\n long startMillis = DateTimeUtils.getInstantMillis(start);\n long endMillis = DateTimeUtils.getInstantMillis(end);\n Chronology chrono = DateTimeUtils.getIntervalChronology(start, end);\n setPeriod(startMillis, endMillis, chrono);\n }\n }\n 
928	public void setPeriod(long startInstant, long endInstant) {\n setPeriod(startInstant, endInstant, null);\n }\n 
929	public void setPeriod(long startInstant, long endInstant, Chronology chrono) {\n chrono = DateTimeUtils.getChronology(chrono);\n setValues(chrono.get(this, startInstant, endInstant));\n }\n 
930	public void setPeriod(ReadableDuration duration) {\n setPeriod(duration, null);\n }\n 
931	public void setPeriod(ReadableDuration duration, Chronology chrono) {\n long durationMillis = DateTimeUtils.getDurationMillis(duration);\n setPeriod(durationMillis, chrono);\n }\n 
932	public void setPeriod(long duration) {\n setPeriod(duration, null);\n }\n 
933	public void setPeriod(long duration, Chronology chrono) {\n chrono = DateTimeUtils.getChronology(chrono);\n setValues(chrono.get(this, duration));\n }\n 
934	public void add(DurationFieldType field, int value) {\n super.addField(field, value);\n }\n 
935	public void add(ReadablePeriod period) {\n super.addPeriod(period);\n }\n 
936	public void add(int years, int months, int weeks, int days,\n int hours, int minutes, int seconds, int millis) {\n setPeriod(\n FieldUtils.safeAdd(getYears(), years),\n FieldUtils.safeAdd(getMonths(), months),\n FieldUtils.safeAdd(getWeeks(), weeks),\n FieldUtils.safeAdd(getDays(), days),\n FieldUtils.safeAdd(getHours(), hours),\n FieldUtils.safeAdd(getMinutes(), minutes),\n FieldUtils.safeAdd(getSeconds(), seconds),\n FieldUtils.safeAdd(getMillis(), millis)\n );\n }\n 
937	public void add(ReadableInterval interval) {\n if (interval != null) {\n add(interval.toPeriod(getPeriodType()));\n }\n }\n 
938	public void add(ReadableDuration duration) {\n if (duration != null) {\n add(new Period(duration.getMillis(), getPeriodType()));\n }\n }\n 
939	public void add(long duration) {\n add(new Period(duration, getPeriodType()));\n }\n 
940	public void add(long duration, Chronology chrono) {\n add(new Period(duration, getPeriodType(), chrono));\n }\n 
941	public void mergePeriod(ReadablePeriod period) {\n super.mergePeriod(period);\n }\n 
942	public int getYears() {\n return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n }\n 
943	public int getMonths() {\n return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n }\n 
944	public int getWeeks() {\n return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n }\n 
945	public int getDays() {\n return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n }\n 
946	public int getHours() {\n return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n }\n 
947	public int getMinutes() {\n return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n }\n 
948	public int getSeconds() {\n return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n }\n 
949	public int getMillis() {\n return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n }\n 
950	public void setYears(int years) {\n super.setField(DurationFieldType.years(), years);\n }\n 
951	public void addYears(int years) {\n super.addField(DurationFieldType.years(), years);\n }\n 
952	public void setMonths(int months) {\n super.setField(DurationFieldType.months(), months);\n }\n 
953	public void addMonths(int months) {\n super.addField(DurationFieldType.months(), months);\n }\n 
954	public void setWeeks(int weeks) {\n super.setField(DurationFieldType.weeks(), weeks);\n }\n 
955	public void addWeeks(int weeks) {\n super.addField(DurationFieldType.weeks(), weeks);\n }\n 
956	public void setDays(int days) {\n super.setField(DurationFieldType.days(), days);\n }\n 
957	public void addDays(int days) {\n super.addField(DurationFieldType.days(), days);\n }\n 
958	public void setHours(int hours) {\n super.setField(DurationFieldType.hours(), hours);\n }\n 
959	public void addHours(int hours) {\n super.addField(DurationFieldType.hours(), hours);\n }\n 
960	public void setMinutes(int minutes) {\n super.setField(DurationFieldType.minutes(), minutes);\n }\n 
961	public void addMinutes(int minutes) {\n super.addField(DurationFieldType.minutes(), minutes);\n }\n 
962	public void setSeconds(int seconds) {\n super.setField(DurationFieldType.seconds(), seconds);\n }\n 
963	public void addSeconds(int seconds) {\n super.addField(DurationFieldType.seconds(), seconds);\n }\n 
964	public void setMillis(int millis) {\n super.setField(DurationFieldType.millis(), millis);\n }\n 
965	public void addMillis(int millis) {\n super.addField(DurationFieldType.millis(), millis);\n }\n 
966	public MutablePeriod copy() {\n return (MutablePeriod) clone();\n }\n 
967	public Object clone() {\n try {\n return super.clone();\n } catch (CloneNotSupportedException ex) {\n throw new InternalError("Clone error");\n }\n }\n 
968	private static void put(Map<String, DateTimeZone> map, String name, String id) {\n try {\n map.put(name, DateTimeZone.forID(id));\n } catch (RuntimeException ex) {\n // ignore\n }\n }\n 
969	protected DateTimeUtils() {\n super();\n }\n 
970	public static final long currentTimeMillis() {\n return cMillisProvider.getMillis();\n }\n 
971	public static final void setCurrentMillisSystem() throws SecurityException {\n checkPermission();\n cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n }\n 
972	public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n checkPermission();\n cMillisProvider = new FixedMillisProvider(fixedMillis);\n }\n 
973	public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {\n checkPermission();\n if (offsetMillis == 0) {\n cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n } else {\n cMillisProvider = new OffsetMillisProvider(offsetMillis);\n }\n }\n 
974	public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException {\n if (millisProvider == null) {\n throw new IllegalArgumentException("The MillisProvider must not be null");\n }\n checkPermission();\n cMillisProvider = millisProvider;\n }\n 
975	private static void checkPermission() throws SecurityException {\n SecurityManager sm = System.getSecurityManager();\n if (sm != null) {\n sm.checkPermission(new JodaTimePermission("CurrentTime.setProvider"));\n }\n }\n 
976	public static final long getInstantMillis(ReadableInstant instant) {\n if (instant == null) {\n return DateTimeUtils.currentTimeMillis();\n }\n return instant.getMillis();\n }\n 
977	public static final Chronology getInstantChronology(ReadableInstant instant) {\n if (instant == null) {\n return ISOChronology.getInstance();\n }\n Chronology chrono = instant.getChronology();\n if (chrono == null) {\n return ISOChronology.getInstance();\n }\n return chrono;\n }\n 
978	public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) {\n Chronology chrono = null;\n if (start != null) {\n chrono = start.getChronology();\n } else if (end != null) {\n chrono = end.getChronology();\n }\n if (chrono == null) {\n chrono = ISOChronology.getInstance();\n }\n return chrono;\n }\n 
979	public static final Chronology getIntervalChronology(ReadableInterval interval) {\n if (interval == null) {\n return ISOChronology.getInstance();\n }\n Chronology chrono = interval.getChronology();\n if (chrono == null) {\n return ISOChronology.getInstance();\n }\n return chrono;\n }\n 
980	public static final ReadableInterval getReadableInterval(ReadableInterval interval) {\n if (interval == null) {\n long now = DateTimeUtils.currentTimeMillis();\n interval = new Interval(now, now);\n }\n return interval;\n }\n 
981	public static final Chronology getChronology(Chronology chrono) {\n if (chrono == null) {\n return ISOChronology.getInstance();\n }\n return chrono;\n }\n 
982	public static final DateTimeZone getZone(DateTimeZone zone) {\n if (zone == null) {\n return DateTimeZone.getDefault();\n }\n return zone;\n }\n 
983	public static final PeriodType getPeriodType(PeriodType type) {\n if (type == null) {\n return PeriodType.standard();\n }\n return type;\n }\n 
984	public static final long getDurationMillis(ReadableDuration duration) {\n if (duration == null) {\n return 0L;\n }\n return duration.getMillis();\n }\n 
985	public static final boolean isContiguous(ReadablePartial partial) {\n if (partial == null) {\n throw new IllegalArgumentException("Partial must not be null");\n }\n DurationFieldType lastType = null;\n for (int i = 0; i < partial.size(); i++) {\n DateTimeField loopField = partial.getField(i);\n if (i > 0) {\n if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) {\n return false;\n }\n }\n lastType = loopField.getDurationField().getType();\n }\n return true;\n }\n 
986	public static final DateFormatSymbols getDateFormatSymbols(Locale locale) {\n try {\n Method method = DateFormatSymbols.class.getMethod("getInstance", new Class[] {Locale.class});\n return (DateFormatSymbols) method.invoke(null, new Object[] {locale});\n } catch (Exception ex) {\n return new DateFormatSymbols(locale);\n }\n }\n 
987	public static final Map<String, DateTimeZone> getDefaultTimeZoneNames() {\n return cZoneNames;\n }\n 
988	public static final void setDefaultTimeZoneNames(Map<String, DateTimeZone> names) {\n cZoneNames = Collections.unmodifiableMap(new HashMap<String, DateTimeZone>(names));\n }\n 
989	public static final double toJulianDay(long epochMillis) {\n // useful links\n // http://en.wikipedia.org/wiki/Julian_day#cite_note-13 - Wikipedia\n // http://aa.usno.navy.mil/data/docs/JulianDate.php" - USNO\n // http://users.zoominternet.net/~matto/Java/Julian%20Date%20Converter.htm - Julian Date Converter by Matt Oltersdorf\n // http://ssd.jpl.nasa.gov/tc.cgi#top - CalTech\n double epochDay = epochMillis / 86400000d;\n return epochDay + 2440587.5d;\n }\n 
990	public static final long toJulianDayNumber(long epochMillis) {\n return (long) Math.floor(toJulianDay(epochMillis) + 0.5d);\n }\n 
991	public static final long fromJulianDay(double julianDay) {\n double epochDay = julianDay - 2440587.5d;\n return (long) (epochDay * 86400000d);\n }\n 
992	public long getMillis() {\n return System.currentTimeMillis();\n }\n 
993	FixedMillisProvider(long fixedMillis) {\n iMillis = fixedMillis;\n }\n 
994	public long getMillis() {\n return iMillis;\n }\n 
995	OffsetMillisProvider(long offsetMillis) {\n iMillis = offsetMillis;\n }\n 
996	public long getMillis() {\n return System.currentTimeMillis() + iMillis;\n }\n 
997	public long subtract(long instant, int value) {\n if (value == Integer.MIN_VALUE) {\n return subtract(instant, (long) value);\n }\n return add(instant, -value);\n }\n 
998	public long subtract(long instant, long value) {\n if (value == Long.MIN_VALUE) {\n throw new ArithmeticException("Long.MIN_VALUE cannot be negated");\n }\n return add(instant, -value);\n }\n 
999	public static Interval parse(String str) {\n return new Interval(str);\n }\n 
1000	public Interval(long startInstant, long endInstant) {\n super(startInstant, endInstant, null);\n }\n 
1001	public Interval(long startInstant, long endInstant, DateTimeZone zone) {\n super(startInstant, endInstant, ISOChronology.getInstance(zone));\n }\n 
1002	public Interval(long startInstant, long endInstant, Chronology chronology) {\n super(startInstant, endInstant, chronology);\n }\n 
1003	public Interval(ReadableInstant start, ReadableInstant end) {\n super(start, end);\n }\n 
1004	public Interval(ReadableInstant start, ReadableDuration duration) {\n super(start, duration);\n }\n 
1005	public Interval(ReadableDuration duration, ReadableInstant end) {\n super(duration, end);\n }\n 
1006	public Interval(ReadableInstant start, ReadablePeriod period) {\n super(start, period);\n }\n 
1007	public Interval(ReadablePeriod period, ReadableInstant end) {\n super(period, end);\n }\n 
1008	public Interval(Object interval) {\n super(interval, null);\n }\n 
1009	public Interval(Object interval, Chronology chronology) {\n super(interval, chronology);\n }\n 
1010	public Interval toInterval() {\n return this;\n }\n 
1011	public Interval overlap(ReadableInterval interval) {\n interval = DateTimeUtils.getReadableInterval(interval);\n if (overlaps(interval) == false) {\n return null;\n }\n long start = Math.max(getStartMillis(), interval.getStartMillis());\n long end = Math.min(getEndMillis(), interval.getEndMillis());\n return new Interval(start, end, getChronology());\n }\n 
1012	public Interval gap(ReadableInterval interval) {\n interval = DateTimeUtils.getReadableInterval(interval);\n long otherStart = interval.getStartMillis();\n long otherEnd = interval.getEndMillis();\n long thisStart = getStartMillis();\n long thisEnd = getEndMillis();\n if (thisStart > otherEnd) {\n return new Interval(otherEnd, thisStart, getChronology());\n } else if (otherStart > thisEnd) {\n return new Interval(thisEnd, otherStart, getChronology());\n } else {\n return null;\n }\n }\n 
1013	public boolean abuts(ReadableInterval interval) {\n if (interval == null) {\n long now = DateTimeUtils.currentTimeMillis();\n return (getStartMillis() == now || getEndMillis() == now);\n } else {\n return (interval.getEndMillis() == getStartMillis() ||\n getEndMillis() == interval.getStartMillis());\n }\n }\n 
1014	public Interval withChronology(Chronology chronology) {\n if (getChronology() == chronology) {\n return this;\n }\n return new Interval(getStartMillis(), getEndMillis(), chronology);\n }\n 
1015	public Interval withStartMillis(long startInstant) {\n if (startInstant == getStartMillis()) {\n return this;\n }\n return new Interval(startInstant, getEndMillis(), getChronology());\n }\n 
1016	public Interval withStart(ReadableInstant start) {\n long startMillis = DateTimeUtils.getInstantMillis(start);\n return withStartMillis(startMillis);\n }\n 
1017	public Interval withEndMillis(long endInstant) {\n if (endInstant == getEndMillis()) {\n return this;\n }\n return new Interval(getStartMillis(), endInstant, getChronology());\n }\n 
1018	public Interval withEnd(ReadableInstant end) {\n long endMillis = DateTimeUtils.getInstantMillis(end);\n return withEndMillis(endMillis);\n }\n 
1019	public Interval withDurationAfterStart(ReadableDuration duration) {\n long durationMillis = DateTimeUtils.getDurationMillis(duration);\n if (durationMillis == toDurationMillis()) {\n return this;\n }\n Chronology chrono = getChronology();\n long startMillis = getStartMillis();\n long endMillis = chrono.add(startMillis, durationMillis, 1);\n return new Interval(startMillis, endMillis, chrono);\n }\n 
1020	public Interval withDurationBeforeEnd(ReadableDuration duration) {\n long durationMillis = DateTimeUtils.getDurationMillis(duration);\n if (durationMillis == toDurationMillis()) {\n return this;\n }\n Chronology chrono = getChronology();\n long endMillis = getEndMillis();\n long startMillis = chrono.add(endMillis, durationMillis, -1);\n return new Interval(startMillis, endMillis, chrono);\n }\n 
1021	public Interval withPeriodAfterStart(ReadablePeriod period) {\n if (period == null) {\n return withDurationAfterStart(null);\n }\n Chronology chrono = getChronology();\n long startMillis = getStartMillis();\n long endMillis = chrono.add(period, startMillis, 1);\n return new Interval(startMillis, endMillis, chrono);\n }\n 
1022	public Interval withPeriodBeforeEnd(ReadablePeriod period) {\n if (period == null) {\n return withDurationBeforeEnd(null);\n }\n Chronology chrono = getChronology();\n long endMillis = getEndMillis();\n long startMillis = chrono.add(period, endMillis, -1);\n return new Interval(startMillis, endMillis, chrono);\n }\n 
1023	public static DateTimeFormatter forPattern(String pattern) {\n return createFormatterForPattern(pattern);\n }\n 
1024	public static DateTimeFormatter forStyle(String style) {\n return createFormatterForStyle(style);\n }\n 
1025	public static String patternForStyle(String style, Locale locale) {\n DateTimeFormatter formatter = createFormatterForStyle(style);\n if (locale == null) {\n locale = Locale.getDefault();\n }\n // Not pretty, but it works.\n return ((StyleFormatter) formatter.getPrinter0()).getPattern(locale);\n }\n 
1026	public static DateTimeFormatter shortDate() {\n return createFormatterForStyleIndex(SHORT, NONE);\n }\n 
1027	public static DateTimeFormatter shortTime() {\n return createFormatterForStyleIndex(NONE, SHORT);\n }\n 
1028	public static DateTimeFormatter shortDateTime() {\n return createFormatterForStyleIndex(SHORT, SHORT);\n }\n 
1029	public static DateTimeFormatter mediumDate() {\n return createFormatterForStyleIndex(MEDIUM, NONE);\n }\n 
1030	public static DateTimeFormatter mediumTime() {\n return createFormatterForStyleIndex(NONE, MEDIUM);\n }\n 
1031	public static DateTimeFormatter mediumDateTime() {\n return createFormatterForStyleIndex(MEDIUM, MEDIUM);\n }\n 
1032	public static DateTimeFormatter longDate() {\n return createFormatterForStyleIndex(LONG, NONE);\n }\n 
1033	public static DateTimeFormatter longTime() {\n return createFormatterForStyleIndex(NONE, LONG);\n }\n 
1034	public static DateTimeFormatter longDateTime() {\n return createFormatterForStyleIndex(LONG, LONG);\n }\n 
1035	public static DateTimeFormatter fullDate() {\n return createFormatterForStyleIndex(FULL, NONE);\n }\n 
1036	public static DateTimeFormatter fullTime() {\n return createFormatterForStyleIndex(NONE, FULL);\n }\n 
1037	public static DateTimeFormatter fullDateTime() {\n return createFormatterForStyleIndex(FULL, FULL);\n }\n 
1038	static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n parsePatternTo(builder, pattern);\n }\n 
1039	protected DateTimeFormat() {\n super();\n }\n 
1040	private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n int length = pattern.length();\n int[] indexRef = new int[1];\n for (int i=0; i<length; i++) {\n indexRef[0] = i;\n String token = parseToken(pattern, indexRef);\n i = indexRef[0];\n int tokenLen = token.length();\n if (tokenLen == 0) {\n break;\n }\n char c = token.charAt(0);\n switch (c) {\n case 'G': // era designator (text)\n builder.appendEraText();\n break;\n case 'C': // century of era (number)\n builder.appendCenturyOfEra(tokenLen, tokenLen);\n break;\n case 'x': // weekyear (number)\n case 'y': // year (number)\n case 'Y': // year of era (number)\n if (tokenLen == 2) {\n boolean lenientParse = true;\n // Peek ahead to next token.\n if (i + 1 < length) {\n indexRef[0]++;\n if (isNumericToken(parseToken(pattern, indexRef))) {\n // If next token is a number, cannot support\n // lenient parse, because it will consume digits\n // that it should not.\n lenientParse = false;\n }\n indexRef[0]--;\n }\n // Use pivots which are compatible with SimpleDateFormat.\n switch (c) {\n case 'x':\n builder.appendTwoDigitWeekyear\n (new DateTime().getWeekyear() - 30, lenientParse);\n break;\n case 'y':\n case 'Y':\n default:\n builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n break;\n }\n } else {\n // Try to support long year values.\n int maxDigits = 9;\n // Peek ahead to next token.\n if (i + 1 < length) {\n indexRef[0]++;\n if (isNumericToken(parseToken(pattern, indexRef))) {\n // If next token is a number, cannot support long years.\n maxDigits = tokenLen;\n }\n indexRef[0]--;\n }\n switch (c) {\n case 'x':\n builder.appendWeekyear(tokenLen, maxDigits);\n break;\n case 'y':\n builder.appendYear(tokenLen, maxDigits);\n break;\n case 'Y':\n builder.appendYearOfEra(tokenLen, maxDigits);\n break;\n }\n }\n break;\n case 'M': // month of year (text and number)\n if (tokenLen >= 3) {\n if (tokenLen >= 4) {\n builder.appendMonthOfYearText();\n } else {\n builder.appendMonthOfYearShortText();\n }\n } else {\n builder.appendMonthOfYear(tokenLen);\n }\n break;\n case 'd': // day of month (number)\n builder.appendDayOfMonth(tokenLen);\n break;\n case 'a': // am/pm marker (text)\n builder.appendHalfdayOfDayText();\n break;\n case 'h': // clockhour of halfday (number, 1..12)\n builder.appendClockhourOfHalfday(tokenLen);\n break;\n case 'H': // hour of day (number, 0..23)\n builder.appendHourOfDay(tokenLen);\n break;\n case 'k': // clockhour of day (1..24)\n builder.appendClockhourOfDay(tokenLen);\n break;\n case 'K': // hour of halfday (0..11)\n builder.appendHourOfHalfday(tokenLen);\n break;\n case 'm': // minute of hour (number)\n builder.appendMinuteOfHour(tokenLen);\n break;\n case 's': // second of minute (number)\n builder.appendSecondOfMinute(tokenLen);\n break;\n case 'S': // fraction of second (number)\n builder.appendFractionOfSecond(tokenLen, tokenLen);\n break;\n case 'e': // day of week (number)\n builder.appendDayOfWeek(tokenLen);\n break;\n case 'E': // dayOfWeek (text)\n if (tokenLen >= 4) {\n builder.appendDayOfWeekText();\n } else {\n builder.appendDayOfWeekShortText();\n }\n break;\n case 'D': // day of year (number)\n builder.appendDayOfYear(tokenLen);\n break;\n case 'w': // week of weekyear (number)\n builder.appendWeekOfWeekyear(tokenLen);\n break;\n case 'z': // time zone (text)\n if (tokenLen >= 4) {\n builder.appendTimeZoneName();\n } else {\n builder.appendTimeZoneShortName(null);\n }\n break;\n case 'Z': // time zone offset\n if (tokenLen == 1) {\n builder.appendTimeZoneOffset(null, "Z", false, 2, 2);\n } else if (tokenLen == 2) {\n builder.appendTimeZoneOffset(null, "Z", true, 2, 2);\n } else {\n builder.appendTimeZoneId();\n }\n break;\n case '\'': // literal text\n String sub = token.substring(1);\n if (sub.length() == 1) {\n builder.appendLiteral(sub.charAt(0));\n } else {\n // Create copy of sub since otherwise the temporary quoted\n // string would still be referenced internally.\n builder.appendLiteral(new String(sub));\n }\n break;\n default:\n throw new IllegalArgumentException\n ("Illegal pattern component: " + token);\n }\n }\n }\n 
1041	private static String parseToken(String pattern, int[] indexRef) {\n StringBuilder buf = new StringBuilder();\n int i = indexRef[0];\n int length = pattern.length();\n char c = pattern.charAt(i);\n if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n // Scan a run of the same character, which indicates a time\n // pattern.\n buf.append(c);\n while (i + 1 < length) {\n char peek = pattern.charAt(i + 1);\n if (peek == c) {\n buf.append(c);\n i++;\n } else {\n break;\n }\n }\n } else {\n // This will identify token as text.\n buf.append('\'');\n boolean inLiteral = false;\n for (; i < length; i++) {\n c = pattern.charAt(i);\n \n if (c == '\'') {\n if (i + 1 < length && pattern.charAt(i + 1) == '\'') {\n // '' is treated as escaped '\n i++;\n buf.append(c);\n } else {\n inLiteral = !inLiteral;\n }\n } else if (!inLiteral &&\n (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n i--;\n break;\n } else {\n buf.append(c);\n }\n }\n }\n indexRef[0] = i;\n return buf.toString();\n }\n 
1042	private static boolean isNumericToken(String token) {\n int tokenLen = token.length();\n if (tokenLen > 0) {\n char c = token.charAt(0);\n switch (c) {\n case 'c': // century (number)\n case 'C': // century of era (number)\n case 'x': // weekyear (number)\n case 'y': // year (number)\n case 'Y': // year of era (number)\n case 'd': // day of month (number)\n case 'h': // hour of day (number, 1..12)\n case 'H': // hour of day (number, 0..23)\n case 'm': // minute of hour (number)\n case 's': // second of minute (number)\n case 'S': // fraction of second (number)\n case 'e': // day of week (number)\n case 'D': // day of year (number)\n case 'F': // day of week in month (number)\n case 'w': // week of year (number)\n case 'W': // week of month (number)\n case 'k': // hour of day (1..24)\n case 'K': // hour of day (0..11)\n return true;\n case 'M': // month of year (text and number)\n if (tokenLen <= 2) {\n return true;\n }\n }\n }\n \n return false;\n }\n 
1043	private static DateTimeFormatter createFormatterForPattern(String pattern) {\n if (pattern == null || pattern.length() == 0) {\n throw new IllegalArgumentException("Invalid pattern specification");\n }\n DateTimeFormatter formatter = cPatternCache.get(pattern);\n if (formatter == null) {\n DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n parsePatternTo(builder, pattern);\n formatter = builder.toFormatter();\n if (cPatternCache.size() < PATTERN_CACHE_SIZE) {\n // the size check is not locked against concurrent access,\n // but is accepted to be slightly off in contention scenarios.\n DateTimeFormatter oldFormatter = cPatternCache.putIfAbsent(pattern, formatter);\n if (oldFormatter != null) {\n formatter = oldFormatter;\n }\n }\n }\n return formatter;\n }\n 
1044	private static DateTimeFormatter createFormatterForStyle(String style) {\n if (style == null || style.length() != 2) {\n throw new IllegalArgumentException("Invalid style specification: " + style);\n }\n int dateStyle = selectStyle(style.charAt(0));\n int timeStyle = selectStyle(style.charAt(1));\n if (dateStyle == NONE && timeStyle == NONE) {\n throw new IllegalArgumentException("Style '--' is invalid");\n }\n return createFormatterForStyleIndex(dateStyle, timeStyle);\n }\n 
1045	private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {\n int index = ((dateStyle << 2) + dateStyle) + timeStyle;  // (dateStyle * 5 + timeStyle);\n // Should never happen but do a double check...\n if (index >= cStyleCache.length()) {\n return createDateTimeFormatter(dateStyle, timeStyle);\n }\n DateTimeFormatter f = cStyleCache.get(index);\n if (f == null) {\n f = createDateTimeFormatter(dateStyle, timeStyle);\n if (cStyleCache.compareAndSet(index, null, f) == false) {\n f = cStyleCache.get(index);\n }\n }\n return f;\n }\n 
1046	private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle){\n int type = DATETIME;\n if (dateStyle == NONE) {\n type = TIME;\n } else if (timeStyle == NONE) {\n type = DATE;\n }\n StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type);\n return new DateTimeFormatter(llf, llf);\n }\n 
1047	private static int selectStyle(char ch) {\n switch (ch) {\n case 'S':\n return SHORT;\n case 'M':\n return MEDIUM;\n case 'L':\n return LONG;\n case 'F':\n return FULL;\n case '-':\n return NONE;\n default:\n throw new IllegalArgumentException("Invalid style character: " + ch);\n }\n }\n 
1048	StyleFormatter(int dateStyle, int timeStyle, int type) {\n super();\n iDateStyle = dateStyle;\n iTimeStyle = timeStyle;\n iType = type;\n }\n 
1049	public int estimatePrintedLength() {\n return 40;  // guess\n }\n 
1050	public void printTo(\n Appendable appenadble, long instant, Chronology chrono,\n int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n InternalPrinter p = getFormatter(locale).getPrinter0();\n p.printTo(appenadble, instant, chrono, displayOffset, displayZone, locale);\n }\n 
1051	public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {\n InternalPrinter p = getFormatter(locale).getPrinter0();\n p.printTo(appendable, partial, locale);\n }\n 
1052	public int estimateParsedLength() {\n return 40;  // guess\n }\n 
1053	public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {\n InternalParser p = getFormatter(bucket.getLocale()).getParser0();\n return p.parseInto(bucket, text, position);\n }\n 
1054	private DateTimeFormatter getFormatter(Locale locale) {\n locale = (locale == null ? Locale.getDefault() : locale);\n StyleFormatterCacheKey key = new StyleFormatterCacheKey(iType, iDateStyle, iTimeStyle, locale);\n DateTimeFormatter f = cCache.get(key);\n if (f == null) {\n f = DateTimeFormat.forPattern(getPattern(locale));\n DateTimeFormatter oldFormatter = cCache.putIfAbsent(key, f);\n if (oldFormatter != null) {\n f = oldFormatter;\n }\n }\n return f;\n }\n 
1055	String getPattern(Locale locale) {\n DateFormat f = null;\n switch (iType) {\n case DATE:\n f = DateFormat.getDateInstance(iDateStyle, locale);\n break;\n case TIME:\n f = DateFormat.getTimeInstance(iTimeStyle, locale);\n break;\n case DATETIME:\n f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);\n break;\n }\n if (f instanceof SimpleDateFormat == false) {\n throw new IllegalArgumentException("No datetime pattern for locale: " + locale);\n }\n return ((SimpleDateFormat) f).toPattern();\n }\n 
1056	public StyleFormatterCacheKey(int iType, int iDateStyle,\n int iTimeStyle, Locale locale) {\n this.locale = locale;\n // keeping old key generation logic of shifting type and style\n this.combinedTypeAndStyle = iType + (iDateStyle << 4) + (iTimeStyle << 8);\n }\n 
1057	@Override\n public int hashCode() {\n final int prime = 31;\n int result = 1;\n result = prime * result + combinedTypeAndStyle;\n result = prime * result + ((locale == null) ? 0 : locale.hashCode());\n return result;\n }\n 
1058	@Override\n public boolean equals(Object obj) {\n if (this == obj) {\n return true;\n }\n if (obj == null) {\n return false;\n }\n if (!(obj instanceof StyleFormatterCacheKey)) {\n return false;\n }\n StyleFormatterCacheKey other = (StyleFormatterCacheKey) obj;\n if (combinedTypeAndStyle != other.combinedTypeAndStyle) {\n return false;\n }\n if (locale == null) {\n if (other.locale != null) {\n return false;\n }\n } else if (!locale.equals(other.locale)) {\n return false;\n }\n return true;\n }\n 
