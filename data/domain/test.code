1	public void register(TermState state, final int ord) {\n    assert state != null : "state must not be null";\n    assert ord >= 0 && ord < states.length;\n    assert states[ord] == null : "state for ord: " + ord\n        + " already registered";\n    states[ord] = state;\n  }
2	private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n                  totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n                    hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException("setShardIndex is false but TopDocs[" + ref.shardIndex + "].scoreDocs[" + (ref.hitIndex-1) + "] is not set");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n                    queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }
3	public int step(int state, int label) {\n    assert state >= 0;\n    assert label >= 0;\n    int trans = states[2*state];\n    int limit = trans + 3*states[2*state+1];\n        while (trans < limit) {\n      int dest = transitions[trans];\n      int min = transitions[trans+1];\n      int max = transitions[trans+2];\n      if (min <= label && label <= max) {\n        return dest;\n      }\n      trans += 3;\n    }\n\n    return -1;\n  }
4	private PhraseQuery addSlopToPhrase(PhraseQuery query, int slop) {\n    PhraseQuery.Builder builder = new PhraseQuery.Builder();\n    builder.setSlop(slop);\n    org.apache.lucene.index.Term[] terms = query.getTerms();\n    int[] positions = query.getPositions();\n    for (int i = 0; i < terms.length; ++i) {\n      builder.add(terms[i], positions[i]);\n    }\n\n    return builder.build();\n  }
5	private static void putAll(final Map<String, Object> src, Map<String, Object> dest) {\n        for (final String key : src.keySet()) {\n            if (shortValues.contains(key)) {\n                dest.put(key, getShort(src, key));\n            } else if (booleanValues.contains(key)) {\n                dest.put(key, getBoolean(src, key));\n            } else if (borderTypeValues.contains(key)) {\n                dest.put(key, getBorderStyle(src, key));\n            } else if (ALIGNMENT.equals(key)) {\n                dest.put(key, getHorizontalAlignment(src, key));\n            } else if (VERTICAL_ALIGNMENT.equals(key)) {\n                dest.put(key, getVerticalAlignment(src, key));\n            } else if (FILL_PATTERN.equals(key)) {\n                dest.put(key, getFillPattern(src, key));\n            } else {\n                if (log.check(POILogger.INFO)) {\n                    log.log(POILogger.INFO, "Ignoring unrecognized CellUtil format properties key: " + key);\n                }\n            }\n        }\n    }
6	@Internal\n	public void replaceText(String pPlaceHolder, String pValue, int pOffset) {\n		int absPlaceHolderIndex = getStartOffset() + pOffset;\n\n		Range subRange = new Range(absPlaceHolderIndex,\n				(absPlaceHolderIndex + pPlaceHolder.length()), this);\n		subRange.insertBefore(pValue);\n\n				subRange = new Range((absPlaceHolderIndex + pValue.length()), (absPlaceHolderIndex\n				+ pPlaceHolder.length() + pValue.length()), this);\n\n				subRange.delete();\n	}
7	public static BytesRef intsRefToBytesRef(IntsRef ints) {\n    byte[] bytes = new byte[ints.length];\n    for(int i=0;i<ints.length;i++) {\n      int x = ints.ints[ints.offset+i];\n      if (x < 0 || x > 255) {\n        throw new IllegalArgumentException("int at pos=" + i + " with value=" + x + " is out-of-bounds for byte");\n      }\n      bytes[i] = (byte) x;\n    }\n\n    return new BytesRef(bytes);\n  }
8	public void bulletedItemInCell(HSSFWorkbook workbook, String listItem, HSSFCell cell) {\n                        HSSFDataFormat format = workbook.createDataFormat();\n        String formatString = InCellLists.BULLET_CHARACTER + " @";\n        int formatIndex = format.getFormat(formatString);\n\n                        HSSFCellStyle bulletStyle = workbook.createCellStyle();\n        bulletStyle.setDataFormat((short)formatIndex);\n\n                cell.setCellValue(new HSSFRichTextString(listItem));\n        cell.setCellStyle(bulletStyle);\n    }
9	static CopyState readCopyState(DataInput in) throws IOException {\n\n        byte[] infosBytes = new byte[in.readVInt()];\n    in.readBytes(infosBytes, 0, infosBytes.length);\n\n    long gen = in.readVLong();\n    long version = in.readVLong();\n    Map<String,FileMetaData> files = readFilesMetaData(in);\n\n    int count = in.readVInt();\n    Set<String> completedMergeFiles = new HashSet<>();\n    for(int i=0;i<count;i++) {\n      completedMergeFiles.add(in.readString());\n    }\n    long primaryGen = in.readVLong();\n\n    return new CopyState(files, version, gen, infosBytes, completedMergeFiles, primaryGen, null);\n  }
10	public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    \n    while(true) {\n            if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n                if (finalOutput == targetOutput) {\n          result.setLength(upto);\n                    return result.get();\n        } else if (finalOutput > targetOutput) {\n                    return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n                result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n                    boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n                        if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            \n                                    final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n                                          output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                                return null;\n              } else {\n                                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                                break;\n              }\n            } else if (arc.isLast()) {\n                            output = minArcOutput;\n                            result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n                            prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n                            fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n                return null;\n      }\n    }    \n  }
11	public void addObjectTableEntry(HwmfObjectTableEntry entry) {\n        ListIterator<HwmfObjectTableEntry> oIter = objectTable.listIterator();\n        while (oIter.hasNext()) {\n            HwmfObjectTableEntry tableEntry = oIter.next();\n            if (tableEntry == null) {\n                oIter.set(entry);\n                return;\n            }\n        }\n        objectTable.add(entry);\n    }
12	public PackagePart getPart(PackagePartName partName) {\n		throwExceptionIfWriteOnly();\n\n		if (partName == null) {\n			throw new IllegalArgumentException("partName");\n		}\n\n				if (partList == null) {\n			try {\n				getParts();\n			} catch (InvalidFormatException e) {\n				return null;\n			}\n		}\n\n		return partList.get(partName);\n	}
13	static void writeInt(final OutputStream outputStream, final int value) throws IOException {\n    outputStream.write(value);\n    outputStream.write(value >> 8);\n    outputStream.write(value >> 16);\n    outputStream.write(value >> 24);\n  }
14	protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line;\n        if (orientation == PlotOrientation.VERTICAL) {\n            double xx = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        } else {\n            double yy = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }
15	public XWPFFootnote createFootnote() {\n        CTFtnEdn newNote = CTFtnEdn.Factory.newInstance(); \n        newNote.setType(STFtnEdn.NORMAL);\n\n        XWPFFootnote footnote = addFootnote(newNote);\n        footnote.getCTFtnEdn().setId(getIdManager().nextId());\n        return footnote;\n        \n    }
16	public boolean removeAnnotation(CategoryAnnotation annotation,\n            boolean notify) {\n        ParamChecks.nullNotPermitted(annotation, "annotation");\n        boolean removed = this.annotations.remove(annotation);\n        annotation.removeChangeListener(this);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }
17	private void rowToCSV(Row row) {\n        Cell cell;\n        int lastCellNum;\n        ArrayList<String> csvLine = new ArrayList<>();\n\n                                if(row != null) {\n\n                                                            lastCellNum = row.getLastCellNum();\n            for(int i = 0; i <= lastCellNum; i++) {\n                cell = row.getCell(i);\n                if(cell == null) {\n                    csvLine.add("");\n                }\n                else {\n                    if(cell.getCellType() != CellType.FORMULA) {\n                        csvLine.add(this.formatter.formatCellValue(cell));\n                    }\n                    else {\n                        csvLine.add(this.formatter.formatCellValue(cell, this.evaluator));\n                    }\n                }\n            }\n                                                if(lastCellNum > this.maxRowWidth) {\n                this.maxRowWidth = lastCellNum;\n            }\n        }\n        this.csvData.add(csvLine);\n    }
18	public final void draw() {\n        GraphicsContext ctx = getGraphicsContext2D();\n        ctx.save();\n        double width = getWidth();\n        double height = getHeight();\n        if (width > 0 && height > 0) {\n            ctx.clearRect(0, 0, width, height);\n            this.info = new ChartRenderingInfo();\n            this.chart.draw(this.g2, new Rectangle((int) width, (int) height), \n                    this.anchor, this.info);\n        }\n        ctx.restore();\n        this.anchor = null;\n    }
19	public String getSignificantDecimalDigitsLastDigitRounded() {\n		long wp = _wholePart + 5; 		StringBuilder sb = new StringBuilder(24);\n		sb.append(wp);\n		sb.setCharAt(sb.length()-1, '0');\n		return sb.toString();\n	}
20	static void errors(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue(84);\n        sheet.createRow(1).createCell(0).setCellValue(0);\n        sheet.createRow(2).createCell(0).setCellFormula("ROUND(A1/A2,0)");\n        sheet.createRow(3).createCell(0).setCellValue(0);\n        sheet.createRow(4).createCell(0).setCellFormula("ROUND(A6/A4,0)");\n        sheet.createRow(5).createCell(0).setCellValue(41);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("ISERROR(A1)");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontColorIndex(IndexedColors.WHITE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(1).setCellValue("<== The error in this cell is hidden. Condition: Formula Is   =ISERROR(C2)   (White Font)");\n        sheet.getRow(4).createCell(1).setCellValue("<== The error in this cell is hidden. Condition: Formula Is   =ISERROR(C2)   (White Font)");\n    }
21	public XWPFHeader createHeader(Enum type, XWPFParagraph[] pars) {\n        XWPFHeader header = getHeader(type);\n\n        if (header == null) {\n            HdrDocument hdrDoc = HdrDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.HEADER;\n            int i = getRelationIndex(relation);\n\n            XWPFHeader wrapper = (XWPFHeader) doc.createRelationship(relation,\n                    XWPFFactory.getInstance(), i);\n            wrapper.setXWPFDocument(doc);\n\n            CTHdrFtr hdr = buildHdr(type, wrapper, pars);\n            wrapper.setHeaderFooter(hdr);\n            hdrDoc.setHdr(hdr);\n            assignHeader(wrapper, type);\n            header = wrapper;\n        }\n\n        return header;\n    }
22	void buffer(char[] termPart, int startPos, int endPos, int startPart, int endPart) {\n    "buffer: pos=""-"" part=""-""  termIn=""  term="\n    assert endPos > startPos: "startPos=" + startPos + " endPos=" + endPos;\n    assert endPart > startPart || (endPart == 0 && startPart == 0 && savedTermLength == 0): "startPart=" + startPart + " endPart=" + endPart;\n    if ((bufferedLen+1)*4 > bufferedParts.length) {\n      bufferedParts = ArrayUtil.grow(bufferedParts, (bufferedLen+1)*4);\n    }\n    if (bufferedTermParts.length == bufferedLen) {\n      int newSize = ArrayUtil.oversize(bufferedLen+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n      char[][] newArray = new char[newSize][];\n      System.arraycopy(bufferedTermParts, 0, newArray, 0, bufferedTermParts.length);\n      bufferedTermParts = newArray;\n    }\n    bufferedTermParts[bufferedLen] = termPart;\n    bufferedParts[bufferedLen*4] = startPos;\n    bufferedParts[bufferedLen*4+1] = endPos;\n    bufferedParts[bufferedLen*4+2] = startPart;\n    bufferedParts[bufferedLen*4+3] = endPart;\n    bufferedLen++;\n  }
23	private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }
24	private void deleteCommits() throws IOException {\n\n    int size = commitsToDelete.size();\n\n    if (size > 0) {\n\n                  Throwable firstThrowable = null;\n      for(int i=0;i<size;i++) {\n        CommitPoint commit = commitsToDelete.get(i);\n        if (infoStream.isEnabled("IFD")) {\n          infoStream.message("IFD", "deleteCommits: now decRef commit \"" + commit.getSegmentsFileName() + "\"");\n        }\n        try {\n          decRef(commit.files);\n        } catch (Throwable t) {\n          if (firstThrowable == null) {\n            firstThrowable = t;\n          }\n        }\n      }\n      commitsToDelete.clear();\n\n      if (firstThrowable != null) {\n        throw IOUtils.rethrowAlways(firstThrowable);\n      }\n\n            size = commits.size();\n      int readFrom = 0;\n      int writeTo = 0;\n      while(readFrom < size) {\n        CommitPoint commit = commits.get(readFrom);\n        if (!commit.deleted) {\n          if (writeTo != readFrom) {\n            commits.set(writeTo, commits.get(readFrom));\n          }\n          writeTo++;\n        }\n        readFrom++;\n      }\n\n      while(size > writeTo) {\n        commits.remove(size-1);\n        size--;\n      }\n    }\n  }
25	public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n        for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!"*".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!"*".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!"*".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n        int left = buffer.remaining();\n        int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!("*".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096;         int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n                              if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }
26	public int freeBlocks(int num) {\n    assert num >= 0 : "free blocks must be >= 0 but was: "+ num;\n    final int stop;\n    final int count;\n    if (num > freeBlocks) {\n      stop = 0;\n      count = freeBlocks;\n    } else {\n      stop = freeBlocks - num;\n      count = num;\n    }\n    while (freeBlocks > stop) {\n      freeByteBlocks[--freeBlocks] = null;\n    }\n    bytesUsed.addAndGet(-count*blockSize);\n    assert bytesUsed.get() >= 0;\n    return count;\n  }
27	public static int countMatches(CharSequence haystack, char needle) {\n        if (haystack == null) return 0;\n        int count = 0;\n        final int length = haystack.length();\n        for (int i = 0; i < length; i++) {\n            if (haystack.charAt(i) == needle) {\n                count++;\n            }\n        }\n        return count;\n    }
28	public static double axisLat(double centerLat, double radiusMeters) {\n                                                            final double PIO2 = Math.PI / 2D;\n    double l1 = toRadians(centerLat);\n    double r = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;\n\n        if (Math.abs(l1) + r >= MAX_LAT_RADIANS) {\n      return centerLat >= 0 ? MAX_LAT_INCL : MIN_LAT_INCL;\n    }\n\n            l1 = centerLat >= 0 ? PIO2 - l1 : l1 + PIO2;\n\n    double l2 = Math.acos(Math.cos(l1) / Math.cos(r));\n    assert !Double.isNaN(l2);\n\n        l2 = centerLat >= 0 ? PIO2 - l2 : l2 - PIO2;\n\n    return toDegrees(l2);\n  }
29	public List<Cell> getMatchingCells(EvaluationConditionalFormatRule rule) {\n        final List<Cell> cells = new ArrayList<>();\n        final Sheet sheet = rule.getSheet();\n        \n        for (CellRangeAddress region : rule.getRegions()) {\n            for (int r = region.getFirstRow(); r <= region.getLastRow(); r++) {\n                final Row row = sheet.getRow(r);\n                if (row == null) {\n                    continue;                 }\n                for (int c = region.getFirstColumn(); c <= region.getLastColumn(); c++) {\n                    final Cell cell = row.getCell(c);\n                    if (cell == null) {\n                        continue;\n                    }\n                    \n                    List<EvaluationConditionalFormatRule> cellRules = getConditionalFormattingForCell(cell);\n                    if (cellRules.contains(rule)) {\n                        cells.add(cell);\n                    }\n                }\n            }\n        }\n        return Collections.unmodifiableList(cells);\n    }
30	private static boolean needsMemFunc(ParseNode root) {\n        Ptg token = root.getToken();\n        if (token instanceof AbstractFunctionPtg) {\n            return true;\n        }\n        if (token instanceof ExternSheetReferenceToken) {             return true;\n        }\n        if (token instanceof NamePtg || token instanceof NameXPtg) {             return true;\n        }\n\n        if (token instanceof OperationPtg || token instanceof ParenthesisPtg) {\n                        for(ParseNode child : root.getChildren()) {\n                if (needsMemFunc(child)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (token instanceof OperandPtg) {\n            return false;\n        }\n        if (token instanceof OperationPtg) {\n            return true;\n        }\n\n        return false;\n    }
31	public void removeItem(int sheetId, String ref){\n                int id = -1;\n        CTCalcCell[] c = chain.getCArray();\n\n        for (int i = 0; i < c.length; i++){\n                        if(c[i].isSetI()) id = c[i].getI();\n\n            if(id == sheetId && c[i].getR().equals(ref)){\n                if(c[i].isSetI() && i < c.length - 1 && !c[i+1].isSetI()) {\n                    c[i+1].setI(id);\n                }\n                chain.removeC(i);\n                break;\n            }\n        }\n    }
32	public static int getEncodedSizeWithoutArrayData(Ptg[] ptgs) {\n		int result = 0;\n		for (Ptg ptg : ptgs) {\n			if (ptg instanceof ArrayPtg) {\n				result += ArrayPtg.PLAIN_TOKEN_SIZE;\n			} else {\n				result += ptg.getSize();\n			}\n		}\n		return result;\n	}
33	private void parseAffix(TreeMap<String,List<Integer>> affixes,\n                          String header,\n                          LineNumberReader reader,\n                          String conditionPattern,\n                          Map<String,Integer> seenPatterns,\n                          Map<String,Integer> seenStrips) throws IOException, ParseException {\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n    StringBuilder sb = new StringBuilder();\n    String args[] = header.split("\\s+");\n\n    boolean crossProduct = args[2].equals("Y");\n    boolean isSuffix = conditionPattern == SUFFIX_CONDITION_REGEX_PATTERN;\n    \n    int numLines = Integer.parseInt(args[3]);\n    affixData = ArrayUtil.grow(affixData, (currentAffix << 3) + (numLines << 3));\n    ByteArrayDataOutput affixWriter = new ByteArrayDataOutput(affixData, currentAffix << 3, numLines << 3);\n    \n    for (int i = 0; i < numLines; i++) {\n      assert affixWriter.getPosition() == currentAffix << 3;\n      String line = reader.readLine();\n      String ruleArgs[] = line.split("\\s+");\n\n                  if (ruleArgs.length < 4) {\n          throw new ParseException("The affix file contains a rule with less than four elements: " + line, reader.getLineNumber());\n      }\n      \n      char flag = flagParsingStrategy.parseFlag(ruleArgs[1]);\n      String strip = ruleArgs[2].equals("0") ? "" : ruleArgs[2];\n      String affixArg = ruleArgs[3];\n      char appendFlags[] = null;\n      \n            int flagSep = affixArg.lastIndexOf('/');\n      if (flagSep != -1) {\n        String flagPart = affixArg.substring(flagSep + 1);\n        affixArg = affixArg.substring(0, flagSep);\n\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        appendFlags = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(appendFlags);\n        twoStageAffix = true;\n      }\n            if ("0".equals(affixArg)) {\n        affixArg = "";\n      }\n      \n      String condition = ruleArgs.length > 4 ? ruleArgs[4] : ".";\n            if (condition.startsWith("[") && condition.indexOf(']') == -1) {\n        condition = condition + "]";\n      }\n            if (condition.indexOf('-') >= 0) {\n        condition = escapeDash(condition);\n      }\n\n      final String regex;\n      if (".".equals(condition)) {\n        regex = ".*";       } else if (condition.equals(strip)) {\n        regex = ".*";                                                   } else {\n        regex = String.format(Locale.ROOT, conditionPattern, condition);\n      }\n      \n            Integer patternIndex = seenPatterns.get(regex);\n      if (patternIndex == null) {\n        patternIndex = patterns.size();\n        if (patternIndex > Short.MAX_VALUE) {\n          throw new UnsupportedOperationException("Too many patterns, please report this to dev@lucene.apache.org");          \n        }\n        seenPatterns.put(regex, patternIndex);\n        CharacterRunAutomaton pattern = new CharacterRunAutomaton(new RegExp(regex, RegExp.NONE).toAutomaton());\n        patterns.add(pattern);\n      }\n      \n      Integer stripOrd = seenStrips.get(strip);\n      if (stripOrd == null) {\n        stripOrd = seenStrips.size();\n        seenStrips.put(strip, stripOrd);\n        if (stripOrd > Character.MAX_VALUE) {\n          throw new UnsupportedOperationException("Too many unique strips, please report this to dev@lucene.apache.org");\n        }\n      }\n\n      if (appendFlags == null) {\n        appendFlags = NOFLAGS;\n      }\n      \n      encodeFlags(scratch, appendFlags);\n      int appendFlagsOrd = flagLookup.add(scratch.get());\n      if (appendFlagsOrd < 0) {\n                appendFlagsOrd = (-appendFlagsOrd)-1;\n      } else if (appendFlagsOrd > Short.MAX_VALUE) {\n                throw new UnsupportedOperationException("Too many unique append flags, please report this to dev@lucene.apache.org");\n      }\n      \n      affixWriter.writeShort((short)flag);\n      affixWriter.writeShort((short)stripOrd.intValue());\n            int patternOrd = patternIndex.intValue() << 1 | (crossProduct ? 1 : 0);\n      affixWriter.writeShort((short)patternOrd);\n      affixWriter.writeShort((short)appendFlagsOrd);\n      \n      if (needsInputCleaning) {\n        CharSequence cleaned = cleanInput(affixArg, sb);\n        affixArg = cleaned.toString();\n      }\n      \n      if (isSuffix) {\n        affixArg = new StringBuilder(affixArg).reverse().toString();\n      }\n      \n      List<Integer> list = affixes.get(affixArg);\n      if (list == null) {\n        list = new ArrayList<>();\n        affixes.put(affixArg, list);\n      }\n      list.add(currentAffix);\n      currentAffix++;\n    }\n  }
34	private int newSlice(final int size) {\n    if (intUpto > INT_BLOCK_SIZE-size) {\n      nextBuffer();\n      assert assertSliceBuffer(buffer);\n    }\n      \n    final int upto = intUpto;\n    intUpto += size;\n    buffer[intUpto-1] = 1;\n    return upto;\n  }
35	private void zzDoEOF() {\n    if (!zzEOFDone) {\n      zzEOFDone = true;\n      switch (zzLexicalState) {\n    case SCRIPT:\n    case COMMENT:\n    case SCRIPT_COMMENT:\n    case STYLE:\n    case STYLE_COMMENT:\n    case SINGLE_QUOTED_STRING:\n    case DOUBLE_QUOTED_STRING:\n    case END_TAG_TAIL_EXCLUDE:\n    case END_TAG_TAIL_SUBSTITUTE:\n    case START_TAG_TAIL_EXCLUDE:\n    case SERVER_SIDE_INCLUDE:\n    case START_TAG_TAIL_SUBSTITUTE: {             cumulativeDiff += yychar - inputStart;\n            addOffCorrectMap(outputCharCount, cumulativeDiff);\n      outputSegment.clear();\n      eofReturnValue = -1;\n      break;\n    }\n    case CHARACTER_REFERENCE_TAIL: {                          cumulativeDiff += inputSegment.length() - outputSegment.length();\n            addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      eofReturnValue = ( ! outputSegment.isRead()) ? outputSegment.nextChar() : -1;\n      break;\n    }\n    case BANG:\n    case CDATA:\n    case AMPERSAND:\n    case NUMERIC_CHARACTER:\n    case END_TAG_TAIL_INCLUDE:\n    case START_TAG_TAIL_INCLUDE:\n    case LEFT_ANGLE_BRACKET:\n    case LEFT_ANGLE_BRACKET_SLASH:\n    case LEFT_ANGLE_BRACKET_SPACE: {              outputSegment = inputSegment;\n      eofReturnValue = ( ! outputSegment.isRead()) ? outputSegment.nextChar() : -1;\n      break;\n    }\n    default: {\n      eofReturnValue = -1;\n    }\n  }\n\n    }\n  }
36	private static double invokeInternal(Function target, ValueEval[] args, int srcCellRow, int srcCellCol)\n				throws NumericEvalEx {\n		ValueEval evalResult;\n		try {\n			evalResult = target.evaluate(args, srcCellRow, (short)srcCellCol);\n		} catch (NotImplementedException e) {\n			throw new NumericEvalEx("Not implemented:" + e.getMessage());\n		}\n\n		if(evalResult == null) {\n			throw new NumericEvalEx("Result object was null");\n		}\n		if(evalResult instanceof ErrorEval) {\n			ErrorEval ee = (ErrorEval) evalResult;\n			throw new NumericEvalEx(formatErrorMessage(ee));\n		}\n		if(!(evalResult instanceof NumericValueEval)) {\n			throw new NumericEvalEx("Result object type (" + evalResult.getClass().getName()\n					+ ") is invalid.  Expected implementor of ("\n					+ NumericValueEval.class.getName() + ")");\n		}\n\n		NumericValueEval result = (NumericValueEval) evalResult;\n		return result.getNumberValue();\n	}
37	protected final void onSave(Set<PackagePart> alreadySaved) throws IOException {\n                if (this.isCommited) {\n            return;\n        }\n\n                prepareForCommit();\n\n        commit();\n        alreadySaved.add(this.getPackagePart());\n        for (RelationPart rp : relations.values()) {\n            POIXMLDocumentPart p = rp.getDocumentPart();\n            if (!alreadySaved.contains(p.getPackagePart())) {\n                p.onSave(alreadySaved);\n            }\n        }\n    }
38	public static Workbook create(InputStream inp, String password) throws IOException, EncryptedDocumentException {\n        InputStream is = FileMagic.prepareToCheckMagic(inp);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        switch (fm) {\n            case OLE2:\n                POIFSFileSystem fs = new POIFSFileSystem(is);\n                return create(fs, password);\n            case OOXML:\n                return createXSSFWorkbook(is);\n            default:\n                throw new IOException("Your InputStream was neither an OLE2 stream, nor an OOXML stream");\n        }\n    }
39	static I_MatchPredicate createCriteriaPredicate(ValueEval arg, int srcRowIndex, int srcColumnIndex) {\n\n        ValueEval evaluatedCriteriaArg = evaluateCriteriaArg(arg, srcRowIndex, srcColumnIndex);\n\n        if(evaluatedCriteriaArg instanceof NumberEval) {\n            return new NumberMatcher(((NumberEval)evaluatedCriteriaArg).getNumberValue(), CmpOp.OP_NONE);\n        }\n        if(evaluatedCriteriaArg instanceof BoolEval) {\n            return new BooleanMatcher(((BoolEval)evaluatedCriteriaArg).getBooleanValue(), CmpOp.OP_NONE);\n        }\n\n        if(evaluatedCriteriaArg instanceof StringEval) {\n            return createGeneralMatchPredicate((StringEval)evaluatedCriteriaArg);\n        }\n        if(evaluatedCriteriaArg instanceof ErrorEval) {\n            return new ErrorMatcher(((ErrorEval)evaluatedCriteriaArg).getErrorCode(), CmpOp.OP_NONE);\n        }\n        if(evaluatedCriteriaArg == BlankEval.instance) {\n            return null;\n        }\n        throw new RuntimeException("Unexpected type for criteria ("\n                + evaluatedCriteriaArg.getClass().getName() + ")");\n    }
40	public static Range iterateDomainBounds(XYDataset dataset,\n            boolean includeInterval) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue, uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = intervalXYData.getXValue(series, item);\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }
41	private static String normalizePartName(URI partName, String baseUri) throws XMLSignatureException {\n        String pn = partName.toASCIIString();\n        if (!pn.startsWith(baseUri)) {\n            pn = baseUri + pn;\n        }\n        try {\n            pn = new URI(pn).normalize().getPath().replace('\\', '/');\n            LOG.log(POILogger.DEBUG, "part name: " + pn);\n        } catch (URISyntaxException e) {\n            throw new XMLSignatureException(e);\n        }\n        return pn;\n    }
42	protected ByteBuffer getBlockAt(final int offset) {\n              int byteOffset = offset * POIFSConstants.SMALL_BLOCK_SIZE;\n       int bigBlockNumber = byteOffset / _filesystem.getBigBlockSize();\n       int bigBlockOffset = byteOffset % _filesystem.getBigBlockSize();\n       \n              Iterator<ByteBuffer> it = _mini_stream.getBlockIterator();\n       for(int i=0; i<bigBlockNumber; i++) {\n          it.next();\n       }\n       ByteBuffer dataBlock = it.next();\n       if(dataBlock == null) {\n          throw new IndexOutOfBoundsException("Big block " + bigBlockNumber + " outside stream");\n       }\n\n              dataBlock.position(\n             dataBlock.position() + bigBlockOffset\n       );\n       ByteBuffer miniBuffer = dataBlock.slice();\n       miniBuffer.limit(POIFSConstants.SMALL_BLOCK_SIZE);\n       return miniBuffer;\n    }
43	public final G acquire() throws IOException {\n    G ref;\n\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n      if (tryIncRef(ref)) {\n        return ref;\n      }\n      if (getRefCount(ref) == 0 && current == ref) {\n        assert ref != null;\n        \n        throw new IllegalStateException("The managed reference has already closed - this is likely a bug when the reference count is modified outside of the ReferenceManager");\n      }\n    } while (true);\n  }
44	public void addLatLine(double lat, double minLon, double maxLon) {\n    String name = "latline" + nextShape;\n    nextShape++;\n\n    b.append("        var " + name + " = WE.polygon([\n");\n    double lon;\n    int steps = getStepCount(lat, minLon, lat, maxLon);\n    for(lon = minLon;lon<=maxLon;lon += (maxLon-minLon)/steps) {\n      b.append("          [" + lat + ", " + lon + "],\n");\n    }\n    b.append("          [" + lat + ", " + maxLon + "],\n");\n    lon -= (maxLon-minLon)/steps;\n    for(;lon>=minLon;lon -= (maxLon-minLon)/steps) {\n      b.append("          [" + lat + ", " + lon + "],\n");\n    }\n    b.append("        ], {color: \"#ff0000\", fillColor: \"#ffffff\", opacity: 1, fillOpacity: 0.0001});\n");\n    b.append("        " + name + ".addTo(earth);\n");\n  }
45	public int getIndexOfFormattingRun(int index) {\n        if(st.sizeOfRArray() == 0) return 0;\n\n        int pos = 0;\n        for(int i = 0; i < st.sizeOfRArray(); i++){\n            CTRElt r = st.getRArray(i);\n            if(i == index) return pos;\n\n            pos += r.getT().length();\n        }\n        return -1;\n    }
46	public void xor(DocIdSetIterator iter) throws IOException {\n    checkUnpositioned(iter);\n    if (BitSetIterator.getFixedBitSetOrNull(iter) != null) {\n      final FixedBitSet bits = BitSetIterator.getFixedBitSetOrNull(iter); \n      xor(bits);\n    } else {\n      int doc;\n      while ((doc = iter.nextDoc()) < numBits) {\n        flip(doc);\n      }\n    }\n  }
47	protected void drawSide(Graphics2D g2,\n                            Rectangle2D plotArea,\n                            Arc2D arc,\n                            Area front,\n                            Area back,\n                            Paint paint,\n                            Paint outlinePaint,\n                            Stroke outlineStroke,\n                            boolean drawFront,\n                            boolean drawBack) {\n\n        if (getDarkerSides()) {\n             paint = PaintAlpha.darker(paint);\n        }\n\n        double start = arc.getAngleStart();\n        double extent = arc.getAngleExtent();\n        double end = start + extent;\n\n        g2.setStroke(outlineStroke);\n\n                if (extent < 0.0) {\n\n            if (isAngleAtFront(start)) {  \n                if (!isAngleAtBack(end)) {\n\n                    if (extent > -180.0) {                                                                      if (drawFront) {\n                            Area side = new Area(new Rectangle2D.Double(\n                                    arc.getEndPoint().getX(), plotArea.getY(),\n                                    arc.getStartPoint().getX()\n                                    - arc.getEndPoint().getX(),\n                                    plotArea.getHeight()));\n                            side.intersect(front);\n                            g2.setPaint(paint);\n                            g2.fill(side);\n                            g2.setPaint(outlinePaint);\n                            g2.draw(side);\n                        }\n                    }\n                    else {                                                                                  Area side1 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getStartPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(front);\n\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                arc.getEndPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getEndPoint().getX(),\n                                plotArea.getHeight()));\n\n                        side2.intersect(front);\n                        g2.setPaint(paint);\n                        if (drawFront) {\n                            g2.fill(side1);\n                            g2.fill(side2);\n                        }\n\n                        if (drawBack) {\n                            g2.fill(back);\n                        }\n\n                        g2.setPaint(outlinePaint);\n                        if (drawFront) {\n                            g2.draw(side1);\n                            g2.draw(side2);\n                        }\n\n                        if (drawBack) {\n                            g2.draw(back);\n                        }\n\n                    }\n                }\n                else {                          \n                    if (drawBack) {\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getEndPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n                        side2.intersect(back);\n                        g2.setPaint(paint);\n                        g2.fill(side2);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side2);\n                    }\n\n                    if (drawFront) {\n                        Area side1 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getStartPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(front);\n                        g2.setPaint(paint);\n                        g2.fill(side1);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side1);\n                    }\n                }\n            }\n            else {                      \n                if (!isAngleAtFront(end)) {\n                    if (extent > -180.0) {                          if (drawBack) {\n                            Area side = new Area(new Rectangle2D.Double(\n                                    arc.getStartPoint().getX(), plotArea.getY(),\n                                    arc.getEndPoint().getX()\n                                    - arc.getStartPoint().getX(),\n                                    plotArea.getHeight()));\n                            side.intersect(back);\n                            g2.setPaint(paint);\n                            g2.fill(side);\n                            g2.setPaint(outlinePaint);\n                            g2.draw(side);\n                        }\n                    }\n                    else {                                                      Area side1 = new Area(new Rectangle2D.Double(\n                                arc.getStartPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getStartPoint().getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(back);\n\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getEndPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n\n                        side2.intersect(back);\n\n                        g2.setPaint(paint);\n                        if (drawBack) {\n                            g2.fill(side1);\n                            g2.fill(side2);\n                        }\n\n                        if (drawFront) {\n                            g2.fill(front);\n                        }\n\n                        g2.setPaint(outlinePaint);\n                        if (drawBack) {\n                            g2.draw(side1);\n                            g2.draw(side2);\n                        }\n\n                        if (drawFront) {\n                            g2.draw(front);\n                        }\n\n                    }\n                }\n                else {  \n                    if (drawBack) {\n                        Area side1 = new Area(new Rectangle2D.Double(\n                                arc.getStartPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getStartPoint().getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(back);\n                        g2.setPaint(paint);\n                        g2.fill(side1);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side1);\n                    }\n\n                    if (drawFront) {\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                arc.getEndPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getEndPoint().getX(),\n                                plotArea.getHeight()));\n                        side2.intersect(front);\n                        g2.setPaint(paint);\n                        g2.fill(side2);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side2);\n                    }\n\n                }\n            }\n        }\n        else if (extent > 0.0) {  \n            if (isAngleAtFront(start)) {  \n                if (!isAngleAtBack(end)) {  \n                    if (extent < 180.0) {                          if (drawFront) {\n                            Area side = new Area(new Rectangle2D.Double(\n                                    arc.getStartPoint().getX(), plotArea.getY(),\n                                    arc.getEndPoint().getX()\n                                    - arc.getStartPoint().getX(),\n                                    plotArea.getHeight()));\n                            side.intersect(front);\n                            g2.setPaint(paint);\n                            g2.fill(side);\n                            g2.setPaint(outlinePaint);\n                            g2.draw(side);\n                        }\n                    }\n                    else {                          Area side1 = new Area(new Rectangle2D.Double(\n                                arc.getStartPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getStartPoint().getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(front);\n\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getEndPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n                        side2.intersect(front);\n\n                        g2.setPaint(paint);\n                        if (drawFront) {\n                            g2.fill(side1);\n                            g2.fill(side2);\n                        }\n\n                        if (drawBack) {\n                            g2.fill(back);\n                        }\n\n                        g2.setPaint(outlinePaint);\n                        if (drawFront) {\n                            g2.draw(side1);\n                            g2.draw(side2);\n                        }\n\n                        if (drawBack) {\n                            g2.draw(back);\n                        }\n\n                    }\n                }\n                else {                      if (drawBack) {\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                arc.getEndPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getEndPoint().getX(),\n                                plotArea.getHeight()));\n                        side2.intersect(back);\n                        g2.setPaint(paint);\n                        g2.fill(side2);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side2);\n                    }\n\n                    if (drawFront) {\n                        Area side1 = new Area(new Rectangle2D.Double(\n                                arc.getStartPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getStartPoint().getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(front);\n                        g2.setPaint(paint);\n                        g2.fill(side1);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side1);\n                    }\n                }\n            }\n            else {  \n                if (!isAngleAtFront(end)) {\n                    if (extent < 180.0) {                          if (drawBack) {\n                            Area side = new Area(new Rectangle2D.Double(\n                                    arc.getEndPoint().getX(), plotArea.getY(),\n                                    arc.getStartPoint().getX()\n                                    - arc.getEndPoint().getX(),\n                                    plotArea.getHeight()));\n                            side.intersect(back);\n                            g2.setPaint(paint);\n                            g2.fill(side);\n                            g2.setPaint(outlinePaint);\n                            g2.draw(side);\n                        }\n                    }\n                    else {                                                      Area side1 = new Area(new Rectangle2D.Double(\n                                arc.getStartPoint().getX(), plotArea.getY(),\n                                plotArea.getX() - arc.getStartPoint().getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(back);\n\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                arc.getEndPoint().getX(), plotArea.getY(),\n                                plotArea.getMaxX() - arc.getEndPoint().getX(),\n                                plotArea.getHeight()));\n                        side2.intersect(back);\n\n                        g2.setPaint(paint);\n                        if (drawBack) {\n                            g2.fill(side1);\n                            g2.fill(side2);\n                        }\n\n                        if (drawFront) {\n                            g2.fill(front);\n                        }\n\n                        g2.setPaint(outlinePaint);\n                        if (drawBack) {\n                            g2.draw(side1);\n                            g2.draw(side2);\n                        }\n\n                        if (drawFront) {\n                            g2.draw(front);\n                        }\n\n                    }\n                }\n                else {                                              if (drawBack) {\n                        Area side1 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getStartPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n                        side1.intersect(back);\n                        g2.setPaint(paint);\n                        g2.fill(side1);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side1);\n                    }\n\n                    if (drawFront) {\n                        Area side2 = new Area(new Rectangle2D.Double(\n                                plotArea.getX(), plotArea.getY(),\n                                arc.getEndPoint().getX() - plotArea.getX(),\n                                plotArea.getHeight()));\n                        side2.intersect(front);\n                        g2.setPaint(paint);\n                        g2.fill(side2);\n                        g2.setPaint(outlinePaint);\n                        g2.draw(side2);\n                    }\n                }\n            }\n\n        }\n\n    }
48	public static void drawRotatedString(AttributedString text, Graphics2D g2,\n            float x, float y, TextAnchor textAnchor,\n            double angle, TextAnchor rotationAnchor) {\n        ParamChecks.nullNotPermitted(text, "text");\n        float[] textAdj = deriveTextBoundsAnchorOffsets(g2, text, textAnchor, \n                null);\n        float[] rotateAdj = deriveRotationAnchorOffsets(g2, text, \n                rotationAnchor);\n        drawRotatedString(text, g2, x + textAdj[0], y + textAdj[1],\n                angle, x + textAdj[0] + rotateAdj[0],\n                y + textAdj[1] + rotateAdj[1]);        \n    }
49	private void write(POIFSFileSystem fs) throws IOException {\n                        List<String> excepts = new ArrayList<>(1);\n\n                fs.createDocument(new ByteArrayInputStream(getBytes()), "Workbook");\n\n                writeProperties(fs, excepts);\n        \n        if (preserveNodes) {\n                                                excepts.addAll(Arrays.asList(WORKBOOK_DIR_ENTRY_NAMES));\n\n                                    excepts.addAll(Arrays.asList(\n                DocumentSummaryInformation.DEFAULT_STREAM_NAME,\n                SummaryInformation.DEFAULT_STREAM_NAME,\n                getEncryptedPropertyStreamName()\n            ));\n\n                        EntryUtils.copyNodes(\n                    new FilteringDirectoryNode(getDirectory(), excepts)\n                    , new FilteringDirectoryNode(fs.getRoot(), excepts)\n                    );\n\n                                    fs.getRoot().setStorageClsid(getDirectory().getStorageClsid());\n        }\n    }
50	public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                        previous, end);\n            }\n        }\n    }
51	void markEnd (int numParallelTasks, int count) {\n    elapsed = System.currentTimeMillis() - start;\n    long totMem = Runtime.getRuntime().totalMemory();\n    if (totMem > maxTotMem) {\n      maxTotMem = totMem;\n    }\n    long usedMem = totMem - Runtime.getRuntime().freeMemory();\n    if (usedMem > maxUsedMem) {\n      maxUsedMem = usedMem;\n    }\n    this.numParallelTasks = numParallelTasks;\n    this.count = count;\n  }
52	public static void writeScaledChartAsPNG(OutputStream out,\n            JFreeChart chart, int width, int height, int widthScaleFactor,\n            int heightScaleFactor) throws IOException {\n\n        ParamChecks.nullNotPermitted(out, "out");\n        ParamChecks.nullNotPermitted(chart, "chart");\n\n        double desiredWidth = width * widthScaleFactor;\n        double desiredHeight = height * heightScaleFactor;\n        double defaultWidth = width;\n        double defaultHeight = height;\n        boolean scale = false;\n\n                if ((widthScaleFactor != 1) || (heightScaleFactor != 1)) {\n            scale = true;\n        }\n\n        double scaleX = desiredWidth / defaultWidth;\n        double scaleY = desiredHeight / defaultHeight;\n\n        BufferedImage image = new BufferedImage((int) desiredWidth,\n                (int) desiredHeight, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = image.createGraphics();\n\n        if (scale) {\n            AffineTransform saved = g2.getTransform();\n            g2.transform(AffineTransform.getScaleInstance(scaleX, scaleY));\n            chart.draw(g2, new Rectangle2D.Double(0, 0, defaultWidth,\n                    defaultHeight), null, null);\n            g2.setTransform(saved);\n            g2.dispose();\n        }\n        else {\n            chart.draw(g2, new Rectangle2D.Double(0, 0, defaultWidth,\n                    defaultHeight), null, null);\n        }\n        out.write(encodeAsPNG(image));\n\n    }
53	public void dump(Writer outWriter) throws IOException {\n        this.out = outWriter;\n\n        int padding = 0;\n        write(out, "<Presentation>" + CR, padding);\n        padding++;\n        if (pictstream != null){\n            write(out, "<Pictures>" + CR, padding);\n            dumpPictures(pictstream, padding);\n            write(out, "</Pictures>" + CR, padding);\n        }\n                write(out, "<PowerPointDocument>" + CR, padding);\n        padding++;\n        dump(docstream, 0, docstream.length, padding);\n        padding--;\n        write(out, "</PowerPointDocument>" + CR, padding);\n        padding--;\n        write(out, "</Presentation>", padding);\n    }
54	public static Trie load(InputStream stemmerTable) throws IOException {\n    DataInputStream in = null;\n    try {\n      in = new DataInputStream(new BufferedInputStream(stemmerTable));\n      String method = in.readUTF().toUpperCase(Locale.ROOT);\n      if (method.indexOf('M') < 0) {\n        return new org.egothor.stemmer.Trie(in);\n      } else {\n        return new org.egothor.stemmer.MultiTrie2(in);\n      }\n    } finally {\n      in.close();\n    }\n  }
55	public synchronized TaskStats markTaskStart (PerfTask task, int round) {\n    TaskStats stats = new TaskStats(task, nextTaskRunNum(), round);\n    this.currentStats = stats;\n    points.add(stats);\n    return stats;\n  }
56	public final RelationPart addRelation(String relId, POIXMLRelation relationshipType, POIXMLDocumentPart part) {\n        PackageRelationship pr = this.packagePart.findExistingRelation(part.getPackagePart());\n        if (pr == null) {\n            PackagePartName ppn = part.getPackagePart().getPartName();\n            String relType = relationshipType.getRelation();\n            pr = packagePart.addRelationship(ppn, TargetMode.INTERNAL, relType, relId);\n        }\n        addRelation(pr, part);\n        return new RelationPart(pr, part);\n    }
57	public Map<String, String[]> highlightFields(String[] fieldsIn, Query query, int[] docidsIn, int[] maxPassagesIn)\n      throws IOException {\n    Map<String, String[]> snippets = new HashMap<>();\n    for (Map.Entry<String, Object[]> ent : highlightFieldsAsObjects(fieldsIn, query, docidsIn, maxPassagesIn).entrySet()) {\n      Object[] snippetObjects = ent.getValue();\n      String[] snippetStrings = new String[snippetObjects.length];\n      snippets.put(ent.getKey(), snippetStrings);\n      for (int i = 0; i < snippetObjects.length; i++) {\n        Object snippet = snippetObjects[i];\n        if (snippet != null) {\n          snippetStrings[i] = snippet.toString();\n        }\n      }\n    }\n\n    return snippets;\n  }
58	protected Size2D arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        Size2D size1 = arrange(container, g2, RectangleConstraint.NONE);\n\n        if (constraint.getWidthRange().contains(size1.getWidth())) {\n            if (constraint.getHeightRange().contains(size1.getHeight())) {\n                return size1;\n            }\n            else {\n                                double h = constraint.getHeightRange().constrain(\n                        size1.getHeight());\n                RectangleConstraint cc = new RectangleConstraint(\n                        size1.getWidth(), h);\n                return arrangeFF(container, g2, cc);\n            }\n        }\n        else {\n            if (constraint.getHeightRange().contains(size1.getHeight())) {\n                                double w = constraint.getWidthRange().constrain(\n                        size1.getWidth());\n                RectangleConstraint cc = new RectangleConstraint(w,\n                        size1.getHeight());\n                return arrangeFF(container, g2, cc);\n\n            }\n            else {\n                double w = constraint.getWidthRange().constrain(\n                        size1.getWidth());\n                double h = constraint.getHeightRange().constrain(\n                        size1.getHeight());\n                RectangleConstraint cc = new RectangleConstraint(w, h);\n                return arrangeFF(container, g2, cc);\n            }\n        }\n    }
59	private Ptg adjustPtgDueToMove(Ptg ptg, int currentExternSheetIx, boolean isRowMove) {\n        if(ptg instanceof RefPtg) {\n            if (currentExternSheetIx != _externSheetIndex) {\n                                return null;\n            }\n            RefPtg rptg = (RefPtg)ptg;\n            return isRowMove ? rowMoveRefPtg(rptg) : columnMoveRefPtg(rptg);\n        }\n        if(ptg instanceof Ref3DPtg) {\n            Ref3DPtg rptg = (Ref3DPtg)ptg;\n            if (_externSheetIndex != rptg.getExternSheetIndex()) {\n                                                return null;\n            }\n            return isRowMove ? rowMoveRefPtg(rptg) : columnMoveRefPtg(rptg);\n        }\n        if(ptg instanceof Ref3DPxg) {\n            Ref3DPxg rpxg = (Ref3DPxg)ptg;\n            if (rpxg.getExternalWorkbookNumber() > 0 ||\n                    ! _sheetName.equalsIgnoreCase(rpxg.getSheetName())) {\n                                return null;\n            }\n            return isRowMove ? rowMoveRefPtg(rpxg) : columnMoveRefPtg(rpxg);\n        }\n        if(ptg instanceof Area2DPtgBase) {\n            if (currentExternSheetIx != _externSheetIndex) {\n                                return ptg;\n            }\n            Area2DPtgBase aptg = (Area2DPtgBase) ptg;\n            return isRowMove ? rowMoveAreaPtg(aptg) : columnMoveAreaPtg(aptg);\n        }\n        if(ptg instanceof Area3DPtg) {\n            Area3DPtg aptg = (Area3DPtg)ptg;\n            if (_externSheetIndex != aptg.getExternSheetIndex()) {\n                                                return null;\n            }\n            return isRowMove ? rowMoveAreaPtg(aptg) : columnMoveAreaPtg(aptg);\n        }\n        if(ptg instanceof Area3DPxg) {\n            Area3DPxg apxg = (Area3DPxg)ptg;\n            if (apxg.getExternalWorkbookNumber() > 0 ||\n                    ! _sheetName.equalsIgnoreCase(apxg.getSheetName())) {\n                                return null;\n            }\n            return isRowMove ? rowMoveAreaPtg(apxg) : columnMoveAreaPtg(apxg);\n        }\n        return null;\n    }
60	public boolean equals(Object o)\n    {\n        if (!(o instanceof UnicodeString)) {\n            return false;\n        }\n        UnicodeString other = (UnicodeString) o;\n\n                if (field_1_charCount != other.field_1_charCount\n            || field_2_optionflags != other.field_2_optionflags\n            || !field_3_string.equals(other.field_3_string)) {\n            return false;\n        }\n\n                if (field_4_format_runs == null) {\n                        return (other.field_4_format_runs == null);\n        } else if (other.field_4_format_runs == null) {\n                        return false;\n        }\n\n                int size = field_4_format_runs.size();\n        if (size != other.field_4_format_runs.size()) {\n          return false;\n        }\n\n        for (int i=0;i<size;i++) {\n          FormatRun run1 = field_4_format_runs.get(i);\n          FormatRun run2 = other.field_4_format_runs.get(i);\n\n          if (!run1.equals(run2)) {\n            return false;\n          }\n        }\n\n                if (field_5_ext_rst == null) {\n            return (other.field_5_ext_rst == null);\n        } else if (other.field_5_ext_rst == null) {\n            return false;\n        }\n            \n       return field_5_ext_rst.equals(other.field_5_ext_rst);\n    }
61	public void setRangeValues(double minLat, double minLon, double maxLat, double maxLon) {\n    checkArgs(minLat, minLon, maxLat, maxLon);\n    final byte[] bytes;\n    if (fieldsData == null) {\n      bytes = new byte[4*BYTES];\n      fieldsData = new BytesRef(bytes);\n    } else {\n      bytes = ((BytesRef)fieldsData).bytes;\n    }\n    encode(minLat, minLon, bytes, 0);\n    encode(maxLat, maxLon, bytes, 2 * BYTES);\n  }
62	public void getTransition(int state, int index, Transition t) {\n    int i = states[2*state] + 3*index;\n    t.source = state;\n    t.dest = transitions[i++];\n    t.min = transitions[i++];\n    t.max = transitions[i++];\n  }
63	public void init(long skipPointer, int df) throws IOException {\n    this.skipPointer[0] = skipPointer;\n    this.docCount = df;\n    assert skipPointer >= 0 && skipPointer <= skipStream[0].length() \n    : "invalid skip pointer: " + skipPointer + ", length=" + skipStream[0].length();\n    Arrays.fill(skipDoc, 0);\n    Arrays.fill(numSkipped, 0);\n    Arrays.fill(childPointer, 0);\n    \n    for (int i = 1; i < numberOfSkipLevels; i++) {\n      skipStream[i] = null;\n    }\n    loadSkipLevels();\n  }
64	public void processWorkbookEvents(HSSFRequest req, DirectoryNode dir) throws IOException {\n                String name = null;\n        Set<String> entryNames = dir.getEntryNames();\n        for (String potentialName : WORKBOOK_DIR_ENTRY_NAMES) {\n            if (entryNames.contains(potentialName)) {\n                name = potentialName;\n                break;\n            }\n        }\n                if (name == null) {\n            name = WORKBOOK_DIR_ENTRY_NAMES[0];\n        }\n\n        InputStream in = dir.createDocumentInputStream(name);\n        try {\n            processEvents(req, in);\n        } finally {\n            in.close();\n        }\n    }
65	private ParseNode  Term() {\n        ParseNode result = powerFactor();\n        while(true) {\n            SkipWhite();\n            Ptg operator;\n            switch(look) {\n                case '*':\n                    Match('*');\n                    operator = MultiplyPtg.instance;\n                    break;\n                case '/':\n                    Match('/');\n                    operator = DividePtg.instance;\n                    break;\n                default:\n                    return result;             }\n            ParseNode other = powerFactor();\n            result = new ParseNode(operator, result, other);\n        }\n    }
66	private void shiftInputWindow() throws IOException {\n    InputWindowToken firstToken = null;\n    if (inputWindow.size() > 0) {\n      firstToken = inputWindow.removeFirst();\n    }\n    while (inputWindow.size() < maxShingleSize) {\n      if (null != firstToken) {          if (null != getNextToken(firstToken)) {\n          inputWindow.add(firstToken);           firstToken = null;\n        } else {\n          break;         }\n      } else {\n        InputWindowToken nextToken = getNextToken(null);\n        if (null != nextToken) {\n          inputWindow.add(nextToken);\n        } else {\n          break;         }\n      }\n    }\n    if (outputUnigramsIfNoShingles && noShingleOutput \n        && gramSize.minValue > 1 && inputWindow.size() < minShingleSize) {\n      gramSize.minValue = 1;\n    }\n    gramSize.reset();\n    isOutputHere = false;\n  }
67	public static boolean copyStream(InputStream inStream, OutputStream outStream) {\n		try {\n			byte[] buffer = new byte[1024];\n			int bytesRead;\n			while ((bytesRead = inStream.read(buffer)) >= 0) {\n				outStream.write(buffer, 0, bytesRead);\n			}\n		} catch (Exception e) {\n			return false;\n		}\n		return true;\n	}
68	public static int compare(final String str1, final String str2)\n    {\n        if (str1 == null) {\n                        return (str2 == null ? 0 : -1);\n        } else if (str2 == null) {\n                        return 1;\n        }\n        \n        if (str1.equalsIgnoreCase(str2)) {\n            return 0;\n        }\n        final String name1 = str1.toLowerCase(Locale.ROOT);\n        final String name2 = str2.toLowerCase(Locale.ROOT);\n\n        final int len1 = name1.length();\n        final int len2 = name2.length();\n        for (int idx1 = 0, idx2 = 0; idx1 < len1 && idx2 < len2; ) {\n            final char c1 = name1.charAt(idx1++);\n            final char c2 = name2.charAt(idx2++);\n\n            if (Character.isDigit(c1) && Character.isDigit(c2)) {\n                final int beg1 = idx1 - 1;                  while (idx1 < len1 && Character.isDigit(name1.charAt(idx1))) {\n                    idx1++;\n                }\n\n                final int beg2 = idx2 - 1;                  while (idx2 < len2 && Character.isDigit(name2.charAt(idx2))) {\n                    idx2++;\n                }\n\n                                final BigInteger b1 = new BigInteger(name1.substring(beg1, idx1));\n                final BigInteger b2 = new BigInteger(name2.substring(beg2, idx2));\n                final int cmp = b1.compareTo(b2);\n                if (cmp != 0) {\n                    return cmp;\n                }\n            }\n            else if (c1 != c2) {\n                return (c1 - c2);\n            }\n        }\n\n        return (len1 - len2);\n    }
69	public String getText() {\n       String text;\n       try {\n           TextListener tl = triggerExtraction();\n\n           text = tl._text.toString();\n           if(! text.endsWith("\n")) {\n               text = text + "\n";\n           }\n       } catch(IOException e) {\n           throw new RuntimeException(e);\n       }\n\n       return text;\n   }
70	public static JFreeChart createScatterPlot(String title, String xAxisLabel,\n            String yAxisLabel, XYDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        NumberAxis xAxis = new NumberAxis(xAxisLabel);\n        xAxis.setAutoRangeIncludesZero(false);\n        NumberAxis yAxis = new NumberAxis(yAxisLabel);\n        yAxis.setAutoRangeIncludesZero(false);\n\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, null);\n\n        XYToolTipGenerator toolTipGenerator = null;\n        if (tooltips) {\n            toolTipGenerator = new StandardXYToolTipGenerator();\n        }\n\n        XYURLGenerator urlGenerator = null;\n        if (urls) {\n            urlGenerator = new StandardXYURLGenerator();\n        }\n        XYItemRenderer renderer = new XYLineAndShapeRenderer(false, true);\n        renderer.setBaseToolTipGenerator(toolTipGenerator);\n        renderer.setURLGenerator(urlGenerator);\n        plot.setRenderer(renderer);\n        plot.setOrientation(orientation);\n\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
71	public static AreaEval createAreaEval(AreaPtg areaPtg, ValueEval[] values) {\n		int nCols = areaPtg.getLastColumn() - areaPtg.getFirstColumn() + 1;\n		int nRows = areaPtg.getLastRow() - areaPtg.getFirstRow() + 1;\n		int nExpected = nRows * nCols;\n		if (values.length != nExpected) {\n			throw new RuntimeException("Expected " + nExpected + " values but got " + values.length);\n		}\n		for (int i = 0; i < nExpected; i++) {\n			if (values[i] == null) {\n				values[i] = NumberEval.ZERO;\n			}\n		}\n		return new MockAreaEval(areaPtg, values);\n	}
72	public static boolean isCellInternalDateFormatted(Cell cell) {\n        if (cell == null) return false;\n        boolean bDate = false;\n\n        double d = cell.getNumericCellValue();\n        if ( DateUtil.isValidExcelDate(d) ) {\n            CellStyle style = cell.getCellStyle();\n            int i = style.getDataFormat();\n            bDate = isInternalDateFormat(i);\n        }\n        return bDate;\n    }
73	public static double calculateMedian(List values, boolean copyAndSort) {\n\n        double result = Double.NaN;\n        if (values != null) {\n            if (copyAndSort) {\n                int itemCount = values.size();\n                List copy = new ArrayList(itemCount);\n                for (int i = 0; i < itemCount; i++) {\n                    copy.add(i, values.get(i));\n                }\n                Collections.sort(copy);\n                values = copy;\n            }\n            int count = values.size();\n            if (count > 0) {\n                if (count % 2 == 1) {\n                    if (count > 1) {\n                        Number value = (Number) values.get((count - 1) / 2);\n                        result = value.doubleValue();\n                    }\n                    else {\n                        Number value = (Number) values.get(0);\n                        result = value.doubleValue();\n                    }\n                }\n                else {\n                    Number value1 = (Number) values.get(count / 2 - 1);\n                    Number value2 = (Number) values.get(count / 2);\n                    result = (value1.doubleValue() + value2.doubleValue())\n                             / 2.0;\n                }\n            }\n        }\n        return result;\n    }
74	public void add(double value, Paint paint) {\n        PaintItem item = new PaintItem(value, paint);\n        int index = Collections.binarySearch(this.lookupTable, item);\n        if (index >= 0) {\n            this.lookupTable.set(index, item);\n        }\n        else {\n            this.lookupTable.add(-(index + 1), item);\n        }\n    }
75	public boolean intersects(final PlanetModel planetModel, final Plane q, final GeoPoint[] notablePoints, final GeoPoint[] moreNotablePoints, final Membership[] bounds, final Membership... moreBounds) {\n                        if (isNumericallyIdentical(q)) {\n                        for (GeoPoint p : notablePoints) {\n        if (meetsAllBounds(p, bounds, moreBounds)) {\n                    return true;\n        }\n      }\n      for (GeoPoint p : moreNotablePoints) {\n        if (meetsAllBounds(p, bounds, moreBounds)) {\n                    return true;\n        }\n      }\n            return false;\n    }\n    \n                final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n                  return false;\n    }\n\n                                                                                double x0;\n    double y0;\n    double z0;\n        final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n            if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return false;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n            if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return false;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n            if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n                return false;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n                                final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n            final double inverse2A = 1.0 / (2.0 * A);\n            final double t = -B * inverse2A;\n            final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return false;\n        }\n      }\n      for (final Membership bound : moreBounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (BsquaredMinus > 0.0) {\n            final double inverse2A = 1.0 / (2.0 * A);\n            final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n            final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      boolean point1Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      if (point1Valid) {\n        return true;\n      }\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          return false;\n        }\n      }\n      for (final Membership bound : moreBounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n            return false;\n    }\n  }
76	public int freeBlocks(int num) {\n    assert num >= 0 : "free blocks must be >= 0 but was: "+ num;\n    final int stop;\n    final int count;\n    if (num > freeBlocks) {\n      stop = 0;\n      count = freeBlocks;\n    } else {\n      stop = freeBlocks - num;\n      count = num;\n    }\n    while (freeBlocks > stop) {\n      freeByteBlocks[--freeBlocks] = null;\n    }\n    bytesUsed.addAndGet(-count*blockSize*Integer.BYTES);\n    assert bytesUsed.get() >= 0;\n    return count;\n  }
77	public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        boolean allItemsNull = true;                                              double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }
78	public int initTransition(int state, Transition t) {\n    assert state < nextState/2: "state=" + state + " nextState=" + nextState;\n    t.source = state;\n    t.transitionUpto = states[2*state];\n    return getNumTransitions(state);\n  }
79	protected void readProperties() {\n        if (initialized) {\n            return;\n        }\n        DocumentSummaryInformation dsi = readPropertySet(DocumentSummaryInformation.class, DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n        if (dsi != null) {\n            dsInf = dsi;\n        }\n        SummaryInformation si = readPropertySet(SummaryInformation.class, SummaryInformation.DEFAULT_STREAM_NAME);\n        if (si != null) {\n            sInf = si;\n        }\n\n                initialized = true;\n    }
80	private int drawDashDotDot(Graphics g,int x, int y, int thickness,\n                              boolean horizontal,\n                              boolean rightBottom) {\n\n      for (int t=0; t < thickness; t++) {\n         if (!rightBottom) {\n            t = 0 - t;                                 }\n         if (horizontal) {\n            g.drawLine(x,y+t,x+5,y+t);\n            g.drawLine(x+8,y+t,x+10,y+t);\n            g.drawLine(x+13,y+t,x+15,y+t);\n         } else {\n            g.drawLine(x+t,y,x+t,y+5);\n            g.drawLine(x+t,y+8,x+t,y+10);\n            g.drawLine(x+t,y+13,x+t,y+15);\n         }\n      }\n      return 18;\n   }
81	private static Polygon2D createTree(Polygon2D components[], int low, int high, boolean splitX) {\n    if (low > high) {\n      return null;\n    }\n    final int mid = (low + high) >>> 1;\n    if (low < high) {\n      Comparator<Polygon2D> comparator;\n      if (splitX) {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.minLon, right.minLon);\n          if (ret == 0) {\n            ret = Double.compare(left.maxX, right.maxX);\n          }\n          return ret;\n        };\n      } else {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.minLat, right.minLat);\n          if (ret == 0) {\n            ret = Double.compare(left.maxY, right.maxY);\n          }\n          return ret;\n        };\n      }\n      ArrayUtil.select(components, low, high + 1, mid, comparator);\n    }\n        Polygon2D newNode = components[mid];\n    newNode.splitX = splitX;\n        newNode.left = createTree(components, low, mid - 1, !splitX);\n    newNode.right = createTree(components, mid + 1, high, !splitX);\n        if (newNode.left != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.left.maxX);\n      newNode.maxY = Math.max(newNode.maxY, newNode.left.maxY);\n    }\n    if (newNode.right != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.right.maxX);\n      newNode.maxY = Math.max(newNode.maxY, newNode.right.maxY);\n    }\n    return newNode;\n  }
82	private static CellType determineType(CellValueRecordInterface cval) {\n        if (cval instanceof FormulaRecordAggregate) {\n            return CellType.FORMULA;\n        }\n                Record record = ( Record ) cval;\n        switch (record.getSid()) {\n\n            case NumberRecord.sid :   return CellType.NUMERIC;\n            case BlankRecord.sid :    return CellType.BLANK;\n            case LabelSSTRecord.sid : return CellType.STRING;\n            case BoolErrRecord.sid :\n                BoolErrRecord boolErrRecord = ( BoolErrRecord ) record;\n\n                return boolErrRecord.isBoolean()\n                         ? CellType.BOOLEAN\n                         : CellType.ERROR;\n        }\n        throw new RuntimeException("Bad cell value rec (" + cval.getClass().getName() + ")");\n    }
83	public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException("DocValuesType must not be null (field: \"" + f.name() + "\")");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException("can only update NUMERIC or BINARY fields! field=" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException("can only update existing docvalues fields! field=" + f.name() + ", type=" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException("cannot update docvalues field involved in the index sort, field=" + f.name() + ", sort=" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException("can only update NUMERIC or BINARY fields: field=" + f.name() + ", type=" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, "updateDocValues");\n\n            return -1;\n    }\n  }
84	public static long copy(InputStream inp, OutputStream out) throws IOException {\n        final byte[] buff = new byte[4096];\n        long totalCount = 0;\n        for (int count; (count = inp.read(buff)) != -1; totalCount += count) {\n            if (count > 0) {\n                out.write(buff, 0, count);\n            }\n        }\n        return totalCount;\n    }
85	public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }
86	public Vector normalize() {\n    double denom = magnitude();\n    if (denom < MINIMUM_RESOLUTION)\n            return null;\n    double normFactor = 1.0 / denom;\n    return new Vector(x * normFactor, y * normFactor, z * normFactor);\n  }
87	public void unwriteProtectWorkbook() {\n        records.remove(fileShare);\n        records.remove(writeProtect);\n        fileShare = null;\n        writeProtect = null;\n    }
88	private static Buffer concat(List<Buffer> buffers) {\n    int totalLength = 0;\n    Buffer largestBuffer = null;\n    for (Buffer buffer : buffers) {\n      totalLength += buffer.length;\n      if (largestBuffer == null || buffer.array.length > largestBuffer.array.length) {\n        largestBuffer = buffer;\n      }\n    }\n    if (largestBuffer == null) {\n      return new Buffer(1);\n    }\n    int[] docs = largestBuffer.array;\n    if (docs.length < totalLength + 1) {\n      docs = Arrays.copyOf(docs, totalLength + 1);\n    }\n    totalLength = largestBuffer.length;\n    for (Buffer buffer : buffers) {\n      if (buffer != largestBuffer) {\n        System.arraycopy(buffer.array, 0, docs, totalLength, buffer.length);\n        totalLength += buffer.length;\n      }\n    }\n    return new Buffer(docs, totalLength);\n  }
89	private void addTermFrequencies(Map<String, Map<String, Int>> field2termFreqMap, Terms vector, String fieldName) throws IOException {\n    Map<String, Int> termFreqMap = field2termFreqMap.get(fieldName);\n    if (termFreqMap == null) {\n      termFreqMap = new HashMap<>();\n      field2termFreqMap.put(fieldName, termFreqMap);\n    }\n    final TermsEnum termsEnum = vector.iterator();\n    final CharsRefBuilder spare = new CharsRefBuilder();\n    BytesRef text;\n    while((text = termsEnum.next()) != null) {\n      spare.copyUTF8Bytes(text);\n      final String term = spare.toString();\n      if (isNoiseWord(term)) {\n        continue;\n      }\n      final int freq = (int) termsEnum.totalTermFreq();\n\n            Int cnt = termFreqMap.get(term);\n      if (cnt == null) {\n        cnt = new Int();\n        termFreqMap.put(term, cnt);\n        cnt.x = freq;\n      } else {\n        cnt.x += freq;\n      }\n    }\n  }
90	private void addCell(HSSFCell cell) {\n\n        int column=cell.getColumnIndex();\n                if(column>=cells.length) {\n            HSSFCell[] oldCells=cells;\n                        int newSize=oldCells.length*3/2+1;\n            if(newSize<column+1) {\n                newSize=column+INITIAL_CAPACITY;\n            }\n            cells=new HSSFCell[newSize];\n            System.arraycopy(oldCells,0,cells,0,oldCells.length);\n        }\n        cells[column]=cell;\n\n                if (row.isEmpty() || column < row.getFirstCol()) {\n            row.setFirstCol((short)column);\n        }\n\n        if (row.isEmpty() || column >= row.getLastCol()) {\n            row.setLastCol((short) (column+1));         }\n    }
91	public void addSlidePersistAtom(SlidePersistAtom spa) {\n				appendChildRecord(spa);\n\n		SlideAtomsSet newSAS = new SlideAtomsSet(spa, new Record[0]);\n\n				SlideAtomsSet[] sas = new SlideAtomsSet[slideAtomsSets.length+1];\n		System.arraycopy(slideAtomsSets, 0, sas, 0, slideAtomsSets.length);\n		sas[sas.length-1] = newSAS;\n		slideAtomsSets = sas;\n	}
92	public static TwoDEval resolveTableArrayArg(ValueEval eval) throws EvaluationException {\n		if (eval instanceof TwoDEval) {\n			return (TwoDEval) eval;\n		}\n\n		if(eval instanceof RefEval) {\n			RefEval refEval = (RefEval) eval;\n			\n						return refEval.offset(0, 0, 0, 0);\n		}\n		throw EvaluationException.invalidValue();\n	}
93	public void setOutsideBorders(Object... args){\n        if (args.length == 0) return;\n\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = new BorderEdge[4];\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[0] = (col == 0) ? BorderEdge.left : null;\n                edges[1] = (col == cols - 1) ? BorderEdge.right : null;\n                edges[2] = (row == 0) ? BorderEdge.top : null;\n                edges[3] = (row == rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
94	private void indexPoint(PerField fp, IndexableField field) throws IOException {\n    int pointDimensionCount = field.fieldType().pointDimensionCount();\n\n    int dimensionNumBytes = field.fieldType().pointNumBytes();\n\n            if (fp.fieldInfo.getPointDimensionCount() == 0) {\n      fieldInfos.globalFieldNumbers.setDimensions(fp.fieldInfo.number, fp.fieldInfo.name, pointDimensionCount, dimensionNumBytes);\n    }\n\n    fp.fieldInfo.setPointDimensions(pointDimensionCount, dimensionNumBytes);\n\n    if (fp.pointValuesWriter == null) {\n      fp.pointValuesWriter = new PointValuesWriter(docWriter, fp.fieldInfo);\n    }\n    fp.pointValuesWriter.addPackedValue(docState.docID, field.binaryValue());\n  }
95	public static synchronized XMLReader newXMLReader() throws SAXException, ParserConfigurationException {\n        XMLReader xmlReader = saxFactory.newSAXParser().getXMLReader();\n        xmlReader.setEntityResolver(IGNORING_ENTITY_RESOLVER);\n        trySetSAXFeature(xmlReader, XMLConstants.FEATURE_SECURE_PROCESSING);\n        trySetXercesSecurityManager(xmlReader);\n        return xmlReader;\n    }
96	protected void drawHorizontalCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            double y, Crosshair crosshair) {\n\n        if (y >= dataArea.getMinY() && y <= dataArea.getMaxY()) {\n            Line2D line = new Line2D.Double(dataArea.getMinX(), y,\n                    dataArea.getMaxX(), y);\n            Paint savedPaint = g2.getPaint();\n            Stroke savedStroke = g2.getStroke();\n            g2.setPaint(crosshair.getPaint());\n            g2.setStroke(crosshair.getStroke());\n            g2.draw(line);\n            if (crosshair.isLabelVisible()) {\n                String label = crosshair.getLabelGenerator().generateLabel(\n                        crosshair);\n                RectangleAnchor anchor = crosshair.getLabelAnchor();\n                Point2D pt = calculateLabelPoint(line, anchor, 5, 5);\n                float xx = (float) pt.getX();\n                float yy = (float) pt.getY();\n                TextAnchor alignPt = textAlignPtForLabelAnchorH(anchor);\n                Shape hotspot = TextUtilities.calculateRotatedStringBounds(\n                        label, g2, xx, yy, alignPt, 0.0, TextAnchor.CENTER);\n                if (!dataArea.contains(hotspot.getBounds2D())) {\n                    anchor = flipAnchorV(anchor);\n                    pt = calculateLabelPoint(line, anchor, 5, 5);\n                    xx = (float) pt.getX();\n                    yy = (float) pt.getY();\n                    alignPt = textAlignPtForLabelAnchorH(anchor);\n                    hotspot = TextUtilities.calculateRotatedStringBounds(\n                           label, g2, xx, yy, alignPt, 0.0, TextAnchor.CENTER);\n                }\n\n                g2.setPaint(crosshair.getLabelBackgroundPaint());\n                g2.fill(hotspot);\n                g2.setPaint(crosshair.getLabelOutlinePaint());\n                g2.draw(hotspot);\n                TextUtilities.drawAlignedString(label, g2, xx, yy, alignPt);\n            }\n            g2.setPaint(savedPaint);\n            g2.setStroke(savedStroke);\n        }\n    }
97	public void replaceText(String pPlaceHolder, String pValue) {\n		while (true) {\n			String text = text();\n			int offset = text.indexOf(pPlaceHolder);\n			if (offset >= 0) {\n				replaceText(pPlaceHolder, pValue, offset);\n			} else {\n				break;\n			}\n		}\n	}
98	public void guess7BitEncoding() {\n            for (MAPIProperty prop : new MAPIProperty[] {\n               MAPIProperty.MESSAGE_CODEPAGE,\n               MAPIProperty.INTERNET_CPID\n      }) {\n        List<PropertyValue> val = mainChunks.getProperties().get(prop);\n        if (val != null && val.size() > 0) {\n           int codepage = ((LongPropertyValue)val.get(0)).getValue();\n           try {\n               String encoding = CodePageUtil.codepageToEncoding(codepage, true);\n               set7BitEncoding(encoding);\n               return;\n            } catch(UnsupportedEncodingException e) {\n               logger.log(POILogger.WARN, "Invalid codepage ID ", codepage, \n                          " set for the message via ", prop, ", ignoring");\n            }\n         }\n      }\n     \n       \n            try {\n         String[] headers = getHeaders();\n         if(headers != null && headers.length > 0) {\n                        Pattern p = Pattern.compile("Content-Type:.*?charset=[\"']?([^;'\"]+)[\"']?", Pattern.CASE_INSENSITIVE);\n\n            for(String header : headers) {\n               if(header.startsWith("Content-Type")) {\n                  Matcher m = p.matcher(header);\n                  if(m.matches()) {\n                                          String charset = m.group(1);\n\n                     if (!charset.equalsIgnoreCase("utf-8")) { \n                        set7BitEncoding(charset);\n                     }\n                     return;\n                  }\n               }\n            }\n         }\n      } catch(ChunkNotFoundException e) {}\n      \n            try {\n         String html = getHtmlBody();\n         if(html != null && html.length() > 0) {\n                        Pattern p = Pattern.compile(\n                  "<META\\s+HTTP-EQUIV=\"Content-Type\"\\s+CONTENT=\"text/html;\\s+charset=(.*?)\""\n            );\n            Matcher m = p.matcher(html);\n            if(m.find()) {\n                              String charset = m.group(1);\n               set7BitEncoding(charset);\n            }\n         }\n      } catch(ChunkNotFoundException e) {}\n   }
99	protected void drawVertical(Graphics2D g2, Rectangle2D area) {\n        Rectangle2D titleArea = (Rectangle2D) area.clone();\n        g2.setFont(this.font);\n        g2.setPaint(this.paint);\n        TextBlockAnchor anchor = null;\n        float y = 0.0f;\n        VerticalAlignment verticalAlignment = getVerticalAlignment();\n        if (verticalAlignment == VerticalAlignment.TOP) {\n            y = (float) titleArea.getY();\n            anchor = TextBlockAnchor.TOP_RIGHT;\n        }\n        else if (verticalAlignment == VerticalAlignment.BOTTOM) {\n            y = (float) titleArea.getMaxY();\n            anchor = TextBlockAnchor.TOP_LEFT;\n        }\n        else if (verticalAlignment == VerticalAlignment.CENTER) {\n            y = (float) titleArea.getCenterY();\n            anchor = TextBlockAnchor.TOP_CENTER;\n        }\n        float x = 0.0f;\n        RectangleEdge position = getPosition();\n        if (position == RectangleEdge.LEFT) {\n            x = (float) titleArea.getX();\n        }\n        else if (position == RectangleEdge.RIGHT) {\n            x = (float) titleArea.getMaxX();\n            if (verticalAlignment == VerticalAlignment.TOP) {\n                anchor = TextBlockAnchor.BOTTOM_RIGHT;\n            }\n            else if (verticalAlignment == VerticalAlignment.CENTER) {\n                anchor = TextBlockAnchor.BOTTOM_CENTER;\n            }\n            else if (verticalAlignment == VerticalAlignment.BOTTOM) {\n                anchor = TextBlockAnchor.BOTTOM_LEFT;\n            }\n        }\n        this.content.draw(g2, x, y, anchor, x, y, -Math.PI / 2.0);\n    }
100	public static void main(String[] args) throws IOException {\n        if(args.length < 2){\n    		System.err.println("Usage: AddDimensionedImage imageFile outputFile");\n    		return;\n    	}\n\n        final String imageFile = args[0];\n        final String outputFile = args[1];\n\n        try (final Workbook workbook = new HSSFWorkbook();\n             final FileOutputStream fos = new FileOutputStream(outputFile)) {               Sheet sheet = workbook.createSheet("Picture Test");\n            new AddDimensionedImage().addImageToSheet("B5", sheet, sheet.createDrawingPatriarch(),\n                    new File(imageFile).toURI().toURL(), 100, 40,\n                    AddDimensionedImage.EXPAND_ROW_AND_COLUMN);\n            workbook.write(fos);\n        }\n    }
101	public Path2D.Double getBoundsAsPath() {\n\n        Double w = getWidth();\n        Double h = getHeight();\n\n        Path2D.Double bounds = new Path2D.Double();\n        bounds.moveTo(0, 0);\n        bounds.lineTo(w, 0);\n        bounds.lineTo(w, h);\n        bounds.lineTo(0, h);\n        bounds.lineTo(0, 0);\n\n        return bounds;\n    }
102	private String replaceSuffix( String value, String toReplace, String changeTo ) {\n    String vvalue ;\n\n        if ((value == null) ||\n        (toReplace == null) ||\n        (changeTo == null) ) {\n      return value ;\n    }\n\n    vvalue = removeSuffix(value,toReplace) ;\n\n    if (value.equals(vvalue)) {\n      return value ;\n    } else {\n      return vvalue + changeTo ;\n    }\n  }
103	public void addField(String fieldName, String text, Analyzer analyzer) {\n    if (fieldName == null)\n      throw new IllegalArgumentException("fieldName must not be null");\n    if (text == null)\n      throw new IllegalArgumentException("text must not be null");\n    if (analyzer == null)\n      throw new IllegalArgumentException("analyzer must not be null");\n    \n    TokenStream stream = analyzer.tokenStream(fieldName, text);\n    storeTerms(getInfo(fieldName, defaultFieldType), stream,\n        analyzer.getPositionIncrementGap(fieldName), analyzer.getOffsetGap(fieldName));\n  }
104	public double getTextHeight(Graphics2D oldGraphics) {\n                BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n        Graphics2D graphics = img.createGraphics();\n        if (oldGraphics != null) {\n            graphics.addRenderingHints(oldGraphics.getRenderingHints());\n            graphics.setTransform(oldGraphics.getTransform());\n        }\n        DrawFactory.getInstance(graphics).fixFonts(graphics);\n        return drawParagraphs(graphics, 0, 0);\n    }
105	protected void drawRightLabel(Graphics2D g2, PiePlotState state,\n                                  PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMaxX();\n        double targetX = anchorX + record.getGap();\n        double targetY = record.getAllocatedY();\n\n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta)\n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta)\n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta)\n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta)\n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            PieLabelLinkStyle style = getLabelLinkStyle();\n            if (style.equals(PieLabelLinkStyle.STANDARD)) {\n                g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n                g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n                g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n            }\n            else if (style.equals(PieLabelLinkStyle.QUAD_CURVE)) {\n                QuadCurve2D q = new QuadCurve2D.Float();\n                q.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY);\n                g2.draw(q);\n                g2.draw(new Line2D.Double(elbowX, elbowY, linkX, linkY));\n            }\n            else if (style.equals(PieLabelLinkStyle.CUBIC_CURVE)) {\n                CubicCurve2D c = new CubicCurve2D .Float();\n                c.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY,\n                        linkX, linkY);\n                g2.draw(c);\n            }\n        }\n\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);\n\n    }
106	private static void checkFunctionClassLoader(Method method, ClassLoader parent) {\n    boolean ok = false;\n    try {\n      final Class<?> clazz = method.getDeclaringClass();\n      ok = Class.forName(clazz.getName(), false, parent) == clazz;\n    } catch (ClassNotFoundException e) {\n      ok = false;\n    }\n    if (!ok) {\n      throw new IllegalArgumentException(method + " is not declared by a class which is accessible by the given parent ClassLoader.");\n    }\n  }
107	private static int computeShift(long a, long b) {\n    assert a <= b;\n                    for (int shift = 1; ; ++shift) {\n      final long delta = (b >>> shift) - (a >>> shift);\n      if (delta >= 0 && delta < Grid.ARITY) {\n        return shift;\n      }\n    }\n  }
108	private void isCellFontSizeMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        short size1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getFontHeightInPoints();\n        short size2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getFontHeightInPoints();\n        if (size1 != size2) {\n            addMessage(loc1, loc2,\n                "Cell Font Size does not Match ::",\n                Short.toString(size1),\n                Short.toString(size2)\n            );\n        }\n    }
109	protected void addRun(CTR run) {\n        int pos;\n        pos = paragraph.sizeOfRArray();\n        paragraph.addNewR();\n        paragraph.setRArray(pos, run);\n    }
110	public static double sum(double[] values) {\n        double sum = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sum += values[i];\n        }\n        return sum;\n    }
111	private void pruneBlockedQueue(final DocumentsWriterDeleteQueue flushingQueue) {\n    Iterator<BlockedFlush> iterator = blockedFlushes.iterator();\n    while (iterator.hasNext()) {\n      BlockedFlush blockedFlush = iterator.next();\n      if (blockedFlush.dwpt.deleteQueue == flushingQueue) {\n        iterator.remove();\n        assert !flushingWriters.containsKey(blockedFlush.dwpt) : "DWPT is already flushing";\n                flushingWriters.put(blockedFlush.dwpt, Long.valueOf(blockedFlush.bytes));\n                flushQueue.add(blockedFlush.dwpt);\n      }\n    }\n  }
112	public Transition[][] getSortedTransitions() {\n    int numStates = getNumStates();\n    Transition[][] transitions = new Transition[numStates][];\n    for(int s=0;s<numStates;s++) {\n      int numTransitions = getNumTransitions(s);\n      transitions[s] = new Transition[numTransitions];\n      for(int t=0;t<numTransitions;t++) {\n        Transition transition = new Transition();\n        getTransition(s, t, transition);\n        transitions[s][t] = transition;\n      }\n    }\n\n    return transitions;\n  }
113	private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    "/tmp/out.dot"\n\n    \n    while (true) {\n            if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n                if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n                              bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n                result.grow(1+upto);\n        \n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          \n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n                    boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n                        if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n                            found = true;\n              break;\n            }\n          }\n\n          if (found) {\n                        arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n                        return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n                    result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          \n          while (true) {\n            \n                                    final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            \n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n                            output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n                            return io;\n            } else {\n                                          fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n                return io;\n      }\n    }\n  }
114	public double getSpaceAfter(){\n        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){\n            public boolean fetch(CTTextParagraphProperties props){\n                if(props.isSetSpcAft()){\n                    CTTextSpacing spc = props.getSpcAft();\n\n                    if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );\n                    else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );\n                    return true;\n                }\n                return false;\n            }\n        };\n        fetchParagraphProperty(fetcher);\n        return fetcher.getValue() == null ? 0 : fetcher.getValue();\n    }
115	public static double average(double[] values) {\n        double ave = 0;\n        double sum = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sum += values[i];\n        }\n        ave = sum / values.length;\n        return ave;\n    }
116	private static int between(Automaton.Builder builder,\n      String x, String y, int n,\n      Collection<Integer> initials, boolean zeros) {\n    int s = builder.createState();\n    if (x.length() == n) {\n      builder.setAccept(s, true);\n    } else {\n      if (zeros) {\n        initials.add(s);\n      }\n      char cx = x.charAt(n);\n      char cy = y.charAt(n);\n      if (cx == cy) {\n        builder.addTransition(s, between(builder, x, y, n + 1, initials, zeros && cx == '0'), cx);\n      } else {         builder.addTransition(s, atLeast(builder, x, n + 1, initials, zeros && cx == '0'), cx);\n        builder.addTransition(s, atMost(builder, y, n + 1), cy);\n        if (cx + 1 < cy) {\n          builder.addTransition(s, anyOfRightLength(builder, x, n+1), (char) (cx + 1), (char) (cy - 1));\n        }\n      }\n    }\n\n    return s;\n  }
117	private void parseContentTypesFile(InputStream in)\n            throws InvalidFormatException {\n        try {\n            Document xmlContentTypetDoc = DocumentHelper.readDocument(in);\n\n                        NodeList defaultTypes = xmlContentTypetDoc.getDocumentElement().getElementsByTagNameNS(TYPES_NAMESPACE_URI, DEFAULT_TAG_NAME);\n            int defaultTypeCount = defaultTypes.getLength();\n            for (int i = 0; i < defaultTypeCount; i++) {\n                Element element = (Element) defaultTypes.item(i);\n                String extension = element.getAttribute(EXTENSION_ATTRIBUTE_NAME);\n                String contentType = element.getAttribute(CONTENT_TYPE_ATTRIBUTE_NAME);\n                addDefaultContentType(extension, contentType);\n            }\n\n                        NodeList overrideTypes = xmlContentTypetDoc.getDocumentElement().getElementsByTagNameNS(TYPES_NAMESPACE_URI, OVERRIDE_TAG_NAME);\n            int overrideTypeCount = overrideTypes.getLength();\n            for (int i = 0; i < overrideTypeCount; i++) {\n                Element element = (Element) overrideTypes.item(i);\n                URI uri = new URI(element.getAttribute(PART_NAME_ATTRIBUTE_NAME));\n                PackagePartName partName = PackagingURIHelper.createPartName(uri);\n                String contentType = element.getAttribute(CONTENT_TYPE_ATTRIBUTE_NAME);\n                addOverrideContentType(partName, contentType);\n            }\n        } catch (URISyntaxException | IOException | SAXException e) {\n            throw new InvalidFormatException(e.getMessage());\n        }\n    }
118	public static boolean equal(double[][] a, double[][] b) {\n        if (a == null) {\n            return (b == null);\n        }\n        if (b == null) {\n            return false;          }\n        if (a.length != b.length) {\n            return false;\n        }\n        for (int i = 0; i < a.length; i++) {\n            if (!Arrays.equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }
119	public static Plane constructNormalizedYPlane(final Vector... planePoints) {\n        double bestDistance = 0.0;\n    Vector bestPoint = null;\n    for (final Vector point : planePoints) {\n      final double pointDist = point.x * point.x + point.z * point.z;\n      if (pointDist > bestDistance) {\n        bestDistance = pointDist;\n        bestPoint = point;\n      }\n    }\n    return constructNormalizedYPlane(bestPoint.x, bestPoint.z, 0.0);\n  }
120	public static Options parseOptions(String[] args) {\n    Options opts = new Options();\n\n    int i = 0;\n    while(i < args.length) {\n      String arg = args[i];\n      if ("-fast".equals(arg)) {\n        opts.doChecksumsOnly = true;\n      } else if ("-exorcise".equals(arg)) {\n        opts.doExorcise = true;\n      } else if ("-crossCheckTermVectors".equals(arg)) {\n        opts.doCrossCheckTermVectors = true;\n      } else if (arg.equals("-verbose")) {\n        opts.verbose = true;\n      } else if (arg.equals("-segment")) {\n        if (i == args.length-1) {\n          throw new IllegalArgumentException("ERROR: missing name for -segment option");\n        }\n        i++;\n        opts.onlySegments.add(args[i]);\n      } else if ("-dir-impl".equals(arg)) {\n        if (i == args.length - 1) {\n          throw new IllegalArgumentException("ERROR: missing value for -dir-impl option");\n        }\n        i++;\n        opts.dirImpl = args[i];\n      } else {\n        if (opts.indexPath != null) {\n          throw new IllegalArgumentException("ERROR: unexpected extra argument '" + args[i] + "'");\n        }\n        opts.indexPath = args[i];\n      }\n      i++;\n    }\n\n    if (opts.indexPath == null) {\n      throw new IllegalArgumentException("\nERROR: index path not specified" +\n                         "\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-exorcise] [-crossCheckTermVectors] [-segment X] [-segment Y] [-dir-impl X]\n" +\n                         "\n" +\n                         "  -exorcise: actually write a new segments_N file, removing any problematic segments\n" +\n                         "  -fast: just verify file checksums, omitting logical integrity checks\n" + \n                         "  -crossCheckTermVectors: verifies that term vectors match postings; THIS IS VERY SLOW!\n" +\n                         "  -codec X: when exorcising, codec to write the new segments_N file with\n" +\n                         "  -verbose: print additional details\n" +\n                         "  -segment X: only check the specified segments.  This can be specified multiple\n" + \n                         "              times, to check more than one segment, eg '-segment _2 -segment _a'.\n" +\n                         "              You can't use this with the -exorcise option\n" +\n                         "  -dir-impl X: use a specific " + FSDirectory.class.getSimpleName() + " implementation. " +\n                         "If no package is specified the " + FSDirectory.class.getPackage().getName() + " package will be used.\n" +\n                         "\n" +\n                         "**WARNING**: -exorcise *LOSES DATA*. This should only be used on an emergency basis as it will cause\n" +\n                         "documents (perhaps many) to be permanently removed from the index.  Always make\n" +\n                         "a backup copy of your index before running this!  Do not run this tool on an index\n" +\n                         "that is actively being written to.  You have been warned!\n" +\n                         "\n" +\n                         "Run without -exorcise, this tool will open the index, report version information\n" +\n                         "and report any exceptions it hits and what action it would take if -exorcise were\n" +\n                         "specified.  With -exorcise, this tool will remove any segments that have issues and\n" + \n                         "write a new segments_N file.  This means all documents contained in the affected\n" +\n                         "segments will be removed.\n" +\n                         "\n" +\n                         "This tool exits with exit code 1 if the index cannot be opened or has any\n" +\n                         "corruption, else 0.\n");\n    }\n\n    if (opts.onlySegments.size() == 0) {\n      opts.onlySegments = null;\n    } else if (opts.doExorcise) {\n      throw new IllegalArgumentException("ERROR: cannot specify both -exorcise and -segment");\n    }\n    \n    if (opts.doChecksumsOnly && opts.doCrossCheckTermVectors) {\n      throw new IllegalArgumentException("ERROR: cannot specify both -fast and -crossCheckTermVectors");\n    }\n\n    return opts;\n  }
121	public static CompressingCodec randomInstance(Random random, int chunkSize, int maxDocsPerChunk, boolean withSegmentSuffix, int blockSize) {\n    switch (random.nextInt(4)) {\n    case 0:\n      return new FastCompressingCodec(chunkSize, maxDocsPerChunk, withSegmentSuffix, blockSize);\n    case 1:\n      return new FastDecompressionCompressingCodec(chunkSize, maxDocsPerChunk, withSegmentSuffix, blockSize);\n    case 2:\n      return new HighCompressionCompressingCodec(chunkSize, maxDocsPerChunk, withSegmentSuffix, blockSize);\n    case 3:\n      return new DummyCompressingCodec(chunkSize, maxDocsPerChunk, withSegmentSuffix, blockSize);\n    default:\n      throw new AssertionError();\n    }\n  }
122	public static FSDirectory newFSDirectory(String clazzName, Path path, LockFactory lf) {\n    try {\n      final Class<? extends FSDirectory> clazz = loadFSDirectoryClass(clazzName);\n      return newFSDirectory(clazz, path, lf);\n    } catch (ClassNotFoundException e) {\n      throw new IllegalArgumentException(FSDirectory.class.getSimpleName()\n          + " implementation not found: " + clazzName, e);\n    } catch (ClassCastException e) {\n      throw new IllegalArgumentException(clazzName + " is not a " + FSDirectory.class.getSimpleName()\n          + " implementation", e);\n    } catch (NoSuchMethodException e) {\n      throw new IllegalArgumentException(clazzName + " constructor with "\n          + Path.class.getSimpleName() + " as parameter not found", e);\n    } catch (Exception e) {\n      throw new IllegalArgumentException("Error creating " + clazzName + " instance", e);\n    }\n  }
123	private Rectangle2D createAlignedRectangle2D(Size2D dimensions,\n            Rectangle2D frame, HorizontalAlignment hAlign,\n            VerticalAlignment vAlign) {\n        double x = Double.NaN;\n        double y = Double.NaN;\n        if (hAlign == HorizontalAlignment.LEFT) {\n            x = frame.getX();\n        }\n        else if (hAlign == HorizontalAlignment.CENTER) {\n            x = frame.getCenterX() - (dimensions.width / 2.0);\n        }\n        else if (hAlign == HorizontalAlignment.RIGHT) {\n            x = frame.getMaxX() - dimensions.width;\n        }\n        if (vAlign == VerticalAlignment.TOP) {\n            y = frame.getY();\n        }\n        else if (vAlign == VerticalAlignment.CENTER) {\n            y = frame.getCenterY() - (dimensions.height / 2.0);\n        }\n        else if (vAlign == VerticalAlignment.BOTTOM) {\n            y = frame.getMaxY() - dimensions.height;\n        }\n\n        return new Rectangle2D.Double(x, y, dimensions.width,\n                dimensions.height);\n    }
124	private List datasetsMappedToRangeAxis(int index) {\n        Integer key = new Integer(index);\n        List result = new ArrayList();\n        for (CategoryDataset dataset : this.datasets.values()) {\n            int i = indexOf(dataset);\n            List mappedAxes = (List) this.datasetToRangeAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (key.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            } else {\n                if (mappedAxes.contains(key)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }
125	public String valueToString(double value) {\n        String strToReturn;\n        try {\n            strToReturn = (String) this.symbols.get((int) value);\n        }\n        catch (IndexOutOfBoundsException  ex) {\n            strToReturn = "";\n        }\n        return strToReturn;\n    }
126	public static double getCellWidth(Cell cell, int defaultCharWidth, DataFormatter formatter, boolean useMergedCells) {\n        Sheet sheet = cell.getSheet();\n        Workbook wb = sheet.getWorkbook();\n        Row row = cell.getRow();\n        int column = cell.getColumnIndex();\n\n                        int colspan = 1;\n        for (CellRangeAddress region : sheet.getMergedRegions()) {\n            if (region.isInRange(row.getRowNum(), column)) {\n                if (!useMergedCells) {\n                                        return -1;\n                }\n                cell = row.getCell(region.getFirstColumn());\n                colspan = 1 + region.getLastColumn() - region.getFirstColumn();\n            }\n        }\n\n        CellStyle style = cell.getCellStyle();\n        CellType cellType = cell.getCellType();\n\n                if (cellType == CellType.FORMULA)\n            cellType = cell.getCachedFormulaResultType();\n\n        Font font = wb.getFontAt(style.getFontIndexAsInt());\n\n        double width = -1;\n        if (cellType == CellType.STRING) {\n            RichTextString rt = cell.getRichStringCellValue();\n            String[] lines = rt.getString().split("\\n");\n            for (String line : lines) {\n                String txt = line + defaultChar;\n\n                AttributedString str = new AttributedString(txt);\n                copyAttributes(font, str, 0, txt.length());\n\n                \n\n                width = getCellWidth(defaultCharWidth, colspan, style, width, str);\n            }\n        } else {\n            String sval = null;\n            if (cellType == CellType.NUMERIC) {\n                                try {\n                    sval = formatter.formatCellValue(cell, dummyEvaluator);\n                } catch (Exception e) {\n                    sval = String.valueOf(cell.getNumericCellValue());\n                }\n            } else if (cellType == CellType.BOOLEAN) {\n                sval = String.valueOf(cell.getBooleanCellValue()).toUpperCase(Locale.ROOT);\n            }\n            if(sval != null) {\n                String txt = sval + defaultChar;\n                AttributedString str = new AttributedString(txt);\n                copyAttributes(font, str, 0, txt.length());\n\n                width = getCellWidth(defaultCharWidth, colspan, style, width, str);\n            }\n        }\n        return width;\n    }
127	public boolean changeExternalReference(String oldUrl, String newUrl) {\n        for (ExternalBookBlock ex : _externalBookBlocks) {\n            SupBookRecord externalRecord = ex.getExternalBookRecord();\n            if (externalRecord.isExternalReferences()\n                    && externalRecord.getURL().equals(oldUrl)) {\n\n                externalRecord.setURL(newUrl);\n                return true;\n            }\n        }\n        return false;\n    }
128	protected String generateLabelString(CategoryDataset dataset,\n                                         int row, int column) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        String result;\n        Object[] items = createItemArray(dataset, row, column);\n        result = MessageFormat.format(this.labelFormat, items);\n        return result;\n\n    }
129	CharSequence processPattern(CharSequence input) {\n    final Matcher m = pattern.matcher(input);\n\n    final StringBuffer cumulativeOutput = new StringBuffer();\n    int cumulative = 0;\n    int lastMatchEnd = 0;\n    while (m.find()) {\n      final int groupSize = m.end() - m.start();\n      final int skippedSize = m.start() - lastMatchEnd;\n      lastMatchEnd = m.end();\n\n      final int lengthBeforeReplacement = cumulativeOutput.length() + skippedSize;\n      m.appendReplacement(cumulativeOutput, replacement);\n                  final int replacementSize = cumulativeOutput.length() - lengthBeforeReplacement;\n\n      if (groupSize != replacementSize) {\n        if (replacementSize < groupSize) {\n                                                  cumulative += groupSize - replacementSize;\n          int atIndex = lengthBeforeReplacement + replacementSize;\n                    addOffCorrectMap(atIndex, cumulative);\n        } else {\n                              for (int i = groupSize; i < replacementSize; i++) {\n            addOffCorrectMap(lengthBeforeReplacement + i, --cumulative);\n                      }\n        }\n      }\n    }\n\n        m.appendTail(cumulativeOutput);\n    return cumulativeOutput;    \n  }
130	private static boolean shouldCountFeb29(SimpleDate start, SimpleDate end) {\n		if (isLeapYear(start.year)) {\n	        if (start.year == end.year) {\n	            	            return true;\n	        }\n\n	        switch (start.month) {\n				case SimpleDate.JANUARY:\n				case SimpleDate.FEBRUARY:\n					return true;\n			}\n			return false;\n		}\n		\n		if (isLeapYear(end.year)) {\n			switch (end.month) {\n				case SimpleDate.JANUARY:\n					return false;\n				case SimpleDate.FEBRUARY:\n					break;\n				default:\n					return true;\n			}\n			return end.day == LONG_FEB_LEN;\n		}\n		return false;\n	}
131	protected double calculateTextBlockHeight(TextBlock block,\n            CategoryLabelPosition position, Graphics2D g2) {\n        RectangleInsets insets = getTickLabelInsets();\n        Size2D size = block.calculateDimensions(g2);\n        Rectangle2D box = new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox = ShapeUtilities.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h = rotatedBox.getBounds2D().getHeight()\n                   + insets.getTop() + insets.getBottom();\n        return h;\n    }
132	private boolean advanceRepeatGroups() throws IOException {\n    for (PhrasePositions[] rg: rptGroups) { \n      if (hasMultiTermRpts) {\n                int incr;\n        for (int i=0; i<rg.length; i+=incr) {\n          incr = 1;\n          PhrasePositions pp = rg[i];\n          int k;\n          while((k=collide(pp)) >= 0) {\n            PhrasePositions pp2 = lesser(pp, rg[k]);\n            if (!advancePP(pp2)) {                return false;             }\n            if (pp2.rptInd < i) {               incr = 0;\n              break;\n            }\n          }\n        }\n      } else {\n                for (int j=1; j<rg.length; j++) {\n          for (int k=0; k<j; k++) {\n            if (!rg[j].nextPosition()) {\n              return false;             }\n          }\n        }\n      }\n    }\n    return true;   }
133	private String dumpBytes(byte[] data, int offset, int len) {\n		StringBuffer ret = new StringBuffer();\n		for(int i=0; i<len; i++) {\n			int j = i + offset;\n			int b = data[j];\n			if(b < 0) { b += 256; }\n\n			String bs = Integer.toHexString(b);\n			if(bs.length() == 1)\n				ret.append('0');\n			ret.append(bs);\n			ret.append(' ');\n		}\n		return ret.toString();\n	}
134	protected void extractFile(Path sgmFile) {\n    try (BufferedReader reader = Files.newBufferedReader(sgmFile, StandardCharsets.ISO_8859_1)) {\n      StringBuilder buffer = new StringBuilder(1024);\n      StringBuilder outBuffer = new StringBuilder(1024);\n\n      String line = null;\n      int docNumber = 0;\n      while ((line = reader.readLine()) != null) {\n        \n        if (line.indexOf("</REUTERS") == -1) {\n          \n          buffer.append(line).append(' ');                                                                                            } else {\n                    Matcher matcher = EXTRACTION_PATTERN.matcher(buffer);\n          while (matcher.find()) {\n            for (int i = 1; i <= matcher.groupCount(); i++) {\n              if (matcher.group(i) != null) {\n                outBuffer.append(matcher.group(i));\n              }\n            }\n            outBuffer.append(System.lineSeparator()).append(System.lineSeparator());\n          }\n          String out = outBuffer.toString();\n          for (int i = 0; i < META_CHARS_SERIALIZATIONS.length; i++) {\n            out = out.replaceAll(META_CHARS_SERIALIZATIONS[i], META_CHARS[i]);\n          }\n          Path outFile = outputDir.resolve(sgmFile.getFileName() + "-" + (docNumber++) + ".txt");\n                    try (BufferedWriter writer = Files.newBufferedWriter(outFile, StandardCharsets.UTF_8)) {\n            writer.write(out);\n          }\n          outBuffer.setLength(0);\n          buffer.setLength(0);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }
135	private static CountryRecord createCountry() {\n        CountryRecord retval = new CountryRecord();\n\n        retval.setDefaultCountry(( short ) 1);\n\n                if ( "ru_RU".equals( LocaleUtil.getUserLocale().toString() ) ) {\n            retval.setCurrentCountry(( short ) 7);\n        } else {\n            retval.setCurrentCountry(( short ) 1);\n        }\n\n        return retval;\n    }
136	private void checkForEmptyCellComments(EmptyCellCommentsCheckType type) {\n       if (commentCellRefs != null && !commentCellRefs.isEmpty()) {\n                                 if (type == EmptyCellCommentsCheckType.END_OF_SHEET_DATA) {\n               while (!commentCellRefs.isEmpty()) {\n                   outputEmptyCellComment(commentCellRefs.remove());\n               }\n               return;\n           }\n\n                      if (this.cellRef == null) {\n               if (type == EmptyCellCommentsCheckType.END_OF_ROW) {\n                   while (!commentCellRefs.isEmpty()) {\n                       if (commentCellRefs.peek().getRow() == rowNum) {\n                           outputEmptyCellComment(commentCellRefs.remove());\n                       } else {\n                           return;\n                       }\n                   }\n                   return;\n               } else {\n                   throw new IllegalStateException("Cell ref should be null only if there are only empty cells in the row; rowNum: " + rowNum);\n               }\n           }\n\n           CellAddress nextCommentCellRef;\n           do {\n               CellAddress cellRef = new CellAddress(this.cellRef);\n               CellAddress peekCellRef = commentCellRefs.peek();\n               if (type == EmptyCellCommentsCheckType.CELL && cellRef.equals(peekCellRef)) {\n                                      commentCellRefs.remove();\n                   return;\n               } else {\n                                      int comparison = peekCellRef.compareTo(cellRef);\n                   if (comparison > 0 && type == EmptyCellCommentsCheckType.END_OF_ROW && peekCellRef.getRow() <= rowNum) {\n                       nextCommentCellRef = commentCellRefs.remove();\n                       outputEmptyCellComment(nextCommentCellRef);\n                   } else if (comparison < 0 && type == EmptyCellCommentsCheckType.CELL && peekCellRef.getRow() <= rowNum) {\n                       nextCommentCellRef = commentCellRefs.remove();\n                       outputEmptyCellComment(nextCommentCellRef);\n                   } else {\n                       nextCommentCellRef = null;\n                   }\n               }\n           } while (nextCommentCellRef != null && !commentCellRefs.isEmpty());\n       }\n   }
137	static Class<?> readClass(final InputStream inputStream) throws IOException, ClassNotFoundException {\n    boolean standard = readBoolean(inputStream);\n    if (standard) {\n      int index = inputStream.read();\n      return StandardObjects.codeRegsitry.get(index);\n    }\n    else {\n      String className = readString(inputStream);\n      return  Class.forName(className);\n    }\n  }
138	public void formatValue(StringBuffer toAppendTo, Object value) {\n        if (value instanceof Number) {\n            double val = ((Number) value).doubleValue();\n            if (val == 0) {\n                toAppendTo.append('0');\n                return;\n            }\n\n            String fmt;\n            double exp = Math.log10(Math.abs(val));\n            boolean stripZeros = true;\n            if (exp > 10 || exp < -9)\n                fmt = "%1.5E";\n            else if ((long) val != val)\n                fmt = "%1.9f";\n            else {\n                fmt = "%1.0f";\n                stripZeros = false;\n            }\n\n            Formatter formatter = new Formatter(toAppendTo, locale);\n            try {\n                formatter.format(locale, fmt, value);\n            } finally {\n                formatter.close();\n            }\n            if (stripZeros) {\n                                int removeFrom;\n                if (fmt.endsWith("E"))\n                    removeFrom = toAppendTo.lastIndexOf("E") - 1;\n                else\n                    removeFrom = toAppendTo.length() - 1;\n                while (toAppendTo.charAt(removeFrom) == '0') {\n                    toAppendTo.deleteCharAt(removeFrom--);\n                }\n                if (toAppendTo.charAt(removeFrom) == '.') {\n                    toAppendTo.deleteCharAt(removeFrom--);\n                }\n            }\n        } else if (value instanceof Boolean) {\n            toAppendTo.append(value.toString().toUpperCase(Locale.ROOT));\n        } else {\n            toAppendTo.append(value);\n        }\n    }
139	protected void init(){\n                int type = getTextType();\n\n        int head;\n        int pos = 0;\n\n                short levels = LittleEndian.getShort(_data, 0);\n        pos += LittleEndian.SHORT_SIZE;\n\n        paragraphStyles = new ArrayList<>(levels);\n        charStyles = new ArrayList<>(levels);\n\n        for(short i = 0; i < levels; i++) {\n            TextPropCollection prprops = new TextPropCollection(0, TextPropType.paragraph);\n            if (type >= TextHeaderAtom.CENTRE_BODY_TYPE) {\n                                short indentLevel = LittleEndian.getShort(_data, pos);\n                prprops.setIndentLevel(indentLevel);\n                pos += LittleEndian.SHORT_SIZE;\n            } else {\n                prprops.setIndentLevel((short)-1);\n            }\n\n            head = LittleEndian.getInt(_data, pos);\n            pos += LittleEndian.INT_SIZE;\n            \n            pos += prprops.buildTextPropList( head, _data, pos);\n            paragraphStyles.add(prprops);\n\n            head = LittleEndian.getInt(_data, pos);\n            pos += LittleEndian.INT_SIZE;\n            TextPropCollection chprops = new TextPropCollection(0, TextPropType.character);\n            pos += chprops.buildTextPropList( head, _data, pos);\n            charStyles.add(chprops);\n        }\n    }
140	public static Record createRecordForType(long type, byte[] b, int start, int len) {\n												RecordConstructor c = RecordTypes.forTypeID((short)type).recordConstructor;\n		if (c == null) {\n															c = RecordTypes.UnknownRecordPlaceholder.recordConstructor;\n		}\n\n		final Record toReturn;\n		try {\n			toReturn = c.apply(b, start, len);\n		} catch(RuntimeException e) {\n									if(start + len > b.length ) {\n				logger.log(POILogger.WARN, "Warning: Skipping record of type " + type + " at position " + start + " which claims to be longer than the file! (" + len + " vs " + (b.length-start) + ")");\n				return null;\n			}\n\n			throw new HSLFException("Couldn't instantiate the class for type with id " + type + " on class " + c + " : " + e, e);\n		}\n\n		\n				if(toReturn instanceof PositionDependentRecord) {\n			PositionDependentRecord pdr = (PositionDependentRecord)toReturn;\n			pdr.setLastOnDiskOffset(start);\n		}\n\n				return toReturn;\n	}
141	private void recalculateBounds() {\n        this.minStartIndex = -1;\n        this.minMiddleIndex = -1;\n        this.minEndIndex = -1;\n        this.maxStartIndex = -1;\n        this.maxMiddleIndex = -1;\n        this.maxEndIndex = -1;\n        for (int i = 0; i < this.data.size(); i++) {\n            TimePeriodValue tpv = (TimePeriodValue) this.data.get(i);\n            updateBounds(tpv.getPeriod(), i);\n        }\n    }
142	public EscherDgRecord createDgRecord() {\n        EscherDgRecord dg = new EscherDgRecord();\n        dg.setRecordId( EscherDgRecord.RECORD_ID );\n        short dgId = findNewDrawingGroupId();\n        dg.setOptions( (short) ( dgId << 4 ) );\n        dg.setNumShapes( 0 );\n        dg.setLastMSOSPID( -1 );\n        drawingGroups.add(dg);\n        dgg.addCluster( dgId, 0 );\n        dgg.setDrawingsSaved( dgg.getDrawingsSaved() + 1 );\n        return dg;\n    }
143	private void initParagraphs() {\n		if (!_parRangeFound) {\n			int[] point = findRange(_paragraphs, _start, _end);\n			_parStart = point[0];\n			_parEnd = point[1];\n			_parRangeFound = true;\n		}\n	}
144	public static double coerceValueToDouble(ValueEval ev) throws EvaluationException {\n\n        if (ev == BlankEval.instance) {\n            return 0.0;\n        }\n        if (ev instanceof NumericValueEval) {\n                        return ((NumericValueEval)ev).getNumberValue();\n        }\n        if (ev instanceof StringEval) {\n            Double dd = parseDouble(((StringEval) ev).getStringValue());\n            if (dd == null) {\n                throw EvaluationException.invalidValue();\n            }\n            return dd.doubleValue();\n        }\n        throw new RuntimeException("Unexpected arg eval type (" + ev.getClass().getName() + ")");\n    }
145	public static JFreeChart createWindPlot(String title, String xAxisLabel,\n            String yAxisLabel, WindDataset dataset, boolean legend,\n            boolean tooltips, boolean urls) {\n\n        ValueAxis xAxis = new DateAxis(xAxisLabel);\n        ValueAxis yAxis = new NumberAxis(yAxisLabel);\n        yAxis.setRange(-12.0, 12.0);\n\n        WindItemRenderer renderer = new WindItemRenderer();\n        if (tooltips) {\n            renderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());\n        }\n        if (urls) {\n            renderer.setURLGenerator(new StandardXYURLGenerator());\n        }\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
146	protected Passage[] getSummaryPassagesNoHighlight(int maxPassages) {\n    assert breakIterator.current() == breakIterator.first();\n\n    List<Passage> passages = new ArrayList<>(Math.min(maxPassages, 10));\n    int pos = breakIterator.current();\n    assert pos == 0;\n    while (passages.size() < maxPassages) {\n      int next = breakIterator.next();\n      if (next == BreakIterator.DONE) {\n        break;\n      }\n      Passage passage = new Passage();\n      passage.setScore(Float.NaN);\n      passage.setStartOffset(pos);\n      passage.setEndOffset(next);\n      passages.add(passage);\n      pos = next;\n    }\n\n    return passages.toArray(new Passage[passages.size()]);\n  }
147	public void updateAveragedOutlier() {\n        double totalXCoords = 0.0;\n        double totalYCoords = 0.0;\n        int size = getItemCount();\n        for (Iterator iterator = this.outliers.iterator();\n                iterator.hasNext();) {\n            Outlier o = (Outlier) iterator.next();\n            totalXCoords += o.getX();\n            totalYCoords += o.getY();\n        }\n        getAveragedOutlier().getPoint().setLocation(\n                new Point2D.Double(totalXCoords / size, totalYCoords / size));\n    }
148	public static XYZSolid makeXYZSolid(final PlanetModel planetModel, final double minX, final double maxX, final double minY, final double maxY, final double minZ, final double maxZ) {\n    if (Math.abs(maxX - minX) < Vector.MINIMUM_RESOLUTION) {\n      if (Math.abs(maxY - minY) < Vector.MINIMUM_RESOLUTION) {\n        if (Math.abs(maxZ - minZ) < Vector.MINIMUM_RESOLUTION) {\n          return new dXdYdZSolid(planetModel, (minX+maxX) * 0.5, (minY+maxY) * 0.5, minZ);\n        } else {\n          return new dXdYZSolid(planetModel, (minX+maxX) * 0.5, (minY+maxY) * 0.5, minZ, maxZ);\n        }\n      } else {\n        if (Math.abs(maxZ - minZ) < Vector.MINIMUM_RESOLUTION) {\n          return new dXYdZSolid(planetModel, (minX+maxX) * 0.5, minY, maxY, (minZ+maxZ) * 0.5);\n        } else {\n          return new dXYZSolid(planetModel, (minX+maxX) * 0.5, minY, maxY, minZ, maxZ);\n        }\n      }\n    }\n    if (Math.abs(maxY - minY) < Vector.MINIMUM_RESOLUTION) {\n      if (Math.abs(maxZ - minZ) < Vector.MINIMUM_RESOLUTION) {\n        return new XdYdZSolid(planetModel, minX, maxX, (minY+maxY) * 0.5, (minZ+maxZ) * 0.5);\n      } else {\n        return new XdYZSolid(planetModel, minX, maxX, (minY+maxY) * 0.5, minZ, maxZ);\n      }\n    }\n    if (Math.abs(maxZ - minZ) < Vector.MINIMUM_RESOLUTION) {\n      return new XYdZSolid(planetModel, minX, maxX, minY, maxY, (minZ+maxZ) * 0.5);\n    }\n    return new StandardXYZSolid(planetModel, minX, maxX, minY, maxY, minZ, maxZ);\n  }
149	protected HSLFEscherClientDataRecord getClientData(boolean create) {\n        HSLFEscherClientDataRecord clientData = getEscherChild(EscherClientDataRecord.RECORD_ID);\n        if (clientData == null && create) {\n            clientData = new HSLFEscherClientDataRecord();\n            clientData.setOptions((short)15);\n            clientData.setRecordId(EscherClientDataRecord.RECORD_ID);\n            getSpContainer().addChildBefore(clientData, EscherTextboxRecord.RECORD_ID);\n        }\n        return clientData;\n    }
150	private boolean applyAllDeletes(DocumentsWriterDeleteQueue deleteQueue) throws IOException {\n    if (flushControl.getAndResetApplyAllDeletes()) {\n      if (deleteQueue != null) {\n        ticketQueue.addDeletes(deleteQueue);\n      }\n      putEvent(ApplyDeletesEvent.INSTANCE);       return true;\n    }\n    return false;\n  }
151	public int stemPrefix(char s[], int len) {\n    for (int i = 0; i < prefixes.length; i++) \n      if (startsWithCheckLength(s, len, prefixes[i]))\n        return deleteN(s, 0, len, prefixes[i].length);\n    return len;\n  }
152	public long deleteDocuments(Term... terms) throws IOException {\n    ensureOpen();\n    try {\n      long seqNo = docWriter.deleteTerms(terms);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, "deleteDocuments(Term..)");\n\n            return -1;\n    }\n  }
153	public Point2D translateScreenToJava2D(Point screenPoint) {\n        Insets insets = getInsets();\n        double x = (screenPoint.getX() - insets.left) / this.scaleX;\n        double y = (screenPoint.getY() - insets.top) / this.scaleY;\n        return new Point2D.Double(x, y);\n    }
154	public static void main(final String args[]) throws IOException {\n      if (args.length == 0) {\n         System.err.println("Must specify at least one file to view");\n         System.exit(1);\n      }\n\n      boolean withSizes = false;\n      boolean newPOIFS = true;\n      for (String arg : args) {\n         if (arg.equalsIgnoreCase("-size") || arg.equalsIgnoreCase("-sizes")) {\n            withSizes = true;\n         } else if (arg.equalsIgnoreCase("-old") || arg.equalsIgnoreCase("-old-poifs")) {\n            newPOIFS = false;\n         } else {\n            if (newPOIFS) {\n               viewFile(arg, withSizes);\n            } else {\n               viewFileOld(arg, withSizes);\n            }\n         }\n      }\n   }
155	private static void refreshRecords(List<HSLFTextParagraph> paragraphs) {\n        TextHeaderAtom headerAtom = paragraphs.get(0)._headerAtom;\n        RecordContainer _txtbox = headerAtom.getParentRecord();\n        if (_txtbox instanceof EscherTextboxWrapper) {\n            try {\n                _txtbox.writeOut(null);\n            } catch (IOException e) {\n                throw new HSLFException("failed dummy write", e);\n            }\n        }\n    }
156	protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                      List ticks) {\n                if (!isRangeGridlinesVisible() && !isRangeMinorGridlinesVisible()) {\n            return;\n        }\n                ValueAxis axis = getRangeAxis();\n        if (axis == null) {\n            return;\n        }\n                CategoryItemRenderer r = getRenderer();\n        if (r == null) {\n            return;\n        }\n\n        Stroke gridStroke = null;\n        Paint gridPaint = null;\n        boolean paintLine;\n        Iterator iterator = ticks.iterator();\n        while (iterator.hasNext()) {\n            paintLine = false;\n            ValueTick tick = (ValueTick) iterator.next();\n            if ((tick.getTickType() == TickType.MINOR)\n                    && isRangeMinorGridlinesVisible()) {\n                gridStroke = getRangeMinorGridlineStroke();\n                gridPaint = getRangeMinorGridlinePaint();\n                paintLine = true;\n            }\n            else if ((tick.getTickType() == TickType.MAJOR)\n                    && isRangeGridlinesVisible()) {\n                gridStroke = getRangeGridlineStroke();\n                gridPaint = getRangeGridlinePaint();\n                paintLine = true;\n            }\n            if (((tick.getValue() != 0.0)\n                    || !isRangeZeroBaselineVisible()) && paintLine) {\n                                                if (r instanceof AbstractCategoryItemRenderer) {\n                    AbstractCategoryItemRenderer aci\n                            = (AbstractCategoryItemRenderer) r;\n                    aci.drawRangeLine(g2, this, axis, dataArea,\n                            tick.getValue(), gridPaint, gridStroke);\n                }\n                else {\n                                                            r.drawRangeGridline(g2, this, axis, dataArea,\n                            tick.getValue());\n                }\n            }\n        }\n    }
157	public double normalDistance(final double x, final double y, final double z, final Membership... bounds) {\n\n    final double dist = evaluate(x,y,z);\n    final double perpX = x - dist * this.x;\n    final double perpY = y - dist * this.y;\n    final double perpZ = z - dist * this.z;\n\n    if (!meetsAllBounds(perpX, perpY, perpZ, bounds)) {\n      return Double.POSITIVE_INFINITY;\n    }\n    \n    return Math.abs(dist);\n  }
158	private FacetResult drillDown() throws IOException {\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    SortedSetDocValuesReaderState state = new DefaultSortedSetDocValuesReaderState(indexReader);\n\n        DrillDownQuery q = new DrillDownQuery(config);\n    q.add("Publish Year", "2010");\n    FacetsCollector fc = new FacetsCollector();\n    FacetsCollector.search(searcher, q, 10, fc);\n\n        Facets facets = new SortedSetDocValuesFacetCounts(state, fc);\n    FacetResult result = facets.getTopChildren(10, "Author");\n    indexReader.close();\n    \n    return result;\n  }
159	public static CharArrayMap<String> getStemDict(Reader reader, CharArrayMap<String> result) throws IOException {\n    BufferedReader br = null;\n    try {\n      br = getBufferedReader(reader);\n      String line;\n      while ((line = br.readLine()) != null) {\n        String[] wordstem = line.split("\t", 2);\n        result.put(wordstem[0], wordstem[1]);\n      }\n    } finally {\n      IOUtils.close(br);\n    }\n    return result;\n  }
160	protected final int getNextPartNumber(POIXMLRelation descriptor, int minIdx) {\n        OPCPackage pkg = packagePart.getPackage();\n\n        try {\n            String name = descriptor.getDefaultFileName();\n            if (name.equals(descriptor.getFileName(9999))) {\n                                PackagePartName ppName = PackagingURIHelper.createPartName(name);\n                if (pkg.containPart(ppName)) {\n                                        return -1;\n                } else {\n                                        return 0;\n                }\n            }\n\n                        int idx = (minIdx < 0) ? 1 : minIdx;\n            int maxIdx = minIdx + pkg.getParts().size();\n            while (idx <= maxIdx) {\n                name = descriptor.getFileName(idx);\n                PackagePartName ppName = PackagingURIHelper.createPartName(name);\n                if (!pkg.containPart(ppName)) {\n                    return idx;\n                }\n                idx++;\n            }\n        } catch (InvalidFormatException e) {\n                        throw new POIXMLException(e);\n        }\n        return -1;\n    }
161	protected <T> T doAction(HttpResponse response, boolean consume, Callable<T> call) throws IOException {\n    Throwable th = null;\n    try {\n      return call.call();\n    } catch (Throwable t) {\n      th = t;\n    } finally {\n      try {\n        verifyStatus(response);\n      } finally {\n        if (consume) {\n          EntityUtils.consumeQuietly(response.getEntity());\n        }\n      }\n    }\n    throw IOUtils.rethrowAlways(th); \n  }
162	protected final void rewindPrefix() throws IOException {\n    if (upto == 0) {\n            upto = 1;\n      fst.readFirstTargetArc(getArc(0), getArc(1), fstReader);\n      return;\n    }\n    \n    final int currentLimit = upto;\n    upto = 1;\n    while (upto < currentLimit && upto <= targetLength+1) {\n      final int cmp = getCurrentLabel() - getTargetLabel();\n      if (cmp < 0) {\n                        break;\n      } else if (cmp > 0) {\n                final FST.Arc<T> arc = getArc(upto);\n        fst.readFirstTargetArc(getArc(upto-1), arc, fstReader);\n                break;\n      }\n      upto++;\n    }\n      }
163	public int newRound() {\n    roundNumber++;\n\n    StringBuilder sb = new StringBuilder("--> Round ").append(roundNumber - 1).append("-->").append(roundNumber);\n\n        if (valByRound.size() > 0) {\n      sb.append(": ");\n      for (final String name : valByRound.keySet()) {\n        Object a = valByRound.get(name);\n        if (a instanceof int[]) {\n          int ai[] = (int[]) a;\n          int n1 = (roundNumber - 1) % ai.length;\n          int n2 = roundNumber % ai.length;\n          sb.append("  ").append(name).append(":").append(ai[n1]).append("-->").append(ai[n2]);\n        } else if (a instanceof double[]) {\n          double ad[] = (double[]) a;\n          int n1 = (roundNumber - 1) % ad.length;\n          int n2 = roundNumber % ad.length;\n          sb.append("  ").append(name).append(":").append(ad[n1]).append("-->").append(ad[n2]);\n        } else if (a instanceof String[]) {\n          String ad[] = (String[]) a;\n          int n1 = (roundNumber - 1) % ad.length;\n          int n2 = roundNumber % ad.length;\n          sb.append("  ").append(name).append(":").append(ad[n1]).append("-->").append(ad[n2]);\n        } else {\n          boolean ab[] = (boolean[]) a;\n          int n1 = (roundNumber - 1) % ab.length;\n          int n2 = roundNumber % ab.length;\n          sb.append("  ").append(name).append(":").append(ab[n1]).append("-->").append(ab[n2]);\n        }\n      }\n    }\n\n    System.out.println();\n    System.out.println(sb.toString());\n    System.out.println();\n\n    return roundNumber;\n  }
164	public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n            if (minLatitude == 90.0) {\n            return new MatchNoDocsQuery("LatLonPoint.newBoxQuery with minLatitude=90.0");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n                return new MatchNoDocsQuery("LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0");\n      } else if (maxLongitude < minLongitude) {\n                minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n        if (maxLongitude < minLongitude) {\n            BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n            byte[] leftOpen = lower.clone();\n            NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n            NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }
165	private ClientAnchorDetail fitImageToRows(Sheet sheet, int rowNumber,\n            double reqImageHeightMM, int resizeBehaviour) {\n        Row row;\n        double rowHeightMM;\n        double rowCoordinatesPerMM;\n        int pictureHeightCoordinates;\n        ClientAnchorDetail rowClientAnchorDetail = null;\n\n                row = sheet.getRow(rowNumber);\n        if(row == null) {\n                        row = sheet.createRow(rowNumber);\n        }\n\n                rowHeightMM = row.getHeightInPoints() / ConvertImageUnits.POINTS_PER_MILLIMETRE;\n\n                                        if(rowHeightMM < reqImageHeightMM) {\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_ROW) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                row.setHeightInPoints((float)(reqImageHeightMM *\n                        ConvertImageUnits.POINTS_PER_MILLIMETRE));\n                if(sheet instanceof HSSFSheet) {                    \n                    rowHeightMM = reqImageHeightMM;\n                    rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                        rowHeightMM;\n                    pictureHeightCoordinates = (int)(reqImageHeightMM *\n                            rowCoordinatesPerMM);\n                }\n                else {\n                    pictureHeightCoordinates = (int)(reqImageHeightMM *\n                            AddDimensionedImage.EMU_PER_MM);\n                }\n                rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n            }\n                                                else if((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                    (resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN)) {\n                rowClientAnchorDetail = this.calculateRowLocation(sheet,\n                        rowNumber, reqImageHeightMM);\n            }\n        }\n                else {\n            if(sheet instanceof HSSFSheet) {\n                rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n                pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n            }\n            else {\n                pictureHeightCoordinates = (int)(reqImageHeightMM *\n                        AddDimensionedImage.EMU_PER_MM);\n            }\n            rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n        }\n        return(rowClientAnchorDetail);\n    }
166	synchronized void removeMergeThread() {\n    Thread currentThread = Thread.currentThread();\n        for(int i=0;i<mergeThreads.size();i++) {\n      if (mergeThreads.get(i) == currentThread) {\n        mergeThreads.remove(i);\n        return;\n      }\n    }\n      \n    assert false: "merge thread " + currentThread + " was not found";\n  }
167	private void appendSpecificTypes(Element root,\n            Entry<PackagePartName, String> entry) {\n        Element specificType = root.getOwnerDocument().createElementNS(TYPES_NAMESPACE_URI, OVERRIDE_TAG_NAME);\n        specificType.setAttribute(PART_NAME_ATTRIBUTE_NAME, entry.getKey().getName());\n        specificType.setAttribute(CONTENT_TYPE_ATTRIBUTE_NAME, entry.getValue());\n        root.appendChild(specificType);\n    }
168	private void substitute( StringBuilder buffer )\n    {\n      substCount = 0;\n      for ( int c = 0; c < buffer.length(); c++ ) {\n                if ( c > 0 && buffer.charAt( c ) == buffer.charAt ( c - 1 )  ) {\n          buffer.setCharAt( c, '*' );\n        }\n                else if ( buffer.charAt( c ) == 'ä' ) {\n          buffer.setCharAt( c, 'a' );\n        }\n        else if ( buffer.charAt( c ) == 'ö' ) {\n          buffer.setCharAt( c, 'o' );\n        }\n        else if ( buffer.charAt( c ) == 'ü' ) {\n          buffer.setCharAt( c, 'u' );\n        }\n                else if ( buffer.charAt( c ) == 'ß' ) {\n            buffer.setCharAt( c, 's' );\n            buffer.insert( c + 1, 's' );\n            substCount++;\n        }\n                if ( c < buffer.length() - 1 ) {\n                    if ( ( c < buffer.length() - 2 ) && buffer.charAt( c ) == 's' &&\n            buffer.charAt( c + 1 ) == 'c' && buffer.charAt( c + 2 ) == 'h' )\n          {\n            buffer.setCharAt( c, '$' );\n            buffer.delete( c + 1, c + 3 );\n            substCount += 2;\n          }\n          else if ( buffer.charAt( c ) == 'c' && buffer.charAt( c + 1 ) == 'h' ) {\n            buffer.setCharAt( c, '§' );\n            buffer.deleteCharAt( c + 1 );\n            substCount++;\n          }\n          else if ( buffer.charAt( c ) == 'e' && buffer.charAt( c + 1 ) == 'i' ) {\n            buffer.setCharAt( c, '%' );\n            buffer.deleteCharAt( c + 1 );\n            substCount++;\n          }\n          else if ( buffer.charAt( c ) == 'i' && buffer.charAt( c + 1 ) == 'e' ) {\n            buffer.setCharAt( c, '&' );\n            buffer.deleteCharAt( c + 1 );\n            substCount++;\n          }\n          else if ( buffer.charAt( c ) == 'i' && buffer.charAt( c + 1 ) == 'g' ) {\n            buffer.setCharAt( c, '#' );\n            buffer.deleteCharAt( c + 1 );\n            substCount++;\n          }\n          else if ( buffer.charAt( c ) == 's' && buffer.charAt( c + 1 ) == 't' ) {\n            buffer.setCharAt( c, '!' );\n            buffer.deleteCharAt( c + 1 );\n            substCount++;\n          }\n        }\n      }\n    }
169	public static double sumsq(double[] values) {\n        double sumsq = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sumsq += values[i]*values[i];\n        }\n        return sumsq;\n    }
170	private static void applyHslModOff(double hsl[], int hslPart, int mod, int off) {\n        if (mod == -1) {\n            mod = 100000;\n        }\n        if (off == -1) {\n            off = 0;\n        }\n        if (!(mod == 100000 && off == 0)) {\n            double fOff = off / 1000d;\n            double fMod = mod / 100000d;\n            hsl[hslPart] = hsl[hslPart]*fMod+fOff;\n        }\n    }
171	private InputStream getXLSFromURL(String urlstring) throws MalformedURLException, IOException {\n    URL url = new URL(urlstring);\n    URLConnection uc = url.openConnection();\n    String field = uc.getHeaderField(0);\n    for (int i=0;field != null; i++) {\n      System.out.println(field);\n      field = uc.getHeaderField(i);\n  }\n      return new BufferedInputStream(uc.getInputStream());\n  }
172	public static Query newSlowBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n            if (minLatitude == 90.0) {\n            return new MatchNoDocsQuery("LatLonDocValuesField.newBoxQuery with minLatitude=90.0");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n                return new MatchNoDocsQuery("LatLonDocValuesField.newBoxQuery with minLongitude=maxLongitude=180.0");\n      } else if (maxLongitude < minLongitude) {\n                minLongitude = -180.0;\n      }\n    }\n    return new LatLonDocValuesBoxQuery(field, minLatitude, maxLatitude, minLongitude, maxLongitude);\n  }
173	public static String getFromUnicodeLE0Terminated(\n            final byte[] string,\n            final int offset,\n            final int len)\n            throws ArrayIndexOutOfBoundsException, IllegalArgumentException {\n        if ((offset < 0) || (offset >= string.length)) {\n            throw new ArrayIndexOutOfBoundsException("Illegal offset " + offset + " (String data is of length " + string.length + ")");\n        }\n\n        if ((len < 0) || (((string.length - offset) / 2) < len)) {\n            throw new IllegalArgumentException("Illegal length " + len);\n        }\n\n        final int newOffset;\n        final int newMaxLen;\n        final String prefix;\n\n                if (len > 0 && string[offset] == 0 && string[offset+1] == 0) {\n            newOffset = offset+2;\n            prefix = "?";\n\n                        final int cp = (len > 1) ? LittleEndian.getShort(string, offset+2) : 0;\n            newMaxLen = Character.isJavaIdentifierPart(cp) ? len-1 : 0;\n        } else {\n            newOffset = offset;\n            prefix = "";\n            newMaxLen = len;\n        }\n\n        int newLen = 0;\n\n                for(; newLen < newMaxLen; newLen++) {\n            if (string[newOffset + newLen * 2] == 0 && string[newOffset + newLen * 2 + 1] == 0) {\n                break;\n            }\n        }\n        newLen = Math.min(newLen, newMaxLen);\n\n        return prefix + ((newLen == 0) ? "" : new String(string, newOffset, newLen * 2, UTF16LE));\n    }
174	protected Report reportAll(List<TaskStats> taskStats) {\n    String longestOp = longestOp(taskStats);\n    boolean first = true;\n    StringBuilder sb = new StringBuilder();\n    sb.append(tableTitle(longestOp));\n    sb.append(newline);\n    int reported = 0;\n    for (final TaskStats stat : taskStats) {\n      if (stat.getElapsed()>=0) {         if (!first) {\n          sb.append(newline);\n        }\n        first = false;\n        String line = taskReportLine(longestOp, stat);\n        reported++;\n        if (taskStats.size()>2 && reported%2==0) {\n          line = line.replaceAll("   "," - ");\n        }\n        sb.append(line);\n      }\n    }\n    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());\n    return new Report(reptxt,reported,reported,taskStats.size());\n  }
175	public static DefaultAxisEditor getInstance(Axis axis) {\n\n        if (axis != null) {\n                                    if (axis instanceof NumberAxis) {\n                return new DefaultNumberAxisEditor((NumberAxis) axis);\n            }\n            if (axis instanceof LogAxis) {\n                return new DefaultLogAxisEditor((LogAxis) axis);\n            }\n            else {\n                return new DefaultAxisEditor(axis);\n            }\n        }\n        else {\n            return null;\n        }\n\n    }
176	protected static Map<String,Step> parse(Class<? extends RSLPStemmerBase> clazz, String resource) {\n        try {\n      InputStream is = clazz.getResourceAsStream(resource);\n      LineNumberReader r = new LineNumberReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n      Map<String,Step> steps = new HashMap<>();\n      String step;\n      while ((step = readLine(r)) != null) {\n        Step s = parseStep(r, step);\n        steps.put(s.name, s);\n      }\n      r.close();\n      return steps;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }
177	private boolean endsWith(char s[], int len, String suffix) {\n    final int suffixLen = suffix.length();\n    if (suffixLen > len)\n      return false;\n    for (int i = suffixLen - 1; i >= 0; i--)\n      if (s[len -(suffixLen - i)] != suffix.charAt(i))\n        return false;\n    \n    return true;\n  }
178	static void hideDupplicates(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("City");\n        sheet.createRow(1).createCell(0).setCellValue("Boston");\n        sheet.createRow(2).createCell(0).setCellValue("Boston");\n        sheet.createRow(3).createCell(0).setCellValue("Chicago");\n        sheet.createRow(4).createCell(0).setCellValue("Chicago");\n        sheet.createRow(5).createCell(0).setCellValue("New York");\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("A2=A1");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontColorIndex(IndexedColors.WHITE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(1).createCell(1).setCellValue("<== the second (and subsequent) " +\n                "occurences of each region name will have white font colour.  " +\n                "Condition: Formula Is   =A2=A1   (White Font)");\n    }
179	private boolean equalShapes(Shape[] s1, Shape[] s2) {\n        if (s1 == null) {\n            return s2 == null;\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }
180	DirectoryReader getReader(boolean applyAllDeletes, boolean writeAllDeletes) throws IOException {\n    ensureOpen();\n\n    if (writeAllDeletes && applyAllDeletes == false) {\n      throw new IllegalArgumentException("applyAllDeletes must be true when writeAllDeletes=true");\n    }\n\n    final long tStart = System.currentTimeMillis();\n\n    if (infoStream.isEnabled("IW")) {\n      infoStream.message("IW", "flush at getReader");\n    }\n                poolReaders = true;\n    DirectoryReader r = null;\n    doBeforeFlush();\n    boolean anyChanges = false;\n    \n    boolean success2 = false;\n    try {\n      boolean success = false;\n      synchronized (fullFlushLock) {\n        try {\n                    long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            anyChanges = true;\n            seqNo = -seqNo;\n          } else {\n            anyChanges = false;\n          }\n          if (anyChanges == false) {\n                                    flushCount.incrementAndGet();\n          }\n\n          processEvents(false, true);\n\n          if (applyAllDeletes) {\n            applyAllDeletesAndUpdates();\n          }\n\n          synchronized(this) {\n\n                        \n                                    readerPool.writeAllDocValuesUpdates();\n\n            if (writeAllDeletes) {\n                            readerPool.commit(segmentInfos);\n            }\n\n                                                \n            r = StandardDirectoryReader.open(this, segmentInfos, applyAllDeletes, writeAllDeletes);\n            if (infoStream.isEnabled("IW")) {\n              infoStream.message("IW", "return reader version=" + r.getVersion() + " reader=" + r);\n            }\n          }\n          success = true;\n        } finally {\n                    docWriter.finishFullFlush(this, success);\n          if (success) {\n            processEvents(false, true);\n            doAfterFlush();\n          } else {\n            if (infoStream.isEnabled("IW")) {\n              infoStream.message("IW", "hit exception during NRT reader");\n            }\n          }\n        }\n      }\n      anyChanges |= maybeMerge.getAndSet(false);\n      if (anyChanges) {\n        maybeMerge(config.getMergePolicy(), MergeTrigger.FULL_FLUSH, UNBOUNDED_MAX_MERGE_SEGMENTS);\n      }\n      if (infoStream.isEnabled("IW")) {\n        infoStream.message("IW", "getReader took " + (System.currentTimeMillis() - tStart) + " msec");\n      }\n      success2 = true;\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, "getReader");\n            return null;\n    } finally {\n      if (!success2) {\n        IOUtils.closeWhileHandlingException(r);\n      }\n    }\n    return r;\n  }
181	public Set<String> readSetOfStrings() throws IOException {\n    int count = readVInt();\n    if (count == 0) {\n      return Collections.emptySet();\n    } else if (count == 1) {\n      return Collections.singleton(readString());\n    } else {\n      Set<String> set = count > 10 ? new HashSet<>() : new TreeSet<>();\n      for (int i = 0; i < count; i++) {\n        set.add(readString());\n      }\n      return Collections.unmodifiableSet(set);\n    }\n  }
182	public static void check(IndexReader reader, BitSetProducer parentsFilter) throws IOException {\n    for (LeafReaderContext context : reader.leaves()) {\n      if (context.reader().maxDoc() == 0) {\n        continue;\n      }\n      final BitSet parents = parentsFilter.getBitSet(context);\n      if (parents == null || parents.cardinality() == 0) {\n        throw new IllegalStateException("Every segment should have at least one parent, but " + context.reader() + " does not have any");\n      }\n      if (parents.get(context.reader().maxDoc() - 1) == false) {\n        throw new IllegalStateException("The last document of a segment must always be a parent, but " + context.reader() + " has a child as a last doc");\n      }\n      final Bits liveDocs = context.reader().getLiveDocs();\n      if (liveDocs != null) {\n        int prevParentDoc = -1;\n        DocIdSetIterator it = new BitSetIterator(parents, 0L);\n        for (int parentDoc = it.nextDoc(); parentDoc != DocIdSetIterator.NO_MORE_DOCS; parentDoc = it.nextDoc()) {\n          final boolean parentIsLive = liveDocs.get(parentDoc);\n          for (int child = prevParentDoc + 1; child != parentDoc; child++) {\n            final boolean childIsLive = liveDocs.get(child);\n            if (parentIsLive != childIsLive) {\n              if (childIsLive) {\n                throw new IllegalStateException("Parent doc " + parentDoc + " of segment " + context.reader() + " is live but has a deleted child document " + child);\n              } else {\n                throw new IllegalStateException("Parent doc " + parentDoc + " of segment " + context.reader() + " is deleted but has a live child document " + child);\n              }\n            }\n          }\n          prevParentDoc = parentDoc;\n        }\n      }\n    }\n  }
183	@SuppressWarnings("WeakerAccess")\n    public void setLineTailWidth(DecorationSize style) {\n        CTLineProperties ln = getLn(this, true);\n        if (ln == null) {\n            return;\n        }\n        \n        CTLineEndProperties lnEnd = ln.isSetTailEnd() ? ln.getTailEnd() : ln.addNewTailEnd();\n        if (style == null) {\n            if (lnEnd.isSetW()) {\n                lnEnd.unsetW();\n            }\n        } else {\n            lnEnd.setW(STLineEndWidth.Enum.forInt(style.ooxmlId));\n        }\n    }
184	public static List<String> inspectViewable(final Object viewable,\n                                       final boolean drilldown,\n                                       final int indentLevel,\n                                       final String indentString)\n    {\n        List<String> objects = new ArrayList<>();\n\n        if (viewable instanceof POIFSViewable)\n        {\n            POIFSViewable inspected = ( POIFSViewable ) viewable;\n\n            objects.add(indent(indentLevel, indentString,\n                               inspected.getShortDescription()));\n            if (drilldown)\n            {\n                if (inspected.preferArray())\n                {\n                    Object[] data = inspected.getViewableArray();\n\n                    for (int j = 0; j < data.length; j++)\n                    {\n                        objects.addAll(inspectViewable(data[ j ], drilldown,\n                                                       indentLevel + 1,\n                                                       indentString));\n                    }\n                }\n                else\n                {\n                    Iterator<Object> iter = inspected.getViewableIterator();\n\n                    while (iter.hasNext())\n                    {\n                        objects.addAll(inspectViewable(iter.next(),\n                                                       drilldown,\n                                                       indentLevel + 1,\n                                                       indentString));\n                    }\n                }\n            }\n        }\n        else\n        {\n            objects.add(indent(indentLevel, indentString,\n                               viewable.toString()));\n        }\n        return objects;\n    }
185	private CellType getBaseCellType(boolean blankCells) {\n        switch (_cell.getT().intValue()) {\n            case STCellType.INT_B:\n                return CellType.BOOLEAN;\n            case STCellType.INT_N:\n                if (!_cell.isSetV() && blankCells) {\n                                                                                                                        return CellType.BLANK;\n                }\n                return CellType.NUMERIC;\n            case STCellType.INT_E:\n                return CellType.ERROR;\n            case STCellType.INT_S:             case STCellType.INT_INLINE_STR:             case STCellType.INT_STR:\n                 return CellType.STRING;\n            default:\n                throw new IllegalStateException("Illegal cell type: " + this._cell.getT());\n        }\n    }
186	private HashMap<Term,Integer> termGroups(LinkedHashMap<Term,Integer> tord, ArrayList<FixedBitSet> bb) throws IOException {\n    HashMap<Term,Integer> tg = new HashMap<>();\n    Term[] t = tord.keySet().toArray(new Term[0]);\n    for (int i=0; i<bb.size(); i++) {       FixedBitSet bits = bb.get(i);\n      for (int ord = bits.nextSetBit(0); ord != DocIdSetIterator.NO_MORE_DOCS; ord = ord + 1 >= bits.length() ? DocIdSetIterator.NO_MORE_DOCS : bits.nextSetBit(ord + 1)) {\n        tg.put(t[ord],i);\n      }\n    }\n    return tg;\n  }
187	public int stem(char s[], int len) {\n        if (len > 5 && endsWith(s, len, "دا")) {\n      len -= 2;\n    } else if (len > 4 && endsWith(s, len, "نا")) {\n      len--;\n    } else if (len > 6 && endsWith(s, len, "ەوە")) {\n      len -= 3;\n    }\n    \n        if (len > 6 && (endsWith(s, len, "مان") || endsWith(s, len, "یان") || endsWith(s, len, "تان"))) {\n      len -= 3;\n    }\n    \n        if (len > 6 && endsWith(s, len, "ێکی")) {\n      return len-3;\n    } else if (len > 7 && endsWith(s, len, "یەکی")) {\n      return len-4;\n    }\n        if (len > 5 && endsWith(s, len, "ێک")) {\n      return len-2;\n    } else if (len > 6 && endsWith(s, len, "یەک")) {\n      return len-3;\n    }\n        else if (len > 6 && endsWith(s, len, "ەکە")) {\n      return len-3;\n    } else if (len > 5 && endsWith(s, len, "کە")) {\n      return len-2;\n    }\n        else if (len > 7 && endsWith(s, len, "ەکان")) {\n      return len-4;\n    } else if (len > 6 && endsWith(s, len, "کان")) {\n      return len-3;\n    }\n        else if (len > 7 && endsWith(s, len, "یانی")) {\n      return len-4;\n    } else if (len > 6 && endsWith(s, len, "انی")) {\n      return len-3;\n    }\n        else if (len > 6 && endsWith(s, len, "یان")) {\n      return len-3;\n    } else if (len > 5 && endsWith(s, len, "ان")) {\n      return len-2;\n    } \n        else if (len > 7 && endsWith(s, len, "یانە")) {\n      return len-4;\n    } else if (len > 6 && endsWith(s, len, "انە")) {\n      return len-3;\n    }\n        else if (len > 5 && (endsWith(s, len, "ایە") || endsWith(s, len, "ەیە"))) {\n      return len-2;\n    } else if (len > 4 && endsWith(s, len, "ە")) {\n      return len-1;\n    }\n        else if (len > 4 && endsWith(s, len, "ی")) {\n      return len-1;\n    }\n    return len;\n  }
188	public ValueEval getDynamicReference(String workbookName, String sheetName, String refStrPart1,\n            String refStrPart2, boolean isA1Style) {\n        if (!isA1Style) {\n            throw new RuntimeException("R1C1 style not supported yet");\n        }\n        SheetRefEvaluator se = createExternSheetRefEvaluator(workbookName, sheetName);\n        if (se == null) {\n            return ErrorEval.REF_INVALID;\n        }\n        SheetRangeEvaluator sre = new SheetRangeEvaluator(_sheetIndex, se);\n        \n                SpreadsheetVersion ssVersion = _workbook.getSpreadsheetVersion();\n\n        NameType part1refType = classifyCellReference(refStrPart1, ssVersion);\n        switch (part1refType) {\n            case BAD_CELL_OR_NAMED_RANGE:\n                return ErrorEval.REF_INVALID;\n            case NAMED_RANGE:\n                EvaluationName nm = _workbook.getName(refStrPart1, _sheetIndex);\n                if(!nm.isRange()){\n                    throw new RuntimeException("Specified name '" + refStrPart1 + "' is not a range as expected.");\n                }\n                return _bookEvaluator.evaluateNameFormula(nm.getNameDefinition(), this);\n        }\n        if (refStrPart2 == null) {\n                        switch (part1refType) {\n                case COLUMN:\n                case ROW:\n                    return ErrorEval.REF_INVALID;\n                case CELL:\n                    CellReference cr = new CellReference(refStrPart1);\n                    return new LazyRefEval(cr.getRow(), cr.getCol(), sre);\n            }\n            throw new IllegalStateException("Unexpected reference classification of '" + refStrPart1 + "'.");\n        }\n        NameType part2refType = classifyCellReference(refStrPart1, ssVersion);\n        switch (part2refType) {\n            case BAD_CELL_OR_NAMED_RANGE:\n                return ErrorEval.REF_INVALID;\n            case NAMED_RANGE:\n                throw new RuntimeException("Cannot evaluate '" + refStrPart1\n                        + "'. Indirect evaluation of defined names not supported yet");\n        }\n\n        if (part2refType != part1refType) {\n                        return ErrorEval.REF_INVALID;\n        }\n        int firstRow, firstCol, lastRow, lastCol;\n        switch (part1refType) {\n            case COLUMN:\n                firstRow =0;\n                if (part2refType.equals(NameType.COLUMN))\n                {\n                    lastRow = ssVersion.getLastRowIndex();\n                    firstCol = parseRowRef(refStrPart1);\n                    lastCol = parseRowRef(refStrPart2);\n                }\n                else {\n                    lastRow = ssVersion.getLastRowIndex();\n                    firstCol = parseColRef(refStrPart1);\n                    lastCol = parseColRef(refStrPart2);\n                }\n                break;\n            case ROW:\n                                firstCol = 0;\n                if (part2refType.equals(NameType.ROW))\n                {\n                    firstRow = parseColRef(refStrPart1);\n                    lastRow = parseColRef(refStrPart2);\n                    lastCol = ssVersion.getLastColumnIndex();\n                } else {\n                    lastCol = ssVersion.getLastColumnIndex();\n                    firstRow = parseRowRef(refStrPart1);\n                    lastRow = parseRowRef(refStrPart2);\n                }\n                break;\n            case CELL:\n                CellReference cr;\n                cr = new CellReference(refStrPart1);\n                firstRow = cr.getRow();\n                firstCol = cr.getCol();\n                cr = new CellReference(refStrPart2);\n                lastRow = cr.getRow();\n                lastCol = cr.getCol();\n                break;\n            default:\n                throw new IllegalStateException("Unexpected reference classification of '" + refStrPart1 + "'.");\n        }\n        return new LazyAreaEval(firstRow, firstCol, lastRow, lastCol, sre);\n    }
189	public void handleMouseDragged(ChartCanvas canvas, MouseEvent e) {\n        if (this.panLast == null) {\n                        canvas.clearLiveHandler();\n            return;\n        }\n\n        JFreeChart chart = canvas.getChart();\n        double dx = e.getX() - this.panLast.getX();\n        double dy = e.getY() - this.panLast.getY();\n        if (dx == 0.0 && dy == 0.0) {\n            return;\n        }\n        double wPercent = -dx / this.panW;\n        double hPercent = dy / this.panH;\n        boolean old = chart.getPlot().isNotify();\n        chart.getPlot().setNotify(false);\n        Pannable p = (Pannable) chart.getPlot();\n        PlotRenderingInfo info = canvas.getRenderingInfo().getPlotInfo();\n        if (p.getOrientation().isVertical()) {\n            p.panDomainAxes(wPercent, info, this.panLast);\n            p.panRangeAxes(hPercent, info, this.panLast);\n        }\n        else {\n            p.panDomainAxes(hPercent, info, this.panLast);\n            p.panRangeAxes(wPercent, info, this.panLast);\n        }\n        this.panLast = new Point2D.Double(e.getX(), e.getY());\n        chart.getPlot().setNotify(old);\n    }
190	public static PolygonPredicate createPolygonPredicate(Polygon[] polygons, Polygon2D tree) {\n    final Rectangle boundingBox = Rectangle.fromPolygon(polygons);\n    final Function<Rectangle, Relation> boxToRelation = box -> tree.relate(\n        box.minLat, box.maxLat, box.minLon, box.maxLon);\n    final Grid subBoxes = createSubBoxes(boundingBox, boxToRelation);\n\n    return new PolygonPredicate(\n        subBoxes.latShift, subBoxes.lonShift,\n        subBoxes.latBase, subBoxes.lonBase,\n        subBoxes.maxLatDelta, subBoxes.maxLonDelta,\n        subBoxes.relations,\n        tree);\n  }
191	private void refill() {\n            if (bufferLen > 64) {\n      int last = bufferLen - 1;\n      buffer[0] = buffer[last];\n      startOffset[0] = startOffset[last];\n      endOffset[0] = endOffset[last];\n      bufferLen = 1;\n      index -= last;\n    }\n\n    char termBuffer[] = termAtt.buffer();\n    int len = termAtt.length();\n    int start = offsetAtt.startOffset();\n    int end = offsetAtt.endOffset();\n    \n    int newSize = bufferLen + len;\n    buffer = ArrayUtil.grow(buffer, newSize);\n    startOffset = ArrayUtil.grow(startOffset, newSize);\n    endOffset = ArrayUtil.grow(endOffset, newSize);\n    lastEndOffset = end;\n\n    if (end - start != len) {\n            for (int i = 0, cp = 0; i < len; i += Character.charCount(cp)) {\n        cp = buffer[bufferLen] = Character.codePointAt(termBuffer, i, len);\n        startOffset[bufferLen] = start;\n        endOffset[bufferLen] = end;\n        bufferLen++;\n      }\n    } else {\n            for (int i = 0, cp = 0, cpLen = 0; i < len; i += cpLen) {\n        cp = buffer[bufferLen] = Character.codePointAt(termBuffer, i, len);\n        cpLen = Character.charCount(cp);\n        startOffset[bufferLen] = start;\n        start = endOffset[bufferLen] = start + cpLen;\n        bufferLen++;\n      }\n    }\n  }
192	protected void drawValueLabel(Graphics2D g2, Rectangle2D area) {\n        g2.setFont(this.valueFont);\n        g2.setPaint(this.valuePaint);\n        String valueStr = "No value";\n        if (this.dataset != null) {\n            Number n = this.dataset.getValue();\n            if (n != null) {\n                valueStr = this.tickLabelFormat.format(n.doubleValue()) + " "\n                         + this.units;\n            }\n        }\n        float x = (float) area.getCenterX();\n        float y = (float) area.getCenterY() + DEFAULT_CIRCLE_SIZE;\n        TextUtilities.drawAlignedString(valueStr, g2, x, y,\n                TextAnchor.TOP_CENTER);\n    }
193	public String getExtension() {\n		String fragment = this.partNameURI.getPath();\n		if (fragment.length() > 0) {\n			int i = fragment.lastIndexOf(".");\n			if (i > -1) {\n                return fragment.substring(i + 1);\n            }\n		}\n		return "";\n	}
194	protected void drawSimpleLabels(Graphics2D g2, List keys,\n            double totalValue, Rectangle2D plotArea, Rectangle2D pieArea,\n            PiePlotState state) {\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                1.0f));\n\n        Rectangle2D labelsArea = this.simpleLabelOffset.createInsetRectangle(\n                pieArea);\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include;\n            double v = 0.0;\n            Number n = getDataset().getValue(key);\n            if (n == null) {\n                include = !getIgnoreNullValues();\n            }\n            else {\n                v = n.doubleValue();\n                include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                                                double mid = getStartAngle() + (getDirection().getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n\n                Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(),\n                        mid - getStartAngle(), Arc2D.OPEN);\n                int x = (int) arc.getEndPoint().getX();\n                int y = (int) arc.getEndPoint().getY();\n\n                PieSectionLabelGenerator myLabelGenerator = getLabelGenerator();\n                if (myLabelGenerator == null) {\n                    continue;\n                }\n                String label = myLabelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label == null) {\n                    continue;\n                }\n                g2.setFont(this.labelFont);\n                FontMetrics fm = g2.getFontMetrics();\n                Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);\n                Rectangle2D out = this.labelPadding.createOutsetRectangle(\n                        bounds);\n                Shape bg = ShapeUtilities.createTranslatedShape(out,\n                        x - bounds.getCenterX(), y - bounds.getCenterY());\n                if (this.labelShadowPaint != null\n                        && this.shadowGenerator == null) {\n                    Shape shadow = ShapeUtilities.createTranslatedShape(bg,\n                            this.shadowXOffset, this.shadowYOffset);\n                    g2.setPaint(this.labelShadowPaint);\n                    g2.fill(shadow);\n                }\n                if (this.labelBackgroundPaint != null) {\n                    g2.setPaint(this.labelBackgroundPaint);\n                    g2.fill(bg);\n                }\n                if (this.labelOutlinePaint != null\n                        && this.labelOutlineStroke != null) {\n                    g2.setPaint(this.labelOutlinePaint);\n                    g2.setStroke(this.labelOutlineStroke);\n                    g2.draw(bg);\n                }\n\n                g2.setPaint(this.labelPaint);\n                g2.setFont(this.labelFont);\n                TextUtilities.drawAlignedString(label, g2, x, y,\n                        TextAnchor.CENTER);\n\n            }\n        }\n\n        g2.setComposite(originalComposite);\n\n    }
195	private Collection<String> getTransitiveDependenciesFromIvyCache\n  (String groupId, String artifactId, String version) {\n    SortedSet<String> transitiveDependencies = new TreeSet<>();\n        File ivyXmlFile = new File(new File(new File(ivyCacheDir, groupId), artifactId), "ivy-" + version + ".xml");\n    if ( ! ivyXmlFile.exists()) {\n      throw new BuildException("File not found: " + ivyXmlFile.getPath());\n    }\n    try {\n      Document document = documentBuilder.parse(ivyXmlFile);\n      String dependencyPath = "/ivy-module/dependencies/dependency"\n                            + "[   not(starts-with(@conf,'test->'))"\n                            + "and not(starts-with(@conf,'provided->'))"\n                            + "and not(starts-with(@conf,'optional->'))]";\n      NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n      for (int i = 0 ; i < dependencies.getLength() ; ++i) {\n        Element dependency = (Element)dependencies.item(i);\n        transitiveDependencies.add(dependency.getAttribute("org") + ':' + dependency.getAttribute("name"));\n      }\n    } catch (Exception e) {\n      throw new BuildException( "Exception collecting transitive dependencies for " \n                              + groupId + ':' + artifactId + ':' + version + " from "\n                              + ivyXmlFile.getAbsolutePath(), e);\n    }\n    return transitiveDependencies;\n  }
196	public ExControl getExControl(){\n        int idx = getControlIndex();\n        Document doc = getSheet().getSlideShow().getDocumentRecord();\n        ExObjList lst = (ExObjList)doc.findFirstOfType(RecordTypes.ExObjList.typeID);\n        if (lst == null) {\n            return null;\n        }\n        \n        for (Record ch : lst.getChildRecords()) {\n            if(ch instanceof ExControl){\n                ExControl c = (ExControl)ch;\n                if(c.getExOleObjAtom().getObjID() == idx){\n                    return c;\n                }\n            }\n        }\n        return null;\n    }
197	private static int countTokensToBeSkipped(Ptg[] ptgs, int startIndex, int distInBytes) {\n        int remBytes = distInBytes;\n        int index = startIndex;\n        while (remBytes != 0) {\n            index++;\n            remBytes -= ptgs[index].getSize();\n            if (remBytes < 0) {\n                throw new RuntimeException("Bad skip distance (wrong token size calculation).");\n            }\n            if (index >= ptgs.length) {\n                throw new RuntimeException("Skip distance too far (ran out of formula tokens).");\n            }\n        }\n        return index-startIndex;\n    }
198	public void addDomainCrosshair(Crosshair crosshair) {\n        ParamChecks.nullNotPermitted(crosshair, "crosshair");\n        this.xCrosshairs.add(crosshair);\n        crosshair.addPropertyChangeListener(this);\n        fireOverlayChanged();\n    }
199	public final boolean remove(T element) {\n    for (int i = 1; i <= size; i++) {\n      if (heap[i] == element) {\n        heap[i] = heap[size];\n        heap[size] = null;         size--;\n        if (i <= size) {\n          if (!upHeap(i)) {\n            downHeap(i);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }
200	private static Boolean isInsidePolygon(final GeoPoint point, final List<GeoPoint> polyPoints) {\n        final double latitude = point.getLatitude();\n    final double longitude = point.getLongitude();\n    final double sinLatitude = Math.sin(latitude);\n    final double cosLatitude = Math.cos(latitude);\n    final double sinLongitude = Math.sin(longitude);\n    final double cosLongitude = Math.cos(longitude);\n    \n        double arcDistance = 0.0;\n    Double prevAngle = null;\n        for (final GeoPoint polyPoint : polyPoints) {\n      final Double angle = computeAngle(polyPoint, sinLatitude, cosLatitude, sinLongitude, cosLongitude);\n      if (angle == null) {\n        return null;\n      }\n            if (prevAngle != null) {\n                double angleDelta = angle - prevAngle;\n        if (angleDelta < -Math.PI) {\n          angleDelta += Math.PI * 2.0;\n        }\n        if (angleDelta > Math.PI) {\n          angleDelta -= Math.PI * 2.0;\n        }\n        if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n          return null;\n        }\n                arcDistance += angleDelta;\n              }\n      prevAngle = angle;\n    }\n    if (prevAngle != null) {\n      final Double lastAngle = computeAngle(polyPoints.get(0), sinLatitude, cosLatitude, sinLongitude, cosLongitude);\n      if (lastAngle == null) {\n        return null;\n      }\n                  double angleDelta = lastAngle - prevAngle;\n      if (angleDelta < -Math.PI) {\n        angleDelta += Math.PI * 2.0;\n      }\n      if (angleDelta > Math.PI) {\n        angleDelta -= Math.PI * 2.0;\n      }\n      if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        return null;\n      }\n            arcDistance += angleDelta;\n          }\n\n            if (Math.abs(arcDistance) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n            return null;\n    }\n    return arcDistance > 0.0;\n  }
201	protected double calculateTotalHeight(double contentHeight) {\n        double result = contentHeight;\n        result = this.padding.extendHeight(result);\n        result = this.frame.getInsets().extendHeight(result);\n        result = this.margin.extendHeight(result);\n        return result;\n    }
202	static HSLFHyperlink createHyperlink(HSLFTextRun run) {\n                ExHyperlink exHyper = new ExHyperlink();\n        int linkId = run.getTextParagraph().getSheet().getSlideShow().addToObjListAtom(exHyper);\n        ExHyperlinkAtom obj = exHyper.getExHyperlinkAtom();\n        obj.setNumber(linkId);\n        InteractiveInfo info = new InteractiveInfo();\n        info.getInteractiveInfoAtom().setHyperlinkID(linkId);\n                        HSLFHyperlink hyper = new HSLFHyperlink(exHyper, info);\n        hyper.linkToNextSlide();\n        \n        TxInteractiveInfoAtom txinfo = new TxInteractiveInfoAtom();\n        int startIdx = run.getTextParagraph().getStartIdxOfTextRun(run);\n        int endIdx = startIdx + run.getLength();\n        txinfo.setStartIndex(startIdx);\n        txinfo.setEndIndex(endIdx);\n        hyper.setTextRunInfo(txinfo);\n        \n        run.setHyperlink(hyper);\n        return hyper;\n    }
203	private BufferedImage createBufferedImage(JFreeChart chart, int w, int h,\n            int minDrawW, int minDrawH, int maxDrawW, int maxDrawH) {\n\n        BufferedImage image = new BufferedImage(w, h,\n                BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = image.createGraphics();\n\n                boolean scale = false;\n        double drawWidth = w;\n        double drawHeight = h;\n        double scaleX = 1.0;\n        double scaleY = 1.0;\n        if (drawWidth < minDrawW) {\n            scaleX = drawWidth / minDrawW;\n            drawWidth = minDrawW;\n            scale = true;\n        }\n        else if (drawWidth > maxDrawW) {\n            scaleX = drawWidth / maxDrawW;\n            drawWidth = maxDrawW;\n            scale = true;\n        }\n        if (drawHeight < minDrawH) {\n            scaleY = drawHeight / minDrawH;\n            drawHeight = minDrawH;\n            scale = true;\n        }\n        else if (drawHeight > maxDrawH) {\n            scaleY = drawHeight / maxDrawH;\n            drawHeight = maxDrawH;\n            scale = true;\n        }\n\n        Rectangle2D chartArea = new Rectangle2D.Double(0.0, 0.0, drawWidth,\n                drawHeight);\n        if (scale) {\n            AffineTransform st = AffineTransform.getScaleInstance(scaleX,\n                    scaleY);\n            g2.transform(st);\n        }\n        chart.draw(g2, chartArea, null, null);\n        g2.dispose();\n        return image;\n\n    }
204	public void removeAllSeries() {\n                        for (int i = 0; i < this.seriesList.size(); i++) {\n            MatrixSeries series = (MatrixSeries) this.seriesList.get(i);\n            series.removeChangeListener(this);\n        }\n\n                this.seriesList.clear();\n        fireDatasetChanged();\n    }
205	public static int parseInt(char[] chars, int offset, int len, int radix)\n          throws NumberFormatException {\n    if (chars == null || radix < Character.MIN_RADIX\n            || radix > Character.MAX_RADIX) {\n      throw new NumberFormatException();\n    }\n    int  i = 0;\n    if (len == 0) {\n      throw new NumberFormatException("chars length is 0");\n    }\n    boolean negative = chars[offset + i] == '-';\n    if (negative && ++i == len) {\n      throw new NumberFormatException("can't convert to an int");\n    }\n    if (negative == true){\n      offset++;\n      len--;\n    }\n    return parse(chars, offset, len, radix, negative);\n  }
206	public void restoreAutoBounds() {\n        Plot plot = this.chart.getPlot();\n        if (plot == null) {\n            return;\n        }\n                                boolean savedNotify = plot.isNotify();\n        plot.setNotify(false);\n        restoreAutoDomainBounds();\n        restoreAutoRangeBounds();\n        plot.setNotify(savedNotify);\n    }
207	protected void drawCornerTextItems(Graphics2D g2, Rectangle2D area) {\n        if (this.cornerTextItems.isEmpty()) {\n            return;\n        }\n\n        g2.setColor(Color.black);\n        double width = 0.0;\n        double height = 0.0;\n        for (Iterator it = this.cornerTextItems.iterator(); it.hasNext();) {\n            String msg = (String) it.next();\n            FontMetrics fm = g2.getFontMetrics();\n            Rectangle2D bounds = TextUtilities.getTextBounds(msg, g2, fm);\n            width = Math.max(width, bounds.getWidth());\n            height += bounds.getHeight();\n        }\n\n        double xadj = ANNOTATION_MARGIN * 2.0;\n        double yadj = ANNOTATION_MARGIN;\n        width += xadj;\n        height += yadj;\n\n        double x = area.getMaxX() - width;\n        double y = area.getMaxY() - height;\n        g2.drawRect((int) x, (int) y, (int) width, (int) height);\n        x += ANNOTATION_MARGIN;\n        for (Iterator it = this.cornerTextItems.iterator(); it.hasNext();) {\n            String msg = (String) it.next();\n            Rectangle2D bounds = TextUtilities.getTextBounds(msg, g2,\n                    g2.getFontMetrics());\n            y += bounds.getHeight();\n            g2.drawString(msg, (int) x, (int) y);\n        }\n    }
208	@SuppressWarnings("WeakerAccess")\n    public void mergeCells(int firstCol, int lastCol)\n    {\n        if (firstCol >= lastCol) {\n            throw new IllegalArgumentException(\n                "Cannot merge, first column >= last column : "\n                + firstCol + " >= " + lastCol\n            );\n        }\n\n        final int colSpan = (lastCol - firstCol) + 1;\n\n        _cells.get(firstCol).setGridSpan(colSpan);\n        for (final XSLFTableCell cell : _cells.subList(firstCol+1, lastCol+1)) {\n            cell.setHMerge();\n        }\n    }
209	public synchronized void addDVUpdate(DocValuesFieldUpdates update) {\n    if (update.getFinished() == false) {\n      throw new IllegalArgumentException("call finish first");\n    }\n    List<DocValuesFieldUpdates> fieldUpdates = pendingDVUpdates.get(update.field);\n    if (fieldUpdates == null) {\n      fieldUpdates = new ArrayList<>();\n      pendingDVUpdates.put(update.field, fieldUpdates);\n    }\n\n    assert assertNoDupGen(fieldUpdates, update);\n\n    ramBytesUsed.addAndGet(update.ramBytesUsed());\n\n    fieldUpdates.add(update);\n\n    if (isMerging) {\n      fieldUpdates = mergingDVUpdates.get(update.field);\n      if (fieldUpdates == null) {\n        fieldUpdates = new ArrayList<>();\n        mergingDVUpdates.put(update.field, fieldUpdates);\n      }\n      fieldUpdates.add(update);\n    }\n  }
210	private void rebuildIndex () {\n        this.indexMap.clear();\n        for (int i = 0; i < this.keys.size(); i++) {\n            final Object key = this.keys.get(i);\n            this.indexMap.put(key, new Integer(i));\n        }\n    }
211	private void updateBounds() {\n        this.minimumRangeValue = Double.NaN;\n        this.minimumRangeValueRow = -1;\n        this.minimumRangeValueColumn = -1;\n        this.maximumRangeValue = Double.NaN;\n        this.maximumRangeValueRow = -1;\n        this.maximumRangeValueColumn = -1;\n        int rowCount = getRowCount();\n        int columnCount = getColumnCount();\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                BoxAndWhiskerItem item = getItem(r, c);\n                if (item != null) {\n                    Number min = item.getMinOutlier();\n                    if (min != null) {\n                        double minv = min.doubleValue();\n                        if (!Double.isNaN(minv)) {\n                            if (minv < this.minimumRangeValue || Double.isNaN(\n                                    this.minimumRangeValue)) {\n                                this.minimumRangeValue = minv;\n                                this.minimumRangeValueRow = r;\n                                this.minimumRangeValueColumn = c;\n                            }\n                        }\n                    }\n                    Number max = item.getMaxOutlier();\n                    if (max != null) {\n                        double maxv = max.doubleValue();\n                        if (!Double.isNaN(maxv)) {\n                            if (maxv > this.maximumRangeValue || Double.isNaN(\n                                    this.maximumRangeValue)) {\n                                this.maximumRangeValue = maxv;\n                                this.maximumRangeValueRow = r;\n                                this.maximumRangeValueColumn = c;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }
212	public void add(XYPlot subplot, int weight) {\n        ParamChecks.nullNotPermitted(subplot, "subplot");\n        if (weight <= 0) {\n            throw new IllegalArgumentException("Require weight >= 1.");\n        }\n\n                subplot.setParent(this);\n        subplot.setWeight(weight);\n        subplot.setInsets(RectangleInsets.ZERO_INSETS, false);\n        subplot.setDomainAxis(null);\n        subplot.addChangeListener(this);\n        this.subplots.add(subplot);\n\n        ValueAxis axis = getDomainAxis();\n        if (axis != null) {\n            axis.configure();\n        }\n        fireChangeEvent();\n    }
213	protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n            float score = boostAtt.getBoost();\n            if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n            if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n            if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n                termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n            st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n            st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }
214	public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n                if (includeInterval && dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = ixyd.getYValue(series, item);\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n                        OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n                        for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }
215	protected void displayPopupMenu(int x, int y) {\n\n        if (this.popup == null) {\n            return;\n        }\n\n                        boolean isDomainZoomable = false;\n        boolean isRangeZoomable = false;\n        Plot plot = (this.chart != null ? this.chart.getPlot() : null);\n        if (plot instanceof Zoomable) {\n            Zoomable z = (Zoomable) plot;\n            isDomainZoomable = z.isDomainZoomable();\n            isRangeZoomable = z.isRangeZoomable();\n        }\n\n        if (this.zoomInDomainMenuItem != null) {\n            this.zoomInDomainMenuItem.setEnabled(isDomainZoomable);\n        }\n        if (this.zoomOutDomainMenuItem != null) {\n            this.zoomOutDomainMenuItem.setEnabled(isDomainZoomable);\n        }\n        if (this.zoomResetDomainMenuItem != null) {\n            this.zoomResetDomainMenuItem.setEnabled(isDomainZoomable);\n        }\n\n        if (this.zoomInRangeMenuItem != null) {\n            this.zoomInRangeMenuItem.setEnabled(isRangeZoomable);\n        }\n        if (this.zoomOutRangeMenuItem != null) {\n            this.zoomOutRangeMenuItem.setEnabled(isRangeZoomable);\n        }\n\n        if (this.zoomResetRangeMenuItem != null) {\n            this.zoomResetRangeMenuItem.setEnabled(isRangeZoomable);\n        }\n\n        if (this.zoomInBothMenuItem != null) {\n            this.zoomInBothMenuItem.setEnabled(isDomainZoomable\n                    && isRangeZoomable);\n        }\n        if (this.zoomOutBothMenuItem != null) {\n            this.zoomOutBothMenuItem.setEnabled(isDomainZoomable\n                    && isRangeZoomable);\n        }\n        if (this.zoomResetBothMenuItem != null) {\n            this.zoomResetBothMenuItem.setEnabled(isDomainZoomable\n                    && isRangeZoomable);\n        }\n\n        this.popup.show(this, x, y);\n\n    }
216	public void checkUpdatedDoc() throws OpenXML4JException, IOException {\n        for (PackagePart pPart : this.doc.getAllEmbeddedParts()) {\n            String ext = pPart.getPartName().getExtension();\n            if (BINARY_EXTENSION.equals(ext) || OPENXML_EXTENSION.equals(ext)) {\n                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is)) {\n                    Sheet sheet = workbook.getSheetAt(SHEET_NUM);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    if(cell.getNumericCellValue() != NEW_VALUE) {\n                        throw new IllegalStateException("Failed to validate document content.");\n                    }\n                }\n            }\n        }\n    }
217	public void setBorderLeft(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetLeft();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
218	public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }
219	protected ByteBufferIndexInput buildSlice(String sliceDescription, long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException("Already closed: " + this);\n    }\n\n    final ByteBuffer newBuffers[] = buildSlice(buffers, offset, length);\n    final int ofs = (int) (offset & chunkSizeMask);\n    \n    final ByteBufferIndexInput clone = newCloneInstance(getFullSliceDescription(sliceDescription), newBuffers, ofs, length);\n    clone.isClone = true;\n    \n    return clone;\n  }
220	private void addTermsDict(FieldInfo field, final Iterable<BytesRef> values) throws IOException {\n        int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    long numValues = 0;\n    BytesRefBuilder previousValue = new BytesRefBuilder();\n    long prefixSum = 0;     for (BytesRef v : values) {\n      minLength = Math.min(minLength, v.length);\n      maxLength = Math.max(maxLength, v.length);\n      if (minLength == maxLength) {\n        int termPosition = (int) (numValues & INTERVAL_MASK);\n        if (termPosition == 0) {\n                    previousValue.copyBytes(v);\n        } else if (termPosition == INTERVAL_COUNT - 1) {\n                    prefixSum += StringHelper.bytesDifference(previousValue.get(), v);\n        }\n      }\n      numValues++;\n    }\n                if (minLength == maxLength && prefixSum <= 3*(numValues >> INTERVAL_SHIFT)) {\n            addBinaryField(field, values);\n    } else if (numValues < REVERSE_INTERVAL_COUNT) {\n            addBinaryField(field, values);\n    } else {\n      assert numValues > 0;             meta.writeVInt(field.number);\n      meta.writeByte(Lucene54DocValuesFormat.BINARY);\n      meta.writeVInt(BINARY_PREFIX_COMPRESSED);\n      meta.writeLong(-1L);\n            final long startFP = data.getFilePointer();\n                  RAMOutputStream addressBuffer = new RAMOutputStream();\n      MonotonicBlockPackedWriter termAddresses = new MonotonicBlockPackedWriter(addressBuffer, MONOTONIC_BLOCK_SIZE);\n            RAMOutputStream bytesBuffer = new RAMOutputStream();\n            RAMOutputStream headerBuffer = new RAMOutputStream();\n      BytesRefBuilder lastTerm = new BytesRefBuilder();\n      lastTerm.grow(maxLength);\n      long count = 0;\n      int suffixDeltas[] = new int[INTERVAL_COUNT];\n      for (BytesRef v : values) {\n        int termPosition = (int) (count & INTERVAL_MASK);\n        if (termPosition == 0) {\n          termAddresses.add(data.getFilePointer() - startFP);\n                    headerBuffer.writeVInt(v.length);\n          headerBuffer.writeBytes(v.bytes, v.offset, v.length);\n          lastTerm.copyBytes(v);\n        } else {\n                              int sharedPrefix = Math.min(255, StringHelper.bytesDifference(lastTerm.get(), v));\n          bytesBuffer.writeByte((byte) sharedPrefix);\n          bytesBuffer.writeBytes(v.bytes, v.offset + sharedPrefix, v.length - sharedPrefix);\n                    suffixDeltas[termPosition] = v.length - sharedPrefix - 1;\n        }\n        \n        count++;\n                if ((count & INTERVAL_MASK) == 0) {\n          flushTermsDictBlock(headerBuffer, bytesBuffer, suffixDeltas);\n        }\n      }\n            int leftover = (int) (count & INTERVAL_MASK);\n      if (leftover > 0) {\n        Arrays.fill(suffixDeltas, leftover, suffixDeltas.length, 0);\n        flushTermsDictBlock(headerBuffer, bytesBuffer, suffixDeltas);\n      }\n      final long indexStartFP = data.getFilePointer();\n            termAddresses.finish();\n      addressBuffer.writeTo(data);\n      addressBuffer = null;\n      termAddresses = null;\n      meta.writeVInt(minLength);\n      meta.writeVInt(maxLength);\n      meta.writeVLong(count);\n      meta.writeLong(startFP);\n      meta.writeLong(indexStartFP);\n      meta.writeVInt(PackedInts.VERSION_CURRENT);\n      meta.writeVInt(MONOTONIC_BLOCK_SIZE);\n      addReverseTermIndex(field, values, maxLength);\n    }\n  }
221	public String getCommonXpath() {\n        if (commonXPath == null) {\n            String[] commonTokens = {};\n            for (XSSFTableColumn column : getColumns()) {\n                if (column.getXmlColumnPr()!=null) {\n                    String xpath = column.getXmlColumnPr().getXPath();\n                    String[] tokens =  xpath.split("/");\n                    if (commonTokens.length==0) {\n                        commonTokens = tokens;\n                        \n                    } else {\n                        final int maxLength = Math.min(commonTokens.length, tokens.length);\n                         \n                        for (int i =0; i<maxLength; i++) {\n                            if (!commonTokens[i].equals(tokens[i])) {\n                             List<String> subCommonTokens = Arrays.asList(commonTokens).subList(0, i);\n                             \n                             String[] container = {};\n                             \n                             commonTokens = subCommonTokens.toArray(container);\n                             break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            commonTokens[0] = "";\n            commonXPath = StringUtil.join(commonTokens, "/");\n        }\n        \n        return commonXPath;\n    }
222	public final static String htmlEncode(String plainText)\n  {\n    if (plainText == null || plainText.length() == 0)\n    {\n      return "";\n    }\n\n    StringBuilder result = new StringBuilder(plainText.length());\n\n    for (int index=0; index<plainText.length(); index++)\n    {\n      char ch = plainText.charAt(index);\n\n      switch (ch) {\n      case '"':\n        result.append("&quot;");\n        break;\n      case '&':\n        result.append("&amp;");\n        break;\n      case '<':\n        result.append("&lt;");\n        break;\n      case '>':\n        result.append("&gt;");\n        break;\n      case '\'':\n        result.append("&#x27;");\n        break;\n      case '/':\n        result.append("&#x2F;");\n        break;\n      default:\n        result.append(ch);\n      }\n    }\n\n    return result.toString();\n  }
223	protected AxisState drawAxis(ValueAxis axis, PolarAxisLocation location,\n            Graphics2D g2, Rectangle2D plotArea) {\n\n        double centerX = plotArea.getCenterX();\n        double centerY = plotArea.getCenterY();\n        double r = Math.min(plotArea.getWidth() / 2.0,\n                plotArea.getHeight() / 2.0) - this.margin;\n        double x = centerX - r;\n        double y = centerY - r;\n\n        Rectangle2D dataArea = null;\n        AxisState result = null;\n        if (location == PolarAxisLocation.NORTH_RIGHT) {\n            dataArea = new Rectangle2D.Double(x, y, r, r);\n            result = axis.draw(g2, centerX, plotArea, dataArea,\n                    RectangleEdge.RIGHT, null);\n        }\n        else if (location == PolarAxisLocation.NORTH_LEFT) {\n            dataArea = new Rectangle2D.Double(centerX, y, r, r);\n            result = axis.draw(g2, centerX, plotArea, dataArea,\n                    RectangleEdge.LEFT, null);\n        }\n        else if (location == PolarAxisLocation.SOUTH_LEFT) {\n            dataArea = new Rectangle2D.Double(centerX, centerY, r, r);\n            result = axis.draw(g2, centerX, plotArea, dataArea,\n                    RectangleEdge.LEFT, null);\n        }\n        else if (location == PolarAxisLocation.SOUTH_RIGHT) {\n            dataArea = new Rectangle2D.Double(x, centerY, r, r);\n            result = axis.draw(g2, centerX, plotArea, dataArea,\n                    RectangleEdge.RIGHT, null);\n        }\n        else if (location == PolarAxisLocation.EAST_ABOVE) {\n            dataArea = new Rectangle2D.Double(centerX, centerY, r, r);\n            result = axis.draw(g2, centerY, plotArea, dataArea,\n                    RectangleEdge.TOP, null);\n        }\n        else if (location == PolarAxisLocation.EAST_BELOW) {\n            dataArea = new Rectangle2D.Double(centerX, y, r, r);\n            result = axis.draw(g2, centerY, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, null);\n        }\n        else if (location == PolarAxisLocation.WEST_ABOVE) {\n            dataArea = new Rectangle2D.Double(x, centerY, r, r);\n            result = axis.draw(g2, centerY, plotArea, dataArea,\n                    RectangleEdge.TOP, null);\n        }\n        else if (location == PolarAxisLocation.WEST_BELOW) {\n            dataArea = new Rectangle2D.Double(x, y, r, r);\n            result = axis.draw(g2, centerY, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, null);\n        }\n\n        return result;\n    }
224	private boolean areSeriesDisjoint(XYDataset x_dataset) {\n\n        int l_minuendItemCount = x_dataset.getItemCount(0);\n        double l_minuendFirst  = x_dataset.getXValue(0, 0);\n        double l_minuendLast   = x_dataset.getXValue(0, l_minuendItemCount - 1);\n\n        int l_subtrahendItemCount = x_dataset.getItemCount(1);\n        double l_subtrahendFirst  = x_dataset.getXValue(1, 0);\n        double l_subtrahendLast   = x_dataset.getXValue(1,\n                l_subtrahendItemCount - 1);\n\n        return ((l_minuendLast < l_subtrahendFirst)\n                || (l_subtrahendLast < l_minuendFirst));\n    }
225	public Object highlightWithoutSearcher(String field, Query query, String content, int maxPassages)\n      throws IOException {\n    if (this.searcher != null) {\n      throw new IllegalStateException("highlightWithoutSearcher should only be called on a " +\n          getClass().getSimpleName() + " without an IndexSearcher.");\n    }\n    Objects.requireNonNull(content, "content is required");\n    Set<Term> queryTerms = extractTerms(query);\n    return getFieldHighlighter(field, query, queryTerms, maxPassages)\n        .highlightFieldForDoc(null, -1, content);\n  }
226	public static void fsync(Path fileToSync, boolean isDir) throws IOException {\n            try (final FileChannel file = FileChannel.open(fileToSync, isDir ? StandardOpenOption.READ : StandardOpenOption.WRITE)) {\n      file.force(true);\n    } catch (IOException ioe) {\n      if (isDir) {\n        assert (Constants.LINUX || Constants.MAC_OS_X) == false :\n            "On Linux and MacOSX fsyncing a directory should not throw IOException, "+\n                "we just don't want to rely on that in production (undocumented). Got: " + ioe;\n                return;\n      }\n            throw ioe;\n    }\n  }
227	public void updateWindowMapMode() {\n        Rectangle2D win = prop.getWindow();\n        HwmfMapMode mapMode = prop.getMapMode();\n        graphicsCtx.setTransform(initialAT);\n\n        switch (mapMode) {\n        default:\n        case MM_ANISOTROPIC:\n                        graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getHeight()/win.getHeight());\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        case MM_ISOTROPIC:\n                                    graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getWidth()/win.getWidth());\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        case MM_LOMETRIC:\n        case MM_HIMETRIC:\n        case MM_LOENGLISH:\n        case MM_HIENGLISH:\n        case MM_TWIPS: {\n                        GraphicsConfiguration gc = graphicsCtx.getDeviceConfiguration();\n            graphicsCtx.transform(gc.getNormalizingTransform());\n            graphicsCtx.scale(1./mapMode.scale, -1./mapMode.scale);\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        }\n        case MM_TEXT:\n                        break;\n        }\n    }
228	private void paintDottedBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             northBorderType == BorderStyle.DOTTED) {\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+2) {\n             g.drawLine(xc,y+k,xc,y+k);\n           }\n        }\n      }\n\n      if (eastBorder &&\n              eastBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; \n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+2) {\n                g.drawLine(width-k,yc,width-k,yc);\n           }\n        }\n      }\n\n      if (southBorder &&\n              southBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(southBorderType);\n        thickness++;\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+2) {\n             g.drawLine(xc,height-k,xc,height-k);\n           }\n        }\n      }\n\n      if (westBorder &&\n            westBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+2) {\n                g.drawLine(x+k,yc,x+k,yc);\n           }\n        }\n      }\n   }
229	public long deleteDocuments(Query... queries) throws IOException {\n    ensureOpen();\n\n        for(Query query : queries) {\n      if (query.getClass() == MatchAllDocsQuery.class) {\n        return deleteAll();\n      }\n    }\n\n    try {\n      long seqNo = docWriter.deleteQueries(queries);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, "deleteDocuments(Query..)");\n\n            return -1;\n    }\n  }
230	protected double calculateTextBlockWidth(TextBlock block,\n            CategoryLabelPosition position, Graphics2D g2) {\n        RectangleInsets insets = getTickLabelInsets();\n        Size2D size = block.calculateDimensions(g2);\n        Rectangle2D box = new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox = ShapeUtilities.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double w = rotatedBox.getBounds2D().getWidth() + insets.getLeft()\n                + insets.getRight();\n        return w;\n    }
231	private Shape[] createHorizontalBlock(double x0, double width, double y0,\n            double y1, boolean inverted) {\n        Shape[] result = new Shape[6];\n        Point2D p00 = new Point2D.Double(y0, x0);\n        Point2D p01 = new Point2D.Double(y0, x0 + width);\n        Point2D p02 = new Point2D.Double(p01.getX() + getXOffset(),\n                p01.getY() - getYOffset());\n        Point2D p03 = new Point2D.Double(p00.getX() + getXOffset(),\n                p00.getY() - getYOffset());\n\n        Point2D p0 = new Point2D.Double(y1, x0);\n        Point2D p1 = new Point2D.Double(y1, x0 + width);\n        Point2D p2 = new Point2D.Double(p1.getX() + getXOffset(),\n                p1.getY() - getYOffset());\n        Point2D p3 = new Point2D.Double(p0.getX() + getXOffset(),\n                p0.getY() - getYOffset());\n\n        GeneralPath bottom = new GeneralPath();\n        bottom.moveTo((float) p1.getX(), (float) p1.getY());\n        bottom.lineTo((float) p01.getX(), (float) p01.getY());\n        bottom.lineTo((float) p02.getX(), (float) p02.getY());\n        bottom.lineTo((float) p2.getX(), (float) p2.getY());\n        bottom.closePath();\n\n        GeneralPath top = new GeneralPath();\n        top.moveTo((float) p0.getX(), (float) p0.getY());\n        top.lineTo((float) p00.getX(), (float) p00.getY());\n        top.lineTo((float) p03.getX(), (float) p03.getY());\n        top.lineTo((float) p3.getX(), (float) p3.getY());\n        top.closePath();\n\n        GeneralPath back = new GeneralPath();\n        back.moveTo((float) p2.getX(), (float) p2.getY());\n        back.lineTo((float) p02.getX(), (float) p02.getY());\n        back.lineTo((float) p03.getX(), (float) p03.getY());\n        back.lineTo((float) p3.getX(), (float) p3.getY());\n        back.closePath();\n\n        GeneralPath front = new GeneralPath();\n        front.moveTo((float) p0.getX(), (float) p0.getY());\n        front.lineTo((float) p1.getX(), (float) p1.getY());\n        front.lineTo((float) p01.getX(), (float) p01.getY());\n        front.lineTo((float) p00.getX(), (float) p00.getY());\n        front.closePath();\n\n        GeneralPath left = new GeneralPath();\n        left.moveTo((float) p0.getX(), (float) p0.getY());\n        left.lineTo((float) p1.getX(), (float) p1.getY());\n        left.lineTo((float) p2.getX(), (float) p2.getY());\n        left.lineTo((float) p3.getX(), (float) p3.getY());\n        left.closePath();\n\n        GeneralPath right = new GeneralPath();\n        right.moveTo((float) p00.getX(), (float) p00.getY());\n        right.lineTo((float) p01.getX(), (float) p01.getY());\n        right.lineTo((float) p02.getX(), (float) p02.getY());\n        right.lineTo((float) p03.getX(), (float) p03.getY());\n        right.closePath();\n        result[0] = bottom;\n        result[1] = back;\n        if (inverted) {\n            result[2] = right;\n            result[3] = left;\n        }\n        else {\n            result[2] = left;\n            result[3] = right;\n        }\n        result[4] = top;\n        result[5] = front;\n        return result;\n    }
232	public String formatNumberDateCell(CellValueRecordInterface cell) {\n		double value;\n		if (cell instanceof NumberRecord) {\n			value = ((NumberRecord) cell).getValue();\n		} else if (cell instanceof FormulaRecord) {\n			value = ((FormulaRecord) cell).getValue();\n		} else {\n			throw new IllegalArgumentException("Unsupported CellValue Record passed in " + cell);\n		}\n\n				int formatIndex = getFormatIndex(cell);\n		String formatString = getFormatString(cell);\n\n		if (formatString == null) {\n			return _defaultFormat.format(value);\n		}\n						return _formatter.formatRawCellContents(value, formatIndex, formatString);\n	}
233	public static List seriesNameListFromDataArray(Object[][] data) {\n        int seriesCount = data.length;\n        List seriesNameList = new java.util.ArrayList(seriesCount);\n        for (int i = 0; i < seriesCount; i++) {\n            seriesNameList.add("Series " + (i + 1));\n        }\n        return seriesNameList;\n    }
234	private static void shiftBreaks(PageBreakRecord breaks, int start, int stop, int count) {\n\n        Iterator<PageBreakRecord.Break> iterator = breaks.getBreaksIterator();\n        List<PageBreakRecord.Break> shiftedBreak = new ArrayList<>();\n        while(iterator.hasNext())\n        {\n            PageBreakRecord.Break breakItem = iterator.next();\n            int breakLocation = breakItem.main;\n            boolean inStart = (breakLocation >= start);\n            boolean inEnd = (breakLocation <= stop);\n            if(inStart && inEnd) {\n                shiftedBreak.add(breakItem);\n            }\n        }\n\n        iterator = shiftedBreak.iterator();\n        while (iterator.hasNext()) {\n            PageBreakRecord.Break breakItem = iterator.next();\n            breaks.removeBreak(breakItem.main);\n            breaks.addBreak((short)(breakItem.main+count), breakItem.subFrom, breakItem.subTo);\n        }\n    }
235	public void importFromXML(String xmlInputString) throws SAXException, XPathExpressionException, IOException {\n\n        DocumentBuilder builder = DocumentHelper.newDocumentBuilder();\n\n        Document doc = builder.parse(new InputSource(new StringReader(xmlInputString.trim())));\n\n        List<XSSFSingleXmlCell> singleXmlCells = _map.getRelatedSingleXMLCell();\n\n        List<XSSFTable> tables = _map.getRelatedTables();\n\n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        XPath xpath = xpathFactory.newXPath();\n\n                                xpath.setNamespaceContext(new DefaultNamespaceContext(doc));\n\n        for (XSSFSingleXmlCell singleXmlCell : singleXmlCells) {\n\n            STXmlDataType.Enum xmlDataType = singleXmlCell.getXmlDataType();\n            String xpathString = singleXmlCell.getXpath();\n            Node result = (Node) xpath.evaluate(xpathString, doc, XPathConstants.NODE);\n                        if (result != null) {\n                String textContent = result.getTextContent();\n                logger.log(POILogger.DEBUG, "Extracting with xpath " + xpathString + " : value is '" + textContent + "'");\n                XSSFCell cell = singleXmlCell.getReferencedCell();\n                logger.log(POILogger.DEBUG, "Setting '" + textContent + "' to cell " + cell.getColumnIndex() + "-" + cell.getRowIndex() + " in sheet "\n                                                + cell.getSheet().getSheetName());\n                setCellValue(textContent, cell, xmlDataType);\n            }\n        }\n\n        for (XSSFTable table : tables) {\n\n            String commonXPath = table.getCommonXpath();\n            NodeList result = (NodeList) xpath.evaluate(commonXPath, doc, XPathConstants.NODESET);\n            int rowOffset = table.getStartCellReference().getRow() + table.getHeaderRowCount();\n            int columnOffset = table.getStartCellReference().getCol();\n\n            table.setDataRowCount(result.getLength());\n\n            for (int i = 0; i < result.getLength(); i++) {\n\n                                \n                Node singleNode = result.item(i).cloneNode(true);\n\n                for (XSSFTableColumn tableColumn : table.getColumns()) {\n\n                    XSSFXmlColumnPr xmlColumnPr = tableColumn.getXmlColumnPr();\n                    if(xmlColumnPr == null) {\n                        continue;\n                    }\n\n                    int rowId = rowOffset + i;\n                    int columnId = columnOffset + tableColumn.getColumnIndex();\n                    String localXPath = xmlColumnPr.getLocalXPath();\n                    localXPath = localXPath.substring(localXPath.indexOf('/', 1) + 1);\n\n                                        String value = (String) xpath.evaluate(localXPath, singleNode, XPathConstants.STRING);\n                    logger.log(POILogger.DEBUG, "Extracting with xpath " + localXPath + " : value is '" + value + "'");\n                    XSSFRow row = table.getXSSFSheet().getRow(rowId);\n                    if (row == null) {\n                        row = table.getXSSFSheet().createRow(rowId);\n                    }\n\n                    XSSFCell cell = row.getCell(columnId);\n                    if (cell == null) {\n                        cell = row.createCell(columnId);\n                    }\n                    logger.log(POILogger.DEBUG, "Setting '" + value + "' to cell " + cell.getColumnIndex() + "-" + cell.getRowIndex() + " in sheet "\n                                                    + table.getXSSFSheet().getSheetName());\n                    setCellValue(value, cell, xmlColumnPr.getXmlDataType());\n                }\n            }\n        }\n    }
236	protected double getRectY(double y, double h1, double h2,\n                              RectangleEdge edge) {\n\n        double result = y;\n        if (edge == RectangleEdge.TOP) {\n            result = result + h1;\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result = result + h2;\n        }\n        return result;\n\n    }
237	public void process() throws IOException, OpenXML4JException, SAXException {\n        ReadOnlySharedStringsTable strings = new ReadOnlySharedStringsTable(this.xlsxPackage);\n        XSSFReader xssfReader = new XSSFReader(this.xlsxPackage);\n        StylesTable styles = xssfReader.getStylesTable();\n        XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) xssfReader.getSheetsData();\n        int index = 0;\n        while (iter.hasNext()) {\n            try (InputStream stream = iter.next()) {\n                String sheetName = iter.getSheetName();\n                this.output.println();\n                this.output.println(sheetName + " [index=" + index + "]:");\n                processSheet(styles, strings, new SheetToCSV(), stream);\n            }\n            ++index;\n        }\n    }
238	public static Range expand(Range range,\n                               double lowerMargin, double upperMargin) {\n        ParamChecks.nullNotPermitted(range, "range");\n        double length = range.getLength();\n        double lower = range.getLowerBound() - length * lowerMargin;\n        double upper = range.getUpperBound() + length * upperMargin;\n        if (lower > upper) {\n            lower = lower / 2.0 + upper / 2.0;\n            upper = lower;\n        }\n        return new Range(lower, upper);\n    }
239	public FileIdCluster addCluster( int dgId, int numShapedUsed, boolean sort ) {\n        FileIdCluster ficNew = new FileIdCluster(dgId, numShapedUsed);\n        field_5_fileIdClusters.add(ficNew);\n        maxDgId = Math.min(maxDgId, dgId);\n        \n        if (sort) {\n            sortCluster();\n        }\n        \n        return ficNew;\n    }
240	public void dump(byte[] data, int offset, int size, PrintStream out) {\n        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory();\n        int pos = offset;\n        while ( pos < offset + size )\n        {\n            EscherRecord r = recordFactory.createRecord(data, pos);\n            int bytesRead = r.fillFields(data, pos, recordFactory );\n            out.println(r);\n            pos += bytesRead;\n        }\n    }
241	private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n            return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n            if (Node.VERBOSE_FILES) {\n        message("file " + fileName + ": will copy [header/footer is different]");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }
242	public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                        previous, end);\n            }\n        }\n    }
243	private void appendAllInternalDependencies(StringBuilder builder) {\n    for (String artifactId : internalCompileScopeDependencies.keySet()) {\n      List<String> exclusions = new ArrayList<>();\n      exclusions.addAll(internalCompileScopeDependencies.get(artifactId));\n      SortedSet<ExternalDependency> extDeps = allExternalDependencies.get(artifactId);\n      if (null != extDeps) {\n        for (ExternalDependency externalDependency : extDeps) {\n          if ( ! externalDependency.isTestDependency && ! externalDependency.isOptional) {\n            exclusions.add(externalDependency.groupId + ':' + externalDependency.artifactId);\n          }\n        }\n      }\n      String groupId = ivyModuleInfo.get(artifactId);\n      appendDependencyXml(builder, groupId, artifactId, "      ", "${project.version}", false, false, null, exclusions);\n    }\n  }
244	public static JFreeChart createCandlestickChart(String title,\n            String timeAxisLabel, String valueAxisLabel, OHLCDataset dataset,\n            boolean legend) {\n\n        ValueAxis timeAxis = new DateAxis(timeAxisLabel);\n        NumberAxis valueAxis = new NumberAxis(valueAxisLabel);\n        XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, null);\n        plot.setRenderer(new CandlestickRenderer());\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
245	protected void drawLabels(Graphics2D g2, List keys, double totalValue,\n                              Rectangle2D plotArea, Rectangle2D linkArea,\n                              PiePlotState state) {\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                1.0f));\n\n                DefaultKeyedValues leftKeys = new DefaultKeyedValues();\n        DefaultKeyedValues rightKeys = new DefaultKeyedValues();\n\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include;\n            double v = 0.0;\n            Number n = this.dataset.getValue(key);\n            if (n == null) {\n                include = !this.ignoreNullValues;\n            }\n            else {\n                v = n.doubleValue();\n                include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                                                double mid = this.startAngle + (this.direction.getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                if (Math.cos(Math.toRadians(mid)) < 0.0) {\n                    leftKeys.addValue(key, new Double(mid));\n                }\n                else {\n                    rightKeys.addValue(key, new Double(mid));\n                }\n            }\n        }\n\n        g2.setFont(getLabelFont());\n\n                        double marginX = plotArea.getX();\n        double gap = plotArea.getWidth() * this.labelGap;\n        double ww = linkArea.getX() - gap - marginX;\n        float labelWidth = (float) this.labelPadding.trimWidth(ww);\n\n                if (this.labelGenerator != null) {\n            drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth,\n                    state);\n            drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth,\n                    state);\n        }\n        g2.setComposite(originalComposite);\n\n    }
246	public CTShape findCommentShape(int row, int col){\n        for(XmlObject itm : _items){\n            if(itm instanceof CTShape){\n                CTShape sh = (CTShape)itm;\n                if(sh.sizeOfClientDataArray() > 0){\n                    CTClientData cldata = sh.getClientDataArray(0);\n                    if(cldata.getObjectType() == STObjectType.NOTE){\n                        int crow = cldata.getRowArray(0).intValue();\n                        int ccol = cldata.getColumnArray(0).intValue();\n                        if(crow == row && ccol == col) {\n                            return sh;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }
247	public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        Range result;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }
248	public long getTimeFromLong(long date) {\n        long result = date;\n        if (this.adjustForDaylightSaving) {\n            this.workingCalendarNoDST.setTime(new Date(date));\n            this.workingCalendar.set(\n                this.workingCalendarNoDST.get(Calendar.YEAR),\n                this.workingCalendarNoDST.get(Calendar.MONTH),\n                this.workingCalendarNoDST.get(Calendar.DATE),\n                this.workingCalendarNoDST.get(Calendar.HOUR_OF_DAY),\n                this.workingCalendarNoDST.get(Calendar.MINUTE),\n                this.workingCalendarNoDST.get(Calendar.SECOND)\n            );\n            this.workingCalendar.set(Calendar.MILLISECOND,\n                    this.workingCalendarNoDST.get(Calendar.MILLISECOND));\n                                    result = this.workingCalendar.getTime().getTime();\n        }\n        return result;\n    }
249	public void setSummaryEntries(DirectoryNode dir, String encryptedStream, POIFSFileSystem entries)\n    throws IOException, GeneralSecurityException {\n        CryptoAPIDocumentOutputStream bos = new CryptoAPIDocumentOutputStream(this);         byte buf[] = new byte[8];\n        \n        bos.write(buf, 0, 8);         List<StreamDescriptorEntry> descList = new ArrayList<>();\n\n        int block = 0;\n        for (Entry entry : entries.getRoot()) {\n            if (entry.isDirectoryEntry()) {\n                continue;\n            }\n            StreamDescriptorEntry descEntry = new StreamDescriptorEntry();\n            descEntry.block = block;\n            descEntry.streamOffset = bos.size();\n            descEntry.streamName = entry.getName();\n            descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);\n            descEntry.reserved2 = 0;\n            \n            bos.setBlock(block);\n            DocumentInputStream dis = dir.createDocumentInputStream(entry);\n            IOUtils.copy(dis, bos);\n            dis.close();\n            \n            descEntry.streamSize = bos.size() - descEntry.streamOffset;\n            descList.add(descEntry);\n            \n            block++;\n        }\n        \n        int streamDescriptorArrayOffset = bos.size();\n        \n        bos.setBlock(0);\n        LittleEndian.putUInt(buf, 0, descList.size());\n        bos.write(buf, 0, 4);\n        \n        for (StreamDescriptorEntry sde : descList) {\n            LittleEndian.putUInt(buf, 0, sde.streamOffset);\n            bos.write(buf, 0, 4);\n            LittleEndian.putUInt(buf, 0, sde.streamSize);\n            bos.write(buf, 0, 4);\n            LittleEndian.putUShort(buf, 0, sde.block);\n            bos.write(buf, 0, 2);\n            LittleEndian.putUByte(buf, 0, (short)sde.streamName.length());\n            bos.write(buf, 0, 1);\n            LittleEndian.putUByte(buf, 0, (short)sde.flags);\n            bos.write(buf, 0, 1);\n            LittleEndian.putUInt(buf, 0, sde.reserved2);\n            bos.write(buf, 0, 4);\n            byte nameBytes[] = StringUtil.getToUnicodeLE(sde.streamName);\n            bos.write(nameBytes, 0, nameBytes.length);\n            LittleEndian.putShort(buf, 0, (short)0);             bos.write(buf, 0, 2);\n        }\n        \n        int savedSize = bos.size();\n        int streamDescriptorArraySize = savedSize - streamDescriptorArrayOffset;\n        LittleEndian.putUInt(buf, 0, streamDescriptorArrayOffset);\n        LittleEndian.putUInt(buf, 4, streamDescriptorArraySize);\n\n        bos.reset();\n        bos.setBlock(0);\n        bos.write(buf, 0, 8);\n        bos.setSize(savedSize);\n        \n        dir.createDocument(encryptedStream, new ByteArrayInputStream(bos.getBuf(), 0, savedSize));\n    }
250	public void configure(ContourPlot plot) {\n        double minZ = plot.getDataset().getMinZValue();\n        double maxZ = plot.getDataset().getMaxZValue();\n        setMinimumValue(minZ);\n        setMaximumValue(maxZ);\n    }
251	private boolean doNext() throws IOException {\n    if (loneState != null) {\n      restoreState(loneState);\n      loneState = null;\n      return true;\n    } else {\n      if (exhausted) {\n        return false;\n      } else if (input.incrementToken()) {\n        return true;\n      } else {\n        exhausted = true;\n        return false;\n      }\n    }\n  }
252	private static CTWorksheet newSheet(){\n        CTWorksheet worksheet = CTWorksheet.Factory.newInstance();\n        CTSheetFormatPr ctFormat = worksheet.addNewSheetFormatPr();\n        ctFormat.setDefaultRowHeight(DEFAULT_ROW_HEIGHT);\n\n        CTSheetView ctView = worksheet.addNewSheetViews().addNewSheetView();\n        ctView.setWorkbookViewId(0);\n\n        worksheet.addNewDimension().setRef("A1");\n\n        worksheet.addNewSheetData();\n\n        CTPageMargins ctMargins = worksheet.addNewPageMargins();\n        ctMargins.setBottom(DEFAULT_MARGIN_BOTTOM);\n        ctMargins.setFooter(DEFAULT_MARGIN_FOOTER);\n        ctMargins.setHeader(DEFAULT_MARGIN_HEADER);\n        ctMargins.setLeft(DEFAULT_MARGIN_LEFT);\n        ctMargins.setRight(DEFAULT_MARGIN_RIGHT);\n        ctMargins.setTop(DEFAULT_MARGIN_TOP);\n\n        return worksheet;\n    }
253	public static TimeSeries createPointMovingAverage(TimeSeries source,\n            String name, int pointCount) {\n\n        ParamChecks.nullNotPermitted(source, "source");\n        if (pointCount < 2) {\n            throw new IllegalArgumentException("periodCount must be greater " \n                    + "than or equal to 2.");\n        }\n\n        TimeSeries result = new TimeSeries(name);\n        double rollingSumForPeriod = 0.0;\n        for (int i = 0; i < source.getItemCount(); i++) {\n                        TimeSeriesDataItem current = source.getRawDataItem(i);\n            RegularTimePeriod period = current.getPeriod();\n                        rollingSumForPeriod += current.getValue().doubleValue();\n\n            if (i > pointCount - 1) {\n                                TimeSeriesDataItem startOfMovingAvg = source.getRawDataItem(\n                        i - pointCount);\n                rollingSumForPeriod -= startOfMovingAvg.getValue()\n                        .doubleValue();\n                result.add(period, rollingSumForPeriod / pointCount);\n            }\n            else if (i == pointCount - 1) {\n                result.add(period, rollingSumForPeriod / pointCount);\n            }\n        }\n        return result;\n    }
254	public static void assertVocabulary(Analyzer a, Path zipFile, String voc, String out) throws IOException {\n    Path tmp = LuceneTestCase.createTempDir();\n    try (InputStream in = Files.newInputStream(zipFile)) {\n      TestUtil.unzip(in, tmp);\n    }\n    try (InputStream v = Files.newInputStream(tmp.resolve(voc)); \n         InputStream o = Files.newInputStream(tmp.resolve(out))) {\n      assertVocabulary(a, v, o);\n    }\n  }
255	private void readAffixFile(InputStream affixStream, CharsetDecoder decoder) throws IOException, ParseException {\n    TreeMap<String, List<Integer>> prefixes = new TreeMap<>();\n    TreeMap<String, List<Integer>> suffixes = new TreeMap<>();\n    Map<String,Integer> seenPatterns = new HashMap<>();\n    \n        seenPatterns.put(".*", 0);\n    patterns.add(null);\n    \n        Map<String,Integer> seenStrips = new LinkedHashMap<>();\n    seenStrips.put("", 0);\n\n    LineNumberReader reader = new LineNumberReader(new InputStreamReader(affixStream, decoder));\n    String line = null;\n    while ((line = reader.readLine()) != null) {\n            if (reader.getLineNumber() == 1 && line.startsWith("\uFEFF")) {\n        line = line.substring(1);\n      }\n      if (line.startsWith(ALIAS_KEY)) {\n        parseAlias(line);\n      } else if (line.startsWith(MORPH_ALIAS_KEY)) {\n        parseMorphAlias(line);\n      } else if (line.startsWith(PREFIX_KEY)) {\n        parseAffix(prefixes, line, reader, PREFIX_CONDITION_REGEX_PATTERN, seenPatterns, seenStrips);\n      } else if (line.startsWith(SUFFIX_KEY)) {\n        parseAffix(suffixes, line, reader, SUFFIX_CONDITION_REGEX_PATTERN, seenPatterns, seenStrips);\n      } else if (line.startsWith(FLAG_KEY)) {\n                        flagParsingStrategy = getFlagParsingStrategy(line);\n      } else if (line.equals(COMPLEXPREFIXES_KEY)) {\n        complexPrefixes = true;       } else if (line.startsWith(CIRCUMFIX_KEY)) {\n        String parts[] = line.split("\\s+");\n        if (parts.length != 2) {\n          throw new ParseException("Illegal CIRCUMFIX declaration", reader.getLineNumber());\n        }\n        circumfix = flagParsingStrategy.parseFlag(parts[1]);\n      } else if (line.startsWith(KEEPCASE_KEY)) {\n        String parts[] = line.split("\\s+");\n        if (parts.length != 2) {\n          throw new ParseException("Illegal KEEPCASE declaration", reader.getLineNumber());\n        }\n        keepcase = flagParsingStrategy.parseFlag(parts[1]);\n      } else if (line.startsWith(NEEDAFFIX_KEY) || line.startsWith(PSEUDOROOT_KEY)) {\n        String parts[] = line.split("\\s+");\n        if (parts.length != 2) {\n          throw new ParseException("Illegal NEEDAFFIX declaration", reader.getLineNumber());\n        }\n        needaffix = flagParsingStrategy.parseFlag(parts[1]);\n      } else if (line.startsWith(ONLYINCOMPOUND_KEY)) {\n        String parts[] = line.split("\\s+");\n        if (parts.length != 2) {\n          throw new ParseException("Illegal ONLYINCOMPOUND declaration", reader.getLineNumber());\n        }\n        onlyincompound = flagParsingStrategy.parseFlag(parts[1]);\n      } else if (line.startsWith(IGNORE_KEY)) {\n        String parts[] = line.split("\\s+");\n        if (parts.length != 2) {\n          throw new ParseException("Illegal IGNORE declaration", reader.getLineNumber());\n        }\n        ignore = parts[1].toCharArray();\n        Arrays.sort(ignore);\n        needsInputCleaning = true;\n      } else if (line.startsWith(ICONV_KEY) || line.startsWith(OCONV_KEY)) {\n        String parts[] = line.split("\\s+");\n        String type = parts[0];\n        if (parts.length != 2) {\n          throw new ParseException("Illegal " + type + " declaration", reader.getLineNumber());\n        }\n        int num = Integer.parseInt(parts[1]);\n        FST<CharsRef> res = parseConversions(reader, num);\n        if (type.equals("ICONV")) {\n          iconv = res;\n          needsInputCleaning |= iconv != null;\n        } else {\n          oconv = res;\n          needsOutputCleaning |= oconv != null;\n        }\n      } else if (line.startsWith(FULLSTRIP_KEY)) {\n        fullStrip = true;\n      } else if (line.startsWith(LANG_KEY)) {\n        language = line.substring(LANG_KEY.length()).trim();\n        alternateCasing = "tr_TR".equals(language) || "az_AZ".equals(language);\n      }\n    }\n    \n    this.prefixes = affixFST(prefixes);\n    this.suffixes = affixFST(suffixes);\n    \n    int totalChars = 0;\n    for (String strip : seenStrips.keySet()) {\n      totalChars += strip.length();\n    }\n    stripData = new char[totalChars];\n    stripOffsets = new int[seenStrips.size()+1];\n    int currentOffset = 0;\n    int currentIndex = 0;\n    for (String strip : seenStrips.keySet()) {\n      stripOffsets[currentIndex++] = currentOffset;\n      strip.getChars(0, strip.length(), stripData, currentOffset);\n      currentOffset += strip.length();\n    }\n    assert currentIndex == seenStrips.size();\n    stripOffsets[currentIndex] = currentOffset;\n  }
256	public Rectangle2D reserved(Rectangle2D area, RectangleEdge edge) {\n        Rectangle2D result = null;\n        if (edge == RectangleEdge.TOP) {\n            result = new Rectangle2D.Double(\n                area.getX(), area.getY(), area.getWidth(), this.top\n            );\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result = new Rectangle2D.Double(\n                area.getX(), area.getMaxY() - this.top,\n                area.getWidth(), this.bottom\n            );\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            result = new Rectangle2D.Double(\n                area.getX(), area.getY(), this.left, area.getHeight()\n            );\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result = new Rectangle2D.Double(\n                area.getMaxX() - this.right, area.getY(),\n                this.right, area.getHeight()\n            );\n        }\n        return result;\n    }
257	public boolean equalsContents(final Object o) {\n        final CustomProperty c = (CustomProperty) o;\n        final String name1 = c.getName();\n        final String name2 = this.getName();\n        boolean equalNames = true;\n        if (name1 == null) {\n            equalNames = name2 == null;\n        } else {\n            equalNames = name1.equals(name2);\n        }\n        return equalNames && c.getID() == this.getID()\n                && c.getType() == this.getType()\n                && c.getValue().equals(this.getValue());\n    }
258	void skipBlock(IndexInput in) throws IOException {\n    final int numBits = in.readByte();\n    if (numBits == ALL_VALUES_EQUAL) {\n      in.readVInt();\n      return;\n    }\n    assert numBits > 0 && numBits <= 32 : numBits;\n    final int encodedSize = encodedSizes[numBits];\n    in.seek(in.getFilePointer() + encodedSize);\n  }
259	private void gramToken() {\n    buffer.append(termAttribute.buffer(), 0, termAttribute.length());\n    int endOffset = offsetAttribute.endOffset();\n\n    clearAttributes();\n\n    int length = buffer.length();\n    char termText[] = termAttribute.buffer();\n    if (length > termText.length) {\n      termText = termAttribute.resizeBuffer(length);\n    }\n    \n    buffer.getChars(0, length, termText, 0);\n    termAttribute.setLength(length);\n    posIncAttribute.setPositionIncrement(0);\n    posLenAttribute.setPositionLength(2);     offsetAttribute.setOffset(lastStartOffset, endOffset);\n    typeAttribute.setType(GRAM_TYPE);\n    buffer.setLength(0);\n  }
260	public void clearQuery(Query query) {\n    lock.lock();\n    try {\n      final Query singleton = uniqueQueries.remove(query);\n      if (singleton != null) {\n        onEviction(singleton);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }
261	protected void drawAxisLine(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        Line2D axisLine = null;\n        double x = dataArea.getX();\n        double y = dataArea.getY();\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(x, cursor, dataArea.getMaxX(), cursor);\n        } else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(x, cursor, dataArea.getMaxX(), cursor);\n        } else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, y, cursor, dataArea.getMaxY());\n        } else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, y, cursor, dataArea.getMaxY());\n        }\n        g2.setPaint(this.axisLinePaint);\n        g2.setStroke(this.axisLineStroke);\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        g2.draw(axisLine);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }
262	public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException("maxNumSegments must be >= 1; got " + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled("IW")) {\n      infoStream.message("IW", "forceMerge: index now " + segString());\n      infoStream.message("IW", "now flush at forceMerge");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n                  for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n                    segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n                    segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException("this writer hit an unrecoverable error; cannot complete forceMerge", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n                                    final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException("background merge hit exception: " + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n                              ensureOpen();\n    }\n              }
263	private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break;       }\n      if (pp.position > next) {         if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength);           numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength);       numMatches++;\n    }    \n    return freq;\n  }
264	public void addValueRecord(int row, CellValueRecordInterface col) {\n\n        if(log.check(POILogger.DEBUG)) {\n          log.log(POILogger.DEBUG, "add value record  row" + row);\n        }\n        DimensionsRecord d = _dimensions;\n\n        if (col.getColumn() >= d.getLastCol()) {\n            d.setLastCol(( short ) (col.getColumn() + 1));\n        }\n        if (col.getColumn() < d.getFirstCol()) {\n            d.setFirstCol(col.getColumn());\n        }\n        _rowsAggregate.insertCell(col);\n    }
265	public static JFreeChart createBubbleChart(String title, String xAxisLabel,\n            String yAxisLabel, XYZDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        NumberAxis xAxis = new NumberAxis(xAxisLabel);\n        xAxis.setAutoRangeIncludesZero(false);\n        NumberAxis yAxis = new NumberAxis(yAxisLabel);\n        yAxis.setAutoRangeIncludesZero(false);\n\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, null);\n\n        XYItemRenderer renderer = new XYBubbleRenderer(\n                XYBubbleRenderer.SCALE_ON_RANGE_AXIS);\n        if (tooltips) {\n            renderer.setBaseToolTipGenerator(new StandardXYZToolTipGenerator());\n        }\n        if (urls) {\n            renderer.setURLGenerator(new StandardXYZURLGenerator());\n        }\n        plot.setRenderer(renderer);\n        plot.setOrientation(orientation);\n\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
266	public void add(IntsRef input, T output) throws IOException {\n    "\nFST ADD: input="" ""\nFST ADD: input="" "" output="\n\n        if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: "inputs are added out of order lastInput=" + lastInput.get() + " vs input=" + input;\n    assert validOutput(output);\n\n        if (input.length == 0) {\n                                    frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n        int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n            if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n            freezeTail(prefixLenPlus1);\n\n        for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n            for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n                  lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n                  frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n        lastInput.copyInts(input);\n\n      }
267	public HSSFColor findColor(byte red, byte green, byte blue)\n    {\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;\n            b = _palette.getColor(++i))\n        {\n            if (b[0] == red && b[1] == green && b[2] == blue)\n            {\n                return new CustomColor(i, b);\n            }\n        }\n        return null;\n    }
268	public static long deinterleave(long b) {\n    b &= MAGIC[0];\n    b = (b ^ (b >>> SHIFT[0])) & MAGIC[1];\n    b = (b ^ (b >>> SHIFT[1])) & MAGIC[2];\n    b = (b ^ (b >>> SHIFT[2])) & MAGIC[3];\n    b = (b ^ (b >>> SHIFT[3])) & MAGIC[4];\n    b = (b ^ (b >>> SHIFT[4])) & MAGIC[5];\n    return b;\n  }
269	@SuppressWarnings("unchecked")\n    public DOMSignedInfo preSign(final DOMSignContext xmlSignContext)\n    throws XMLSignatureException, MarshalException {\n        signatureConfig.init(false);\n\n        final Document document = (Document)xmlSignContext.getParent();\n\n                        EventTarget target = (EventTarget)document;\n        EventListener creationListener = signatureConfig.getSignatureMarshalListener();\n        if (creationListener != null) {\n            if (creationListener instanceof SignatureMarshalListener) {\n                ((SignatureMarshalListener)creationListener).setEventTarget(target);\n            }\n            SignatureMarshalListener.setListener(target, creationListener, true);\n        }\n\n        \n        URIDereferencer uriDereferencer = signatureConfig.getUriDereferencer();\n        if (null != uriDereferencer) {\n            xmlSignContext.setURIDereferencer(uriDereferencer);\n        }\n\n        for (Map.Entry<String,String> me : signatureConfig.getNamespacePrefixes().entrySet()) {\n            xmlSignContext.putNamespacePrefix(me.getKey(), me.getValue());\n        }\n        xmlSignContext.setDefaultNamespacePrefix("");\n        \n        XMLSignatureFactory signatureFactory = signatureConfig.getSignatureFactory();\n\n        \n        List<Reference> references = new ArrayList<>();\n\n        \n        List<XMLObject> objects = new ArrayList<>();\n        for (SignatureFacet signatureFacet : signatureConfig.getSignatureFacets()) {\n            LOG.log(POILogger.DEBUG, "invoking signature facet: " + signatureFacet.getClass().getSimpleName());\n            signatureFacet.preSign(document, references, objects);\n        }\n\n        \n        SignedInfo signedInfo;\n        try {\n            SignatureMethod signatureMethod = signatureFactory.newSignatureMethod\n                (signatureConfig.getSignatureMethodUri(), null);\n            CanonicalizationMethod canonicalizationMethod = signatureFactory\n                .newCanonicalizationMethod(signatureConfig.getCanonicalizationMethod(),\n                (C14NMethodParameterSpec) null);\n            signedInfo = signatureFactory.newSignedInfo(\n                canonicalizationMethod, signatureMethod, references);\n        } catch (GeneralSecurityException e) {\n            throw new XMLSignatureException(e);\n        }\n\n        \n        String signatureValueId = signatureConfig.getPackageSignatureId() + "-signature-value";\n        javax.xml.crypto.dsig.XMLSignature xmlSignature = signatureFactory\n            .newXMLSignature(signedInfo, null, objects, signatureConfig.getPackageSignatureId(),\n            signatureValueId);\n\n        \n        xmlSignature.sign(xmlSignContext);\n\n        \n        for (XMLObject object : objects) {\n            LOG.log(POILogger.DEBUG, "object java type: " + object.getClass().getName());\n            List<XMLStructure> objectContentList = object.getContent();\n            for (XMLStructure objectContent : objectContentList) {\n                LOG.log(POILogger.DEBUG, "object content java type: " + objectContent.getClass().getName());\n                if (!(objectContent instanceof Manifest)) {\n                    continue;\n                }\n                Manifest manifest = (Manifest) objectContent;\n                List<Reference> manifestReferences = manifest.getReferences();\n                for (Reference manifestReference : manifestReferences) {\n                    if (manifestReference.getDigestValue() != null) {\n                        continue;\n                    }\n\n                    DOMReference manifestDOMReference = (DOMReference)manifestReference;\n                    manifestDOMReference.digest(xmlSignContext);\n                }\n            }\n        }\n\n        \n        List<Reference> signedInfoReferences = signedInfo.getReferences();\n        for (Reference signedInfoReference : signedInfoReferences) {\n            DOMReference domReference = (DOMReference)signedInfoReference;\n\n                        if (domReference.getDigestValue() != null) {\n                continue;\n            }\n\n            domReference.digest(xmlSignContext);\n        }\n\n        return (DOMSignedInfo)signedInfo;\n    }
270	private void outputCompressed(OutputStream res) throws IOException {\n				if(rawCodeLen < 3) {\n		for(int i=0; i<rawCodeLen; i++) {\n			outputUncompressed(rawCode[i], res);\n		}\n		return;\n	}\n	\n		int codesAt = findRawCodeInBuffer();\n   codesAt -= 18;\n	if(codesAt < 0) {\n	   codesAt += 4096;\n	}\n\n		maskBitsSet++;\n	\n				int bp1 = (codesAt & 255);\n	int bp2 = (rawCodeLen-3) + ((codesAt-bp1) >> 4);\n	buffer[bufferLen] = HDGFLZW.fromInt(bp1);\n	bufferLen++;\n   buffer[bufferLen] = HDGFLZW.fromInt(bp2);\n   bufferLen++;\n   \n      for(int i=0; i<rawCodeLen; i++) {\n      dict[(posOut&4095)] = rawCode[i];\n      posOut++; \n   }\n\n		if(maskBitsSet == 8) {\n		output8Codes(res);\n	}\n}
271	private void init() {\n						\n	    isEncrypted = (LittleEndian.getInt(encHeaderToken) == LittleEndian.getInt(_contents,12)); \n	    \n				currentEditOffset = LittleEndian.getUInt(_contents,16);\n\n				docFinalVersion = LittleEndian.getUShort(_contents,22);\n		docMajorNo = _contents[24];\n		docMinorNo = _contents[25];\n\n				long usernameLen = LittleEndian.getUShort(_contents,20);\n		if(usernameLen > 512) {\n						logger.log(POILogger.WARN, "Warning - invalid username length " + usernameLen + " found, treating as if there was no username set");\n			usernameLen = 0;\n		}\n\n						if(_contents.length >= 28+(int)usernameLen + 4) {\n			releaseVersion = LittleEndian.getUInt(_contents,28+(int)usernameLen);\n		} else {\n						releaseVersion = 0;\n		}\n\n				int start = 28+(int)usernameLen+4;\n		int len = 2*(int)usernameLen;\n\n		if(_contents.length >= start+len) {\n			byte[] textBytes = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n			System.arraycopy(_contents,start,textBytes,0,len);\n			lastEditUser = StringUtil.getFromUnicodeLE(textBytes);\n		} else {\n						byte[] textBytes = IOUtils.safelyAllocate(usernameLen, MAX_RECORD_LENGTH);\n			System.arraycopy(_contents,28,textBytes,0,(int)usernameLen);\n			lastEditUser = StringUtil.getFromCompressedUnicode(textBytes,0,(int)usernameLen);\n		}\n	}
272	public static PropertySet create(final DirectoryEntry dir, final String name)\n    throws FileNotFoundException, NoPropertySetStreamException, IOException, UnsupportedEncodingException {\n        InputStream inp = null;\n        try {\n            DocumentEntry entry = (DocumentEntry)dir.getEntry(name);\n            inp = new DocumentInputStream(entry);\n            try {\n                return create(inp);\n            } catch (MarkUnsupportedException e) {\n                return null;\n            }\n        } finally {\n            if (inp != null) {\n                inp.close();\n            }\n        }\n    }
273	protected EmbeddedObjectRefSubRecord findObjectRecord() {\n        Iterator<SubRecord> subRecordIter = getObjRecord().getSubRecords().iterator();\n\n        while (subRecordIter.hasNext()) {\n            Object subRecord = subRecordIter.next();\n            if (subRecord instanceof EmbeddedObjectRefSubRecord) {\n                return (EmbeddedObjectRefSubRecord) subRecord;\n            }\n        }\n\n        throw new IllegalStateException("Object data does not contain a reference to an embedded object OLE2 directory");\n    }
274	public static PlanetObject readPlanetObject(final InputStream inputStream) throws IOException {\n    final PlanetModel pm = new PlanetModel(inputStream);\n    final SerializableObject so = readObject(pm, inputStream);\n    if (!(so instanceof PlanetObject)) {\n      throw new IOException("Type of object is not expected PlanetObject: "+so.getClass().getName());\n    }\n    return (PlanetObject)so;\n  }
275	protected List buildRadialTicks(List allTicks)\n    {\n        List ticks = new ArrayList();\n        Iterator it = allTicks.iterator();\n        while (it.hasNext()) {\n            ValueTick tick = (ValueTick) it.next();\n            if (isRadiusMinorGridlinesVisible() ||\n                    TickType.MAJOR.equals(tick.getTickType())) {\n                ticks.add(tick);\n            }\n        }\n        return ticks;\n    }
276	private boolean checkIvyXmlFile(File ivyXmlFile)\n      throws ParserConfigurationException, SAXException, IOException {\n    log("Scanning: " + ivyXmlFile.getPath(), verboseLevel);\n    XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n    DependencyRevChecker revChecker = new DependencyRevChecker(ivyXmlFile); \n    xmlReader.setContentHandler(revChecker);\n    xmlReader.setErrorHandler(revChecker);\n    xmlReader.parse(new InputSource(ivyXmlFile.getAbsolutePath()));\n    return ! revChecker.fail;\n  }
277	public static double calculateMean(Collection values,\n            boolean includeNullAndNaN) {\n\n        ParamChecks.nullNotPermitted(values, "values");\n        int count = 0;\n        double total = 0.0;\n        Iterator iterator = values.iterator();\n        while (iterator.hasNext()) {\n            Object object = iterator.next();\n            if (object == null) {\n                if (includeNullAndNaN) {\n                    return Double.NaN;\n                }\n            }\n            else {\n                if (object instanceof Number) {\n                    Number number = (Number) object;\n                    double value = number.doubleValue();\n                    if (Double.isNaN(value)) {\n                        if (includeNullAndNaN) {\n                            return Double.NaN;\n                        }\n                    }\n                    else {\n                        total = total + number.doubleValue();\n                        count = count + 1;\n                    }\n                }\n            }\n        }\n        return total / count;\n    }
278	protected void addMultiTermClauses(List<BooleanClause> clauses, Query q) {\n            if (q == null) {\n      return;\n    }\n    boolean allNestedTermQueries = false;\n    if (q instanceof BooleanQuery) {\n      allNestedTermQueries = true;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        if ( ! (clause.getQuery() instanceof TermQuery)) {\n          allNestedTermQueries = false;\n          break;\n        }\n      }\n    }\n    if (allNestedTermQueries) {\n      clauses.addAll(((BooleanQuery)q).clauses());\n    } else {\n      BooleanClause.Occur occur = operator == OR_OPERATOR ? BooleanClause.Occur.SHOULD : BooleanClause.Occur.MUST;\n      if (q instanceof BooleanQuery) {\n        for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n          clauses.add(newBooleanClause(clause.getQuery(), occur));\n        }\n      } else {\n        clauses.add(newBooleanClause(q, occur));\n      }\n    }\n  }
279	private ParseTree getAntlrParseTree() throws ParseException {\n    final ANTLRInputStream antlrInputStream = new ANTLRInputStream(sourceText);\n    final JavascriptErrorHandlingLexer javascriptLexer = new JavascriptErrorHandlingLexer(antlrInputStream);\n    javascriptLexer.removeErrorListeners();\n    final JavascriptParser javascriptParser = new JavascriptParser(new CommonTokenStream(javascriptLexer));\n    javascriptParser.removeErrorListeners();\n    javascriptParser.setErrorHandler(new JavascriptParserErrorStrategy());\n    return javascriptParser.compile();\n  }
280	public void setParentTextSize(int size) {\n        if (initialised) {\n            return;\n        }\n        \n        int pos = 0;\n        int textHandled = 0;\n\n        paragraphStyles.clear();\n        charStyles.clear();\n        \n                        int prsize = size;\n        while(pos < rawContents.length && textHandled < prsize) {\n                        int textLen = LittleEndian.getInt(rawContents,pos);\n            textLen = checkTextLength(textLen, textHandled, size);\n            textHandled += textLen;\n            pos += 4;\n\n            short indent = LittleEndian.getShort(rawContents,pos);\n            pos += 2;\n\n                        int paraFlags = LittleEndian.getInt(rawContents,pos);\n            pos += 4;\n\n                        TextPropCollection thisCollection = new TextPropCollection(textLen, TextPropType.paragraph);\n            thisCollection.setIndentLevel(indent);\n            int plSize = thisCollection.buildTextPropList(paraFlags, rawContents, pos);\n            pos += plSize;\n\n                        paragraphStyles.add(thisCollection);\n\n                        if(pos < rawContents.length && textHandled == size) {\n                prsize++;\n            }\n\n        }\n        if (rawContents.length > 0 && textHandled != (size+1)){\n            logger.log(POILogger.WARN, "Problem reading paragraph style runs: textHandled = " + textHandled + ", text.size+1 = " + (size+1));\n        }\n\n                textHandled = 0;\n        int chsize = size;\n        while(pos < rawContents.length && textHandled < chsize) {\n                        int textLen = LittleEndian.getInt(rawContents,pos);\n            textLen = checkTextLength(textLen, textHandled, size);\n            textHandled += textLen;\n            pos += 4;\n\n                        int charFlags = LittleEndian.getInt(rawContents,pos);\n            pos += 4;\n\n                                    TextPropCollection thisCollection = new TextPropCollection(textLen, TextPropType.character);\n            int chSize = thisCollection.buildTextPropList(charFlags, rawContents, pos);\n            pos += chSize;\n\n                        charStyles.add(thisCollection);\n\n                        if(pos < rawContents.length && textHandled == size) {\n                chsize++;\n            }\n        }\n        if (rawContents.length > 0 && textHandled != (size+1)){\n            logger.log(POILogger.WARN, "Problem reading character style runs: textHandled = " + textHandled + ", text.size+1 = " + (size+1));\n        }\n\n                if(pos < rawContents.length) {\n            reserved = IOUtils.safelyAllocate(rawContents.length-pos, rawContents.length);\n            System.arraycopy(rawContents,pos,reserved,0,reserved.length);\n        }\n\n        initialised = true;\n    }
281	public void drawVerticalItem(Graphics2D g2, CategoryItemRendererState state,\n        Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n        ValueAxis rangeAxis, CategoryDataset dataset, int row, int column) {\n\n        BoxAndWhiskerCategoryDataset bawDataset\n                = (BoxAndWhiskerCategoryDataset) dataset;\n\n        double categoryEnd = domainAxis.getCategoryEnd(column,\n                getColumnCount(), dataArea, plot.getDomainAxisEdge());\n        double categoryStart = domainAxis.getCategoryStart(column,\n                getColumnCount(), dataArea, plot.getDomainAxisEdge());\n        double categoryWidth = categoryEnd - categoryStart;\n\n        double xx = categoryStart;\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getWidth() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            double usedWidth = (state.getBarWidth() * seriesCount)\n                               + (seriesGap * (seriesCount - 1));\n                                    double offset = (categoryWidth - usedWidth) / 2;\n            xx = xx + offset + (row * (state.getBarWidth() + seriesGap));\n        }\n        else {\n                                    double offset = (categoryWidth - state.getBarWidth()) / 2;\n            xx = xx + offset;\n        }\n\n        double yyAverage;\n        double yyOutlier;\n\n        Paint itemPaint = getItemPaint(row, column);\n        g2.setPaint(itemPaint);\n        Stroke s = getItemStroke(row, column);\n        g2.setStroke(s);\n\n        double aRadius = 0;                 \n        RectangleEdge location = plot.getRangeAxisEdge();\n\n        Number yQ1 = bawDataset.getQ1Value(row, column);\n        Number yQ3 = bawDataset.getQ3Value(row, column);\n        Number yMax = bawDataset.getMaxRegularValue(row, column);\n        Number yMin = bawDataset.getMinRegularValue(row, column);\n        Shape box = null;\n        if (yQ1 != null && yQ3 != null && yMax != null && yMin != null) {\n\n            double yyQ1 = rangeAxis.valueToJava2D(yQ1.doubleValue(), dataArea,\n                    location);\n            double yyQ3 = rangeAxis.valueToJava2D(yQ3.doubleValue(), dataArea,\n                    location);\n            double yyMax = rangeAxis.valueToJava2D(yMax.doubleValue(),\n                    dataArea, location);\n            double yyMin = rangeAxis.valueToJava2D(yMin.doubleValue(),\n                    dataArea, location);\n            double xxmid = xx + state.getBarWidth() / 2.0;\n            double halfW = (state.getBarWidth() / 2.0) * this.whiskerWidth;\n\n                        box = new Rectangle2D.Double(xx, Math.min(yyQ1, yyQ3),\n                    state.getBarWidth(), Math.abs(yyQ1 - yyQ3));\n            if (this.fillBox) {\n                g2.fill(box);\n            }\n\n            Paint outlinePaint = getItemOutlinePaint(row, column);\n            if (this.useOutlinePaintForWhiskers) {\n                g2.setPaint(outlinePaint);\n            }\n                        g2.draw(new Line2D.Double(xxmid, yyMax, xxmid, yyQ3));\n            g2.draw(new Line2D.Double(xxmid - halfW, yyMax, xxmid + halfW, yyMax));\n\n                        g2.draw(new Line2D.Double(xxmid, yyMin, xxmid, yyQ1));\n            g2.draw(new Line2D.Double(xxmid - halfW, yyMin, xxmid + halfW, yyMin));\n\n            g2.setStroke(getItemOutlineStroke(row, column));\n            g2.setPaint(outlinePaint);\n            g2.draw(box);\n        }\n\n        g2.setPaint(this.artifactPaint);\n\n                if (this.meanVisible) {\n            Number yMean = bawDataset.getMeanValue(row, column);\n            if (yMean != null) {\n                yyAverage = rangeAxis.valueToJava2D(yMean.doubleValue(),\n                        dataArea, location);\n                aRadius = state.getBarWidth() / 4;\n                                                if ((yyAverage > (dataArea.getMinY() - aRadius))\n                        && (yyAverage < (dataArea.getMaxY() + aRadius))) {\n                    Ellipse2D.Double avgEllipse = new Ellipse2D.Double(\n                            xx + aRadius, yyAverage - aRadius, aRadius * 2,\n                            aRadius * 2);\n                    g2.fill(avgEllipse);\n                    g2.draw(avgEllipse);\n                }\n            }\n        }\n\n                if (this.medianVisible) {\n            Number yMedian = bawDataset.getMedianValue(row, column);\n            if (yMedian != null) {\n                double yyMedian = rangeAxis.valueToJava2D(\n                        yMedian.doubleValue(), dataArea, location);\n                g2.draw(new Line2D.Double(xx, yyMedian, \n                        xx + state.getBarWidth(), yyMedian));\n            }\n        }\n\n                double maxAxisValue = rangeAxis.valueToJava2D(\n                rangeAxis.getUpperBound(), dataArea, location) + aRadius;\n        double minAxisValue = rangeAxis.valueToJava2D(\n                rangeAxis.getLowerBound(), dataArea, location) - aRadius;\n\n        g2.setPaint(itemPaint);\n\n                double oRadius = state.getBarWidth() / 3;            List outliers = new ArrayList();\n        OutlierListCollection outlierListCollection\n                = new OutlierListCollection();\n\n                                List yOutliers = bawDataset.getOutliers(row, column);\n        if (yOutliers != null) {\n            for (int i = 0; i < yOutliers.size(); i++) {\n                double outlier = ((Number) yOutliers.get(i)).doubleValue();\n                Number minOutlier = bawDataset.getMinOutlier(row, column);\n                Number maxOutlier = bawDataset.getMaxOutlier(row, column);\n                Number minRegular = bawDataset.getMinRegularValue(row, column);\n                Number maxRegular = bawDataset.getMaxRegularValue(row, column);\n                if (outlier > maxOutlier.doubleValue()) {\n                    outlierListCollection.setHighFarOut(true);\n                }\n                else if (outlier < minOutlier.doubleValue()) {\n                    outlierListCollection.setLowFarOut(true);\n                }\n                else if (outlier > maxRegular.doubleValue()) {\n                    yyOutlier = rangeAxis.valueToJava2D(outlier, dataArea,\n                            location);\n                    outliers.add(new Outlier(xx + state.getBarWidth() / 2.0,\n                            yyOutlier, oRadius));\n                }\n                else if (outlier < minRegular.doubleValue()) {\n                    yyOutlier = rangeAxis.valueToJava2D(outlier, dataArea,\n                            location);\n                    outliers.add(new Outlier(xx + state.getBarWidth() / 2.0,\n                            yyOutlier, oRadius));\n                }\n                Collections.sort(outliers);\n            }\n\n                                    for (Iterator iterator = outliers.iterator(); iterator.hasNext();) {\n                Outlier outlier = (Outlier) iterator.next();\n                outlierListCollection.add(outlier);\n            }\n\n            for (Iterator iterator = outlierListCollection.iterator();\n                     iterator.hasNext();) {\n                OutlierList list = (OutlierList) iterator.next();\n                Outlier outlier = list.getAveragedOutlier();\n                Point2D point = outlier.getPoint();\n\n                if (list.isMultiple()) {\n                    drawMultipleEllipse(point, state.getBarWidth(), oRadius,\n                            g2);\n                }\n                else {\n                    drawEllipse(point, oRadius, g2);\n                }\n            }\n\n                        if (outlierListCollection.isHighFarOut()) {\n                drawHighFarOut(aRadius / 2.0, g2,\n                        xx + state.getBarWidth() / 2.0, maxAxisValue);\n            }\n\n            if (outlierListCollection.isLowFarOut()) {\n                drawLowFarOut(aRadius / 2.0, g2,\n                        xx + state.getBarWidth() / 2.0, minAxisValue);\n            }\n        }\n                if (state.getInfo() != null && box != null) {\n            EntityCollection entities = state.getEntityCollection();\n            if (entities != null) {\n                addItemEntity(entities, dataset, row, column, box);\n            }\n        }\n\n    }
282	static void writeClass(final OutputStream outputStream, final Class<?> clazz) throws IOException {\n    Integer index = StandardObjects.classRegsitry.get(clazz);\n    if (index == null){\n      writeBoolean(outputStream, false);\n      writeString(outputStream, clazz.getName());\n    }\n    else {\n      writeBoolean(outputStream, true);\n      outputStream.write(index);\n    }\n  }
283	public void report(QualityQuery qq, TopDocs td, String docNameField, IndexSearcher searcher) throws IOException {\n    if (logger==null) {\n      return;\n    }\n    ScoreDoc sd[] = td.scoreDocs;\n    String sep = " \t ";\n    DocNameExtractor xt = new DocNameExtractor(docNameField);\n    for (int i=0; i<sd.length; i++) {\n      String docName = xt.docName(searcher,sd[i].doc);\n      logger.println(\n          qq.getQueryID()       + sep +\n          "Q0"                   + sep +\n          format(docName,20)    + sep +\n          format(""+i,7)        + sep +\n          nf.format(sd[i].score) + sep +\n          name\n          );\n    }\n  }
284	private void updateFreq() throws IOException {\n    assert freq >= minShouldMatch;\n                                for (int i = tailSize - 1; i >= 0; --i) {\n      advanceTail(tail[i]);\n    }\n    tailSize = 0;\n  }
285	public static ChunkHeader createChunkHeader(int documentVersion, byte[] data, int offset) {\n		if(documentVersion >= 6) {\n			ChunkHeaderV6 ch;\n			if(documentVersion > 6) {\n				ch = new ChunkHeaderV11();\n			} else {\n				ch = new ChunkHeaderV6();\n			}\n			ch.setType((int)LittleEndian.getUInt(data, offset + 0));\n			ch.setId((int)LittleEndian.getUInt(data, offset + 4));\n			ch.setUnknown1((int)LittleEndian.getUInt(data, offset + 8));\n			ch.setLength((int)LittleEndian.getUInt(data, offset + 12));\n			ch.setUnknown2(LittleEndian.getShort(data, offset + 16));\n			ch.setUnknown3(LittleEndian.getUByte(data, offset + 18));\n\n			return ch;\n		} else if(documentVersion == 5 || documentVersion == 4) {\n			ChunkHeaderV4V5 ch = new ChunkHeaderV4V5();\n\n			ch.setType(LittleEndian.getShort(data, offset + 0));\n			ch.setId(LittleEndian.getShort(data, offset + 2));\n			ch.setUnknown2(LittleEndian.getUByte(data, offset + 4));\n			ch.setUnknown3(LittleEndian.getUByte(data, offset + 5));\n			ch.setUnknown1(LittleEndian.getShort(data, offset + 6));\n			ch.setLength((int)LittleEndian.getUInt(data, offset + 8));\n\n			return ch;\n		} else {\n			throw new IllegalArgumentException("Visio files with versions below 4 are not supported, yours was " + documentVersion);\n		}\n	}
286	static int getCopyLenBits(int offset) {\n        for (int n = 11; n >= 4; n--) {\n            if ((offset & POWER2[n]) != 0) {\n                return 15 - n;\n            }\n        }\n        return 12;\n    }
287	private synchronized void encode(String id, Document doc) throws IOException {\n    assert id.equals(doc.get("docid")): "id=" + id + " vs docid=" + doc.get("docid");\n    buffer.writeString(id);\n    writeNullableString(doc.get("title"));\n    writeNullableString(doc.get("body"));\n    writeNullableString(doc.get("marker"));\n  }
288	private boolean initPhrasePositions() throws IOException {\n    end = Integer.MIN_VALUE;\n    if (!checkedRpts) {\n      return initFirstTime();\n    }\n    if (!hasRpts) {\n      initSimple();\n      return true;     }\n    return initComplex();\n  }
289	public ASN1ObjectIdentifier mapDigestAlgoToOID(HashAlgorithm digestAlgo) {\n        switch (digestAlgo) {\n        case sha1:   return X509ObjectIdentifiers.id_SHA1;\n        case sha256: return NISTObjectIdentifiers.id_sha256;\n        case sha384: return NISTObjectIdentifiers.id_sha384;\n        case sha512: return NISTObjectIdentifiers.id_sha512;\n        default:\n            throw new IllegalArgumentException("unsupported digest algo: " + digestAlgo);\n        }\n    }
290	protected void encode(ByteSequencesWriter writer, ByteArrayDataOutput output, byte[] buffer, BytesRef spare, BytesRef payload, Set<BytesRef> contexts, long weight) throws IOException {\n    int requiredLength = spare.length + 8 + ((hasPayloads) ? 2 + payload.length : 0);\n    if (hasContexts) {\n      for(BytesRef ctx : contexts) {\n        requiredLength += 2 + ctx.length;\n      }\n      requiredLength += 2;     }\n    if (requiredLength >= buffer.length) {\n      buffer = ArrayUtil.grow(buffer, requiredLength);\n    }\n    output.reset(buffer);\n    output.writeBytes(spare.bytes, spare.offset, spare.length);\n    if (hasContexts) {\n      for (BytesRef ctx : contexts) {\n        output.writeBytes(ctx.bytes, ctx.offset, ctx.length);\n        output.writeShort((short) ctx.length);\n      }\n      output.writeShort((short) contexts.size());\n    }\n    if (hasPayloads) {\n      output.writeBytes(payload.bytes, payload.offset, payload.length);\n      output.writeShort((short) payload.length);\n    }\n    output.writeLong(weight);\n    writer.write(buffer, 0, output.getPosition());\n  }
291	public static int compareArrayByPrefix(char[] shortArray, int shortIndex,\n      char[] longArray, int longIndex) {\n\n        if (shortArray == null)\n      return 0;\n    else if (longArray == null)\n      return (shortIndex < shortArray.length) ? 1 : 0;\n\n    int si = shortIndex, li = longIndex;\n    while (si < shortArray.length && li < longArray.length\n        && shortArray[si] == longArray[li]) {\n      si++;\n      li++;\n    }\n    if (si == shortArray.length) {\n            return 0;\n    } else {\n            if (li == longArray.length)\n        return 1;\n      else\n                return (shortArray[si] > longArray[li]) ? 1 : -1;\n    }\n  }
292	public void listInCell(HSSFWorkbook workbook, ArrayList<String> listItems, HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n        for(String listItem : listItems) {\n            buffer.append(listItem);\n            buffer.append("\n");\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
293	protected double calculateCoefficient(int position) {\n\n    double coefficient;\n    switch (blenderType) {\n      case POSITION_LINEAR:\n        coefficient = 1 - LINEAR_COEF * position;\n        break;\n\n      case POSITION_RECIPROCAL:\n        coefficient = 1. / (position + 1);\n        break;\n\n      case POSITION_EXPONENTIAL_RECIPROCAL:\n        coefficient = 1. / Math.pow((position + 1.0), exponent);\n        break;\n\n      default:\n        coefficient = 1;\n    }\n\n    return coefficient;\n  }
294	public static JFreeChart createAreaChart(String title,\n            String categoryAxisLabel, String valueAxisLabel,\n            CategoryDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel);\n        categoryAxis.setCategoryMargin(0.0);\n\n        ValueAxis valueAxis = new NumberAxis(valueAxisLabel);\n\n        AreaRenderer renderer = new AreaRenderer();\n        if (tooltips) {\n            renderer.setBaseToolTipGenerator(\n                    new StandardCategoryToolTipGenerator());\n        }\n        if (urls) {\n            renderer.setBaseItemURLGenerator(\n                    new StandardCategoryURLGenerator());\n        }\n\n        CategoryPlot plot = new CategoryPlot(dataset, categoryAxis, valueAxis,\n                renderer);\n        plot.setOrientation(orientation);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
295	void add(CharSequence key, CharSequence cmd) {\n    if (key == null || cmd == null) {\n      return;\n    }\n    if (cmd.length() == 0) {\n      return;\n    }\n    int id_cmd = cmds.indexOf(cmd);\n    if (id_cmd == -1) {\n      id_cmd = cmds.size();\n      cmds.add(cmd);\n    }\n    \n    int node = root;\n    Row r = getRow(node);\n    \n    StrEnum e = new StrEnum(key, forward);\n    \n    for (int i = 0; i < e.length() - 1; i++) {\n      Character ch = new Character(e.next());\n      node = r.getRef(ch);\n      if (node >= 0) {\n        r = getRow(node);\n      } else {\n        node = rows.size();\n        Row n;\n        rows.add(n = new Row());\n        r.setRef(ch, node);\n        r = n;\n      }\n    }\n    r.setCmd(new Character(e.next()), id_cmd);\n  }
296	public EscherContainerRecord getEscherContainer() {\n		for(Iterator<EscherRecord> it = escherRecords.iterator(); it.hasNext();) {\n			Object er = it.next();\n			if(er instanceof EscherContainerRecord) {\n				return (EscherContainerRecord)er;\n			}\n		}\n		return null;\n	}
297	public void extractAttachments(File dir) throws IOException {\n        int count = 0;\n        for(Attachment att : message.getAttachments()) {\n            count++;\n            \n                        String filename = att.getLongFilename();\n            if(filename == null || filename.length() == 0) {\n                filename = att.getFilename();\n            }\n            if(filename == null || filename.length() == 0) {\n                filename = "attachment" + count;\n                if(att.getExtension() != null) {\n                    filename += att.getExtension();\n                }\n            }\n            \n                        File file = new File(dir, filename);\n            OutputStream fout = new FileOutputStream(file);\n            try {\n                fout.write( att.getContents() );\n            } finally {\n                fout.close();\n            }\n        }\n    }
298	public XWPFParagraph createParagraph() {\n        XWPFParagraph paragraph = new XWPFParagraph(headerFooter.addNewP(), this);\n        paragraphs.add(paragraph);\n        bodyElements.add(paragraph);\n        return paragraph;\n    }
299	protected void drawLabel(Graphics2D g2, Rectangle2D plotArea, double value,\n                             int cat, double startAngle, double extent) {\n        FontRenderContext frc = g2.getFontRenderContext();\n\n        String label;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                        label = this.labelGenerator.generateColumnLabel(this.dataset, cat);\n        }\n        else {\n                        label = this.labelGenerator.generateRowLabel(this.dataset, cat);\n        }\n\n        Rectangle2D labelBounds = getLabelFont().getStringBounds(label, frc);\n        LineMetrics lm = getLabelFont().getLineMetrics(label, frc);\n        double ascent = lm.getAscent();\n\n        Point2D labelLocation = calculateLabelLocation(labelBounds, ascent,\n                plotArea, startAngle);\n\n        Composite saveComposite = g2.getComposite();\n\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                1.0f));\n        g2.setPaint(getLabelPaint());\n        g2.setFont(getLabelFont());\n        g2.drawString(label, (float) labelLocation.getX(),\n                (float) labelLocation.getY());\n        g2.setComposite(saveComposite);\n    }
300	private XSSFGraphicFrame createGraphicFrame(XSSFClientAnchor anchor) {\n        CTTwoCellAnchor ctAnchor = createTwoCellAnchor(anchor);\n        CTGraphicalObjectFrame ctGraphicFrame = ctAnchor.addNewGraphicFrame();\n        ctGraphicFrame.set(XSSFGraphicFrame.prototype());\n        ctGraphicFrame.setXfrm(createXfrm(anchor));\n\n        long frameId = numOfGraphicFrames++;\n        XSSFGraphicFrame graphicFrame = new XSSFGraphicFrame(this, ctGraphicFrame);\n        graphicFrame.setAnchor(anchor);\n        graphicFrame.setId(frameId);\n        graphicFrame.setName("Diagramm" + frameId);\n        return graphicFrame;\n    }
301	private List<String> matchAlmostRecursion(TSTNode currentNode, int charIndex,\n          int d, CharSequence matchAlmostKey, int matchAlmostNumReturnValues,\n          List<String> matchAlmostResult2, boolean upTo) {\n    if ((currentNode == null)\n            || (matchAlmostNumReturnValues != -1 && matchAlmostResult2.size() >= matchAlmostNumReturnValues)\n            || (d < 0) || (charIndex >= matchAlmostKey.length())) {\n      return matchAlmostResult2;\n    }\n    int charComp = compareCharsAlphabetically(matchAlmostKey.charAt(charIndex),\n            currentNode.splitchar);\n    List<String> matchAlmostResult = matchAlmostResult2;\n    if ((d > 0) || (charComp < 0)) {\n      matchAlmostResult = matchAlmostRecursion(\n              currentNode.relatives[TSTNode.LOKID], charIndex, d,\n              matchAlmostKey, matchAlmostNumReturnValues, matchAlmostResult,\n              upTo);\n    }\n    int nextD = (charComp == 0) ? d : d - 1;\n    boolean cond = (upTo) ? (nextD >= 0) : (nextD == 0);\n    if ((matchAlmostKey.length() == charIndex + 1) && cond\n            && (currentNode.data != null)) {\n      matchAlmostResult.add(getKey(currentNode));\n    }\n    matchAlmostResult = matchAlmostRecursion(\n            currentNode.relatives[TSTNode.EQKID], charIndex + 1, nextD,\n            matchAlmostKey, matchAlmostNumReturnValues, matchAlmostResult, upTo);\n    if ((d > 0) || (charComp > 0)) {\n      matchAlmostResult = matchAlmostRecursion(\n              currentNode.relatives[TSTNode.HIKID], charIndex, d,\n              matchAlmostKey, matchAlmostNumReturnValues, matchAlmostResult,\n              upTo);\n    }\n    return matchAlmostResult;\n  }
302	public final void addProp(TextProp textProp) {\n	    if (textProp == null) {\n	        throw new HSLFException("TextProp must not be null");\n	    }\n\n	    String propName = textProp.getName();\n	    validatePropName(propName);\n	    \n	    textProps.put(propName, textProp);\n	}
303	public static void main(String[] args) {\n		if(args.length <= 0) {\n			System.err.println("No files names provided");\n		} else {\n			for (String arg : args) {\n				try {\n					Msg2txt processor = new Msg2txt(arg);\n					processor.processMessage();\n				} catch (IOException e) {\n					System.err.println("Could not process " + arg + ": " + e);\n				}\n			}\n		}\n	}
304	public void deletePartRecursive(PackagePartName partName) {\n		if (partName == null || !this.containPart(partName)) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		PackagePart partToDelete = this.getPart(partName);\n				this.removePart(partName);\n				try {\n			for (PackageRelationship relationship : partToDelete\n					.getRelationships()) {\n				PackagePartName targetPartName = PackagingURIHelper\n						.createPartName(PackagingURIHelper.resolvePartUri(\n								partName.getURI(), relationship.getTargetURI()));\n				this.deletePartRecursive(targetPartName);\n			}\n		} catch (InvalidFormatException e) {\n			logger.log(POILogger.WARN, "An exception occurs while deleting part '"\n					+ partName.getName()\n					+ "'. Some parts may remain in the package. - "\n					+ e.getMessage());\n			return;\n		}\n				PackagePartName relationshipPartName = PackagingURIHelper\n				.getRelationshipPartName(partName);\n		if (relationshipPartName != null && containPart(relationshipPartName)) {\n			this.removePart(relationshipPartName);\n		}\n	}
305	public static RectangleEdge resolveDomainAxisLocation(\n            AxisLocation location, PlotOrientation orientation) {\n\n        ParamChecks.nullNotPermitted(location, "location");\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n\n        RectangleEdge result = null;\n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.TOP;\n            }\n        }\n        else if (location == AxisLocation.TOP_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.TOP;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n                if (result == null) {\n            throw new IllegalStateException("resolveDomainAxisLocation()");\n        }\n        return result;\n\n    }
306	static String getDictionaryEncoding(InputStream affix) throws IOException, ParseException {\n    final StringBuilder encoding = new StringBuilder();\n    for (;;) {\n      encoding.setLength(0);\n      int ch;\n      while ((ch = affix.read()) >= 0) {\n        if (ch == '\n') {\n          break;\n        }\n        if (ch != '\r') {\n          encoding.append((char)ch);\n        }\n      }\n      if (\n          encoding.length() == 0 || encoding.charAt(0) == '#' ||\n                    encoding.toString().trim().length() == 0\n      ) {\n        if (ch < 0) {\n          throw new ParseException("Unexpected end of affix file.", 0);\n        }\n        continue;\n      }\n      Matcher matcher = ENCODING_PATTERN.matcher(encoding);\n      if (matcher.find()) {\n        int last = matcher.end();\n        return encoding.substring(last).trim();\n      }\n    }\n  }
307	private LinkedHashMap<Term,Integer> repeatingTerms() {\n    LinkedHashMap<Term,Integer> tord = new LinkedHashMap<>();\n    HashMap<Term,Integer> tcnt = new HashMap<>();\n    for (PhrasePositions pp : phrasePositions) {\n      for (Term t : pp.terms) {\n        Integer cnt0 = tcnt.get(t);\n        Integer cnt = cnt0==null ? new Integer(1) : new Integer(1+cnt0.intValue());\n        tcnt.put(t, cnt);\n        if (cnt==2) {\n          tord.put(t,tord.size());\n        }\n      }\n    }\n    return tord;\n  }
308	protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        Rectangle2D revPlotArea = space.shrink(plotArea, null);\n        space = calculateDomainAxisSpace(g2, revPlotArea, space);\n        return space;\n    }
309	protected void drawGridBandsHorizontal(Graphics2D g2,\n            Rectangle2D plotArea, Rectangle2D dataArea, \n            boolean firstGridBandIsDark, List ticks) {\n\n        boolean currentGridBandIsDark = firstGridBandIsDark;\n        double yy = dataArea.getY();\n        double xx1, xx2;\n\n                double outlineStrokeWidth = 1.0;\n        Stroke outlineStroke = getPlot().getOutlineStroke();\n        if (outlineStroke != null && outlineStroke instanceof BasicStroke) {\n            outlineStrokeWidth = ((BasicStroke) outlineStroke).getLineWidth();\n        }\n\n        Iterator iterator = ticks.iterator();\n        ValueTick tick;\n        Rectangle2D band;\n        while (iterator.hasNext()) {\n            tick = (ValueTick) iterator.next();\n            xx1 = valueToJava2D(tick.getValue() - 0.5d, dataArea,\n                    RectangleEdge.BOTTOM);\n            xx2 = valueToJava2D(tick.getValue() + 0.5d, dataArea,\n                    RectangleEdge.BOTTOM);\n            if (currentGridBandIsDark) {\n                g2.setPaint(this.gridBandPaint);\n            }\n            else {\n                g2.setPaint(this.gridBandAlternatePaint);\n            }\n            band = new Rectangle2D.Double(Math.min(xx1, xx2), \n                    yy + outlineStrokeWidth, Math.abs(xx2 - xx1), \n                    dataArea.getMaxY() - yy - outlineStrokeWidth);\n            g2.fill(band);\n            currentGridBandIsDark = !currentGridBandIsDark;\n        }\n    }
310	private void resubstitute( StringBuilder buffer )\n    {\n      for ( int c = 0; c < buffer.length(); c++ ) {\n        if ( buffer.charAt( c ) == '*' ) {\n          char x = buffer.charAt( c - 1 );\n          buffer.setCharAt( c, x );\n        }\n        else if ( buffer.charAt( c ) == '$' ) {\n          buffer.setCharAt( c, 's' );\n          buffer.insert( c + 1, new char[]{'c', 'h'}, 0, 2 );\n        }\n        else if ( buffer.charAt( c ) == '§' ) {\n          buffer.setCharAt( c, 'c' );\n          buffer.insert( c + 1, 'h' );\n        }\n        else if ( buffer.charAt( c ) == '%' ) {\n          buffer.setCharAt( c, 'e' );\n          buffer.insert( c + 1, 'i' );\n        }\n        else if ( buffer.charAt( c ) == '&' ) {\n          buffer.setCharAt( c, 'i' );\n          buffer.insert( c + 1, 'e' );\n        }\n        else if ( buffer.charAt( c ) == '#' ) {\n          buffer.setCharAt( c, 'i' );\n          buffer.insert( c + 1, 'g' );\n        }\n        else if ( buffer.charAt( c ) == '!' ) {\n          buffer.setCharAt( c, 's' );\n          buffer.insert( c + 1, 't' );\n        }\n      }\n    }
311	protected Size2D arrangeNR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        RectangleConstraint c1 = constraint.toUnconstrainedHeight();\n        Size2D size1 = arrange(container, g2, c1);\n\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\n            return size1;\n        }\n        else {\n            double h = constraint.getHeightRange().constrain(size1.getHeight());\n            RectangleConstraint c2 = constraint.toFixedHeight(h);\n            return arrange(container, g2, c2);\n        }\n    }
312	public int addChildBefore(Record newChild, Record before) {\n				int loc = findChildLocation(before);\n		if(loc == -1) {\n			throw new IllegalArgumentException("Asked to add a new child before another record, but that record wasn't one of our children!");\n		}\n\n				addChildAt(newChild, loc);\n		return loc;\n	}
313	public static String getDigestMethodUri(HashAlgorithm digestAlgo) {\n        switch (digestAlgo) {\n        case sha1:   return DigestMethod.SHA1;\n        case sha224: return DigestMethod_SHA224;\n        case sha256: return DigestMethod.SHA256;\n        case sha384: return DigestMethod_SHA384;\n        case sha512: return DigestMethod.SHA512;\n        case ripemd160: return DigestMethod.RIPEMD160;\n        default: throw new EncryptedDocumentException("Hash algorithm "\n            +digestAlgo+" not supported for signing.");\n        }\n    }
314	private BigDecimal parseNumber(NumberBuffer buffer) {\n    BigDecimal sum = BigDecimal.ZERO;\n    BigDecimal result = parseLargePair(buffer);\n\n    if (result == null) {\n      return null;\n    }\n\n    while (result != null) {\n      sum = sum.add(result);\n      result = parseLargePair(buffer);\n    }\n\n    return sum;\n  }
315	public boolean addRow(XWPFTableRow row, int pos) {\n        if (pos >= 0 && pos <= tableRows.size()) {\n            ctTbl.insertNewTr(pos);\n            ctTbl.setTrArray(pos, row.getCtRow());\n            tableRows.add(pos, row);\n            return true;\n        }\n        return false;\n    }
316	protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2,\n                                  Rectangle2D plotArea, Rectangle2D linkArea,\n                                  float maxLabelWidth, PiePlotState state) {\n\n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n        for (int i = 0; i < leftKeys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, leftKeys.getKey(i));\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label,\n                        this.labelFont, this.labelPaint, maxLabelWidth,\n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                if (this.shadowGenerator == null) {\n                    labelBox.setShadowPaint(this.labelShadowPaint);\n                }\n                else {\n                    labelBox.setShadowPaint(null);\n                }\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(\n                        leftKeys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() - Math.sin(theta)\n                               * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        leftKeys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 1.0\n                        - getLabelLinkDepth()\n                        + getExplodePercent(leftKeys.getKey(i))));\n            }\n        }\n        double hh = plotArea.getHeight();\n        double gap = hh * getInteriorGap();\n        this.labelDistributor.distributeLabels(plotArea.getMinY() + gap,\n                hh - 2 * gap);\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawLeftLabel(g2, state,\n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n    }
317	synchronized void maybeThrowDeterministicException() throws IOException {\n    if (failures != null) {\n      for(int i = 0; i < failures.size(); i++) {\n        try {\n          failures.get(i).eval(this);\n        } catch (Throwable t) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println("MockDirectoryWrapper: throw exc");\n            t.printStackTrace(System.out);\n          }\n          throw IOUtils.rethrowAlways(t);\n        }\n      }\n    }\n  }
318	private void capture() {\n    assert liveToken;\n    liveToken = false;\n    BufferedInputToken token = lookahead.get(lookaheadNextWrite);\n    lookaheadNextWrite++;\n\n    token.state = captureState();\n    token.startOffset = offsetAtt.startOffset();\n    token.endOffset = offsetAtt.endOffset();\n    assert token.term.length() == 0;\n    token.term.append(termAtt);\n\n    captureCount++;\n    maxLookaheadUsed = Math.max(maxLookaheadUsed, lookahead.getBufferSize());\n      }
319	protected void drawItemPass1(Graphics2D x_graphics,\n                                 Rectangle2D x_dataArea,\n                                 PlotRenderingInfo x_info,\n                                 XYPlot x_plot,\n                                 ValueAxis x_domainAxis,\n                                 ValueAxis x_rangeAxis,\n                                 XYDataset x_dataset,\n                                 int x_series,\n                                 int x_item,\n                                 CrosshairState x_crosshairState) {\n\n        Shape l_entityArea = null;\n        EntityCollection l_entities = null;\n        if (null != x_info) {\n            l_entities = x_info.getOwner().getEntityCollection();\n        }\n\n        Paint l_seriesPaint   = getItemPaint(x_series, x_item);\n        Stroke l_seriesStroke = getItemStroke(x_series, x_item);\n        x_graphics.setPaint(l_seriesPaint);\n        x_graphics.setStroke(l_seriesStroke);\n\n        PlotOrientation l_orientation      = x_plot.getOrientation();\n        RectangleEdge l_domainAxisLocation = x_plot.getDomainAxisEdge();\n        RectangleEdge l_rangeAxisLocation  = x_plot.getRangeAxisEdge();\n\n        double l_x0 = x_dataset.getXValue(x_series, x_item);\n        double l_y0 = x_dataset.getYValue(x_series, x_item);\n        double l_x1 = x_domainAxis.valueToJava2D(l_x0, x_dataArea,\n                l_domainAxisLocation);\n        double l_y1 = x_rangeAxis.valueToJava2D(l_y0, x_dataArea,\n                l_rangeAxisLocation);\n\n        if (getShapesVisible()) {\n            Shape l_shape = getItemShape(x_series, x_item);\n            if (l_orientation == PlotOrientation.HORIZONTAL) {\n                l_shape = ShapeUtilities.createTranslatedShape(l_shape,\n                        l_y1, l_x1);\n            }\n            else {\n                l_shape = ShapeUtilities.createTranslatedShape(l_shape,\n                        l_x1, l_y1);\n            }\n            if (l_shape.intersects(x_dataArea)) {\n                x_graphics.setPaint(getItemPaint(x_series, x_item));\n                x_graphics.fill(l_shape);\n            }\n            l_entityArea = l_shape;\n        }\n\n                if (null != l_entities) {\n            if (null == l_entityArea) {\n                l_entityArea = new Rectangle2D.Double((l_x1 - 2), (l_y1 - 2),\n                        4, 4);\n            }\n            String l_tip = null;\n            XYToolTipGenerator l_tipGenerator = getToolTipGenerator(x_series,\n                    x_item);\n            if (null != l_tipGenerator) {\n                l_tip = l_tipGenerator.generateToolTip(x_dataset, x_series,\n                        x_item);\n            }\n            String l_url = null;\n            XYURLGenerator l_urlGenerator = getURLGenerator();\n            if (null != l_urlGenerator) {\n                l_url = l_urlGenerator.generateURL(x_dataset, x_series,\n                        x_item);\n            }\n            XYItemEntity l_entity = new XYItemEntity(l_entityArea, x_dataset,\n                    x_series, x_item, l_tip, l_url);\n            l_entities.add(l_entity);\n        }\n\n                if (isItemLabelVisible(x_series, x_item)) {\n            drawItemLabel(x_graphics, l_orientation, x_dataset, x_series,\n                          x_item, l_x1, l_y1, (l_y1 < 0.0));\n        }\n\n        int l_domainAxisIndex = x_plot.getDomainAxisIndex(x_domainAxis);\n        int l_rangeAxisIndex  = x_plot.getRangeAxisIndex(x_rangeAxis);\n        updateCrosshairValues(x_crosshairState, l_x0, l_y0, l_domainAxisIndex,\n                              l_rangeAxisIndex, l_x1, l_y1, l_orientation);\n\n        if (0 == x_item) {\n            return;\n        }\n\n        double l_x2 = x_domainAxis.valueToJava2D(x_dataset.getXValue(x_series,\n                (x_item - 1)), x_dataArea, l_domainAxisLocation);\n        double l_y2 = x_rangeAxis.valueToJava2D(x_dataset.getYValue(x_series,\n                (x_item - 1)), x_dataArea, l_rangeAxisLocation);\n\n        Line2D l_line = null;\n        if (PlotOrientation.HORIZONTAL == l_orientation) {\n            l_line = new Line2D.Double(l_y1, l_x1, l_y2, l_x2);\n        }\n        else if (PlotOrientation.VERTICAL == l_orientation) {\n            l_line = new Line2D.Double(l_x1, l_y1, l_x2, l_y2);\n        }\n\n        if ((null != l_line) && l_line.intersects(x_dataArea)) {\n            x_graphics.setPaint(getItemPaint(x_series, x_item));\n            x_graphics.setStroke(getItemStroke(x_series, x_item));\n            x_graphics.draw(l_line);\n        }\n    }
320	private FacetResult drillDown() throws IOException {\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n            DrillDownQuery q = new DrillDownQuery(config);\n\n        q.add("tags", "solr");\n    FacetsCollector fc = new FacetsCollector();\n    FacetsCollector.search(searcher, q, 10, fc);\n\n        Facets facets = new TaxonomyFacetSumFloatAssociations("$genre", taxoReader, config, fc);\n    FacetResult result = facets.getTopChildren(10, "genre");\n\n    indexReader.close();\n    taxoReader.close();\n    \n    return result;\n  }
321	public void groupColumnRange(int fromColumn, int toColumn, boolean indent) {\n\n                _columnInfos.groupColumnRange( fromColumn, toColumn, indent);\n\n                int maxLevel = _columnInfos.getMaxOutlineLevel();\n\n        GutsRecord guts = getGutsRecord();\n        guts.setColLevelMax( (short) ( maxLevel+1 ) );\n        if (maxLevel == 0) {\n            guts.setTopColGutter( (short)0 );\n        } else {\n            guts.setTopColGutter( (short) ( 29 + (12 * (maxLevel-1)) ) );\n        }\n    }
322	public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n            \n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * inverseScale * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * inverseScale * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  \n    return new GeoPoint(this, φ2, λ2);\n  }
323	public boolean isValidCell(CellReference cellRef) {\n        final DataValidationContext context = getValidationContextForCell(cellRef);\n\n        if (context == null) return true;\n        \n        final Cell cell = SheetUtil.getCell(workbook.getSheet(cellRef.getSheetName()), cellRef.getRow(), cellRef.getCol());\n        \n                \n                if (   cell == null\n            || isType(cell, CellType.BLANK)  \n            || (isType(cell,CellType.STRING) \n                && (cell.getStringCellValue() == null || cell.getStringCellValue().isEmpty())\n               )\n           ) {\n            return context.getValidation().getEmptyCellAllowed();\n        }\n        \n                \n        return ValidationEnum.isValid(cell, context);\n    }
324	protected Query analyzeBoolean(String field, TokenStream stream) throws IOException {\n    TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n    \n    stream.reset();\n    List<Term> terms = new ArrayList<>();\n    while (stream.incrementToken()) {\n      terms.add(new Term(field, termAtt.getBytesRef()));\n    }\n    \n    return newSynonymQuery(terms.toArray(new Term[terms.size()]));\n  }
325	private static String unescapeString(CharSequence text) {\n        int len = text.length();\n        StringBuilder sb = new StringBuilder(len);\n        int i = 0;\n        while (i < len) {\n            char ch = text.charAt(i);\n            if (ch == '\'') {\n                                i++;\n                if (i >= len) {\n                    return null;\n                }\n                ch = text.charAt(i);\n                if (ch != '\'') {\n                    return null;\n                }\n            }\n            sb.append(ch);\n            i++;\n        }\n        return sb.toString();\n    }
326	public void processRecordInternally(Record record) {\n		if (record instanceof FormatRecord) {\n			FormatRecord fr = (FormatRecord) record;\n			_customFormatRecords.put(Integer.valueOf(fr.getIndexCode()), fr);\n		}\n		if (record instanceof ExtendedFormatRecord) {\n			ExtendedFormatRecord xr = (ExtendedFormatRecord) record;\n			_xfRecords.add(xr);\n		}\n	}
327	private static double evaluate(int hours, int minutes, int seconds) throws EvaluationException {\n\n		if (hours > 32767 || minutes > 32767 || seconds > 32767) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		int totalSeconds = hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;\n\n		if (totalSeconds < 0) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		return (totalSeconds % SECONDS_PER_DAY) / (double)SECONDS_PER_DAY;\n	}
328	private void indexDocValue(PerField fp, DocValuesType dvType, IndexableField field) throws IOException {\n\n    if (fp.fieldInfo.getDocValuesType() == DocValuesType.NONE) {\n                        fieldInfos.globalFieldNumbers.setDocValuesType(fp.fieldInfo.number, fp.fieldInfo.name, dvType);\n    }\n    fp.fieldInfo.setDocValuesType(dvType);\n\n    int docID = docState.docID;\n\n    switch(dvType) {\n\n      case NUMERIC:\n        if (fp.docValuesWriter == null) {\n          fp.docValuesWriter = new NumericDocValuesWriter(fp.fieldInfo, bytesUsed);\n        }\n        ((NumericDocValuesWriter) fp.docValuesWriter).addValue(docID, field.numericValue().longValue());\n        break;\n\n      case BINARY:\n        if (fp.docValuesWriter == null) {\n          fp.docValuesWriter = new BinaryDocValuesWriter(fp.fieldInfo, bytesUsed);\n        }\n        ((BinaryDocValuesWriter) fp.docValuesWriter).addValue(docID, field.binaryValue());\n        break;\n\n      case SORTED:\n        if (fp.docValuesWriter == null) {\n          fp.docValuesWriter = new SortedDocValuesWriter(fp.fieldInfo, bytesUsed);\n        }\n        ((SortedDocValuesWriter) fp.docValuesWriter).addValue(docID, field.binaryValue());\n        break;\n        \n      case SORTED_NUMERIC:\n        if (fp.docValuesWriter == null) {\n          fp.docValuesWriter = new SortedNumericDocValuesWriter(fp.fieldInfo, bytesUsed);\n        }\n        ((SortedNumericDocValuesWriter) fp.docValuesWriter).addValue(docID, field.numericValue().longValue());\n        break;\n\n      case SORTED_SET:\n        if (fp.docValuesWriter == null) {\n          fp.docValuesWriter = new SortedSetDocValuesWriter(fp.fieldInfo, bytesUsed);\n        }\n        ((SortedSetDocValuesWriter) fp.docValuesWriter).addValue(docID, field.binaryValue());\n        break;\n\n      default:\n        throw new AssertionError("unrecognized DocValues.Type: " + dvType);\n    }\n  }
329	public static String toFormulaString(FormulaRenderingWorkbook book, Ptg[] ptgs) {\n        if (ptgs == null || ptgs.length == 0) {\n            throw new IllegalArgumentException("ptgs must not be null");\n        }\n        Stack<String> stack = new Stack<>();\n\n        for (Ptg ptg : ptgs) {\n                        if(ptg instanceof MemAreaPtg || ptg instanceof MemFuncPtg || ptg instanceof MemErrPtg) {\n                                                                continue;\n            }\n            if (ptg instanceof ParenthesisPtg) {\n                String contents = stack.pop();\n                stack.push ("(" + contents + ")");\n                continue;\n            }\n            if (ptg instanceof AttrPtg) {\n                AttrPtg attrPtg = ((AttrPtg) ptg);\n                if (attrPtg.isOptimizedIf() || attrPtg.isOptimizedChoose() || attrPtg.isSkip()) {\n                    continue;\n                }\n                if (attrPtg.isSpace()) {\n                                        continue;\n                                                                            }\n                if (attrPtg.isSemiVolatile()) {\n                                        continue;\n                }\n                if (attrPtg.isSum()) {\n                    String[] operands = getOperands(stack, attrPtg.getNumberOfOperands());\n                    stack.push(attrPtg.toFormulaString(operands));\n                    continue;\n                }\n                throw new RuntimeException("Unexpected tAttr: " + attrPtg);\n            }\n\n            if (ptg instanceof WorkbookDependentFormula) {\n                WorkbookDependentFormula optg = (WorkbookDependentFormula) ptg;\n                stack.push(optg.toFormulaString(book));\n                continue;\n            }\n            if (! (ptg instanceof OperationPtg)) {\n                stack.push(ptg.toFormulaString());\n                continue;\n            }\n\n            OperationPtg o = (OperationPtg) ptg;\n            String[] operands = getOperands(stack, o.getNumberOfOperands());\n            stack.push(o.toFormulaString(operands));\n        }\n        if(stack.isEmpty()) {\n                                    throw new IllegalStateException("Stack underflow");\n        }\n        String result = stack.pop();\n        if(!stack.isEmpty()) {\n                                    throw new IllegalStateException("too much stuff left on the stack");\n        }\n        return result;\n    }
330	public GeoPoint[] interpolate(final GeoPoint start, final GeoPoint end, final double[] proportions) {\n                                                                                                                                                                \n        double A = x;\n    double B = y;\n    double C = z;\n\n        final double transX = -D * A;\n    final double transY = -D * B;\n    final double transZ = -D * C;\n\n    double cosRA;\n    double sinRA;\n    double cosHA;\n    double sinHA;\n\n    double magnitude = magnitude();\n    if (magnitude >= MINIMUM_RESOLUTION) {\n      final double denom = 1.0 / magnitude;\n      A *= denom;\n      B *= denom;\n      C *= denom;\n\n                              final double xyMagnitude = Math.sqrt(A * A + B * B);\n      if (xyMagnitude >= MINIMUM_RESOLUTION) {\n        final double xyDenom = 1.0 / xyMagnitude;\n        cosRA = A * xyDenom;\n        sinRA = -B * xyDenom;\n      } else {\n        cosRA = 1.0;\n        sinRA = 0.0;\n      }\n\n                  sinHA = xyMagnitude;\n      cosHA = C;\n    } else {\n      cosRA = 1.0;\n      sinRA = 0.0;\n      cosHA = 1.0;\n      sinHA = 0.0;\n    }\n\n        final Vector modifiedStart = modify(start, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    final Vector modifiedEnd = modify(end, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    if (Math.abs(modifiedStart.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException("Start point was not on plane: " + modifiedStart.z);\n    if (Math.abs(modifiedEnd.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException("End point was not on plane: " + modifiedEnd.z);\n\n        final double startAngle = Math.atan2(modifiedStart.y, modifiedStart.x);\n    final double endAngle = Math.atan2(modifiedEnd.y, modifiedEnd.x);\n\n    final double startMagnitude = Math.sqrt(modifiedStart.x * modifiedStart.x + modifiedStart.y * modifiedStart.y);\n    double delta;\n\n    double newEndAngle = endAngle;\n    while (newEndAngle < startAngle) {\n      newEndAngle += Math.PI * 2.0;\n    }\n\n    if (newEndAngle - startAngle <= Math.PI) {\n      delta = newEndAngle - startAngle;\n    } else {\n      double newStartAngle = startAngle;\n      while (newStartAngle < endAngle) {\n        newStartAngle += Math.PI * 2.0;\n      }\n      delta = newStartAngle - endAngle;\n    }\n\n    final GeoPoint[] returnValues = new GeoPoint[proportions.length];\n    for (int i = 0; i < returnValues.length; i++) {\n      final double newAngle = startAngle + proportions[i] * delta;\n      final double sinNewAngle = Math.sin(newAngle);\n      final double cosNewAngle = Math.cos(newAngle);\n      final Vector newVector = new Vector(cosNewAngle * startMagnitude, sinNewAngle * startMagnitude, 0.0);\n      returnValues[i] = reverseModify(newVector, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    }\n\n    return returnValues;\n  }
331	private void handleExportToPDF() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setSelectedExtensionFilter(new FileChooser.ExtensionFilter(\n                "Portable Document Format (PDF)", "pdf"));\n        fileChooser.setTitle("Export to PDF");\n        File file = fileChooser.showSaveDialog(this.getScene().getWindow());\n        if (file != null) {\n            ExportUtils.writeAsPDF(this.chart, (int) getWidth(), \n                    (int) getHeight(), file);\n        } \n    }
332	public HSSFColor findSimilarColor(int red, int green, int blue) {\n        HSSFColor result = null;\n        int minColorDistance = Integer.MAX_VALUE;\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;\n            b = _palette.getColor(++i))\n        {\n            int colorDistance = Math.abs(red - unsignedInt(b[0])) +\n            	Math.abs(green - unsignedInt(b[1])) +\n            	Math.abs(blue - unsignedInt(b[2]));\n            if (colorDistance < minColorDistance)\n            {\n                minColorDistance = colorDistance;\n                result = getColor(i);\n            }\n        }\n        return result;\n    }
333	public List<EvaluationConditionalFormatRule> getConditionalFormattingForCell(final CellReference cellRef) {\n        List<EvaluationConditionalFormatRule> rules = values.get(cellRef);\n        \n        if (rules == null) {\n                        rules = new ArrayList<>();\n            \n            final Sheet sheet;\n            if (cellRef.getSheetName() != null) {\n                sheet = workbook.getSheet(cellRef.getSheetName());\n            } else {\n                sheet = workbook.getSheetAt(workbook.getActiveSheetIndex());\n            }\n            \n            \n            boolean stopIfTrue = false;\n            for (EvaluationConditionalFormatRule rule : getRules(sheet)) {\n                \n                if (stopIfTrue) {\n                    continue;                 }\n\n                if (rule.matches(cellRef)) {\n                    rules.add(rule);\n                    stopIfTrue = rule.getRule().getStopIfTrue();\n                }\n            }\n            Collections.sort(rules);\n            values.put(cellRef, rules);\n        }\n        \n        return Collections.unmodifiableList(rules);\n    }
334	private void addSharedExternalDependencies() {\n            Map<String,SortedSet<ExternalDependency>> sharedDependencies = new HashMap<>();\n    for (String module : interModuleExternalCompileScopeDependencies.keySet()) {\n      TreeSet<ExternalDependency> deps = new TreeSet<>();\n      sharedDependencies.put(module, deps);\n      Set<String> moduleDependencies = interModuleExternalCompileScopeDependencies.get(module);\n      if (null != moduleDependencies) {\n        for (String otherArtifactId : moduleDependencies) {\n          SortedSet<ExternalDependency> otherExtDeps = allExternalDependencies.get(otherArtifactId); \n          if (null != otherExtDeps) {\n            for (ExternalDependency otherDep : otherExtDeps) {\n              if ( ! otherDep.isTestDependency) {\n                deps.add(otherDep);\n              }\n            }\n          }\n        }\n      }\n    }\n    for (String module : interModuleExternalTestScopeDependencies.keySet()) {\n      SortedSet<ExternalDependency> deps = sharedDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        sharedDependencies.put(module, deps);\n      }\n      Set<String> moduleDependencies = interModuleExternalTestScopeDependencies.get(module);\n      if (null != moduleDependencies) {\n        for (String otherArtifactId : moduleDependencies) {\n          int testScopePos = otherArtifactId.indexOf(":test");\n          boolean isTestScope = false;\n          if (-1 != testScopePos) {\n            otherArtifactId = otherArtifactId.substring(0, testScopePos);\n            isTestScope = true;\n          }\n          SortedSet<ExternalDependency> otherExtDeps = allExternalDependencies.get(otherArtifactId);\n          if (null != otherExtDeps) {\n            for (ExternalDependency otherDep : otherExtDeps) {\n              if (otherDep.isTestDependency == isTestScope) {\n                if (  ! deps.contains(otherDep)\n                   && (  null == allExternalDependencies.get(module)\n                      || ! allExternalDependencies.get(module).contains(otherDep))) {\n                                    ExternalDependency otherDepTestScope = new ExternalDependency\n                      (otherDep.groupId, otherDep.artifactId, otherDep.classifier, true, otherDep.isOptional);\n                  deps.add(otherDepTestScope);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    for (String module : sharedDependencies.keySet()) {\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      for (ExternalDependency dep : sharedDependencies.get(module)) {\n        String dependencyCoordinate = dep.groupId + ":" + dep.artifactId;\n        if (globalOptionalExternalDependencies.contains(dependencyCoordinate)\n            || (perModuleOptionalExternalDependencies.containsKey(module)\n                && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate))) {\n                    dep = new ExternalDependency(dep.groupId, dep.artifactId, dep.classifier, dep.isTestDependency, true);\n        }\n        deps.add(dep);\n      }\n    }\n  }
335	public static Cell createCell(Row row, int column, String value, CellStyle style) {\n        Cell cell = getCell(row, column);\n\n        cell.setCellValue(cell.getRow().getSheet().getWorkbook().getCreationHelper()\n                .createRichTextString(value));\n        if (style != null) {\n            cell.setCellStyle(style);\n        }\n        return cell;\n    }
336	void waitForMerges() throws IOException {\n\n                mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled("IW")) {\n        infoStream.message("IW", "waitForMerges");\n      }\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n            assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled("IW")) {\n        infoStream.message("IW", "waitForMerges done");\n      }\n    }\n  }
337	public static String decodeURI(URI uri) {\n		StringBuilder retVal = new StringBuilder(64);\n		String uriStr = uri.toASCIIString();\n		char c;\n		final int length = uriStr.length();\n		for (int i = 0; i < length; ++i) {\n			c = uriStr.charAt(i);\n			if (c == '%') {\n												if (((length - i) < 2)) {\n					throw new IllegalArgumentException("The uri " + uriStr\n							+ " contain invalid encoded character !");\n				}\n\n								char decodedChar = (char) Integer.parseInt(uriStr.substring(\n						i + 1, i + 3), 16);\n				retVal.append(decodedChar);\n				i += 2;\n				continue;\n			}\n			retVal.append(c);\n		}\n		return retVal.toString();\n	}
338	public GeneralPath draw(Graphics2D g2,\n                            Rectangle2D dataArea,\n                            ValueAxis horizontalAxis, ValueAxis verticalAxis) {\n\n        GeneralPath generalPath = generateClipPath(\n            dataArea, horizontalAxis, verticalAxis\n        );\n        if (this.fillPath || this.drawPath) {\n            Composite saveComposite = g2.getComposite();\n            Paint savePaint = g2.getPaint();\n            Stroke saveStroke = g2.getStroke();\n\n            if (this.fillPaint != null) {\n                g2.setPaint(this.fillPaint);\n            }\n            if (this.composite != null) {\n                g2.setComposite(this.composite);\n            }\n            if (this.fillPath) {\n                g2.fill(generalPath);\n            }\n\n            if (this.drawStroke != null) {\n                g2.setStroke(this.drawStroke);\n            }\n            if (this.drawPath) {\n                g2.draw(generalPath);\n            }\n            g2.setPaint(savePaint);\n            g2.setComposite(saveComposite);\n            g2.setStroke(saveStroke);\n        }\n        return generalPath;\n\n    }
339	protected Query getPrefixQuery(String field, String termStr) throws ParseException\n  {\n    if (!allowLeadingWildcard && termStr.startsWith("*"))\n      throw new ParseException("'*' not allowed as first character in PrefixQuery");\n    BytesRef term = getAnalyzer().normalize(field, termStr);\n    Term t = new Term(field, term);\n    return newPrefixQuery(t);\n  }
340	private void processChunkParseCommands() throws IOException {\n		String line;\n		InputStream cpd = null;\n		BufferedReader inp = null;\n		try {\n	        cpd = ChunkFactory.class.getResourceAsStream(chunkTableName);\n	        if(cpd == null) {\n	            throw new IllegalStateException("Unable to find HDGF chunk definition on the classpath - " + chunkTableName);\n	        }\n\n	        inp = new BufferedReader(new InputStreamReader(cpd, LocaleUtil.CHARSET_1252));\n		    \n		    while( (line = inp.readLine()) != null ) {\n    			if (line.isEmpty() || "# \t".contains(line.substring(0,1))) {\n    			    continue;\n    			}\n    \n    			    			if(!line.matches("^start [0-9]+$")) {\n    				throw new IllegalStateException("Expecting start xxx, found " + line);\n    			}\n    			int chunkType = Integer.parseInt(line.substring(6));\n    			ArrayList<CommandDefinition> defsL = new ArrayList<>();\n    \n    			    			while( (line = inp.readLine()) != null ) {\n    			    if (line.startsWith("end")) {\n    			        break;\n    			    }\n    				StringTokenizer st = new StringTokenizer(line, " ");\n    				int defType = Integer.parseInt(st.nextToken());\n    				int offset = Integer.parseInt(st.nextToken());\n    				String name = st.nextToken("\uffff").substring(1);\n    \n    				CommandDefinition def = new CommandDefinition(defType,offset,name);\n    				defsL.add(def);\n    			}\n    \n    			CommandDefinition[] defs = defsL.toArray(new CommandDefinition[defsL.size()]);\n    \n    			    			chunkCommandDefinitions.put(Integer.valueOf(chunkType), defs);\n    		}\n		} finally {\n    		if (inp != null) {\n    		    inp.close();\n    		}\n    		if (cpd != null) {\n    		    cpd.close();\n    		}\n		}\n	}
341	private void GetChar() {\n                        if (IsWhite(look)) {\n            if (look == ' ') {\n                _inIntersection = true;\n            }\n        }\n        else {\n            _inIntersection = false;\n        }\n        \n                if (_pointer > _formulaLength) {\n            throw new RuntimeException("too far");\n        }\n        if (_pointer < _formulaLength) {\n            look=_formulaString.codePointAt(_pointer);\n        } else {\n                                    look = (char)0;\n            _inIntersection = false;\n        }\n        _pointer += Character.charCount(look);\n            }
342	protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n        ThreadState maxRamUsingThreadState = control.findLargestNonPendingWriter();\n    assert assertMessage("set largest ram consuming thread pending on lower watermark");\n    return maxRamUsingThreadState;\n  }
343	public String getTextAsString() {\n		StringBuffer ret = new StringBuffer();\n		List<String> textV = getTextAsVector();\n		for(String text : textV) {\n			ret.append(text);\n			if(! text.endsWith("\n")) {\n				ret.append('\n');\n			}\n		}\n		return ret.toString();\n	}
344	private static int convert(Automaton.Builder a, State s,\n      IdentityHashMap<State,Integer> visited) {\n\n    Integer converted = visited.get(s);\n    if (converted != null) {\n      return converted;\n    }\n    \n    converted = a.createState();\n    a.setAccept(converted, s.is_final);\n    \n    visited.put(s, converted);\n    int i = 0;\n    int[] labels = s.labels;\n    for (DaciukMihovAutomatonBuilder.State target : s.states) {\n      a.addTransition(converted, convert(a, target, visited), labels[i++]);\n    }\n    \n    return converted;\n  }
345	private static void findConflictsBeneathNode(IvyNodeElement node) {\n        Map<ModuleId,Collection<IvyNodeElement>> moduleRevisionMap = new HashMap<>();\n    IvyNodeElement[] deepDependencies = node.getDeepDependencies();\n    for (int i = 0; i < deepDependencies.length; i++) {\n      if (deepDependencies[i].isEvicted())\n        continue;\n\n      ModuleId moduleId = deepDependencies[i].getModuleRevisionId().getModuleId();\n      if (moduleRevisionMap.containsKey(moduleId)) {\n        Collection<IvyNodeElement> conflicts = moduleRevisionMap.get(moduleId);\n        conflicts.add(deepDependencies[i]);\n        for (Iterator<IvyNodeElement> iter = conflicts.iterator(); iter.hasNext();) {\n          IvyNodeElement conflict = iter.next();\n          conflict.setConflicts(conflicts);\n        }\n      } else {\n        List<IvyNodeElement> immutableMatchingSet = Arrays.asList(deepDependencies[i]);\n        moduleRevisionMap.put(moduleId, new HashSet<>(immutableMatchingSet));\n      }\n    }\n  }
346	private void updateOffsets() {\n        if (this.blockAnchor.equals(RectangleAnchor.BOTTOM_LEFT)) {\n            this.xOffset = 0.0;\n            this.yOffset = 0.0;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.BOTTOM)) {\n            this.xOffset = -this.blockWidth / 2.0;\n            this.yOffset = 0.0;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.BOTTOM_RIGHT)) {\n            this.xOffset = -this.blockWidth;\n            this.yOffset = 0.0;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.LEFT)) {\n            this.xOffset = 0.0;\n            this.yOffset = -this.blockHeight / 2.0;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.CENTER)) {\n            this.xOffset = -this.blockWidth / 2.0;\n            this.yOffset = -this.blockHeight / 2.0;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.RIGHT)) {\n            this.xOffset = -this.blockWidth;\n            this.yOffset = -this.blockHeight / 2.0;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.TOP_LEFT)) {\n            this.xOffset = 0.0;\n            this.yOffset = -this.blockHeight;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.TOP)) {\n            this.xOffset = -this.blockWidth / 2.0;\n            this.yOffset = -this.blockHeight;\n        }\n        else if (this.blockAnchor.equals(RectangleAnchor.TOP_RIGHT)) {\n            this.xOffset = -this.blockWidth;\n            this.yOffset = -this.blockHeight;\n        }\n    }
347	void reset() {\n    position = -1;\n    length = 0;\n    numOverlap = 0;\n    offset = 0;\n    maxTermFrequency = 0;\n    uniqueTermCount = 0;\n    lastStartOffset = 0;\n    lastPosition = 0;\n  }
348	public long next() throws IOException {\n    if (ord == valueCount) {\n      throw new EOFException();\n    }\n    if (off == blockSize) {\n      refill();\n    }\n    final long value = values[off++];\n    ++ord;\n    return value;\n  }
349	public void copy(TextPropCollection other) {\n	    if (other == null) {\n	        throw new HSLFException("trying to copy null TextPropCollection");\n	    }\n	    if (this == other) return;\n        this.charactersCovered = other.charactersCovered;\n        this.indentLevel = other.indentLevel;\n        this.maskSpecial = other.maskSpecial;\n        this.textProps.clear();\n        for (TextProp tp : other.textProps.values()) {\n            TextProp tpCopy = (tp instanceof BitMaskTextProp)\n                ? ((BitMaskTextProp)tp).cloneAll()\n                : tp.clone();\n            addProp(tpCopy);\n        }\n	}
350	private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n            message("top: skip switch to infos: version=" + infos.getVersion() + " is unchanged: " + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message("top: switch to infos=" + infos.toString() + " version=" + infos.getVersion());\n\n        RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n                assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message("top: set copyState primaryGen=" + primaryGen + " version=" + infos.getVersion() + " files=" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }
351	public static SubRecord createSubRecord(LittleEndianInput in, int cmoOt) {\n		int sid = in.readUShort();\n		int secondUShort = in.readUShort(); \n		switch (sid) {\n			case CommonObjectDataSubRecord.sid:\n				return new CommonObjectDataSubRecord(in, secondUShort);\n			case EmbeddedObjectRefSubRecord.sid:\n				return new EmbeddedObjectRefSubRecord(in, secondUShort);\n			case GroupMarkerSubRecord.sid:\n				return new GroupMarkerSubRecord(in, secondUShort);\n			case EndSubRecord.sid:\n				return new EndSubRecord(in, secondUShort);\n			case NoteStructureSubRecord.sid:\n				return new NoteStructureSubRecord(in, secondUShort);\n			case LbsDataSubRecord.sid:\n				return new LbsDataSubRecord(in, secondUShort, cmoOt);\n            case FtCblsSubRecord.sid:\n                return new FtCblsSubRecord(in, secondUShort);\n            case FtPioGrbitSubRecord.sid:\n            	return new FtPioGrbitSubRecord(in, secondUShort);\n            case FtCfSubRecord.sid:\n            	return new FtCfSubRecord(in, secondUShort);\n		}\n		return new UnknownSubRecord(in, sid, secondUShort);\n	}
352	public void processAttachment(AttachmentChunks attachment, \n	      File dir) throws IOException {\n	   String fileName = attachment.getAttachFileName().toString();\n	   if(attachment.getAttachLongFileName() != null) {\n	      fileName = attachment.getAttachLongFileName().toString();\n	   }\n	   \n		File f = new File(dir, fileName);\n		OutputStream fileOut = null;\n		try {\n			fileOut = new FileOutputStream(f);\n			fileOut.write(attachment.getAttachData().getValue());\n		} finally {\n			if(fileOut != null) {\n				fileOut.close();\n			}\n		}\n	}
353	public static boolean marshallRelationshipPart(\n			PackageRelationshipCollection rels, PackagePartName relPartName,\n			ZipArchiveOutputStream zos) {\n				Document xmlOutDoc = DocumentHelper.createDocument();\n						Element root = xmlOutDoc.createElementNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIPS_TAG_NAME);\n        xmlOutDoc.appendChild(root);\n\n										\n		URI sourcePartURI = PackagingURIHelper\n				.getSourcePartUriFromRelationshipPartUri(relPartName.getURI());\n\n		for (PackageRelationship rel : rels) {\n			            Element relElem = xmlOutDoc.createElementNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIP_TAG_NAME);\n            root.appendChild(relElem);\n\n						relElem.setAttribute(PackageRelationship.ID_ATTRIBUTE_NAME, rel.getId());\n\n						relElem.setAttribute(PackageRelationship.TYPE_ATTRIBUTE_NAME, rel.getRelationshipType());\n\n						String targetValue;\n			URI uri = rel.getTargetURI();\n			if (rel.getTargetMode() == TargetMode.EXTERNAL) {\n												targetValue = uri.toString();\n\n								relElem.setAttribute(PackageRelationship.TARGET_MODE_ATTRIBUTE_NAME, "External");\n			} else {\n                URI targetURI = rel.getTargetURI();\n                targetValue = PackagingURIHelper.relativizeURI(\n						sourcePartURI, targetURI, true).toString();\n			}\n			relElem.setAttribute(PackageRelationship.TARGET_ATTRIBUTE_NAME, targetValue);\n		}\n\n		xmlOutDoc.normalize();\n\n				\n				ZipArchiveEntry ctEntry = new ZipArchiveEntry(ZipHelper.getZipURIFromOPCName(\n				relPartName.getURI().toASCIIString()).getPath());\n		try {\n			zos.putArchiveEntry(ctEntry);\n			try {\n				return StreamHelper.saveXmlInStream(xmlOutDoc, zos);\n			} finally {\n				zos.closeArchiveEntry();\n			}\n		} catch (IOException e) {\n			logger.log(POILogger.ERROR,"Cannot create zip entry " + relPartName, e);\n			return false;\n		}\n	}
354	public void write(final byte[] dst, final int offset)\n    throws ArrayStoreException {\n        \n        if (dst.length < LENGTH) {\n            throw new ArrayStoreException\n                ("Destination byte[] must have room for at least 16 bytes, " +\n                 "but has a length of only " + dst.length + ".");\n        }\n        \n        \n        dst[0 + offset] = bytes[3];\n        dst[1 + offset] = bytes[2];\n        dst[2 + offset] = bytes[1];\n        dst[3 + offset] = bytes[0];\n\n        \n        dst[4 + offset] = bytes[5];\n        dst[5 + offset] = bytes[4];\n\n        \n        dst[6 + offset] = bytes[7];\n        dst[7 + offset] = bytes[6];\n\n        \n        System.arraycopy(bytes, 8, dst, 8 + offset, 8);\n    }
355	public void drawDomainLine(Graphics2D g2, XYPlot plot, ValueAxis axis,\n            Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {\n\n        Range range = axis.getRange();\n        if (!range.contains(value)) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        Line2D line = null;\n        double v = axis.valueToJava2D(value, dataArea, \n                plot.getDomainAxisEdge());\n        if (orientation.isHorizontal()) {\n            line = new Line2D.Double(dataArea.getMinX(), v, dataArea.getMaxX(),\n                    v);\n        } else if (orientation.isVertical()) {\n            line = new Line2D.Double(v, dataArea.getMinY(), v,\n                    dataArea.getMaxY());\n        }\n\n        g2.setPaint(paint);\n        g2.setStroke(stroke);\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        g2.draw(line);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }
356	public HSLFFontInfo addFont(FontInfo fontInfo) {\n        HSLFFontInfo fi = getFontInfo(fontInfo.getTypeface());\n        if (fi != null) {\n            return fi;\n        }\n\n        fi = new HSLFFontInfo(fontInfo);\n        fi.setIndex(fonts.size());\n        fonts.put(fi.getTypeface(), fi);\n        \n        FontEntityAtom fnt = fi.createRecord();\n\n                appendChildRecord(fnt);\n\n                return fi;\n    }
357	public void add(long l) throws IOException {\n    checkNotFinished();\n    if (off == values.length) {\n      flush();\n    }\n    values[off++] = l;\n    ++ord;\n  }
358	public Rectangle2D.Double getTextBounds() {\n\n        double txtPinX = _parent.getTxtPinX();\n        double txtPinY = _parent.getTxtPinY();\n\n        double txtLocPinX = _parent.getTxtLocPinX();\n        double txtLocPinY = _parent.getTxtLocPinY();\n\n        double txtWidth = _parent.getTxtWidth();\n        double txtHeight = _parent.getTxtHeight();\n\n        double x = txtPinX - txtLocPinX;\n        double y = txtPinY - txtLocPinY;\n\n        return new Rectangle2D.Double(x, y, txtWidth, txtHeight);\n    }
359	final void callOpenHook(Path path, Closeable stream) throws IOException {\n    boolean success = false;\n    try {\n      onOpen(path, stream);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }
360	protected Query analyzeTerm(String field, TokenStream stream) throws IOException {\n    TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n    \n    stream.reset();\n    if (!stream.incrementToken()) {\n      throw new AssertionError();\n    }\n    \n    return newTermQuery(new Term(field, termAtt.getBytesRef()));\n  }
361	public void drawOutline(Graphics2D g2, Rectangle2D area) {\n        if (!this.outlineVisible) {\n            return;\n        }\n        if ((this.outlineStroke != null) && (this.outlinePaint != null)) {\n            g2.setStroke(this.outlineStroke);\n            g2.setPaint(this.outlinePaint);\n            Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n            g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n            g2.draw(area);\n            g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n        }\n    }
362	protected void onDeleteFormula(XSSFCell cell){\n\n        CTCellFormula f = cell.getCTCell().getF();\n        if (f != null && f.getT() == STCellFormulaType.SHARED && f.isSetRef() && f.getStringValue() != null) {\n\n            CellRangeAddress ref = CellRangeAddress.valueOf(f.getRef());\n            if(ref.getNumberOfCells() > 1){\n                DONE:\n                for(int i = cell.getRowIndex(); i <= ref.getLastRow(); i++){\n                    XSSFRow row = getRow(i);\n                    if(row != null) for(int j = cell.getColumnIndex(); j <= ref.getLastColumn(); j++){\n                        XSSFCell nextCell = row.getCell(j);\n                        if(nextCell != null && nextCell != cell){\n                            CTCellFormula nextF = nextCell.getCTCell().getF();\n                            nextF.setStringValue(nextCell.getCellFormula());\n                            CellRangeAddress nextRef = new CellRangeAddress(\n                                    nextCell.getRowIndex(), ref.getLastRow(),\n                                    nextCell.getColumnIndex(), ref.getLastColumn());\n                            nextF.setRef(nextRef.formatAsString());\n\n                            sharedFormulas.put((int)nextF.getSi(), nextF);\n                            break DONE;\n                        }\n                    }\n                }\n            }\n\n        }\n    }
363	public XWPFEndnote createEndnote() {\n        CTFtnEdn newNote = CTFtnEdn.Factory.newInstance(); \n        newNote.setType(STFtnEdn.NORMAL);\n\n        XWPFEndnote footnote = addEndnote(newNote);\n        footnote.getCTFtnEdn().setId(getIdManager().nextId());\n        return footnote;\n        \n    }
364	public Map<String,String> readMapOfStrings() throws IOException {\n    int count = readVInt();\n    if (count == 0) {\n      return Collections.emptyMap();\n    } else if (count == 1) {\n      return Collections.singletonMap(readString(), readString());\n    } else {\n      Map<String,String> map = count > 10 ? new HashMap<>() : new TreeMap<>();\n      for (int i = 0; i < count; i++) {\n        final String key = readString();\n        final String val = readString();\n        map.put(key, val);\n      }\n      return Collections.unmodifiableMap(map);\n    }\n  }
365	protected final SpanQuery createSpanQuery(TokenStream in, String field) throws IOException {\n    TermToBytesRefAttribute termAtt = in.getAttribute(TermToBytesRefAttribute.class);\n    if (termAtt == null) {\n      return null;\n    }\n\n    List<SpanTermQuery> terms = new ArrayList<>();\n    while (in.incrementToken()) {\n      terms.add(new SpanTermQuery(new Term(field, termAtt.getBytesRef())));\n    }\n\n    if (terms.isEmpty()) {\n      return null;\n    } else if (terms.size() == 1) {\n      return terms.get(0);\n    } else {\n      return new SpanNearQuery(terms.toArray(new SpanTermQuery[0]), 0, true);\n    }\n  }
366	private void compareNumberOfColumnsInSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n            \n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n\n            Iterator<Row> ri1 = loc1.sheet.rowIterator();\n            Iterator<Row> ri2 = loc2.sheet.rowIterator();\n            \n            int num1 = (ri1.hasNext()) ? ri1.next().getPhysicalNumberOfCells() : 0;\n            int num2 = (ri2.hasNext()) ? ri2.next().getPhysicalNumberOfCells() : 0;\n            \n            if (num1 != num2) {\n                String str = String.format(Locale.ROOT, "%s\nworkbook1 -> %s [%d] != workbook2 -> %s [%d]",\n                    "Number Of Columns does not Match ::",\n                    loc1.sheet.getSheetName(), num1,\n                    loc2.sheet.getSheetName(), num2\n                );\n                listOfDifferences.add(str);\n            }\n        }\n    }
367	protected List<LookupResult> createResults(IndexSearcher searcher, TopFieldDocs hits, int num,\n                                             CharSequence charSequence,\n                                             boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    List<LookupResult> results = new ArrayList<>();\n    for (int i=0;i<hits.scoreDocs.length;i++) {\n      FieldDoc fd = (FieldDoc) hits.scoreDocs[i];\n      BinaryDocValues textDV = MultiDocValues.getBinaryValues(searcher.getIndexReader(), TEXT_FIELD_NAME);\n      textDV.advance(fd.doc);\n      BytesRef term = textDV.binaryValue();\n      String text = term.utf8ToString();\n      long score = (Long) fd.fields[0];\n\n                  BinaryDocValues payloadsDV = MultiDocValues.getBinaryValues(searcher.getIndexReader(), "payloads");\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        if (payloadsDV.advance(fd.doc) == fd.doc) {\n          payload = BytesRef.deepCopyOf(payloadsDV.binaryValue());\n        } else {\n          payload = new BytesRef(BytesRef.EMPTY_BYTES);\n        }\n      } else {\n        payload = null;\n      }\n\n            int segment = ReaderUtil.subIndex(fd.doc, leaves);\n      SortedSetDocValues contextsDV = leaves.get(segment).reader().getSortedSetDocValues(CONTEXTS_FIELD_NAME);\n      Set<BytesRef> contexts;\n      if (contextsDV != null) {\n        contexts = new HashSet<BytesRef>();\n        int targetDocID = fd.doc - leaves.get(segment).docBase;\n        if (contextsDV.advance(targetDocID) == targetDocID) {\n          long ord;\n          while ((ord = contextsDV.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n            BytesRef context = BytesRef.deepCopyOf(contextsDV.lookupOrd(ord));\n            contexts.add(context);\n          }\n        }\n      } else {\n        contexts = null;\n      }\n\n      LookupResult result;\n\n      if (doHighlight) {\n        result = new LookupResult(text, highlight(text, matchedTokens, prefixToken), score, payload, contexts);\n      } else {\n        result = new LookupResult(text, score, payload, contexts);\n      }\n\n      results.add(result);\n    }\n\n    return results;\n  }
368	public void cloneStyleFrom(FontRecord source) {\n		field_1_font_height         = source.field_1_font_height;\n		field_2_attributes          = source.field_2_attributes;\n		field_3_color_palette_index = source.field_3_color_palette_index;\n		field_4_bold_weight         = source.field_4_bold_weight;\n		field_5_super_sub_script    = source.field_5_super_sub_script;\n		field_6_underline           = source.field_6_underline;\n		field_7_family              = source.field_7_family;\n		field_8_charset             = source.field_8_charset;\n		field_9_zero                = source.field_9_zero;\n		field_11_font_name          = source.field_11_font_name;\n	}
369	public void addBin(SimpleHistogramBin bin) {\n                Iterator iterator = this.bins.iterator();\n        while (iterator.hasNext()) {\n            SimpleHistogramBin existingBin\n                    = (SimpleHistogramBin) iterator.next();\n            if (bin.overlapsWith(existingBin)) {\n                throw new RuntimeException("Overlapping bin");\n            }\n        }\n        this.bins.add(bin);\n        Collections.sort(this.bins);\n    }
370	private static HashAlgorithm getDigestMethodAlgo(String digestMethodUri) {\n        if (digestMethodUri == null || digestMethodUri.isEmpty()) {\n            return null;\n        }\n        switch (digestMethodUri) {\n            case DigestMethod.SHA1:   return HashAlgorithm.sha1;\n            case DigestMethod_SHA224: return HashAlgorithm.sha224;\n            case DigestMethod.SHA256: return HashAlgorithm.sha256;\n            case DigestMethod_SHA384: return HashAlgorithm.sha384;\n            case DigestMethod.SHA512: return HashAlgorithm.sha512;\n            case DigestMethod.RIPEMD160: return HashAlgorithm.ripemd160;\n            default: throw new EncryptedDocumentException("Hash algorithm "\n                    +digestMethodUri+" not supported for signing.");\n        }\n    }
371	protected void insertBalanced(String[] k, char[] v, int offset, int n) {\n    int m;\n    if (n < 1) {\n      return;\n    }\n    m = n >> 1;\n\n    insert(k[m + offset], v[m + offset]);\n    insertBalanced(k, v, offset, m);\n\n    insertBalanced(k, v, offset + m + 1, n - m - 1);\n  }
372	public synchronized void setMultiValued(String dimName, boolean v) {\n    DimConfig ft = fieldTypes.get(dimName);\n    if (ft == null) {\n      ft = new DimConfig();\n      fieldTypes.put(dimName, ft);\n    }\n    ft.multiValued = v;\n  }
373	private static int getDimensionsIndex(List<RecordBase> records) {\n		int nRecs = records.size();\n		for(int i=0; i<nRecs; i++) {\n			if(records.get(i) instanceof DimensionsRecord) {\n				return i;\n			}\n		}\n				throw new RuntimeException("DimensionsRecord not found");\n	}
374	public List<SegToken> getShortPath() {\n    int current;\n    int nodeCount = getToCount();\n    List<PathNode> path = new ArrayList<>();\n    PathNode zeroPath = new PathNode();\n    zeroPath.weight = 0;\n    zeroPath.preNode = 0;\n    path.add(zeroPath);\n    for (current = 1; current <= nodeCount; current++) {\n      double weight;\n      List<SegTokenPair> edges = getToList(current);\n\n      double minWeight = Double.MAX_VALUE;\n      SegTokenPair minEdge = null;\n      for (SegTokenPair edge : edges) {\n        weight = edge.weight;\n        PathNode preNode = path.get(edge.from);\n        if (preNode.weight + weight < minWeight) {\n          minWeight = preNode.weight + weight;\n          minEdge = edge;\n        }\n      }\n      PathNode newNode = new PathNode();\n      newNode.weight = minWeight;\n      newNode.preNode = minEdge.from;\n      path.add(newNode);\n    }\n\n        int preNode, lastNode;\n    lastNode = path.size() - 1;\n    current = lastNode;\n    List<Integer> rpath = new ArrayList<>();\n    List<SegToken> resultPath = new ArrayList<>();\n\n    rpath.add(current);\n    while (current != 0) {\n      PathNode currentPathNode = path.get(current);\n      preNode = currentPathNode.preNode;\n      rpath.add(Integer.valueOf(preNode));\n      current = preNode;\n    }\n    for (int j = rpath.size() - 1; j >= 0; j--) {\n      Integer idInteger = rpath.get(j);\n      int id = idInteger.intValue();\n      SegToken t = segTokenList.get(id);\n      resultPath.add(t);\n    }\n    return resultPath;\n\n  }
375	private PackageRelationshipCollection getRelationshipsCore(String filter)\n            throws InvalidFormatException {\n        this._container.throwExceptionIfWriteOnly();\n        if (_relationships == null) {\n            this.throwExceptionIfRelationship();\n            _relationships = new PackageRelationshipCollection(this);\n        }\n        return new PackageRelationshipCollection(_relationships, filter);\n    }
376	public static String compress(byte[] data) throws IOException {\n        java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\n        java.util.zip.GZIPOutputStream gz = new java.util.zip.GZIPOutputStream(bos);\n        gz.write(data);\n        gz.finish();\n        return DatatypeConverter.printBase64Binary(bos.toByteArray());        \n    }
377	public XSSFBorderFormatting createBorderFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTBorder border;\n        if(!dxf.isSetBorder()) {\n            border = dxf.addNewBorder();\n        } else {\n            border = dxf.getBorder();\n        }\n\n        return new XSSFBorderFormatting(border, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
378	protected synchronized boolean maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n\n                                                      \n      if (mergeThreads.contains(Thread.currentThread())) {\n                                return false;\n      }\n\n      if (verbose() && startStallTime == 0) {\n        message("    too many merges; stalling...");\n      }\n      startStallTime = System.currentTimeMillis();\n      doStall();\n    }\n\n    if (verbose() && startStallTime != 0) {\n      message("  stalled for " + (System.currentTimeMillis()-startStallTime) + " msec");\n    }\n\n    return true;\n  }
379	public final void removeBreak(int main) {\n        Integer rowKey = Integer.valueOf(main);\n        Break region = _breakMap.get(rowKey);\n        _breaks.remove(region);\n        _breakMap.remove(rowKey);\n    }
380	private ParseNode parseNonRange(int savePointer) {\n        resetPointer(savePointer);\n\n        if (Character.isDigit(look)) {\n            return new ParseNode(parseNumber());\n        }\n        if (look == '"') {\n            return new ParseNode(new StringPtg(parseStringLiteral()));\n        }\n        \n        // from now on we can only be dealing with non-quoted identifiers\n        // which will either be named ranges or functions\n        String name = parseAsName();\n\n        if (look == '(') {\n            return function(name);\n        }\n        if(look == '['){\n            return parseStructuredReference(name);\n        }\n        if (name.equalsIgnoreCase("TRUE") || name.equalsIgnoreCase("FALSE")) {\n            return  new ParseNode(BoolPtg.valueOf(name.equalsIgnoreCase("TRUE")));\n        }\n        if (_book == null) {\n            // Only test cases omit the book (expecting it not to be needed)\n            throw new IllegalStateException("Need book to evaluate name '" + name + "'");\n        }\n        EvaluationName evalName = _book.getName(name, _sheetIndex);\n        if (evalName == null) {\n            throw new FormulaParseException("Specified named range '"\n                    + name + "' does not exist in the current workbook.");\n        }\n        if (evalName.isRange()) {\n            return new ParseNode(evalName.createPtg());\n        }\n        // TODO - what about NameX ?\n        throw new FormulaParseException("Specified name '"\n                + name + "' is not a range as expected.");\n    }
381	public static PostingsEnum getTermPositionsEnum(IndexReader r, String field, BytesRef term, int flags) throws IOException {\n    assert field != null;\n    assert term != null;\n    final Terms terms = getTerms(r, field);\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (termsEnum.seekExact(term)) {\n        return termsEnum.postings(null, flags);\n      }\n    }\n    return null;\n  }
382	protected Query getMultiFieldQuery(List<Query> queries) throws ParseException {\n    if (queries.isEmpty()) {\n      return null;     }\n    BooleanQuery.Builder query = newBooleanQuery();\n    for (Query sub : queries) {\n      query.add(sub, BooleanClause.Occur.SHOULD);\n    }\n    return query.build();\n  }
383	static String writeSpatialArgs(SpatialArgs args) {\n    StringBuilder str = new StringBuilder();\n    str.append(args.getOperation().getName());\n    str.append('(');\n    str.append(args.getShape().toString());\n    if (args.getDistErrPct() != null)\n      str.append(" distErrPct=").append(String.format(Locale.ROOT, "%.2f%%", args.getDistErrPct() * 100d));\n    if (args.getDistErr() != null)\n      str.append(" distErr=").append(args.getDistErr());\n    str.append(')');\n    return str.toString();\n  }
384	public String makeConcise(String result, int form) {\n        if (form > 0) {\n            result = result.replaceAll("XLV", "VL");             result = result.replaceAll("XCV", "VC");             result = result.replaceAll("CDL", "LD");             result = result.replaceAll("CML", "LM");             result = result.replaceAll("CMVC", "LMVL");         }\n        if (form == 1) {\n            result = result.replaceAll("CDXC", "LDXL");             result = result.replaceAll("CDVC", "LDVL");             result = result.replaceAll("CMXC", "LMXL");             result = result.replaceAll("XCIX", "VCIV");             result = result.replaceAll("XLIX", "VLIV");         }\n        if (form > 1) {\n            result = result.replaceAll("XLIX", "IL");             result = result.replaceAll("XCIX", "IC");             result = result.replaceAll("CDXC", "XD");             result = result.replaceAll("CDVC", "XDV");             result = result.replaceAll("CDIC", "XDIX");             result = result.replaceAll("LMVL", "XMV");             result = result.replaceAll("CMIC", "XMIX");             result = result.replaceAll("CMXC", "XM");         }\n        if (form > 2) {\n            result = result.replaceAll("XDV", "VD");              result = result.replaceAll("XDIX", "VDIV");             result = result.replaceAll("XMV", "VM");             result = result.replaceAll("XMIX", "VMIV");         }\n        if (form == 4) {\n            result = result.replaceAll("VDIV", "ID");             result = result.replaceAll("VMIV", "IM");         }\n\n        return result;\n    }
385	public static void rm(Path... locations) throws IOException {\n    LinkedHashMap<Path,Throwable> unremoved = rm(new LinkedHashMap<Path,Throwable>(), locations);\n    if (!unremoved.isEmpty()) {\n      StringBuilder b = new StringBuilder("Could not remove the following files (in the order of attempts):\n");\n      for (Map.Entry<Path,Throwable> kv : unremoved.entrySet()) {\n        b.append("   ")\n         .append(kv.getKey().toAbsolutePath())\n         .append(": ")\n         .append(kv.getValue())\n         .append("\n");\n      }\n      throw new IOException(b.toString());\n    }\n  }
386	protected Size2D arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        double height = constraint.getHeight() / this.rows;\n        RectangleConstraint bc = constraint.toFixedHeight(height);\n        List blocks = container.getBlocks();\n        double maxW = 0.0;\n        for (int r = 0; r < this.rows; r++) {\n            for (int c = 0; c < this.columns; c++) {\n                int index = r * this.columns + c;\n                if (index >= blocks.size()) {\n                    break;\n                }\n                Block b = (Block) blocks.get(index);\n                if (b != null) {\n                    Size2D s = b.arrange(g2, bc);\n                    maxW = Math.max(maxW, s.getWidth());\n                }\n            }\n        }\n        RectangleConstraint cc = constraint.toFixedWidth(maxW * this.columns);\n        return arrange(container, g2, cc);\n    }
387	protected Ellipse2D getWaferEdge(Rectangle2D plotArea) {\n        Ellipse2D edge = new Ellipse2D.Double();\n        double diameter = plotArea.getWidth();\n        double upperLeftX = plotArea.getX();\n        double upperLeftY = plotArea.getY();\n                if (plotArea.getWidth() != plotArea.getHeight()) {\n            double major, minor;\n            if (plotArea.getWidth() > plotArea.getHeight()) {\n                major = plotArea.getWidth();\n                minor = plotArea.getHeight();\n            }\n            else {\n                major = plotArea.getHeight();\n                minor = plotArea.getWidth();\n            }\n                        diameter = minor;\n                        if (plotArea.getWidth() == minor) {                 upperLeftY = plotArea.getY() + (major - minor) / 2;\n            }\n            else {                 upperLeftX = plotArea.getX() + (major - minor) / 2;\n            }\n        }\n        edge.setFrame(upperLeftX, upperLeftY, diameter, diameter);\n        return edge;\n    }
388	private static double round(double value, int nb) {\n        if (nb <= 0) {\n            return Math.floor(value + 0.5d);\n        }\n        double p = Math.pow(10, nb);\n        double tempval = Math.floor(value * p + 0.5d);\n        return tempval / p;\n    }
389	public synchronized void startUpdateThread(long intervalMillis, String threadName) {\n    ensureOpen();\n    if (updateThread != null && updateThread.isAlive()) {\n      throw new IllegalStateException(\n          "cannot start an update thread when one is running, must first call 'stopUpdateThread()'");\n    }\n    threadName = threadName == null ? INFO_STREAM_COMPONENT : "ReplicationThread-" + threadName;\n    updateThread = new ReplicationThread(intervalMillis);\n    updateThread.setName(threadName);\n    updateThread.start();\n        assert updateThread.isAlive() : "updateThread started but not alive?";\n  }
390	public int stem(char s[], int len) {\n    int numVowels = numVowels(s, len);\n    \n    for (int i = 0; i < affixes.length; i++) {\n      Affix affix = affixes[i];\n      if (numVowels > affix.vc && len >= affix.affix.length + 3 && endsWith(s, len, affix.affix)) {\n        len -= affix.affix.length;\n        return affix.palatalizes ? unpalatalize(s, len) : len;\n      }\n    }\n    \n    return len;\n  }
391	public void add(Axis axis, RectangleEdge edge) {\n        ParamChecks.nullNotPermitted(axis, "axis");\n        ParamChecks.nullNotPermitted(edge, "edge");\n        if (edge == RectangleEdge.TOP) {\n            this.axesAtTop.add(axis);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            this.axesAtBottom.add(axis);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            this.axesAtLeft.add(axis);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            this.axesAtRight.add(axis);\n        }\n    }
392	private void makePositionIndex(Set uniqueValues) {\n        int valuesPerColor = (int) Math.ceil(\n            (double) uniqueValues.size() / this.paintLimit\n        );\n        int count = 0;         int paint = 0;\n        for (Iterator i = uniqueValues.iterator(); i.hasNext();) {\n            this.paintIndex.put(i.next(), new Integer(paint));\n            if (++count % valuesPerColor == 0) {\n                paint++;\n            }\n            if (paint > this.paintLimit) {\n                paint = this.paintLimit;\n            }\n        }\n    }
393	public static Plane constructNormalizedZPlane(final Vector... planePoints) {\n        double bestDistance = 0.0;\n    Vector bestPoint = null;\n    for (final Vector point : planePoints) {\n      final double pointDist = point.x * point.x + point.y * point.y;\n      if (pointDist > bestDistance) {\n        bestDistance = pointDist;\n        bestPoint = point;\n      }\n    }\n    return constructNormalizedZPlane(bestPoint.x, bestPoint.y);\n  }
394	private void attemptPaletteSelection() {\n        PaletteChooserPanel panel\n            = new PaletteChooserPanel(null, this.availablePaletteSamples);\n        int result = JOptionPane.showConfirmDialog(\n            this, panel, localizationResources.getString("Palette_Selection"),\n            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE\n        );\n\n        if (result == JOptionPane.OK_OPTION) {\n            double zmin = this.currentPalette.getPalette().getMinZ();\n            double zmax = this.currentPalette.getPalette().getMaxZ();\n            this.currentPalette.setPalette(panel.getSelectedPalette());\n            this.currentPalette.getPalette().setMinZ(zmin);\n            this.currentPalette.getPalette().setMaxZ(zmax);\n        }\n    }
395	public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    if (targetGen > searchingGen) {\n                        reopenLock.lock();\n\n                  waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }
396	public int getNumBorders(CellAddress cell) {\n        Map<String, Object> cellProperties = _propertyTemplate.get(cell);\n        if (cellProperties == null) {\n            return 0;\n        }\n\n        int count = 0;\n        for (String property : cellProperties.keySet()) {\n            if (property.equals(CellUtil.BORDER_TOP))\n                count += 1;\n            if (property.equals(CellUtil.BORDER_BOTTOM))\n                count += 1;\n            if (property.equals(CellUtil.BORDER_LEFT))\n                count += 1;\n            if (property.equals(CellUtil.BORDER_RIGHT))\n                count += 1;\n        }\n        return count;\n    }
397	public synchronized void resetInputs() throws IOException {\n    source.printStatistics("docs");\n        setConfig(config, source);\n    source.resetInputs();\n    numDocsCreated.set(0);\n    resetLeftovers();\n  }
398	public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IOException {\n        if (poifsDir.hasEntry("WordDocument")) {\n                        try {\n                return new WordExtractor(poifsDir);\n            } catch (OldWordFileFormatException e) {\n                return new Word6Extractor(poifsDir);\n            }\n        }\n\n        if (poifsDir.hasEntry(HSLFSlideShow.POWERPOINT_DOCUMENT)) {\n            return new SlideShowExtractor(SlideShowFactory.create(poifsDir));\n        }\n\n        if (poifsDir.hasEntry("VisioDocument")) {\n            return new VisioTextExtractor(poifsDir);\n        }\n\n        if (poifsDir.hasEntry("Quill")) {\n            return new PublisherTextExtractor(poifsDir);\n        }\n\n        final String[] outlookEntryNames = new String[] {\n                                                                                                "__substg1.0_1000001E",                 "__substg1.0_1000001F",                 "__substg1.0_0047001E",                 "__substg1.0_0047001F",                 "__substg1.0_0037001E",                 "__substg1.0_0037001F",         };\n        for (String entryName : outlookEntryNames) {\n            if (poifsDir.hasEntry(entryName)) {\n                return new OutlookTextExtactor(poifsDir);\n            }\n        }\n\n        throw new IllegalArgumentException("No supported documents found in the OLE2 stream");\n    }
399	public CellFormatResult apply(Cell c) {\n        switch (ultimateType(c)) {\n        case BLANK:\n            return apply("");\n        case BOOLEAN:\n            return apply(c.getBooleanCellValue());\n        case NUMERIC:\n            Double value = c.getNumericCellValue();\n            if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                if (DateUtil.isValidExcelDate(value)) {\n                    return apply(c.getDateCellValue(), value);\n                } else {\n                    return apply(INVALID_VALUE_FOR_FORMAT);\n                }\n            } else {\n                return apply(value);\n            }\n        case STRING:\n            return apply(c.getStringCellValue());\n        default:\n            return apply("?");\n        }\n    }
400	public void updateXPoints() {\n        this.propagateEvents = false;\n        for (int s = 0; s < this.data.size(); s++) {\n            updateXPoints((XYSeries) this.data.get(s));\n        }\n        if (this.autoPrune) {\n            prune();\n        }\n        this.propagateEvents = true;\n    }
401	static void sameCell(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue(84);\n        sheet.createRow(1).createCell(0).setCellValue(74);\n        sheet.createRow(2).createCell(0).setCellValue(50);\n        sheet.createRow(3).createCell(0).setCellValue(51);\n        sheet.createRow(4).createCell(0).setCellValue(49);\n        sheet.createRow(5).createCell(0).setCellValue(41);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule(ComparisonOperator.GT, "70");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n                ConditionalFormattingRule rule2 = sheetCF.createConditionalFormattingRule(ComparisonOperator.LT, "50");\n        PatternFormatting fill2 = rule2.createPatternFormatting();\n        fill2.setFillBackgroundColor(IndexedColors.GREEN.index);\n        fill2.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1, rule2);\n\n        sheet.getRow(0).createCell(2).setCellValue("<== Condition 1: Cell Value Is greater than 70 (Blue Fill)");\n        sheet.getRow(4).createCell(2).setCellValue("<== Condition 2: Cell Value Is less than 50 (Green Fill)");\n    }
402	private void updateName(XSSFName name, String oldName, String newName) {\n        String formula = name.getRefersToFormula();\n        if (formula != null) {\n            int sheetIndex = name.getSheetIndex();\n            int rowIndex = -1;             Ptg[] ptgs = FormulaParser.parse(formula, _fpwb, FormulaType.NAMEDRANGE, sheetIndex, rowIndex);\n            for (Ptg ptg : ptgs) {\n                updatePtg(ptg, oldName, newName);\n            }\n            String updatedFormula = FormulaRenderer.toFormulaString(_fpwb, ptgs);\n            if (!formula.equals(updatedFormula)) name.setRefersToFormula(updatedFormula);\n        }\n    }
403	private List<Lock> acquireWriteLocks(Directory... dirs) throws IOException {\n    List<Lock> locks = new ArrayList<>(dirs.length);\n    for(int i=0;i<dirs.length;i++) {\n      boolean success = false;\n      try {\n        Lock lock = dirs[i].obtainLock(WRITE_LOCK_NAME);\n        locks.add(lock);\n        success = true;\n      } finally {\n        if (success == false) {\n                              IOUtils.closeWhileHandlingException(locks);\n        }\n      }\n    }\n    return locks;\n  }
404	public Bounds addXValue(final double x) {\n    final double small = x - FUDGE_FACTOR;\n    if (minX == null || minX > small) {\n      minX = new Double(small);\n    }\n    final double large = x + FUDGE_FACTOR;\n    if (maxX == null || maxX < large) {\n      maxX = new Double(large);\n    }\n    return this;\n  }
405	private void flushUnigram() {\n    clearAttributes();\n    char termBuffer[] = termAtt.resizeBuffer(2);     int len = Character.toChars(buffer[index], termBuffer, 0);\n    termAtt.setLength(len);\n    offsetAtt.setOffset(startOffset[index], endOffset[index]);\n    typeAtt.setType(SINGLE_TYPE);\n    index++;\n  }
406	public void updatePlotProperties(Plot plot) {\n\n                plot.setOutlinePaint(getOutlinePaint());\n        plot.setOutlineStroke(getOutlineStroke());\n        plot.setBackgroundPaint(getBackgroundPaint());\n        plot.setInsets(getPlotInsets());\n\n                if (this.domainAxisPropertyPanel != null) {\n            Axis domainAxis = null;\n            if (plot instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) plot;\n                domainAxis = p.getDomainAxis();\n            }\n            else if (plot instanceof XYPlot) {\n                XYPlot p = (XYPlot) plot;\n                domainAxis = p.getDomainAxis();\n            }\n            if (domainAxis != null) {\n                this.domainAxisPropertyPanel.setAxisProperties(domainAxis);\n            }\n        }\n\n        if (this.rangeAxisPropertyPanel != null) {\n            Axis rangeAxis = null;\n            if (plot instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) plot;\n                rangeAxis = p.getRangeAxis();\n            }\n            else if (plot instanceof XYPlot) {\n                XYPlot p = (XYPlot) plot;\n                rangeAxis = p.getRangeAxis();\n            }\n            else if (plot instanceof PolarPlot) {\n                PolarPlot p = (PolarPlot) plot;\n                rangeAxis = p.getAxis();\n            }\n            if (rangeAxis != null) {\n                this.rangeAxisPropertyPanel.setAxisProperties(rangeAxis);\n            }\n        }\n\n        if (this.plotOrientation != null) {\n            if (plot instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) plot;\n                p.setOrientation(this.plotOrientation);\n            }\n            else if (plot instanceof XYPlot) {\n                XYPlot p = (XYPlot) plot;\n                p.setOrientation(this.plotOrientation);\n            }\n        }\n\n        if (this.drawLines != null) {\n            if (plot instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) plot;\n                CategoryItemRenderer r = p.getRenderer();\n                if (r instanceof LineAndShapeRenderer) {\n                    ((LineAndShapeRenderer) r).setLinesVisible(\n                            this.drawLines.booleanValue());\n                }\n            }\n            else if (plot instanceof XYPlot) {\n                XYPlot p = (XYPlot) plot;\n                XYItemRenderer r = p.getRenderer();\n                if (r instanceof StandardXYItemRenderer) {\n                    ((StandardXYItemRenderer) r).setPlotLines(\n                            this.drawLines.booleanValue());\n                }\n            }\n        }\n\n        if (this.drawShapes != null) {\n            if (plot instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) plot;\n                CategoryItemRenderer r = p.getRenderer();\n                if (r instanceof LineAndShapeRenderer) {\n                    ((LineAndShapeRenderer) r).setShapesVisible(\n                            this.drawShapes.booleanValue());\n                }\n            }\n            else if (plot instanceof XYPlot) {\n                XYPlot p = (XYPlot) plot;\n                XYItemRenderer r = p.getRenderer();\n                if (r instanceof StandardXYItemRenderer) {\n                    ((StandardXYItemRenderer) r).setBaseShapesVisible(\n                        this.drawShapes.booleanValue());\n                }\n            }\n        }\n\n        if (this.colorBarAxisPropertyPanel != null) {\n            ColorBar colorBar = null;\n            if (plot instanceof  ContourPlot) {\n                ContourPlot p = (ContourPlot) plot;\n                colorBar = p.getColorBar();\n            }\n            if (colorBar != null) {\n                this.colorBarAxisPropertyPanel.setAxisProperties(colorBar);\n            }\n        }\n\n    }
407	public synchronized long addDocument(String id, Document doc) throws IOException {\n    assert buffer.getFilePointer() == 0;\n    buffer.writeByte(OP_ADD_DOCUMENT);\n    encode(id, doc);\n    return flushBuffer();\n  }
408	@SuppressWarnings("fallthrough")\n  public static long round(long time, Resolution resolution) {\n    final Calendar calInstance = TL_CAL.get();\n    calInstance.setTimeInMillis(time);\n    \n    switch (resolution) {\n            case YEAR:\n        calInstance.set(Calendar.MONTH, 0);\n      case MONTH:\n        calInstance.set(Calendar.DAY_OF_MONTH, 1);\n      case DAY:\n        calInstance.set(Calendar.HOUR_OF_DAY, 0);\n      case HOUR:\n        calInstance.set(Calendar.MINUTE, 0);\n      case MINUTE:\n        calInstance.set(Calendar.SECOND, 0);\n      case SECOND:\n        calInstance.set(Calendar.MILLISECOND, 0);\n      case MILLISECOND:\n                break;\n      default:\n        throw new IllegalArgumentException("unknown resolution " + resolution);\n    }\n    return calInstance.getTimeInMillis();\n  }
409	protected AxisState drawTickMarksAndLabels(Graphics2D g2,\n            double cursor, Rectangle2D plotArea, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        AxisState state = new AxisState(cursor);\n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n        List ticks = refreshTicks(g2, state, dataArea, edge);\n        state.setTicks(ticks);\n        g2.setFont(getTickLabelFont());\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        Iterator iterator = ticks.iterator();\n        while (iterator.hasNext()) {\n            ValueTick tick = (ValueTick) iterator.next();\n            if (isTickLabelsVisible()) {\n                g2.setPaint(getTickLabelPaint());\n                float[] anchorPoint = calculateAnchorPoint(tick, cursor,\n                        dataArea, edge);\n                if (tick instanceof LogTick) {\n                    LogTick lt = (LogTick) tick;\n                    if (lt.getAttributedLabel() == null) {\n                        continue;\n                    }\n                    AttrStringUtils.drawRotatedString(lt.getAttributedLabel(), \n                            g2, anchorPoint[0], anchorPoint[1], \n                            tick.getTextAnchor(), tick.getAngle(), \n                            tick.getRotationAnchor());\n                } else {\n                    if (tick.getText() == null) {\n                        continue;\n                    }\n                    TextUtilities.drawRotatedString(tick.getText(), g2,\n                            anchorPoint[0], anchorPoint[1], \n                            tick.getTextAnchor(), tick.getAngle(), \n                            tick.getRotationAnchor());\n                }\n            }\n\n            if ((isTickMarksVisible() && tick.getTickType().equals(\n                    TickType.MAJOR)) || (isMinorTickMarksVisible()\n                    && tick.getTickType().equals(TickType.MINOR))) {\n\n                double ol = (tick.getTickType().equals(TickType.MINOR)) \n                        ? getMinorTickMarkOutsideLength()\n                        : getTickMarkOutsideLength();\n\n                double il = (tick.getTickType().equals(TickType.MINOR)) \n                        ? getMinorTickMarkInsideLength()\n                        : getTickMarkInsideLength();\n\n                float xx = (float) valueToJava2D(tick.getValue(), dataArea,\n                        edge);\n                Line2D mark = null;\n                g2.setStroke(getTickMarkStroke());\n                g2.setPaint(getTickMarkPaint());\n                if (edge == RectangleEdge.LEFT) {\n                    mark = new Line2D.Double(cursor - ol, xx, cursor + il, xx);\n                }\n                else if (edge == RectangleEdge.RIGHT) {\n                    mark = new Line2D.Double(cursor + ol, xx, cursor - il, xx);\n                }\n                else if (edge == RectangleEdge.TOP) {\n                    mark = new Line2D.Double(xx, cursor - ol, xx, cursor + il);\n                }\n                else if (edge == RectangleEdge.BOTTOM) {\n                    mark = new Line2D.Double(xx, cursor + ol, xx, cursor - il);\n                }\n                g2.draw(mark);\n            }\n        }\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n        \n                        double used = 0.0;\n        if (isTickLabelsVisible()) {\n            if (edge == RectangleEdge.LEFT) {\n                used += findMaximumTickLabelWidth(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorLeft(used);\n            } else if (edge == RectangleEdge.RIGHT) {\n                used = findMaximumTickLabelWidth(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorRight(used);\n            } else if (edge == RectangleEdge.TOP) {\n                used = findMaximumTickLabelHeight(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorUp(used);\n            } else if (edge == RectangleEdge.BOTTOM) {\n                used = findMaximumTickLabelHeight(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorDown(used);\n            }\n        }\n\n        return state;\n    }
410	public void insertValue(int position, Comparable key, Object value) {\n        if (position < 0 || position > this.data.size()) {\n            throw new IllegalArgumentException("'position' out of bounds.");\n        }\n        ParamChecks.nullNotPermitted(key, "key");\n        int pos = getIndex(key);\n        if (pos >= 0) {\n            this.data.remove(pos);\n        }\n        KeyedObject item = new KeyedObject(key, value);\n        if (position <= this.data.size()) {\n            this.data.add(position, item);\n        }\n        else {\n            this.data.add(item);\n        }\n    }
411	protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }
412	private static int findLastIndexInRunOfEqualValues(LookupValueComparer lookupComparer, ValueVector vector,\n				int firstFoundIndex, int maxIx) {\n		for(int i=firstFoundIndex+1; i<maxIx; i++) {\n			if(!lookupComparer.compareTo(vector.getItem(i)).isEqual()) {\n				return i-1;\n			}\n		}\n		return maxIx - 1;\n	}
413	private void newDrawing(){\n        CTShapeLayout layout = CTShapeLayout.Factory.newInstance();\n        layout.setExt(STExt.EDIT);\n        CTIdMap idmap = layout.addNewIdmap();\n        idmap.setExt(STExt.EDIT);\n        idmap.setData("1");\n        _items.add(layout);\n        _qnames.add(QNAME_SHAPE_LAYOUT);\n\n        CTShapetype shapetype = CTShapetype.Factory.newInstance();\n        _shapeTypeId = COMMENT_SHAPE_TYPE_ID;\n        shapetype.setId(_shapeTypeId);\n        shapetype.setCoordsize("21600,21600");\n        shapetype.setSpt(202);\n        shapetype.setPath2("m,l,21600r21600,l21600,xe");\n        shapetype.addNewStroke().setJoinstyle(STStrokeJoinStyle.MITER);\n        CTPath path = shapetype.addNewPath();\n        path.setGradientshapeok(STTrueFalse.T);\n        path.setConnecttype(STConnectType.RECT);\n        _items.add(shapetype);\n        _qnames.add(QNAME_SHAPE_TYPE);\n    }
414	public static InputStream getDecryptedStream(final DirectoryNode root, String password)\n            throws IOException {\n        EncryptionInfo info = new EncryptionInfo(root);\n        Decryptor d = Decryptor.getInstance(info);\n\n        try {\n            boolean passwordCorrect = false;\n            if (password != null && d.verifyPassword(password)) {\n                passwordCorrect = true;\n            }\n            if (!passwordCorrect && d.verifyPassword(Decryptor.DEFAULT_PASSWORD)) {\n                passwordCorrect = true;\n            }\n\n            if (passwordCorrect) {\n                return d.getDataStream(root);\n            } else if (password != null) {\n                throw new EncryptedDocumentException("Password incorrect");\n            } else {\n                throw new EncryptedDocumentException("The supplied spreadsheet is protected, but no password was supplied");\n            }\n        } catch (GeneralSecurityException e) {\n            throw new IOException(e);\n        }\n    }
415	public void updateCrosshairPoint(double x, double y, int domainAxisIndex,\n            int rangeAxisIndex, double transX, double transY,\n            PlotOrientation orientation) {\n\n        if (this.anchor != null) {\n            double d = 0.0;\n            if (this.calculateDistanceInDataSpace) {\n                d = (x - this.anchorX) * (x - this.anchorX)\n                  + (y - this.anchorY) * (y - this.anchorY);\n            }\n            else {\n                double xx = this.anchor.getX();\n                double yy = this.anchor.getY();\n                if (orientation == PlotOrientation.HORIZONTAL) {\n                    double temp = yy;\n                    yy = xx;\n                    xx = temp;\n                }\n                d = (transX - xx) * (transX - xx)\n                    + (transY - yy) * (transY - yy);\n            }\n\n            if (d < this.distance) {\n                this.crosshairX = x;\n                this.crosshairY = y;\n                this.domainAxisIndex = domainAxisIndex;\n                this.rangeAxisIndex = rangeAxisIndex;\n                this.distance = d;\n            }\n        }\n\n    }
416	public Pointer[] createContainerPointers(Pointer parent, byte[] data) {\n                int numPointersOffset = parent.getNumPointersOffset(data);\n                int numPointers = parent.getNumPointers(numPointersOffset, data);\n                int skip = parent.getPostNumPointersSkip();\n\n                int pos = numPointersOffset + skip;\n        Pointer[] childPointers = new Pointer[numPointers];\n        for(int i=0; i<numPointers; i++) {\n            childPointers[i] = this.createPointer(data, pos);\n            pos += childPointers[i].getSizeInBytes();\n        }\n\n        return childPointers;\n    }
417	public ArrayList<PackagePart> getParts() throws InvalidFormatException {\n		throwExceptionIfWriteOnly();\n\n				if (partList == null) {\n			\n\n								    			boolean hasCorePropertiesPart = false;\n			boolean needCorePropertiesPart = true;\n\n			partList = getPartsImpl();\n			for (PackagePart part : new ArrayList<>(partList.sortedValues())) {\n			    part.loadRelationships();\n\n								if (ContentTypes.CORE_PROPERTIES_PART.equals(part.getContentType())) {\n					if (!hasCorePropertiesPart) {\n						hasCorePropertiesPart = true;\n					} else {\n					   logger.log(POILogger.WARN, "OPC Compliance error [M4.1]: " +\n					   		"there is more than one core properties relationship in the package! " +\n					   		"POI will use only the first, but other software may reject this file.");\n					}\n				}\n\n				PartUnmarshaller partUnmarshaller = partUnmarshallers.get(part._contentType);\n\n				if (partUnmarshaller != null) {\n					UnmarshallContext context = new UnmarshallContext(this, part._partName);\n					try {\n						PackagePart unmarshallPart = partUnmarshaller.unmarshall(context, part.getInputStream());\n						partList.remove(part.getPartName());\n						partList.put(unmarshallPart._partName, unmarshallPart);\n\n																		if (unmarshallPart instanceof PackagePropertiesPart &&\n								hasCorePropertiesPart &&\n								needCorePropertiesPart) {\n							this.packageProperties = (PackagePropertiesPart) unmarshallPart;\n							needCorePropertiesPart = false;\n						}\n					} catch (IOException ioe) {\n						logger.log(POILogger.WARN, "Unmarshall operation : IOException for "\n								+ part._partName);\n						continue;\n					} catch (InvalidOperationException invoe) {\n						throw new InvalidFormatException(invoe.getMessage(), invoe);\n					}\n				}\n			}\n		}\n		return new ArrayList<>(partList.sortedValues());\n	}
418	private boolean collectVersionConflictsToIgnore() {\n    log("Checking for orphans in " + ignoreConflictsFile.getName(), verboseLevel);\n    boolean orphansFound = false;\n    InterpolatedProperties properties = new InterpolatedProperties();\n    try (InputStream inputStream = new FileInputStream(ignoreConflictsFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      properties.load(reader);\n    } catch (IOException e) {\n      throw new BuildException("Exception reading " + ignoreConflictsFile + ": " + e.toString(), e);\n    }\n    for (Object obj : properties.keySet()) {\n      String coordinate = (String)obj;\n      if (COORDINATE_KEY_PATTERN.matcher(coordinate).matches()) {\n        if ( ! directDependencies.containsKey(coordinate)) {\n          orphansFound = true;\n          log("ORPHAN coordinate key '" + coordinate + "' in " + ignoreConflictsFile.getName()\n                  + " is not found in " + centralizedVersionsFile.getName(),\n              Project.MSG_ERR);\n        } else {\n          String versionsToIgnore = properties.getProperty(coordinate);\n          List<String> ignore = Arrays.asList(versionsToIgnore.trim().split("\\s*,\\s*|\\s+"));\n          ignoreConflictVersions.put(coordinate, new HashSet<>(ignore));\n        }\n      }\n    }\n    return ! orphansFound;\n  }
419	public void zoomRange(double lowerPercent, double upperPercent) {\n        double start = this.range.getLowerBound();\n        double length = this.range.getLength();\n        double r0, r1;\n        if (isInverted()) {\n            r0 = start + (length * (1 - upperPercent));\n            r1 = start + (length * (1 - lowerPercent));\n        }\n        else {\n            r0 = start + length * lowerPercent;\n            r1 = start + length * upperPercent;\n        }\n        if ((r1 > r0) && !Double.isInfinite(r1 - r0)) {\n            setRange(new Range(r0, r1));\n        }\n    }
420	protected double trimToContentHeight(double fixedHeight) {\n        double result = this.margin.trimHeight(fixedHeight);\n        result = this.frame.getInsets().trimHeight(result);\n        result = this.padding.trimHeight(result);\n        return Math.max(result, 0.0);\n    }
421	public int stem(char s[], int len) {\n    len = removeCase(s, len);\n    len = removePossessives(s, len);\n    if (len > 0) {\n      len = normalize(s, len);\n    }\n    return len;\n  }
422	private static PackagePart getPartFromOPCPackage(OPCPackage pkg, String coreDocumentRel) {\n        PackageRelationship coreRel = pkg.getRelationshipsByType(coreDocumentRel).getRelationship(0);\n\n        if (coreRel != null) {\n            PackagePart pp = pkg.getPart(coreRel);\n            if (pp == null) {\n                throw new POIXMLException("OOXML file structure broken/invalid - core document '" + coreRel.getTargetURI() + "' not found.");\n            }\n            return pp;\n        }\n\n        coreRel = pkg.getRelationshipsByType(PackageRelationshipTypes.STRICT_CORE_DOCUMENT).getRelationship(0);\n        if (coreRel != null) {\n            throw new POIXMLException("Strict OOXML isn't currently supported, please see bug #57699");\n        }\n\n        throw new POIXMLException("OOXML file structure broken/invalid - no core document found!");\n    }
423	protected void drawTasks(Graphics2D g2,\n                             CategoryItemRendererState state,\n                             Rectangle2D dataArea,\n                             CategoryPlot plot,\n                             CategoryAxis domainAxis,\n                             ValueAxis rangeAxis,\n                             GanttCategoryDataset dataset,\n                             int row,\n                             int column) {\n\n        int count = dataset.getSubIntervalCount(row, column);\n        if (count == 0) {\n            drawTask(g2, state, dataArea, plot, domainAxis, rangeAxis,\n                    dataset, row, column);\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        for (int subinterval = 0; subinterval < count; subinterval++) {\n\n            RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge();\n\n                        Number value0 = dataset.getStartValue(row, column, subinterval);\n            if (value0 == null) {\n                return;\n            }\n            double translatedValue0 = rangeAxis.valueToJava2D(\n                    value0.doubleValue(), dataArea, rangeAxisLocation);\n\n                        Number value1 = dataset.getEndValue(row, column, subinterval);\n            if (value1 == null) {\n                return;\n            }\n            double translatedValue1 = rangeAxis.valueToJava2D(\n                    value1.doubleValue(), dataArea, rangeAxisLocation);\n\n            if (translatedValue1 < translatedValue0) {\n                double temp = translatedValue1;\n                translatedValue1 = translatedValue0;\n                translatedValue0 = temp;\n            }\n\n            double rectStart = calculateBarW0(plot, plot.getOrientation(),\n                    dataArea, domainAxis, state, row, column);\n            double rectLength = Math.abs(translatedValue1 - translatedValue0);\n            double rectBreadth = state.getBarWidth();\n\n                        Rectangle2D bar = null;\n            RectangleEdge barBase = null;\n            if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {\n                bar = new Rectangle2D.Double(translatedValue0, rectStart,\n                        rectLength, rectBreadth);\n                barBase = RectangleEdge.LEFT;\n            }\n            else if (plot.getOrientation() == PlotOrientation.VERTICAL) {\n                bar = new Rectangle2D.Double(rectStart, translatedValue0,\n                        rectBreadth, rectLength);\n                barBase = RectangleEdge.BOTTOM;\n            }\n\n            Rectangle2D completeBar = null;\n            Rectangle2D incompleteBar = null;\n            Number percent = dataset.getPercentComplete(row, column,\n                    subinterval);\n            double start = getStartPercent();\n            double end = getEndPercent();\n            if (percent != null) {\n                double p = percent.doubleValue();\n                if (orientation == PlotOrientation.HORIZONTAL) {\n                    completeBar = new Rectangle2D.Double(translatedValue0,\n                            rectStart + start * rectBreadth, rectLength * p,\n                            rectBreadth * (end - start));\n                    incompleteBar = new Rectangle2D.Double(translatedValue0\n                            + rectLength * p, rectStart + start * rectBreadth,\n                            rectLength * (1 - p), rectBreadth * (end - start));\n                }\n                else if (orientation == PlotOrientation.VERTICAL) {\n                    completeBar = new Rectangle2D.Double(rectStart + start\n                            * rectBreadth, translatedValue0 + rectLength\n                            * (1 - p), rectBreadth * (end - start),\n                            rectLength * p);\n                    incompleteBar = new Rectangle2D.Double(rectStart + start\n                            * rectBreadth, translatedValue0, rectBreadth\n                            * (end - start), rectLength * (1 - p));\n                }\n\n            }\n\n            if (getShadowsVisible()) {\n                getBarPainter().paintBarShadow(g2, this, row, column, bar,\n                        barBase, true);\n            }\n            getBarPainter().paintBar(g2, this, row, column, bar, barBase);\n\n            if (completeBar != null) {\n                g2.setPaint(getCompletePaint());\n                g2.fill(completeBar);\n            }\n            if (incompleteBar != null) {\n                g2.setPaint(getIncompletePaint());\n                g2.fill(incompleteBar);\n            }\n            if (isDrawBarOutline()\n                    && state.getBarWidth() > BAR_OUTLINE_WIDTH_THRESHOLD) {\n                g2.setStroke(getItemStroke(row, column));\n                g2.setPaint(getItemOutlinePaint(row, column));\n                g2.draw(bar);\n            }\n\n            if (subinterval == count - 1) {\n                                int datasetIndex = plot.indexOf(dataset);\n                Comparable columnKey = dataset.getColumnKey(column);\n                Comparable rowKey = dataset.getRowKey(row);\n                double xx = domainAxis.getCategorySeriesMiddle(columnKey,\n                        rowKey, dataset, getItemMargin(), dataArea,\n                        plot.getDomainAxisEdge());\n                updateCrosshairValues(state.getCrosshairState(),\n                        dataset.getRowKey(row), dataset.getColumnKey(column),\n                        value1.doubleValue(), datasetIndex, xx,\n                        translatedValue1, orientation);\n\n            }\n                        if (state.getInfo() != null) {\n                EntityCollection entities = state.getEntityCollection();\n                if (entities != null) {\n                    addItemEntity(entities, dataset, row, column, bar);\n                }\n            }\n        }\n    }
424	Map<BytesRef, Spans> getTermToSpans(LeafReader leafReader, int doc)\n      throws IOException {\n    if (spanQueries.isEmpty()) {\n      return Collections.emptyMap();\n    }\n    final LeafReader filteredReader = new SingleFieldFilterLeafReader(leafReader, fieldName);\n        Map<BytesRef, Spans> result = new HashMap<>();\n    for (SpanQuery spanQuery : spanQueries) {\n      getTermToSpans(spanQuery, filteredReader.getContext(), doc, result);\n    }\n    return result;\n  }
425	public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n        indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager();     refreshReaderManager();\n    nextID = indexWriter.maxDoc();\n    taxoArrays = null;     \n            cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    cacheMisses.set(0);\n    \n        ++indexEpoch;\n  }
426	private int numVowels(char s[], int len) {\n    int n = 0;\n    for (int i = 0; i < len; i++) {\n      switch(s[i]) {\n        case 'a': case 'e': case 'i':  \n        case 'o': case 'u': case 'ā':  \n        case 'ī': case 'ē': case 'ū':\n          n++;\n      }\n    }\n    return n;\n  }
427	private String decodeFlags( int flags )\n    {\n        StringBuffer result = new StringBuffer();\n        result.append( ( flags & FLAG_GROUP ) != 0 ? "|GROUP" : "" );\n        result.append( ( flags & FLAG_CHILD ) != 0 ? "|CHILD" : "" );\n        result.append( ( flags & FLAG_PATRIARCH ) != 0 ? "|PATRIARCH" : "" );\n        result.append( ( flags & FLAG_DELETED ) != 0 ? "|DELETED" : "" );\n        result.append( ( flags & FLAG_OLESHAPE ) != 0 ? "|OLESHAPE" : "" );\n        result.append( ( flags & FLAG_HAVEMASTER ) != 0 ? "|HAVEMASTER" : "" );\n        result.append( ( flags & FLAG_FLIPHORIZ ) != 0 ? "|FLIPHORIZ" : "" );\n        result.append( ( flags & FLAG_FLIPVERT ) != 0 ? "|FLIPVERT" : "" );\n        result.append( ( flags & FLAG_CONNECTOR ) != 0 ? "|CONNECTOR" : "" );\n        result.append( ( flags & FLAG_HAVEANCHOR ) != 0 ? "|HAVEANCHOR" : "" );\n        result.append( ( flags & FLAG_BACKGROUND ) != 0 ? "|BACKGROUND" : "" );\n        result.append( ( flags & FLAG_HASSHAPETYPE ) != 0 ? "|HASSHAPETYPE" : "" );\n\n                if(result.length() > 0) {\n            result.deleteCharAt(0);\n        }\n        return result.toString();\n    }
428	public static byte[][] decompress(byte[] data, int offset, int length) throws IOException {\n		ByteArrayInputStream bais = new ByteArrayInputStream(data, offset, length);\n\n				HDGFLZW lzw = new HDGFLZW();\n		byte[] decompressed = lzw.decompress(bais);\n\n				byte[][] ret = new byte[2][];\n		ret[0] = new byte[4];\n		ret[1] = new byte[decompressed.length - 4];\n\n		System.arraycopy(decompressed, 0, ret[0], 0, 4);\n		System.arraycopy(decompressed, 4, ret[1], 0, ret[1].length);\n\n				return ret;\n	}
429	public synchronized void apply(IndexWriter writer) throws IOException {\n    if (applied.getCount() == 0) {\n            return;\n    }\n\n    long startNS = System.nanoTime();\n\n    assert any();\n\n    Set<SegmentCommitInfo> seenSegments = new HashSet<>();\n\n    int iter = 0;\n    int totalSegmentCount = 0;\n    long totalDelCount = 0;\n\n    boolean finished = false;\n\n                while (true) {\n      String messagePrefix;\n      if (iter == 0) {\n        messagePrefix = "";\n      } else {\n        messagePrefix = "iter " + iter;\n      }\n\n      long iterStartNS = System.nanoTime();\n\n      long mergeGenStart = writer.mergeFinishedGen.get();\n\n      Set<String> delFiles = new HashSet<>();\n      BufferedUpdatesStream.SegmentState[] segStates;\n\n      synchronized (writer) {\n        List<SegmentCommitInfo> infos = getInfosToApply(writer);\n        if (infos == null) {\n          break;\n        }\n\n        for (SegmentCommitInfo info : infos) {\n          delFiles.addAll(info.files());\n        }\n\n                        segStates = writer.bufferedUpdatesStream.openSegmentStates(writer.readerPool, infos, seenSegments, delGen());\n\n        if (segStates.length == 0) {\n\n          if (infoStream.isEnabled("BD")) {\n            infoStream.message("BD", "packet matches no segments");\n          }\n          break;\n        }\n\n        if (infoStream.isEnabled("BD")) {\n          infoStream.message("BD", String.format(Locale.ROOT,\n                                                 messagePrefix + "now apply del packet (%s) to %d segments, mergeGen %d",\n                                                 this, segStates.length, mergeGenStart));\n        }\n\n        totalSegmentCount += segStates.length;\n\n                        writer.deleter.incRef(delFiles);\n      }\n\n      boolean success = false;\n      long delCount;\n      try {\n                delCount = apply(segStates);\n        success = true;\n      } finally {\n        finishApply(writer, segStates, success, delFiles);\n      }\n\n            writer.readerPool.writeSomeDocValuesUpdates();\n\n                  totalDelCount += delCount;\n\n      if (infoStream.isEnabled("BD")) {\n        infoStream.message("BD", String.format(Locale.ROOT,\n                                               messagePrefix + "done inner apply del packet (%s) to %d segments; %d new deletes/updates; took %.3f sec",\n                                               this, segStates.length, delCount, (System.nanoTime() - iterStartNS) / 1000000000.));\n      }\n      \n      if (privateSegment != null) {\n                \n        break;\n      }\n\n                  synchronized (writer) {\n        long mergeGenCur = writer.mergeFinishedGen.get();\n\n        if (mergeGenCur == mergeGenStart) {\n\n                    \n                    writer.bufferedUpdatesStream.finished(this);\n\n          finished = true;\n\n                    break;\n        }\n      }\n\n      if (infoStream.isEnabled("BD")) {\n        infoStream.message("BD", messagePrefix + "concurrent merges finished; move to next iter");\n      }\n        \n            \n      iter++;\n    }\n\n    if (finished == false) {\n            writer.bufferedUpdatesStream.finished(this);\n    }\n        \n    if (infoStream.isEnabled("BD")) {\n      String message = String.format(Locale.ROOT,\n                                     "done apply del packet (%s) to %d segments; %d new deletes/updates; took %.3f sec",\n                                     this, totalSegmentCount, totalDelCount, (System.nanoTime() - startNS) / 1000000000.);\n      if (iter > 0) {\n        message += "; " + (iter+1) + " iters due to concurrent merges";\n      }\n      message += "; " + writer.bufferedUpdatesStream.getPendingUpdatesCount() + " packets remain";\n      infoStream.message("BD", message);\n    }\n  }
430	public static double evaluate(double[] v) throws EvaluationException {\n		if (v.length < 2) {\n			throw new EvaluationException(ErrorEval.NA);\n		}\n\n				int[] counts = new int[v.length];\n		Arrays.fill(counts, 1);\n		for (int i = 0, iSize = v.length; i < iSize; i++) {\n			for (int j = i + 1, jSize = v.length; j < jSize; j++) {\n				if (v[i] == v[j])\n					counts[i]++;\n			}\n		}\n		double maxv = 0;\n		int maxc = 0;\n		for (int i = 0, iSize = counts.length; i < iSize; i++) {\n			if (counts[i] > maxc) {\n				maxv = v[i];\n				maxc = counts[i];\n			}\n		}\n		if (maxc > 1) {\n			return maxv;\n		}\n		throw new EvaluationException(ErrorEval.NA);\n\n	}
431	public void toggleAutoRange() {\n        this.autoRange = this.autoRangeCheckBox.isSelected();\n        if (this.autoRange) {\n            this.minimumRangeValue.setText(Double.toString(this.minimumValue));\n            this.minimumRangeValue.setEnabled(false);\n            this.maximumRangeValue.setText(Double.toString(this.maximumValue));\n            this.maximumRangeValue.setEnabled(false);\n        }\n        else {\n            this.minimumRangeValue.setEnabled(true);\n            this.maximumRangeValue.setEnabled(true);\n        }\n    }
432	public int normalize(char s[], int len) {\n\n    for (int i = 0; i < len; i++) {\n      switch (s[i]) {\n      case ALEF_MADDA:\n      case ALEF_HAMZA_ABOVE:\n      case ALEF_HAMZA_BELOW:\n        s[i] = ALEF;\n        break;\n      case DOTLESS_YEH:\n        s[i] = YEH;\n        break;\n      case TEH_MARBUTA:\n        s[i] = HEH;\n        break;\n      case TATWEEL:\n      case KASRATAN:\n      case DAMMATAN:\n      case FATHATAN:\n      case FATHA:\n      case DAMMA:\n      case KASRA:\n      case SHADDA:\n      case SUKUN:\n        len = delete(s, i, len);\n        i--;\n        break;\n      default:\n        break;\n      }\n    }\n\n    return len;\n  }
433	boolean changeName(final String oldName, final String newName)\n    {\n        boolean   rval  = false;\n        EntryNode child = ( EntryNode ) _byname.get(oldName);\n\n        if (child != null)\n        {\n            rval = (( DirectoryProperty ) getProperty())\n                .changeName(child.getProperty(), newName);\n            if (rval)\n            {\n                _byname.remove(oldName);\n                _byname.put(child.getProperty().getName(), child);\n            }\n        }\n        return rval;\n    }
434	public static SpatialPrefixTree makeSPT(Map<String,String> args, ClassLoader classLoader, SpatialContext ctx) {\n    SpatialPrefixTreeFactory instance;\n    String cname = args.get(PREFIX_TREE);\n    if (cname == null)\n      cname = ctx.isGeo() ? "geohash" : "quad";\n    if ("geohash".equalsIgnoreCase(cname))\n      instance = new GeohashPrefixTree.Factory();\n    else if ("quad".equalsIgnoreCase(cname))\n      instance = new QuadPrefixTree.Factory();\n    else if ("packedQuad".equalsIgnoreCase(cname))\n      instance = new PackedQuadPrefixTree.Factory();\n    else {\n      try {\n        Class<?> c = classLoader.loadClass(cname);\n        instance = (SpatialPrefixTreeFactory) c.newInstance();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    instance.init(args,ctx);\n    return instance.newSPT();\n  }
435	public static NameType classifyCellReference(String str, SpreadsheetVersion ssVersion) {\n        int len = str.length();\n        if (len < 1) {\n            throw new IllegalArgumentException("Empty string not allowed");\n        }\n        char firstChar = str.charAt(0);\n        switch (firstChar) {\n            case ABSOLUTE_REFERENCE_MARKER:\n            case '.':\n            case '_':\n                break;\n            default:\n                if (!Character.isLetter(firstChar) && !Character.isDigit(firstChar)) {\n                    throw new IllegalArgumentException("Invalid first char (" + firstChar\n                            + ") of cell reference or named range.  Letter expected");\n                }\n        }\n        if (!Character.isDigit(str.charAt(len-1))) {\n                        return validateNamedRangeName(str, ssVersion);\n        }\n        Matcher cellRefPatternMatcher = STRICTLY_CELL_REF_PATTERN.matcher(str);\n        if (!cellRefPatternMatcher.matches()) {\n            return validateNamedRangeName(str, ssVersion);\n        }\n        String lettersGroup = cellRefPatternMatcher.group(1);\n        String digitsGroup = cellRefPatternMatcher.group(2);\n        if (cellReferenceIsWithinRange(lettersGroup, digitsGroup, ssVersion)) {\n                        return NameType.CELL;\n        }\n                                                if (str.indexOf(ABSOLUTE_REFERENCE_MARKER) >= 0) {\n                        return NameType.BAD_CELL_OR_NAMED_RANGE;\n        }\n        return NameType.NAMED_RANGE;\n    }
436	public void newDocumentLink() {\n        _range = new CellRangeAddress(0, 0, 0, 0);\n        _guid = STD_MONIKER;\n        _linkOpts = HLINK_LABEL | HLINK_PLACE;\n        setLabel("");\n        _moniker = FILE_MONIKER;\n        setAddress("");\n        setTextMark("");\n    }
437	public void newUrlLink() {\n        _range = new CellRangeAddress(0, 0, 0, 0);\n        _guid = STD_MONIKER;\n        _linkOpts = HLINK_URL | HLINK_ABS | HLINK_LABEL;\n        setLabel("");\n        _moniker = URL_MONIKER;\n        setAddress("");\n        _uninterpretedTail = URL_TAIL;\n    }
438	public static long skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);\n        }\n        if (toSkip == 0) {\n            return 0L;\n        }\n        \n        if (SKIP_BYTE_BUFFER == null) {\n            SKIP_BYTE_BUFFER = new byte[SKIP_BUFFER_SIZE];\n        }\n        long remain = toSkip;\n        while (remain > 0) {\n                        final long n = input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));\n            if (n < 0) {                 break;\n            }\n            remain -= n;\n        }\n        if (toSkip == remain) {\n            return -1L;\n        }\n        return toSkip - remain;\n    }
439	private double convertOoxml2AwtAngle(double ooAngle, double width, double height) {\n        double aspect = (height / width);\n                double awtAngle = -ooAngle;\n                double awtAngle2 = awtAngle%360.;\n        double awtAngle3 = awtAngle-awtAngle2;\n                        switch ((int)(awtAngle2 / 90)) {\n            case -3:\n                                awtAngle3 -= 360;\n                awtAngle2 += 360;\n                break;\n            case -2:\n            case -1:\n                                awtAngle3 -= 180;\n                awtAngle2 += 180;\n                break;\n            default:\n            case 0:\n                                break;\n            case 2:\n            case 1:\n                                awtAngle3 += 180;\n                awtAngle2 -= 180;\n                break;\n            case 3:\n                                awtAngle3 += 360;\n                awtAngle2 -= 360;\n                break;\n        }\n\n                awtAngle = Math.toDegrees(Math.atan2(Math.tan(Math.toRadians(awtAngle2)), aspect)) + awtAngle3;\n        return awtAngle;\n    }
440	public void validateAngleOffset() {\n        double newOffset;\n        try {\n            newOffset = Double.parseDouble(this.angleOffset.getText());\n        }\n        catch (NumberFormatException e) {\n            newOffset = this.angleOffsetValue;\n        }\n        this.angleOffsetValue = newOffset;\n        this.angleOffset.setText(Double.toString(this.angleOffsetValue));\n    }
441	public void addEpsilon(int source, int dest) {\n    Transition t = new Transition();\n    int count = initTransition(dest, t);\n    for(int i=0;i<count;i++) {\n      getNextTransition(t);\n      addTransition(source, t.dest, t.min, t.max);\n    }\n    if (isAccept(dest)) {\n      setAccept(source, true);\n    }\n  }
442	public void processRecords(InputStream in) throws RecordFormatException {\n		Record last_record = null;\n\n		RecordInputStream recStream = new RecordInputStream(in);\n\n		while (recStream.hasNextRecord()) {\n			recStream.nextRecord();\n			Record[] recs = RecordFactory.createRecord(recStream);   			if (recs.length > 1) {\n				for (Record rec : recs) {\n					if ( last_record != null ) {\n						if (!processRecord(last_record)) {\n							return;\n						}\n					}\n					last_record = rec; 				}										} else {\n				Record record = recs[ 0 ];\n\n				if (record != null) {\n					if (last_record != null) {\n						if (!processRecord(last_record)) {\n							return;\n						}\n					}\n					 last_record = record;\n				}\n			}\n		}\n\n		if (last_record != null) {\n			processRecord(last_record);\n		}\n	}
443	protected GeoPoint[] findIntersections(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n            final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n                  return NO_POINTS;\n    }\n\n                                                                                double x0;\n    double y0;\n    double z0;\n        final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n            if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n            if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n            if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n                return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n                                final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n            final double inverse2A = 1.0 / (2.0 * A);\n            final double t = -B * inverse2A;\n            final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return NO_POINTS;\n        }\n      }\n      for (final Membership bound : moreBounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return NO_POINTS;\n        }\n      }\n      return new GeoPoint[]{new GeoPoint(pointX, pointY, pointZ)};\n    } else if (BsquaredMinus > 0.0) {\n            final double inverse2A = 1.0 / (2.0 * A);\n            final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n            final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n            return NO_POINTS;\n    }\n  }
444	public void paint(Graphics2D g) {\n        g.setBackground(Color.CYAN);\n        AffineTransform origTransform = g.getTransform();\n        for (Painting c : paintings) {\n            c.draw(g);\n        }\n        g.setTransform(origTransform);\n\n        clear();\n    }
445	private Ptg columnCopyAreaPtg(AreaPtgBase aptg) {\n        boolean changed = false;\n\n        final int aFirstColumn = aptg.getFirstColumn();\n        final int aLastColumn = aptg.getLastColumn();\n\n        if (aptg.isFirstColRelative()) {\n            final int destFirstColumnIndex = aFirstColumn + _amountToMove;\n            if (destFirstColumnIndex < 0 || _version.getLastColumnIndex() < destFirstColumnIndex)\n                return createDeletedRef(aptg);\n            aptg.setFirstColumn(destFirstColumnIndex);\n            changed = true;\n        }\n        if (aptg.isLastColRelative()) {\n            final int destLastColumnIndex = aLastColumn + _amountToMove;\n            if (destLastColumnIndex < 0 || _version.getLastColumnIndex() < destLastColumnIndex)\n                return createDeletedRef(aptg);\n            aptg.setLastColumn(destLastColumnIndex);\n            changed = true;\n        }\n        if (changed) {\n            aptg.sortTopLeftToBottomRight();\n        }\n\n        return changed ? aptg : null;\n    }
446	public double getSpaceBefore(){\n        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){\n            public boolean fetch(CTTextParagraphProperties props){\n                if(props.isSetSpcBef()){\n                    CTTextSpacing spc = props.getSpcBef();\n\n                    if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );\n                    else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );\n                    return true;\n                }\n                return false;\n            }\n        };\n        fetchParagraphProperty(fetcher);\n\n        return fetcher.getValue() == null ? 0 : fetcher.getValue();\n    }
447	public void zoomInRange(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n                                                boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomRangeAxes(this.zoomInFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }
448	protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }
449	public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n            return a;\n    }\n    if (a.getNumStates() <= 1) {\n            return a;\n    }\n\n        Automaton.Builder b = new Automaton.Builder();\n\n        \n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n        b.createState();\n\n    ArrayDeque<SortedIntSet.FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n        final PointTransitionSet points = new PointTransitionSet();\n\n        final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      \n            for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n                continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n                        worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): "accCount=" + accCount + " vs existing accept=" +\n              b.isAccept(q) + " states=" + statesSet;\n          }\n\n          \n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n                        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n                        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: "upto=" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }
450	public void updateHeaders() {\n        XSSFSheet sheet = (XSSFSheet)getParent();\n        CellReference ref = getStartCellReference();\n        if (ref == null) return;\n\n        int headerRow = ref.getRow();\n        int firstHeaderColumn = ref.getCol();\n        XSSFRow row = sheet.getRow(headerRow);\n        DataFormatter formatter = new DataFormatter();\n\n        if (row != null && row.getCTRow().validate()) {\n            int cellnum = firstHeaderColumn;\n            CTTableColumns ctTableColumns = getCTTable().getTableColumns();\n            if(ctTableColumns != null) {\n                for (CTTableColumn col : ctTableColumns.getTableColumnList()) {\n                    XSSFCell cell = row.getCell(cellnum);\n                    if (cell != null) {\n                        col.setName(formatter.formatCellValue(cell));\n                    }\n                    cellnum++;\n                }\n            }\n        }\n        tableColumns = null;\n        columnMap = null;\n        xmlColumnPrs = null;\n        commonXPath = null;\n    }
451	private String readLogicalPropertiesLine(BufferedReader reader) throws IOException {\n    final StringBuilder logicalLine = new StringBuilder();\n    String line;\n    do {\n      line = reader.readLine();\n      if (null == line) { \n        return null;\n      }\n    } while (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches());\n\n    Matcher backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line); \n        if (backslashMatcher.find() && 1 == (backslashMatcher.group(1).length() % 2)) {\n      final Matcher firstLineMatcher = TRAILING_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n      if (firstLineMatcher.matches()) {\n        logicalLine.append(firstLineMatcher.group(1));       }\n      line = reader.readLine();\n      while (null != line\n             && (backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line)).find()\n             && 1 == (backslashMatcher.group(1).length() % 2)) {\n                final Matcher goodStuffMatcher = WHITESPACE_GOODSTUFF_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n        if (goodStuffMatcher.matches()) {\n          logicalLine.append(goodStuffMatcher.group(1));\n        }\n        line = reader.readLine();\n      }\n      if (null != line) {\n                final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(line);\n        if (leadingWhitespaceMatcher.matches()) {\n          line = leadingWhitespaceMatcher.group(1);         }\n        logicalLine.append(line);\n      }\n    } else {\n      logicalLine.append(line);\n    }\n        final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(logicalLine);\n    final CharSequence leadingWhitespaceStripped = leadingWhitespaceMatcher.matches()\n                                                 ? leadingWhitespaceMatcher.group(1)\n                                                 : logicalLine;\n\n        StringBuilder output = new StringBuilder();\n    final int numChars = leadingWhitespaceStripped.length();\n    for (int pos = 0 ; pos < numChars - 1 ; ++pos) {\n      char ch = leadingWhitespaceStripped.charAt(pos);\n      if (ch == '\\') {\n        ch = leadingWhitespaceStripped.charAt(++pos);\n      }\n      output.append(ch);\n    }\n    if (numChars > 0) {\n      output.append(leadingWhitespaceStripped.charAt(numChars - 1));\n    }\n\n    return output.toString();\n  }
452	public  QualityStats [] execute(Judge judge, SubmissionReport submitRep, \n                                  PrintWriter qualityLog) throws Exception {\n    int nQueries = Math.min(maxQueries, qualityQueries.length);\n    QualityStats stats[] = new QualityStats[nQueries]; \n    for (int i=0; i<nQueries; i++) {\n      QualityQuery qq = qualityQueries[i];\n            Query q = qqParser.parse(qq);\n            long t1 = System.currentTimeMillis();\n      TopDocs td = searcher.search(q,maxResults);\n      long searchTime = System.currentTimeMillis()-t1;\n            if (judge!=null) {\n        stats[i] = analyzeQueryResults(qq, q, td, judge, qualityLog, searchTime);\n      }\n      if (submitRep!=null) {\n        submitRep.report(qq,td,docNameField,searcher);\n      }\n    } \n    if (submitRep!=null) {\n      submitRep.flush();\n    }\n    return stats;\n  }
453	protected AxisSpace calculateAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }
454	private FieldInfos initFieldInfos() throws IOException {\n    if (!si.hasFieldUpdates()) {\n      return core.coreFieldInfos;\n    } else {\n            FieldInfosFormat fisFormat = si.info.getCodec().fieldInfosFormat();\n      final String segmentSuffix = Long.toString(si.getFieldInfosGen(), Character.MAX_RADIX);\n      return fisFormat.read(si.info.dir, si.info, segmentSuffix, IOContext.READONCE);\n    }\n  }
455	public static Calendar parseDate(String strVal) throws EvaluationException {\n        String[] parts = Pattern.compile("/").split(strVal);\n        if (parts.length != 3) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        String part2 = parts[2];\n        int spacePos = part2.indexOf(' ');\n        if (spacePos > 0) {\n                        part2 = part2.substring(0, spacePos);\n        }\n        int f0;\n        int f1;\n        int f2;\n        try {\n            f0 = Integer.parseInt(parts[0]);\n            f1 = Integer.parseInt(parts[1]);\n            f2 = Integer.parseInt(part2);\n        } catch (NumberFormatException e) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        if (f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)) {\n                        throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n\n        if (f0 >= 1900 && f0 < 9999) {\n                        return makeDate(f0, f1, f2);\n        }\n                        throw new RuntimeException("Unable to determine date format for text '" + strVal + "'");\n    }
456	@Internal\n    public XWPFEndnote addEndnote(CTFtnEdn note) {\n        CTFtnEdn newNote = ctEndnotes.addNewEndnote();\n        newNote.set(note);\n        XWPFEndnote xNote = new XWPFEndnote(newNote, this);\n        listFootnote.add(xNote);\n        return xNote;\n    }
457	public synchronized void setHierarchical(String dimName, boolean v) {\n    DimConfig ft = fieldTypes.get(dimName);\n    if (ft == null) {\n      ft = new DimConfig();\n      fieldTypes.put(dimName, ft);\n    }\n    ft.hierarchical = v;\n  }
458	private static void applyAttributes(CTRPrElt pr, CTTextCharacterProperties rPr) {\n\n        if (pr.sizeOfBArray() > 0) {\n            rPr.setB(pr.getBArray(0).getVal());\n        }\n        if (pr.sizeOfUArray() > 0) {\n            STUnderlineValues.Enum u1 = pr.getUArray(0).getVal();\n            if (u1 == STUnderlineValues.SINGLE) {\n                rPr.setU(STTextUnderlineType.SNG);\n            } else if (u1 == STUnderlineValues.DOUBLE) {\n                rPr.setU(STTextUnderlineType.DBL);\n            } else if (u1 == STUnderlineValues.NONE) {\n                rPr.setU(STTextUnderlineType.NONE);\n            }\n        }\n        if (pr.sizeOfIArray() > 0) {\n            rPr.setI(pr.getIArray(0).getVal());\n        }\n\n        if (pr.sizeOfRFontArray() > 0) {\n            CTTextFont rFont = rPr.isSetLatin() ? rPr.getLatin() : rPr.addNewLatin();\n            rFont.setTypeface(pr.getRFontArray(0).getVal());\n        }\n\n        if (pr.sizeOfSzArray() > 0) {\n            int sz = (int) (pr.getSzArray(0).getVal() * 100);\n            rPr.setSz(sz);\n        }\n\n        if (pr.sizeOfColorArray() > 0) {\n            CTSolidColorFillProperties fill = rPr.isSetSolidFill() ? rPr.getSolidFill() : rPr.addNewSolidFill();\n            org.openxmlformats.schemas.spreadsheetml.x2006.main.CTColor xlsColor = pr.getColorArray(0);\n            if (xlsColor.isSetRgb()) {\n                CTSRgbColor clr = fill.isSetSrgbClr() ? fill.getSrgbClr() : fill.addNewSrgbClr();\n                clr.setVal(xlsColor.getRgb());\n            } else if (xlsColor.isSetIndexed()) {\n                HSSFColor indexed = HSSFColor.getIndexHash().get((int) xlsColor.getIndexed());\n                if (indexed != null) {\n                    byte[] rgb = new byte[3];\n                    rgb[0] = (byte) indexed.getTriplet()[0];\n                    rgb[1] = (byte) indexed.getTriplet()[1];\n                    rgb[2] = (byte) indexed.getTriplet()[2];\n                    CTSRgbColor clr = fill.isSetSrgbClr() ? fill.getSrgbClr() : fill.addNewSrgbClr();\n                    clr.setVal(rgb);\n                }\n            }\n        }\n    }
459	protected synchronized void maybeNewPrimary(long newPrimaryGen) throws IOException {\n    if (newPrimaryGen != lastPrimaryGen) {\n      message("top: now change lastPrimaryGen from " + lastPrimaryGen + " to " + newPrimaryGen + " pendingMergeFiles=" + pendingMergeFiles);\n\n      message("top: delete if no ref pendingMergeFiles=" + pendingMergeFiles);\n      for(String fileName : pendingMergeFiles) {\n        deleter.deleteIfNoRef(fileName);\n      }\n\n      assert newPrimaryGen > lastPrimaryGen: "newPrimaryGen=" + newPrimaryGen + " vs lastPrimaryGen=" + lastPrimaryGen;\n      lastPrimaryGen = newPrimaryGen;\n      pendingMergeFiles.clear();\n    } else {\n      message("top: keep current lastPrimaryGen=" + lastPrimaryGen);\n    }\n  }
460	public void setBorderTop(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        if (ct == null) {\n            throw new RuntimeException("invalid paragraph state");\n        }\n\n        CTBorder pr = (ct.isSetTop()) ? ct.getTop() : ct.addNewTop();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetTop();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
461	final synchronized void mergeFinish(MergePolicy.OneMerge merge) {\n\n            notifyAll();\n\n            if (merge.registerDone) {\n      final List<SegmentCommitInfo> sourceSegments = merge.segments;\n      for (SegmentCommitInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }
462	private void validateSheetIndex(int index) {\n        int lastSheetIx = sheets.size() - 1;\n        if (index < 0 || index > lastSheetIx) {\n            String range = "(0.." +    lastSheetIx + ")";\n            if (lastSheetIx == -1) {\n                range = "(no sheets)";\n            }\n            throw new IllegalArgumentException("Sheet index ("\n                    + index +") is out of range " + range);\n        }\n    }
463	public void addTransition(int source, int dest, int min, int max) {\n    assert nextTransition%3 == 0;\n\n    if (source >= nextState/2) {\n      throw new IllegalArgumentException("source=" + source + " is out of bounds (maxState is " + (nextState/2-1) + ")");\n    }\n    if (dest >= nextState/2) {\n      throw new IllegalArgumentException("dest=" + dest + " is out of bounds (max state is " + (nextState/2-1) + ")");\n    }\n\n    growTransitions();\n    if (curState != source) {\n      if (curState != -1) {\n        finishCurrentState();\n      }\n\n            curState = source;\n      if (states[2*curState] != -1) {\n        throw new IllegalStateException("from state (" + source + ") already had transitions added");\n      }\n      assert states[2*curState+1] == 0;\n      states[2*curState] = nextTransition;\n    }\n\n    transitions[nextTransition++] = dest;\n    transitions[nextTransition++] = min;\n    transitions[nextTransition++] = max;\n\n        states[2*curState+1]++;\n  }
464	static void addVmOpt(StringBuilder b, String key, Object value) {\n    if (value == null) return;\n\n    b.append(" -D").append(key).append("=");\n    String v = value.toString();\n            if (Pattern.compile("[\\s=']").matcher(v).find()) {\n      v = '"' + v + '"';\n    }\n    b.append(v);\n  }
465	public void debug() {\n		System.err.println("Trailer is at " + trailerPointer.getOffset());\n		System.err.println("Trailer has type " + trailerPointer.getType());\n		System.err.println("Trailer has length " + trailerPointer.getLength());\n		System.err.println("Trailer has format " + trailerPointer.getFormat());\n\n		for(int i=0; i<trailer.getPointedToStreams().length; i++) {\n			Stream stream = trailer.getPointedToStreams()[i];\n			Pointer ptr = stream.getPointer();\n\n			System.err.println("Looking at pointer " + i);\n			System.err.println("\tType is " + ptr.getType() + "\t\t" + Integer.toHexString(ptr.getType()));\n			System.err.println("\tOffset is " + ptr.getOffset() + "\t\t" + Long.toHexString(ptr.getOffset()));\n			System.err.println("\tAddress is " + ptr.getAddress() + "\t" + Long.toHexString(ptr.getAddress()));\n			System.err.println("\tLength is " + ptr.getLength() + "\t\t" + Long.toHexString(ptr.getLength()));\n			System.err.println("\tFormat is " + ptr.getFormat() + "\t\t" + Long.toHexString(ptr.getFormat()));\n			System.err.println("\tCompressed is " + ptr.destinationCompressed());\n			System.err.println("\tStream is " + stream.getClass());\n\n			if(stream instanceof PointerContainingStream) {\n				PointerContainingStream pcs = (PointerContainingStream)stream;\n\n				if(pcs.getPointedToStreams() != null && pcs.getPointedToStreams().length > 0) {\n					System.err.println("\tContains " + pcs.getPointedToStreams().length + " other pointers/streams");\n					for(int j=0; j<pcs.getPointedToStreams().length; j++) {\n						Stream ss = pcs.getPointedToStreams()[j];\n						Pointer sptr = ss.getPointer();\n						System.err.println("\t\t" + j + " - Type is " + sptr.getType() + "\t\t" + Integer.toHexString(sptr.getType()));\n						System.err.println("\t\t" + j + " - Length is " + sptr.getLength() + "\t\t" + Long.toHexString(sptr.getLength()));\n					}\n				}\n			}\n\n			if(stream instanceof StringsStream) {\n				System.err.println("\t\t**strings**");\n				StringsStream ss = (StringsStream)stream;\n				System.err.println("\t\t" + ss._getContentsLength());\n			}\n		}\n	}
466	public long writeSkip(IndexOutput output) throws IOException {\n    long skipPointer = output.getFilePointer();\n        if (skipBuffer == null || skipBuffer.length == 0) return skipPointer;\n    \n    for (int level = numberOfSkipLevels - 1; level > 0; level--) {\n      long length = skipBuffer[level].getFilePointer();\n      if (length > 0) {\n        output.writeVLong(length);\n        skipBuffer[level].writeTo(output);\n      }\n    }\n    skipBuffer[0].writeTo(output);\n    \n    return skipPointer;\n  }
467	public static Mutable getMutable(int valueCount,\n      int bitsPerValue, PackedInts.Format format) {\n    assert valueCount >= 0;\n    switch (format) {\n      case PACKED_SINGLE_BLOCK:\n        return Packed64SingleBlock.create(valueCount, bitsPerValue);\n      case PACKED:\n        switch (bitsPerValue) {\n          case 8:\n            return new Direct8(valueCount);\n          case 16:\n            return new Direct16(valueCount);\n          case 32:\n            return new Direct32(valueCount);\n          case 64:\n            return new Direct64(valueCount);\n          case 24:\n            if (valueCount <= Packed8ThreeBlocks.MAX_SIZE) {\n              return new Packed8ThreeBlocks(valueCount);\n            }\n            break;\n          case 48:\n            if (valueCount <= Packed16ThreeBlocks.MAX_SIZE) {\n              return new Packed16ThreeBlocks(valueCount);\n            }\n            break;\n        }\n        return new Packed64(valueCount, bitsPerValue);\n      default:\n        throw new AssertionError();\n    }\n  }
468	int getStartIdxOfTextRun(HSLFTextRun textrun) {\n        int idx = 0;\n        for (HSLFTextParagraph p : parentList) {\n            for (HSLFTextRun r : p) {\n                if (r == textrun) {\n                    return idx;\n                }\n                idx += r.getLength();\n            }\n        }\n        return -1;\n    }
469	protected void findDomainLimits() {\n        long startL = getOldestTime().getFirstMillisecond(this.workingCalendar);\n        long endL;\n        if (this.domainIsPointsInTime) {\n            endL = getNewestTime().getFirstMillisecond(this.workingCalendar);\n        }\n        else {\n            endL = getNewestTime().getLastMillisecond(this.workingCalendar);\n        }\n        this.domainStart = new Long(startL);\n        this.domainEnd = new Long(endL);\n        this.domainRange = new Range(startL, endL);\n    }
470	public int findFirstRecordLocBySid( short sid ) {         int max = _records.size();\n        for (int i=0; i< max; i++) {\n            Object rb = _records.get(i);\n            if (!(rb instanceof Record)) {\n                continue;\n            }\n            Record record = (Record) rb;\n            if (record.getSid() == sid) {\n                return i;\n            }\n        }\n        return -1;\n    }
471	public int getCalPrecisionField(Calendar cal) {\n    int lastField = -1;\n    for (int level = YEAR_LEVEL; level < FIELD_BY_LEVEL.length; level++) {\n      int field = FIELD_BY_LEVEL[level];\n      if (!cal.isSet(field))\n        break;\n      lastField = field;\n    }\n    return lastField;\n  }
472	private static BorderStyle getBorderStyle(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        BorderStyle border;\n        if (value instanceof BorderStyle) {\n            border = (BorderStyle) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map uses Short values for "\n                        + name + ". Should use BorderStyle enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            border = BorderStyle.valueOf(code);\n        }\n        else if (value == null) {\n            border = BorderStyle.NONE;\n        }\n        else {\n            throw new RuntimeException("Unexpected border style class. Must be BorderStyle or Short (deprecated).");\n        }\n        return border;\n    }
473	public void createFreezePane(int colSplit, int rowSplit, int topRow, int leftmostColumn) {\n        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n        if (paneLoc != -1)\n            _records.remove(paneLoc);\n\n                if(colSplit == 0 && rowSplit == 0){\n            windowTwo.setFreezePanes(false);\n            windowTwo.setFreezePanesNoSplit(false);\n            SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n            if (sel != null) {\n                sel.setPane(PaneInformation.PANE_UPPER_LEFT);\n            }\n            return;\n        }\n\n        int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n        PaneRecord pane = new PaneRecord();\n        pane.setX((short)colSplit);\n        pane.setY((short)rowSplit);\n        pane.setTopRow((short) topRow);\n        pane.setLeftColumn((short) leftmostColumn);\n        if (rowSplit == 0) {\n            pane.setTopRow((short)0);\n            pane.setActivePane((short)1);\n        } else if (colSplit == 0) {\n            pane.setLeftColumn((short)0);\n            pane.setActivePane((short)2);\n        } else {\n            pane.setActivePane((short)0);\n        }\n        _records.add(loc+1, pane);\n\n        windowTwo.setFreezePanes(true);\n        windowTwo.setFreezePanesNoSplit(true);\n\n        SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n        if (sel != null) {\n            sel.setPane((byte) pane.getActivePane());\n        }\n    }
474	public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }
475	private int findFirstRow(int firstrow) {\n        int rownum = firstrow + 1;\n        HSSFRow r = getRow(rownum);\n\n        while (r == null && rownum <= getLastRowNum()) {\n            r = getRow(++rownum);\n        }\n\n        if (rownum > getLastRowNum())\n            return 0;\n\n        return rownum;\n    }
476	public void validateTickUnit() {\n        double newTickUnit;\n        try {\n            newTickUnit = Double.parseDouble(this.manualTickUnit.getText());\n        }\n        catch (NumberFormatException e) {\n            newTickUnit = this.manualTickUnitValue;\n        }\n\n        if (newTickUnit > 0.0 && newTickUnit < 360.0) {\n            this.manualTickUnitValue = newTickUnit;\n        }\n        this.manualTickUnit.setText(Double.toString(this.manualTickUnitValue));\n    }
477	private boolean resolveTransitively(File ivyXmlFile) {\n    boolean success = true;\n\n    ResolveOptions options = new ResolveOptions();\n    options.setDownload(false);               options.setTransitive(true);              options.setUseCacheOnly(false);           options.setOutputReport(false);           options.setLog(LogOptions.LOG_QUIET);     options.setConfs(new String[] {"*"}); \n            String moduleName = "unknown";\n    String ivyXmlContent = xmlToString(ivyXmlFile);\n    Matcher matcher = MODULE_NAME_PATTERN.matcher(ivyXmlContent);\n    if (matcher.find()) {\n      moduleName = matcher.group(1);\n    }\n    ivyXmlContent = ivyXmlContent.replaceAll("\\btransitive\\s*=\\s*[\"']false[\"']", "transitive=\"true\"");\n    File transitiveIvyXmlFile = null;\n    try {\n      File buildDir = new File(commonBuildDir, "ivy-transitive-resolve");\n      if ( ! buildDir.exists() && ! buildDir.mkdirs()) {\n        throw new BuildException("Could not create temp directory " + buildDir.getPath());\n      }\n      matcher = MODULE_DIRECTORY_PATTERN.matcher(ivyXmlFile.getCanonicalPath());\n      if ( ! matcher.matches()) {\n        throw new BuildException("Unknown ivy.xml module directory: " + ivyXmlFile.getCanonicalPath());\n      }\n      String moduleDirPrefix = matcher.group(1).replaceAll("[/\\\\]", ".");\n      transitiveIvyXmlFile = new File(buildDir, "transitive." + moduleDirPrefix + ".ivy.xml");\n      try (Writer writer = new OutputStreamWriter(new FileOutputStream(transitiveIvyXmlFile), StandardCharsets.UTF_8)) {\n        writer.write(ivyXmlContent);\n      }\n      ResolveReport resolveReport = ivy.resolve(transitiveIvyXmlFile.toURI().toURL(), options);\n      IvyNodeElement root = IvyNodeElementAdapter.adapt(resolveReport);\n      for (IvyNodeElement directDependency : root.getDependencies()) {\n        String coordinate = "/" + directDependency.getOrganization() + "/" + directDependency.getName();\n        Dependency dependency = directDependencies.get(coordinate);\n        if (null == dependency) {\n          log("ERROR: the following coordinate key does not appear in " \n              + centralizedVersionsFile.getName() + ": " + coordinate);\n          success = false;\n        } else {\n          dependency.directlyReferenced = true;\n          if (collectConflicts(directDependency, directDependency, moduleName)) {\n            success = false;\n          }\n        }\n      }\n    } catch (ParseException | IOException e) {\n      if (null != transitiveIvyXmlFile) {\n        log("Exception reading " + transitiveIvyXmlFile.getPath() + ": " + e.toString());\n      }\n      success = false;\n    }\n    return success;\n  }
478	public static Polygon2D create(Polygon... polygons) {\n    Polygon2D components[] = new Polygon2D[polygons.length];\n    for (int i = 0; i < components.length; i++) {\n      Polygon gon = polygons[i];\n      Polygon gonHoles[] = gon.getHoles();\n      Polygon2D holes = null;\n      if (gonHoles.length > 0) {\n        holes = create(gonHoles);\n      }\n      components[i] = new Polygon2D(gon, holes);\n    }\n    return createTree(components, 0, components.length - 1, false);\n  }
479	private List<FacetResult> facetsOnly() throws IOException {\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    FacetsCollector fc = new FacetsCollector();\n\n                searcher.search(new MatchAllDocsQuery(), fc);\n\n        List<FacetResult> results = new ArrayList<>();\n\n        Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, fc);\n   \n    results.add(facets.getTopChildren(10, "Author"));\n    results.add(facets.getTopChildren(10, "Publish Date"));\n    \n    indexReader.close();\n    taxoReader.close();\n    \n    return results;\n  }
480	private static byte[] encodeCeil(double latitude, double longitude) {\n    byte[] bytes = new byte[2 * Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitudeCeil(latitude), bytes, 0);\n    NumericUtils.intToSortableBytes(encodeLongitudeCeil(longitude), bytes, Integer.BYTES);\n    return bytes;\n  }
481	public boolean release(long id) {\n        if (id < lowerbound || id > upperbound) {\n            throw new IllegalArgumentException("Value for parameter 'id' was out of bounds, had " + id + ", but should be within [" + lowerbound + ":" + upperbound + "]");\n        }\n\n        if (id == upperbound) {\n            Segment lastSegment = segments.getLast();\n            if (lastSegment.end == upperbound - 1) {\n                lastSegment.end = upperbound;\n                return true;\n            } else if (lastSegment.end == upperbound) {\n                return false;\n            } else {\n                segments.add(new Segment(upperbound, upperbound));\n                return true;\n            }\n        }\n\n        if (id == lowerbound) {\n            Segment firstSegment = segments.getFirst();\n            if (firstSegment.start == lowerbound + 1) {\n                firstSegment.start = lowerbound;\n                return true;\n            } else if (firstSegment.start == lowerbound) {\n                return false;\n            } else {\n                segments.addFirst(new Segment(lowerbound, lowerbound));\n                return true;\n            }\n        }\n\n        long higher = id + 1;\n        long lower = id - 1;\n        ListIterator<Segment> iter = segments.listIterator();\n\n        while (iter.hasNext()) {\n            Segment segment = iter.next();\n            if (segment.end < lower) {\n                continue;\n            }\n            if (segment.start > higher) {\n                iter.previous();\n                iter.add(new Segment(id, id));\n                return true;\n            }\n            if (segment.start == higher) {\n                segment.start = id;\n                return true;\n            }\n            else if (segment.end == lower) {\n                segment.end = id;\n                \n                if (iter.hasNext()) {\n                  Segment next = iter.next();\n                    if (next.start == segment.end + 1) {\n                        segment.end = next.end;\n                        iter.remove();\n                    }\n                }\n                return true;\n            }\n            else {\n                \n                break;\n            }\n        }\n        return false;\n    }
482	private double transEnd(double value, Rectangle2D area, RectangleEdge edge,\n                            double length1, double length2) {\n        double min = 0.0;\n        double max = 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            max = area.getMaxX();\n            min = area.getMaxX() - area.getWidth() * length2\n                  / (length1 + length2);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            max = area.getMinY();\n            min = area.getMinY() + area.getHeight() * length2\n                  / (length1 + length2);\n        }\n        if (isInverted()) {\n            return max - ((value - this.fixedRange.getLowerBound())\n                    / (this.displayEnd - this.fixedRange.getLowerBound()))\n                    * (max - min);\n        }\n        else {\n            return min + ((value - this.fixedRange.getLowerBound())\n                    / (this.displayEnd - this.fixedRange.getLowerBound()))\n                    * (max - min);\n        }\n\n    }
483	public void addBreak(int main, int subFrom, int subTo) {\n\n        Integer key = Integer.valueOf(main);\n        Break region = _breakMap.get(key);\n        if(region == null) {\n            region = new Break(main, subFrom, subTo);\n            _breakMap.put(key, region);\n            _breaks.add(region);\n        } else {\n            region.main = main;\n            region.subFrom = subFrom;\n            region.subTo = subTo;\n        }\n    }
484	private void saveCSVFile(File file)\n                                     throws FileNotFoundException, IOException {\n        ArrayList<String> line;\n        StringBuffer buffer;\n        String csvLineElement;\n\n                try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {\n\n            System.out.println("Saving the CSV file [" + file.getName() + "]");\n\n                                                for(int i = 0; i < this.csvData.size(); i++) {\n                buffer = new StringBuffer();\n\n                                                                                                                                                                                                                line = this.csvData.get(i);\n                for(int j = 0; j < this.maxRowWidth; j++) {\n                    if(line.size() > j) {\n                        csvLineElement = line.get(j);\n                        if(csvLineElement != null) {\n                            buffer.append(this.escapeEmbeddedCharacters(\n                                    csvLineElement));\n                        }\n                    }\n                    if(j < (this.maxRowWidth - 1)) {\n                        buffer.append(this.separator);\n                    }\n                }\n\n                                bw.write(buffer.toString().trim());\n\n                                                                if(i < (this.csvData.size() - 1)) {\n                    bw.newLine();\n                }\n            }\n        }\n    }
485	public void addNum(BigInteger abstractNumID, BigInteger numID) {\n        CTNum ctNum = this.ctNumbering.addNewNum();\n        ctNum.addNewAbstractNumId();\n        ctNum.getAbstractNumId().setVal(abstractNumID);\n        ctNum.setNumId(numID);\n        XWPFNum num = new XWPFNum(ctNum, this);\n        nums.add(num);\n    }
486	private static int atLeast(Automaton.Builder builder, String x, int n, Collection<Integer> initials,\n      boolean zeros) {\n    int s = builder.createState();\n    if (x.length() == n) {\n      builder.setAccept(s, true);\n    } else {\n      if (zeros) {\n        initials.add(s);\n      }\n      char c = x.charAt(n);\n      builder.addTransition(s, atLeast(builder, x, n + 1, initials, zeros && c == '0'), c);\n      if (c < '9') {\n        builder.addTransition(s, anyOfRightLength(builder, x, n + 1), (char) (c + 1), '9');\n      }\n    }\n    return s;\n  }
487	public void restoreAutoDomainBounds() {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            Zoomable z = (Zoomable) plot;\n                                                boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n                        Point2D zp = (this.zoomPoint != null\n                    ? this.zoomPoint : new Point());\n            z.zoomDomainAxes(0.0, this.info.getPlotInfo(), zp);\n            plot.setNotify(savedNotify);\n        }\n    }
488	public TermAutomatonQuery toQuery(String field, TokenStream in) throws IOException {\n\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n    final OffsetAttribute offsetAtt = in.addAttribute(OffsetAttribute.class);\n\n    in.reset();\n\n    TermAutomatonQuery query = new TermAutomatonQuery(field);\n\n    int pos = -1;\n    int lastPos = 0;\n    int maxOffset = 0;\n    int maxPos = -1;\n    int state = -1;\n    while (in.incrementToken()) {\n      int posInc = posIncAtt.getPositionIncrement();\n      if (preservePositionIncrements == false && posInc > 1) {\n        posInc = 1;\n      }\n      assert pos > -1 || posInc > 0;\n\n      if (posInc > 1) {\n        throw new IllegalArgumentException("cannot handle holes; to accept any term, use '*' term");\n      }\n\n      if (posInc > 0) {\n                pos += posInc;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength();\n      while (state < endPos) {\n        state = query.createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n            if (term.length == 1 && term.bytes[term.offset] == (byte) '*') {\n        query.addAnyTransition(pos, endPos);\n      } else {\n        query.addTransition(pos, endPos, term);\n      }\n\n      maxOffset = Math.max(maxOffset, offsetAtt.endOffset());\n      maxPos = Math.max(maxPos, endPos);\n    }\n\n    in.end();\n\n    \n        query.setAccept(state, true);\n    query.finish();\n\n    return query;\n  }
489	private String dependencyToArtifactId(String newPropertyKey, String dependency) {\n    StringBuilder artifactId = new StringBuilder();\n    Matcher matcher = COMPILATION_OUTPUT_DIRECTORY_PATTERN.matcher(dependency);\n    if (matcher.matches()) {\n            String artifact = matcher.group(2);\n      artifact = artifact.replace('/', '-');\n      artifact = artifact.replaceAll("(?<!solr-)analysis-", "analyzers-");\n      if ("lucene".equals(matcher.group(1))) {\n        artifactId.append("lucene-");\n      }\n      artifactId.append(artifact);\n    } else {\n      matcher = internalJarPattern.matcher(dependency);\n      if (matcher.matches()) {\n                        artifactId.append(matcher.group(1));\n        artifactId.append(matcher.group(2));\n      } else {\n        throw new BuildException\n            ("Malformed module dependency from '" + newPropertyKey + "': '" + dependency + "'");\n      }\n    }\n    return artifactId.toString();\n  }
490	public void pan(double percent) {\n        Range r = getRange();\n        double length = range.getLength();\n        double adj = length * percent;\n        double lower = r.getLowerBound() + adj;\n        double upper = r.getUpperBound() + adj;\n        setRange(lower, upper);\n    }
491	public double linearDistance(final PlanetModel planetModel, final double x, final double y, final double z, final Membership... bounds) {\n    if (evaluateIsZero(x,y,z)) {\n      if (meetsAllBounds(x,y,z, bounds))\n        return 0.0;\n      return Double.POSITIVE_INFINITY;\n    }\n    \n        final Plane perpPlane = new Plane(this.y * z - this.z * y, this.z * x - this.x * z, this.x * y - this.y * x, 0.0);\n\n                \n    final GeoPoint[] intersectionPoints = findIntersections(planetModel, perpPlane);\n    \n        double minDistance = Double.POSITIVE_INFINITY;\n    \n    for (final GeoPoint intersectionPoint : intersectionPoints) {\n      if (meetsAllBounds(intersectionPoint, bounds)) {\n        final double theDistance = intersectionPoint.linearDistance(x,y,z);\n        if (theDistance < minDistance) {\n          minDistance = theDistance;\n        }\n      }\n    }\n    return minDistance;\n  }
492	public final RelationPart createRelationship(POIXMLRelation descriptor, POIXMLFactory factory, int idx, boolean noRelation) {\n        try {\n            PackagePartName ppName = PackagingURIHelper.createPartName(descriptor.getFileName(idx));\n            PackageRelationship rel = null;\n            PackagePart part = packagePart.getPackage().createPart(ppName, descriptor.getContentType());\n            if (!noRelation) {\n                \n                rel = packagePart.addRelationship(ppName, TargetMode.INTERNAL, descriptor.getRelation());\n            }\n            POIXMLDocumentPart doc = factory.newDocumentPart(descriptor);\n            doc.packagePart = part;\n            doc.parent = this;\n            if (!noRelation) {\n                \n                addRelation(rel, doc);\n            }\n\n            return new RelationPart(rel, doc);\n        } catch (PartAlreadyExistsException pae) {\n                                    throw pae;\n        } catch (Exception e) {\n                        throw new POIXMLException(e);\n        }\n    }
493	private void removeParticleDenotion( StringBuilder buffer )\n    {\n      if ( buffer.length() > 4 ) {\n        for ( int c = 0; c < buffer.length() - 3; c++ ) {\n          if ( buffer.substring( c, c + 4 ).equals( "gege" ) ) {\n            buffer.delete( c, c + 2 );\n            return;\n          }\n        }\n      }\n    }
494	public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n                    priorException.addSuppressed(new CorruptIndexException("checksum status indeterminate: remaining=" + remaining +\n                                                                 ", please run checkindex for more details", in));\n        } else {\n                    in.skipBytes(remaining - footerLength());\n          \n                    try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException("checksum passed (" + Long.toHexString(checksum) + \n                                                                   "). possibly transient resource issue, or a Lucene or JVM bug", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n                priorException.addSuppressed(new CorruptIndexException("checksum status indeterminate: unexpected exception", in, t));\n      }\n      throw IOUtils.rethrowAlways(priorException);\n    }\n  }
495	public static DistancePredicate createDistancePredicate(double lat, double lon, double radiusMeters) {\n    final Rectangle boundingBox = Rectangle.fromPointDistance(lat, lon, radiusMeters);\n    final double axisLat = Rectangle.axisLat(lat, radiusMeters);\n    final double distanceSortKey = GeoUtils.distanceQuerySortKey(radiusMeters);\n    final Function<Rectangle, Relation> boxToRelation = box -> GeoUtils.relate(\n        box.minLat, box.maxLat, box.minLon, box.maxLon, lat, lon, distanceSortKey, axisLat);\n    final Grid subBoxes = createSubBoxes(boundingBox, boxToRelation);\n\n    return new DistancePredicate(\n        subBoxes.latShift, subBoxes.lonShift,\n        subBoxes.latBase, subBoxes.lonBase,\n        subBoxes.maxLatDelta, subBoxes.maxLonDelta,\n        subBoxes.relations,\n        lat, lon, distanceSortKey);\n  }
496	public static CachingCollector create(Collector other, boolean cacheScores, double maxRAMMB) {\n    int bytesPerDoc = Integer.BYTES;\n    if (cacheScores) {\n      bytesPerDoc += Float.BYTES;\n    }\n    final int maxDocsToCache = (int) ((maxRAMMB * 1024 * 1024) / bytesPerDoc);\n    return create(other, cacheScores, maxDocsToCache);\n  }
497	protected SpanQuery analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), phraseSlop, true);\n    }\n  }
498	public int newSlice(final int size) {\n    if (byteUpto > BYTE_BLOCK_SIZE-size)\n      nextBuffer();\n    final int upto = byteUpto;\n    byteUpto += size;\n    buffer[byteUpto-1] = 16;\n    return upto;\n  }
499	int next() {\n    current = end;\n    if (current == DONE) {\n      return DONE;\n    }\n    \n    if (skipPossessive) {\n      current += 2;\n      skipPossessive = false;\n    }\n\n    int lastType = 0;\n    \n    while (current < endBounds && (isSubwordDelim(lastType = charType(text[current])))) {\n      current++;\n    }\n\n    if (current >= endBounds) {\n      return end = DONE;\n    }\n    \n    for (end = current + 1; end < endBounds; end++) {\n      int type = charType(text[end]);\n      if (isBreak(lastType, type)) {\n        break;\n      }\n      lastType = type;\n    }\n    \n    if (end < endBounds - 1 && endsWithPossessive(end + 2)) {\n      skipPossessive = true;\n    }\n    \n    return end;\n  }
500	private FacetResult drillDown() throws IOException {\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n            DrillDownQuery q = new DrillDownQuery(config);\n\n        q.add("Publish Date", "2010");\n    FacetsCollector fc = new FacetsCollector();\n    FacetsCollector.search(searcher, q, 10, fc);\n\n        Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, fc);\n    FacetResult result = facets.getTopChildren(10, "Author");\n\n    indexReader.close();\n    taxoReader.close();\n    \n    return result;\n  }
501	public short findNewDrawingGroupId() {\n        BitSet bs = new BitSet();\n        bs.set(0);\n        for (FileIdCluster fic : field_5_fileIdClusters) {\n            bs.set(fic.getDrawingGroupId());\n        }\n        return (short)bs.nextClearBit(0);\n    }
502	private StrokeLineJoin awtToJavaFXLineJoin(int j) {\n        if (j == BasicStroke.JOIN_BEVEL) {\n            return StrokeLineJoin.BEVEL;\n        } else if (j == BasicStroke.JOIN_MITER) {\n            return StrokeLineJoin.MITER;\n        } else if (j == BasicStroke.JOIN_ROUND) {\n            return StrokeLineJoin.ROUND;\n        } else {\n            throw new IllegalArgumentException("Unrecognised join code: " + j);            \n        }\n    }
503	public void setBorderRight(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetRight() ? ct.getRight() : ct.addNewRight();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetRight();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
504	public void zoomOutBoth(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot == null) {\n            return;\n        }\n                                boolean savedNotify = plot.isNotify();\n        plot.setNotify(false);\n        zoomOutDomain(x, y);\n        zoomOutRange(x, y);\n        plot.setNotify(savedNotify);\n    }
505	public void restoreAutoRangeBounds() {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            Zoomable z = (Zoomable) plot;\n                                                boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n                        Point2D zp = (this.zoomPoint != null\n                    ? this.zoomPoint : new Point());\n            z.zoomRangeAxes(0.0, this.info.getPlotInfo(), zp);\n            plot.setNotify(savedNotify);\n        }\n    }
506	public void exportToXML(OutputStream os, String encoding, boolean validate) throws SAXException, TransformerException{\n        List<XSSFSingleXmlCell> singleXMLCells = map.getRelatedSingleXMLCell();\n        List<XSSFTable> tables = map.getRelatedTables();\n\n        String rootElement = map.getCtMap().getRootElement();\n\n        Document doc = DocumentHelper.createDocument();\n\n        final Element root;\n\n        if (isNamespaceDeclared()) {\n            root = doc.createElementNS(getNamespace(),rootElement);\n        } else {\n            root = doc.createElementNS("", rootElement);\n        }\n        doc.appendChild(root);\n\n\n        List<String> xpaths = new Vector<>();\n        Map<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<>();\n        Map<String,XSSFTable> tableMappings = new HashMap<>();\n\n        for(XSSFSingleXmlCell simpleXmlCell : singleXMLCells) {\n            xpaths.add(simpleXmlCell.getXpath());\n            singleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);\n        }\n        for(XSSFTable table : tables) {\n            String commonXPath = table.getCommonXpath();\n            xpaths.add(commonXPath);\n            tableMappings.put(commonXPath, table);\n        }\n\n        indexMap.clear();\n        xpaths.sort(this);\n        indexMap.clear();\n        \n        for(String xpath : xpaths) {\n\n            XSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);\n            XSSFTable table = tableMappings.get(xpath);\n\n            if (!xpath.matches(".*\\[.*")) {\n\n                                if (simpleXmlCell!=null) {\n                    XSSFCell cell = simpleXmlCell.getReferencedCell();\n                    if (cell!=null) {\n                        Node currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);\n                        mapCellOnNode(cell,currentNode);\n                        \n                                                                        if ("".equals(currentNode.getTextContent()) && currentNode.getParentNode() != null) {\n                            currentNode.getParentNode().removeChild(currentNode);\n                        }\n                    }\n                }\n\n                                if (table!=null) {\n\n                    List<XSSFTableColumn> tableColumns = table.getColumns();\n\n                    XSSFSheet sheet = table.getXSSFSheet();\n\n                    int startRow = table.getStartCellReference().getRow() + table.getHeaderRowCount();\n                    int endRow = table.getEndCellReference().getRow();\n\n                    for(int i = startRow; i<= endRow; i++) {\n                        XSSFRow row = sheet.getRow(i);\n\n                        Node tableRootNode = getNodeByXPath(table.getCommonXpath(), doc.getFirstChild(), doc, true);\n\n                        short startColumnIndex = table.getStartCellReference().getCol();\n                        for (XSSFTableColumn tableColumn : tableColumns) {\n                            XSSFCell cell = row.getCell(startColumnIndex + tableColumn.getColumnIndex());\n                            if (cell != null) {\n                                XSSFXmlColumnPr xmlColumnPr = tableColumn.getXmlColumnPr();\n                                if (xmlColumnPr != null) {\n                                    String localXPath = xmlColumnPr.getLocalXPath();\n                                    Node currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);\n                                    mapCellOnNode(cell, currentNode);\n                                }\n                            }\n                        }\n                    }\n                }\n            } \n        }\n\n        boolean isValid = true;\n        if (validate) {\n            isValid =isValid(doc);\n        }\n\n        if (isValid) {\n\n                        \n                        TransformerFactory transfac = TransformerFactory.newInstance();\n            Transformer trans = transfac.newTransformer();\n            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");\n            trans.setOutputProperty(OutputKeys.INDENT, "yes");\n            trans.setOutputProperty(OutputKeys.ENCODING, encoding);\n\n            \n            StreamResult result = new StreamResult(os);\n            DOMSource source = new DOMSource(doc);\n            trans.transform(source, result);\n\n        }\n    }
507	private boolean isStemmable( String term ) {\n    for ( int c = 0; c < term.length(); c++ ) {\n            if ( !Character.isLetter(term.charAt(c))) {\n        return false;\n      }\n    }\n    return true;\n  }
508	public static InternalWorkbook createWorkbook(List<Record> recs) {\n        LOG.log(DEBUG, "Workbook (readfile) created with reclen=", recs.size());\n        InternalWorkbook retval = new InternalWorkbook();\n        List<Record> records = new ArrayList<>(recs.size() / 3);\n        retval.records.setRecords(records);\n\n        boolean eofPassed = false;\n        for (int k = 0; k < recs.size(); k++) {\n            Record rec = recs.get(k);\n            String logObj;\n            switch (rec.getSid()) {\n\n                case EOFRecord.sid :\n                    logObj = "workbook eof";\n                    break;\n\n                case BoundSheetRecord.sid :\n                    logObj = "boundsheet";\n                    retval.boundsheets.add((BoundSheetRecord) rec);\n                    retval.records.setBspos( k );\n                    break;\n\n                case SSTRecord.sid :\n                    logObj = "sst";\n                    retval.sst = ( SSTRecord ) rec;\n                    break;\n\n                case FontRecord.sid :\n                    logObj = "font";\n                    retval.records.setFontpos( k );\n                    retval.numfonts++;\n                    break;\n\n                case ExtendedFormatRecord.sid :\n                    logObj = "XF";\n                    retval.records.setXfpos( k );\n                    retval.numxfs++;\n                    break;\n\n                case TabIdRecord.sid :\n                    logObj = "tabid";\n                    retval.records.setTabpos( k );\n                    break;\n\n                case ProtectRecord.sid :\n                    logObj = "protect";\n                    retval.records.setProtpos( k );\n                    break;\n\n                case BackupRecord.sid :\n                    logObj = "backup";\n                    retval.records.setBackuppos( k );\n                    break;\n\n                case ExternSheetRecord.sid :\n                    throw new RecordFormatException("Extern sheet is part of LinkTable");\n\n                case NameRecord.sid :\n                case SupBookRecord.sid :\n                                        LOG.log(DEBUG, "found SupBook record at " + k);\n                    retval.linkTable = new LinkTable(recs, k, retval.records, retval.commentRecords);\n                    k+=retval.linkTable.getRecordCount() - 1;\n                    continue;\n\n                case FormatRecord.sid :\n                    logObj = "format";\n                    FormatRecord fr = (FormatRecord) rec;\n                    retval.formats.add(fr);\n                    retval.maxformatid = retval.maxformatid >= fr.getIndexCode() ? retval.maxformatid : fr.getIndexCode();\n                    break;\n\n                case DateWindow1904Record.sid :\n                    logObj = "datewindow1904";\n                    retval.uses1904datewindowing = ((DateWindow1904Record)rec).getWindowing() == 1;\n                    break;\n\n                case PaletteRecord.sid:\n                    logObj = "palette";\n                    retval.records.setPalettepos( k );\n                    break;\n\n                case WindowOneRecord.sid:\n                    logObj = "WindowOneRecord";\n                    retval.windowOne = (WindowOneRecord) rec;\n                    break;\n\n                case WriteAccessRecord.sid:\n                    logObj = "WriteAccess";\n                    retval.writeAccess = (WriteAccessRecord) rec;\n                    break;\n\n                case WriteProtectRecord.sid:\n                    logObj = "WriteProtect";\n                    retval.writeProtect = (WriteProtectRecord) rec;\n                    break;\n\n                case FileSharingRecord.sid:\n                    logObj = "FileSharing";\n                    retval.fileShare = (FileSharingRecord) rec;\n                    break;\n\n                case NameCommentRecord.sid:\n                    logObj = "NameComment";\n                    final NameCommentRecord ncr = (NameCommentRecord) rec;\n                    retval.commentRecords.put(ncr.getNameText(), ncr);\n                    break;\n\n                case HyperlinkRecord.sid:\n                                        logObj = "Hyperlink";\n                    retval.hyperlinks.add((HyperlinkRecord)rec);\n                    break;\n\n                default:\n                    logObj = "(sid=" + rec.getSid() + ")";\n                    break;\n            }\n            if (!eofPassed) {\n                records.add(rec);\n            }\n            LOG.log(DEBUG, "found "+logObj+" record at " + k);\n            if (rec.getSid() == EOFRecord.sid) {\n                eofPassed = true;\n            }\n        }\n                                        \n        if (retval.windowOne == null) {\n            retval.windowOne = createWindowOne();\n        }\n        LOG.log(DEBUG, "exit create workbook from existing file function");\n        return retval;\n    }
509	public void serialize(DataOutput out) throws IOException {\n    out.writeUTF(id);\n    out.writeUTF(version);\n    out.writeInt(sourceFiles.size());\n    for (Entry<String,List<RevisionFile>> e : sourceFiles.entrySet()) {\n      out.writeUTF(e.getKey());\n      List<RevisionFile> files = e.getValue();\n      out.writeInt(files.size());\n      for (RevisionFile file : files) {\n        out.writeUTF(file.fileName);\n        out.writeLong(file.size);\n      }\n    }\n  }
510	public final void setReader(Reader input) {\n    if (input == null) {\n      throw new NullPointerException("input must not be null");\n    } else if (this.input != ILLEGAL_STATE_READER) {\n      throw new IllegalStateException("TokenStream contract violation: close() call missing");\n    }\n    this.inputPending = input;\n    setReaderTestPoint();\n  }
511	public void addStyle(XWPFStyle style) {\n        listStyle.add(style);\n        ctStyles.addNewStyle();\n        int pos = ctStyles.sizeOfStyleArray() - 1;\n        ctStyles.setStyleArray(pos, style.getCTStyle());\n    }
512	public static boolean isValidPartName(URI partUri) {\n		if (partUri == null)\n			throw new IllegalArgumentException("partUri");\n\n		try {\n			createPartName(partUri);\n			return true;\n		} catch (Exception e) {\n			return false;\n		}\n	}
513	public void zoomInBoth(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot == null) {\n            return;\n        }\n                                boolean savedNotify = plot.isNotify();\n        plot.setNotify(false);\n        zoomInDomain(x, y);\n        zoomInRange(x, y);\n        plot.setNotify(savedNotify);\n    }
514	private void doDrillDownAdvanceScoring(Bits acceptDocs, LeafCollector collector, DocsAndCost[] dims) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n            \n        int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n                  \n                              DocsAndCost dc = dims[0];\n      int docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            seen.set(slot);\n                                                            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n      \n                              dc = dims[1];\n      docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)\n            && (dc.twoPhase == null || dc.twoPhase.matches())) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n                        seen.set(slot);\n                                                docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n                                    if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n                                                      } else {\n              counts[slot] = 1;\n                                                      }\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n\n                  \n                  \n            int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != DocIdSetIterator.NO_MORE_DOCS) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseIterator.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseIterator.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n                                        scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n                                        docIDs[slot0] = -1;\n\n                                      }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n                  for (int dim=2;dim<numDims;dim++) {\n                                dc = dims[dim];\n        docID = dc.approximation.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID\n              && counts[slot] >= dim\n              && (dc.twoPhase == null || dc.twoPhase.matches())) {\n                                    if (missingDims[slot] >= dim) {\n                                                        missingDims[slot] = dim+1;\n              counts[slot] = dim+2;\n            } else {\n                                                        counts[slot] = dim+1;\n            }\n          }\n\n                    docID = dc.approximation.nextDoc();\n        }\n      }\n\n                              for (int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n                                if (counts[slot] == 1+numDims) {\n          collectHit(collector, dims);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(dims[missingDims[slot]].sidewaysLeafCollector);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }
515	private void output8Codes(OutputStream res) throws IOException {\n		res.write(new byte[] { HDGFLZW.fromInt(nextMask) } );\n	res.write(buffer, 0, bufferLen);\n\n		nextMask = 0;\n	maskBitsSet = 0;\n	bufferLen = 0;\n}
516	public static String quoteEscape(String original) {\n    String result = original;\n    \n    if (result.indexOf('\"') >= 0) {\n      result = result.replace("\"", ESCAPED_QUOTE);\n    }\n    if(result.indexOf(COMMA) >= 0) {\n      result = "\"" + result + "\"";\n    }\n    return result;\n  }
517	public ValueEval evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex) {\n		try {\n			if (args.length < 1  ||  args.length > 2) {\n				return ErrorEval.VALUE_INVALID;\n			}\n\n						ValueEval serialDateVE = OperandResolver.getSingleValue(args[0], srcRowIndex, srcColumnIndex);\n			double serialDate = OperandResolver.coerceValueToDouble(serialDateVE);\n			if (!DateUtil.isValidExcelDate(serialDate)) {\n				return ErrorEval.NUM_ERROR;									}\n			Calendar date = DateUtil.getJavaCalendar(serialDate, false);					int weekday = date.get(Calendar.DAY_OF_WEEK);		\n						int returnOption = 1;								if (args.length == 2) {\n				ValueEval ve = OperandResolver.getSingleValue(args[1], srcRowIndex, srcColumnIndex);\n				if (ve == MissingArgEval.instance  ||  ve == BlankEval.instance) {\n					return ErrorEval.NUM_ERROR;						}\n				returnOption = OperandResolver.coerceValueToInt(ve);\n				if (returnOption == 2) {\n					returnOption = 11;								}\n			} \n						double result;\n			if (returnOption == 1) {\n				result = weekday;\n						} else if (returnOption == 3) {\n				result = (weekday + 6 - 1) % 7;\n			} else if (returnOption >= 11  &&  returnOption <= 17) {\n				result = (weekday + 6 - (returnOption - 10)) % 7 + 1;					} else {\n				return ErrorEval.NUM_ERROR;					}\n\n			return new NumberEval(result);\n		} catch (EvaluationException e) {\n			return e.getErrorEval();\n		}\n	}
518	public synchronized String exec(String a, String b) {\n    if (a == null || b == null) {\n      return null;\n    }\n    \n    int x;\n    int y;\n    int maxx;\n    int maxy;\n    int go[] = new int[4];\n    final int X = 1;\n    final int Y = 2;\n    final int R = 3;\n    final int D = 0;\n    \n    \n    maxx = a.length() + 1;\n    maxy = b.length() + 1;\n    if ((maxx >= sizex) || (maxy >= sizey)) {\n      sizex = maxx + 8;\n      sizey = maxy + 8;\n      net = new int[sizex][sizey];\n      way = new int[sizex][sizey];\n    }\n    \n    \n    for (x = 0; x < maxx; x++) {\n      for (y = 0; y < maxy; y++) {\n        net[x][y] = 0;\n      }\n    }\n    \n    \n    for (x = 1; x < maxx; x++) {\n      net[x][0] = x;\n      way[x][0] = X;\n    }\n    for (y = 1; y < maxy; y++) {\n      net[0][y] = y;\n      way[0][y] = Y;\n    }\n    \n    for (x = 1; x < maxx; x++) {\n      for (y = 1; y < maxy; y++) {\n        go[X] = net[x - 1][y] + DELETE;\n                go[Y] = net[x][y - 1] + INSERT;\n                go[R] = net[x - 1][y - 1] + REPLACE;\n        go[D] = net[x - 1][y - 1]\n            + ((a.charAt(x - 1) == b.charAt(y - 1)) ? NOOP : 100);\n                short min = D;\n        if (go[min] >= go[X]) {\n          min = X;\n        }\n        if (go[min] > go[Y]) {\n          min = Y;\n        }\n        if (go[min] > go[R]) {\n          min = R;\n        }\n        way[x][y] = min;\n        net[x][y] = (short) go[min];\n      }\n    }\n    \n        StringBuilder result = new StringBuilder();\n    final char base = 'a' - 1;\n    char deletes = base;\n    char equals = base;\n    for (x = maxx - 1, y = maxy - 1; x + y != 0;) {\n      switch (way[x][y]) {\n        case X:\n          if (equals != base) {\n            result.append("-" + (equals));\n            equals = base;\n          }\n          deletes++;\n          x--;\n          break;\n                case Y:\n          if (deletes != base) {\n            result.append("D" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append("-" + (equals));\n            equals = base;\n          }\n          result.append('I');\n          result.append(b.charAt(--y));\n          break;\n                case R:\n          if (deletes != base) {\n            result.append("D" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append("-" + (equals));\n            equals = base;\n          }\n          result.append('R');\n          result.append(b.charAt(--y));\n          x--;\n          break;\n                case D:\n          if (deletes != base) {\n            result.append("D" + (deletes));\n            deletes = base;\n          }\n          equals++;\n          x--;\n          y--;\n          break;\n              }\n    }\n    if (deletes != base) {\n      result.append("D" + (deletes));\n      deletes = base;\n    }\n    \n    return result.toString();\n  }
519	public final static QueryNode logicalAnd(QueryNode q1, QueryNode q2) {\n    if (q1 == null)\n      return q2;\n    if (q2 == null)\n      return q1;\n\n    ANDOperation op = null;\n    if (q1 instanceof AndQueryNode && q2 instanceof AndQueryNode)\n      op = ANDOperation.BOTH;\n    else if (q1 instanceof AndQueryNode)\n      op = ANDOperation.Q1;\n    else if (q2 instanceof AndQueryNode)\n      op = ANDOperation.Q2;\n    else\n      op = ANDOperation.NONE;\n\n    try {\n      QueryNode result = null;\n      switch (op) {\n      case NONE:\n        List<QueryNode> children = new ArrayList<>();\n        children.add(q1.cloneTree());\n        children.add(q2.cloneTree());\n        result = new AndQueryNode(children);\n        return result;\n      case Q1:\n        result = q1.cloneTree();\n        result.add(q2.cloneTree());\n        return result;\n      case Q2:\n        result = q2.cloneTree();\n        result.add(q1.cloneTree());\n        return result;\n      case BOTH:\n        result = q1.cloneTree();\n        result.add(q2.cloneTree().getChildren());\n        return result;\n      }\n    } catch (CloneNotSupportedException e) {\n      throw new QueryNodeError(e);\n    }\n\n    return null;\n\n  }
520	public static ZipSecureFile openZipFile(File file) throws IOException, NotOfficeXmlFileException {\n        if (!file.exists()) {\n            throw new FileNotFoundException("File does not exist");\n        }\n        if (file.isDirectory()) {\n            throw new IOException("File is a directory");\n        }\n        \n                try (FileInputStream input = new FileInputStream(file)) {\n            verifyZipHeader(input);\n        }\n\n                return new ZipSecureFile(file);\n    }
521	private void createPolygon (Graphics2D x_graphics,\n                                Rectangle2D x_dataArea,\n                                XYPlot x_plot,\n                                ValueAxis x_domainAxis,\n                                ValueAxis x_rangeAxis,\n                                boolean x_positive,\n                                LinkedList x_xValues,\n                                LinkedList x_yValues) {\n\n        PlotOrientation l_orientation      = x_plot.getOrientation();\n        RectangleEdge l_domainAxisLocation = x_plot.getDomainAxisEdge();\n        RectangleEdge l_rangeAxisLocation  = x_plot.getRangeAxisEdge();\n\n        Object[] l_xValues = x_xValues.toArray();\n        Object[] l_yValues = x_yValues.toArray();\n\n        GeneralPath l_path = new GeneralPath();\n\n        if (PlotOrientation.VERTICAL == l_orientation) {\n            double l_x = x_domainAxis.valueToJava2D((\n                    (Double) l_xValues[0]).doubleValue(), x_dataArea,\n                    l_domainAxisLocation);\n            if (this.roundXCoordinates) {\n                l_x = Math.rint(l_x);\n            }\n\n            double l_y = x_rangeAxis.valueToJava2D((\n                    (Double) l_yValues[0]).doubleValue(), x_dataArea,\n                    l_rangeAxisLocation);\n\n            l_path.moveTo((float) l_x, (float) l_y);\n            for (int i = 1; i < l_xValues.length; i++) {\n                l_x = x_domainAxis.valueToJava2D((\n                        (Double) l_xValues[i]).doubleValue(), x_dataArea,\n                        l_domainAxisLocation);\n                if (this.roundXCoordinates) {\n                    l_x = Math.rint(l_x);\n                }\n\n                l_y = x_rangeAxis.valueToJava2D((\n                        (Double) l_yValues[i]).doubleValue(), x_dataArea,\n                        l_rangeAxisLocation);\n                l_path.lineTo((float) l_x, (float) l_y);\n            }\n            l_path.closePath();\n        }\n        else {\n            double l_x = x_domainAxis.valueToJava2D((\n                    (Double) l_xValues[0]).doubleValue(), x_dataArea,\n                    l_domainAxisLocation);\n            if (this.roundXCoordinates) {\n                l_x = Math.rint(l_x);\n            }\n\n            double l_y = x_rangeAxis.valueToJava2D((\n                    (Double) l_yValues[0]).doubleValue(), x_dataArea,\n                    l_rangeAxisLocation);\n\n            l_path.moveTo((float) l_y, (float) l_x);\n            for (int i = 1; i < l_xValues.length; i++) {\n                l_x = x_domainAxis.valueToJava2D((\n                        (Double) l_xValues[i]).doubleValue(), x_dataArea,\n                        l_domainAxisLocation);\n                if (this.roundXCoordinates) {\n                    l_x = Math.rint(l_x);\n                }\n\n                l_y = x_rangeAxis.valueToJava2D((\n                        (Double) l_yValues[i]).doubleValue(), x_dataArea,\n                        l_rangeAxisLocation);\n                l_path.lineTo((float) l_y, (float) l_x);\n            }\n            l_path.closePath();\n        }\n\n        if (l_path.intersects(x_dataArea)) {\n            x_graphics.setPaint(x_positive ? getPositivePaint()\n                    : getNegativePaint());\n            x_graphics.fill(l_path);\n        }\n    }
522	public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n                return new LeafReaderFields(leaves.get(0).reader());\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = new LeafReaderFields(r);\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }
523	protected void drawVerticalCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            double x, Crosshair crosshair) {\n\n        if (x >= dataArea.getMinX() && x <= dataArea.getMaxX()) {\n            Line2D line = new Line2D.Double(x, dataArea.getMinY(), x,\n                    dataArea.getMaxY());\n            Paint savedPaint = g2.getPaint();\n            Stroke savedStroke = g2.getStroke();\n            g2.setPaint(crosshair.getPaint());\n            g2.setStroke(crosshair.getStroke());\n            g2.draw(line);\n            if (crosshair.isLabelVisible()) {\n                String label = crosshair.getLabelGenerator().generateLabel(\n                        crosshair);\n                RectangleAnchor anchor = crosshair.getLabelAnchor();\n                Point2D pt = calculateLabelPoint(line, anchor, 5, 5);\n                float xx = (float) pt.getX();\n                float yy = (float) pt.getY();\n                TextAnchor alignPt = textAlignPtForLabelAnchorV(anchor);\n                Shape hotspot = TextUtilities.calculateRotatedStringBounds(\n                        label, g2, xx, yy, alignPt, 0.0, TextAnchor.CENTER);\n                if (!dataArea.contains(hotspot.getBounds2D())) {\n                    anchor = flipAnchorH(anchor);\n                    pt = calculateLabelPoint(line, anchor, 5, 5);\n                    xx = (float) pt.getX();\n                    yy = (float) pt.getY();\n                    alignPt = textAlignPtForLabelAnchorV(anchor);\n                    hotspot = TextUtilities.calculateRotatedStringBounds(\n                           label, g2, xx, yy, alignPt, 0.0, TextAnchor.CENTER);\n                }\n                g2.setPaint(crosshair.getLabelBackgroundPaint());\n                g2.fill(hotspot);\n                g2.setPaint(crosshair.getLabelOutlinePaint());\n                g2.draw(hotspot);\n                TextUtilities.drawAlignedString(label, g2, xx, yy, alignPt);\n            }\n            g2.setPaint(savedPaint);\n            g2.setStroke(savedStroke);\n        }\n    }
524	static XMLReader createParser() {\n    try {\n      SAXParserFactory factory = SAXParserFactory.newInstance();\n      factory.setNamespaceAware(true);\n      return factory.newSAXParser().getXMLReader();\n    } catch (Exception e) {\n      throw new RuntimeException("Couldn't create XMLReader: " + e.getMessage());\n    }\n  }
525	private void compareDataInAllSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n\n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n\n            compareDataInSheet(loc1, loc2);\n        }\n    }
526	static void multiCell(Sheet sheet) {\n                Row row0 = sheet.createRow(0);\n        row0.createCell(0).setCellValue("Units");\n        row0.createCell(1).setCellValue("Cost");\n        row0.createCell(2).setCellValue("Total");\n\n        Row row1 = sheet.createRow(1);\n        row1.createCell(0).setCellValue(71);\n        row1.createCell(1).setCellValue(29);\n        row1.createCell(2).setCellValue(2059);\n\n        Row row2 = sheet.createRow(2);\n        row2.createCell(0).setCellValue(85);\n        row2.createCell(1).setCellValue(29);\n        row2.createCell(2).setCellValue(2059);\n\n        Row row3 = sheet.createRow(3);\n        row3.createCell(0).setCellValue(71);\n        row3.createCell(1).setCellValue(29);\n        row3.createCell(2).setCellValue(2059);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("$A2>75");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:C4")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(4).setCellValue("<== Condition 1: Formula Is =$B2>75   (Blue Fill)");\n    }
527	private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex, final double leniencyValue) {\n          \n        int considerPointIndex = pointIndex;\n    while (true) {\n            final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (!considerStartPoint.isNumericallyIdentical(considerEndPoint)) {\n                final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n        \n        boolean isChoiceLegal = true;\n\n                if (isChoiceLegal) {\n                    if (currentPath.lastPlane != null) {\n            if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n                                          isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n                            isChoiceLegal = false;\n            } else {\n                                                                                                                                                                                                    final Plane thirdPlane = new Plane(currentPath.previous.lastPoint, considerEndPoint);\n              if (thirdPlane.evaluateIsZero(considerStartPoint)) {\n                isChoiceLegal = false;\n              }\n            }\n          }\n        }\n        \n        if (isChoiceLegal && considerPointIndex == startPointIndex) {\n                    final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n          if (firstPlaneEndpoint == null) {\n                        isChoiceLegal = false;\n          } else {\n            if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n                            isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n                            isChoiceLegal = false;\n            } else {\n                                          final Plane thirdPlane = new Plane(considerStartPoint, firstPlaneEndpoint.lastPoint);\n              if (thirdPlane.evaluateIsZero(considerEndPoint)) {\n                isChoiceLegal = false;\n              }\n            }\n          }\n        }\n        \n        if (isChoiceLegal) {\n                    int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n          while (checkIndex != considerPointIndex) {\n            if (Math.abs(considerPlane.evaluate(points.get(checkIndex))) >= Vector.MINIMUM_RESOLUTION + leniencyValue) {\n                                                                                                  return null;\n            }\n            checkIndex = getLegalIndex(checkIndex + 1, points.size());\n          }\n        }\n        \n        if (isChoiceLegal) {\n                    if (considerPointIndex == startPointIndex) {\n                        return currentPath;\n          }\n                    final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n          final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex, leniencyValue);\n          if (result != null) {\n            return result;\n          }\n        }\n\n      }\n      \n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }
528	@SuppressWarnings("WeakerAccess")\n    public void setLineHeadWidth(DecorationSize style) {\n        CTLineProperties ln = getLn(this, true);\n        if (ln == null) {\n            return;\n        }\n        CTLineEndProperties lnEnd = ln.isSetHeadEnd() ? ln.getHeadEnd() : ln.addNewHeadEnd();\n        if (style == null) {\n            if (lnEnd.isSetW()) {\n                lnEnd.unsetW();\n            }\n        } else {\n            lnEnd.setW(STLineEndWidth.Enum.forInt(style.ooxmlId));\n        }\n    }
529	public List<String> getTextAsVector() {\n	    List<String> textV = new ArrayList<>();\n\n				int walkPos = 0;\n\n				while(walkPos != -1) {\n            walkPos = findTextRecords(walkPos,textV);\n		}\n\n				return textV;\n	}
530	public static Record [] createRecord(RecordInputStream in) {\n        Record record = createSingleRecord(in);\n        if (record instanceof DBCellRecord) {\n                        return new Record[] { null, };\n        }\n        if (record instanceof RKRecord) {\n            return new Record[] { convertToNumberRecord((RKRecord) record), };\n        }\n        if (record instanceof MulRKRecord) {\n            return convertRKRecords((MulRKRecord)record);\n        }\n        return new Record[] { record, };\n    }
531	private FieldFragList getFieldFragList( FragListBuilder fragListBuilder,\n      final FieldQuery fieldQuery, IndexReader reader, int docId,\n      Set< String > matchedFields, int fragCharSize ) throws IOException {\n    Iterator< String > matchedFieldsItr = matchedFields.iterator();\n    if ( !matchedFieldsItr.hasNext() ) {\n      throw new IllegalArgumentException( "matchedFields must contain at least on field name." );\n    }\n    FieldPhraseList[] toMerge = new FieldPhraseList[ matchedFields.size() ];\n    int i = 0;\n    while ( matchedFieldsItr.hasNext() ) {\n      FieldTermStack stack = new FieldTermStack( reader, docId, matchedFieldsItr.next(), fieldQuery );\n      toMerge[ i++ ] = new FieldPhraseList( stack, fieldQuery, phraseLimit );\n    } \n    return fragListBuilder.createFieldFragList( new FieldPhraseList( toMerge ), fragCharSize );\n  }
532	public void balance() {\n        \n    int i = 0, n = length;\n    String[] k = new String[n];\n    char[] v = new char[n];\n    Iterator iter = new Iterator();\n    while (iter.hasMoreElements()) {\n      v[i] = iter.getValue();\n      k[i++] = iter.nextElement();\n    }\n    init();\n    insertBalanced(k, v, 0, n);\n\n              }
533	private int nextIterationMarkSpanSize() throws IOException {\n    int spanSize = 0;\n    for (int i = bufferPosition; buffer.get(i) != -1 && isIterationMark((char) (buffer.get(i))); i++) {\n      spanSize++;\n    }\n        if (bufferPosition - spanSize < iterationMarkSpanEndPosition) {\n      spanSize = bufferPosition - iterationMarkSpanEndPosition;\n    }\n    return spanSize;\n  }
534	public V put(char[] text, V value) {\n    if (ignoreCase) {\n      CharacterUtils.toLowerCase(text, 0, text.length);\n    }\n    int slot = getSlot(text, 0, text.length);\n    if (keys[slot] != null) {\n      final V oldValue = values[slot];\n      values[slot] = value;\n      return oldValue;\n    }\n    keys[slot] = text;\n    values[slot] = value;\n    count++;\n\n    if (count + (count>>2) > keys.length) {\n      rehash();\n    }\n\n    return null;\n  }
535	public static TokenStream getTermVectorTokenStreamOrNull(String field, Fields tvFields, int maxStartOffset)\n      throws IOException {\n    if (tvFields == null) {\n      return null;\n    }\n    final Terms tvTerms = tvFields.terms(field);\n    if (tvTerms == null || !tvTerms.hasOffsets()) {\n      return null;\n    }\n    return new TokenStreamFromTermVector(tvTerms, maxStartOffset);\n  }
536	public String getLocalXPath() {\n        StringBuilder localXPath = new StringBuilder();\n        int numberOfCommonXPathAxis = table.getCommonXpath().split("/").length-1;\n\n        String[] xPathTokens = ctXmlColumnPr.getXpath().split("/");\n        for (int i = numberOfCommonXPathAxis; i < xPathTokens.length; i++) {\n            localXPath.append("/" + xPathTokens[i]);\n        }\n        return localXPath.toString();\n    }
537	protected PackagePart addPackagePart(PackagePart part) {\n		throwExceptionIfReadOnly();\n		if (part == null) {\n			throw new IllegalArgumentException("part");\n		}\n\n		if (partList.containsKey(part._partName)) {\n			if (!partList.get(part._partName).isDeleted()) {\n				throw new InvalidOperationException(\n						"A part with the name '"\n								+ part._partName.getName()\n								+ "' already exists : Packages shall not contain equivalent part names and package implementers shall neither create nor recognize packages with equivalent part names. [M1.12]");\n			}\n									part.setDeleted(false);\n						this.partList.remove(part._partName);\n		}\n		this.partList.put(part._partName, part);\n		this.isDirty = true;\n		return part;\n	}
538	private void bottomChanged(BytesRef lastTerm) throws IOException {\n    int oldMaxEdits = maxEdits;\n    \n        boolean termAfter = bottomTerm == null || (lastTerm != null && lastTerm.compareTo(bottomTerm) >= 0);\n\n            while (maxEdits > 0) {\n      float maxBoost = 1.0f - ((float) maxEdits / (float) termLength);\n      if (bottom < maxBoost || (bottom == maxBoost && termAfter == false)) {\n        break;\n      }\n      maxEdits--;\n    }\n\n    if (oldMaxEdits != maxEdits || lastTerm == null) {\n                        actualEnum = getAutomatonEnum(maxEdits, lastTerm);\n    }\n  }
539	public void updateNamesAfterCellShift(FormulaShifter shifter) {\n        for (int i = 0 ; i < getNumNames() ; ++i){\n            NameRecord nr = getNameRecord(i);\n            Ptg[] ptgs = nr.getNameDefinition();\n            if (shifter.adjustFormula(ptgs, nr.getSheetNumber())) {\n                nr.setNameDefinition(ptgs);\n            }\n        }\n    }
540	public SpatialArgs parse(String v, SpatialContext ctx) throws ParseException, InvalidShapeException {\n    int idx = v.indexOf('(');\n    int edx = v.lastIndexOf(')');\n\n    if (idx < 0 || idx > edx) {\n      throw new ParseException("missing parens: " + v, -1);\n    }\n\n    SpatialOperation op = SpatialOperation.get(v.substring(0, idx).trim());\n\n    String body = v.substring(idx + 1, edx).trim();\n    if (body.length() < 1) {\n      throw new ParseException("missing body : " + v, idx + 1);\n    }\n\n    Shape shape = parseShape(body, ctx);\n    SpatialArgs args = newSpatialArgs(op, shape);\n\n    if (v.length() > (edx + 1)) {\n      body = v.substring(edx + 1).trim();\n      if (body.length() > 0) {\n        Map<String, String> aa = parseMap(body);\n        readNameValuePairs(args, aa);\n        if (!aa.isEmpty()) {\n          throw new IllegalArgumentException("unused parameters: " + aa);\n        }\n      }\n    }\n    args.validate();\n    return args;\n  }
541	public void attemptPaintSelection() {\n        Paint p = this.titlePaint.getPaint();\n        Color defaultColor = (p instanceof Color ? (Color) p : Color.blue);\n        Color c = JColorChooser.showDialog(\n            this, localizationResources.getString("Title_Color"), defaultColor\n        );\n        if (c != null) {\n            this.titlePaint.setPaint(c);\n        }\n    }
542	HSSFSimpleShape createComboBox(HSSFAnchor anchor) {\n        HSSFCombobox shape = new HSSFCombobox(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
543	private void isCellFontItalicsMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        boolean b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getItalic();\n        boolean b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getItalic();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 ? "" : "NOT ")+"ITALICS",\n                (b2 ? "" : "NOT ")+"ITALICS"\n            );\n        }\n    }
544	@SuppressWarnings({"unchecked","rawtypes"})\n  private static Arc<Object>[] cacheRootArcs(FST<Object> automaton) {\n    try {\n      List<Arc<Object>> rootArcs = new ArrayList<>();\n      Arc<Object> arc = automaton.getFirstArc(new Arc<>());\n      FST.BytesReader fstReader = automaton.getBytesReader();\n      automaton.readFirstTargetArc(arc, arc, fstReader);\n      while (true) {\n        rootArcs.add(new Arc<>().copyFrom(arc));\n        if (arc.isLast()) break;\n        automaton.readNextArc(arc, fstReader);\n      }\n      \n      Collections.reverse(rootArcs);       return rootArcs.toArray(new Arc[rootArcs.size()]);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }
545	protected final CharArraySet getSnowballWordSet(ResourceLoader loader,\n      String wordFiles, boolean ignoreCase) throws IOException {\n    List<String> files = splitFileNames(wordFiles);\n    CharArraySet words = null;\n    if (files.size() > 0) {\n                  words = new CharArraySet(files.size() * 10, ignoreCase);\n      for (String file : files) {\n        InputStream stream = null;\n        Reader reader = null;\n        try {\n          stream = loader.openResource(file.trim());\n          CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n              .onMalformedInput(CodingErrorAction.REPORT)\n              .onUnmappableCharacter(CodingErrorAction.REPORT);\n          reader = new InputStreamReader(stream, decoder);\n          WordlistLoader.getSnowballWordSet(reader, words);\n        } finally {\n          IOUtils.closeWhileHandlingException(reader, stream);\n        }\n      }\n    }\n    return words;\n  }
546	private String[] getParts(String string) {\n    	String[] parts = new String[] { "", "", "" };\n    	if(string == null)\n    		return parts;\n    	\n    	    	    	    	int lAt = 0;\n    	int cAt = 0;\n    	int rAt = 0;\n    	\n    	while(\n    		    		(lAt = string.indexOf(HeaderFooterEntity_L)) > -2 &&\n    		(cAt = string.indexOf(HeaderFooterEntity_C)) > -2 &&  \n    		(rAt = string.indexOf(HeaderFooterEntity_R)) > -2 &&\n    		(lAt > -1 || cAt > -1 || rAt > -1)\n    	) {\n    		    		if(rAt > cAt && rAt > lAt) {\n        		parts[2] = string.substring(rAt + HeaderFooterEntity_R.length());\n        		string = string.substring(0, rAt);\n    		} else if(cAt > rAt && cAt > lAt) {\n        		parts[1] = string.substring(cAt + HeaderFooterEntity_C.length());\n        		string = string.substring(0, cAt);\n    		} else {\n        		parts[0] = string.substring(lAt + HeaderFooterEntity_L.length());\n        		string = string.substring(0, lAt);\n    		}\n    	}\n    	\n    	return parts;\n    }
547	protected static void preserveSpaces(STXstring xs) {\n        String text = xs.getStringValue();\n        if (text != null && text.length() > 0) {\n            char firstChar = text.charAt(0);\n            char lastChar  = text.charAt(text.length() - 1);\n            if(Character.isWhitespace(firstChar) || Character.isWhitespace(lastChar)) {\n                XmlCursor c = xs.newCursor();\n                c.toNextToken();\n                c.insertAttributeWithValue(new QName("http://www.w3.org/XML/1998/namespace", "space"), "preserve");\n                c.dispose();\n            }\n        }\n    }
548	protected int hstrcmp(char[] s, int si, char[] t, int ti) {\n    for (; s[si] == t[ti]; si++, ti++) {\n      if (s[si] == 0) {\n        return 0;\n      }\n    }\n    if (t[ti] == 0) {\n      return 0;\n    }\n    return s[si] - t[ti];\n  }
549	public Calendar parseCalendar(String str) throws ParseException {\n        if (str == null || str.isEmpty())\n      throw new IllegalArgumentException("str is null or blank");\n    Calendar cal = newCal();\n    if (str.equals("*"))\n      return cal;\n    int offset = 0;    try {\n            int lastOffset = str.charAt(str.length()-1) == 'Z' ? str.length() - 1 : str.length();\n      int hyphenIdx = str.indexOf('-', 1);      if (hyphenIdx < 0)\n        hyphenIdx = lastOffset;\n      int year = Integer.parseInt(str.substring(offset, hyphenIdx));\n      cal.set(Calendar.ERA, year <= 0 ? 0 : 1);\n      cal.set(Calendar.YEAR, year <= 0 ? -1*year + 1 : year);\n      offset = hyphenIdx + 1;\n      if (lastOffset < offset)\n        return cal;\n\n            \n            cal.set(Calendar.MONTH, Integer.parseInt(str.substring(offset, offset+2)) - 1);      offset += 3;\n      if (lastOffset < offset)\n        return cal;\n            cal.set(Calendar.DAY_OF_MONTH, Integer.parseInt(str.substring(offset, offset+2)));\n      offset += 3;\n      if (lastOffset < offset)\n        return cal;\n            cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(str.substring(offset, offset+2)));\n      offset += 3;\n      if (lastOffset < offset)\n        return cal;\n            cal.set(Calendar.MINUTE, Integer.parseInt(str.substring(offset, offset+2)));\n      offset += 3;\n      if (lastOffset < offset)\n        return cal;\n            cal.set(Calendar.SECOND, Integer.parseInt(str.substring(offset, offset+2)));\n      offset += 3;\n      if (lastOffset < offset)\n        return cal;\n            cal.set(Calendar.MILLISECOND, Integer.parseInt(str.substring(offset, offset+3)));\n      offset += 3;      if (lastOffset == offset)\n        return cal;\n    } catch (Exception e) {\n      ParseException pe = new ParseException("Improperly formatted date: "+str, offset);\n      pe.initCause(e);\n      throw pe;\n    }\n    throw new ParseException("Improperly formatted date: "+str, offset);\n  }
550	protected Size2D arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n                        Size2D s1 = arrangeNN(container, g2);\n        if (constraint.getHeightRange().contains(s1.height)) {\n            return s1;          }\n        else {\n            RectangleConstraint c = constraint.toFixedHeight(\n                constraint.getHeightRange().getUpperBound()\n            );\n            return arrangeRF(container, g2, c);\n        }\n    }
551	public static void main(String[] args) {\n    String usage = "java org.apache.lucene.demo.IndexFiles"\n                 + " [-index INDEX_PATH] [-docs DOCS_PATH] [-update]\n\n"\n                 + "This indexes the documents in DOCS_PATH, creating a Lucene index"\n                 + "in INDEX_PATH that can be searched with SearchFiles";\n    String indexPath = "index";\n    String docsPath = null;\n    boolean create = true;\n    for(int i=0;i<args.length;i++) {\n      if ("-index".equals(args[i])) {\n        indexPath = args[i+1];\n        i++;\n      } else if ("-docs".equals(args[i])) {\n        docsPath = args[i+1];\n        i++;\n      } else if ("-update".equals(args[i])) {\n        create = false;\n      }\n    }\n\n    if (docsPath == null) {\n      System.err.println("Usage: " + usage);\n      System.exit(1);\n    }\n\n    final Path docDir = Paths.get(docsPath);\n    if (!Files.isReadable(docDir)) {\n      System.out.println("Document directory '" +docDir.toAbsolutePath()+ "' does not exist or is not readable, please check the path");\n      System.exit(1);\n    }\n    \n    Date start = new Date();\n    try {\n      System.out.println("Indexing to directory '" + indexPath + "'...");\n\n      Directory dir = FSDirectory.open(Paths.get(indexPath));\n      Analyzer analyzer = new StandardAnalyzer();\n      IndexWriterConfig iwc = new IndexWriterConfig(analyzer);\n\n      if (create) {\n                        iwc.setOpenMode(OpenMode.CREATE);\n      } else {\n                iwc.setOpenMode(OpenMode.CREATE_OR_APPEND);\n      }\n\n                                    \n      IndexWriter writer = new IndexWriter(dir, iwc);\n      indexDocs(writer, docDir);\n\n                                          \n      writer.close();\n\n      Date end = new Date();\n      System.out.println(end.getTime() - start.getTime() + " total milliseconds");\n\n    } catch (IOException e) {\n      System.out.println(" caught a " + e.getClass() +\n       "\n with message: " + e.getMessage());\n    }\n  }
552	public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index < 0) {\n            throw new SeriesException("There is no existing value for the "\n                    + "specified 'period'.");\n        }\n        update(index, value);\n    }
553	public synchronized void stopUpdateThread() {\n    if (updateThread != null) {\n                        updateThread.stop.countDown();\n      try {\n        updateThread.join();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ThreadInterruptedException(e);\n      }\n      updateThread = null;\n    }\n  }
554	public static void evaluateAllFormulaCells(SXSSFWorkbook wb, boolean skipOutOfWindow) {\n        SXSSFFormulaEvaluator eval = new SXSSFFormulaEvaluator(wb);\n        \n                for (Sheet sheet : wb) {\n            if (((SXSSFSheet)sheet).areAllRowsFlushed()) {\n                throw new SheetsFlushedException();\n            }\n        }\n        \n                for (Sheet sheet : wb) {\n            \n                        int lastFlushedRowNum = ((SXSSFSheet) sheet).getLastFlushedRowNum();\n            if (lastFlushedRowNum > -1) {\n                if (! skipOutOfWindow) throw new RowFlushedException(0);\n                logger.log(POILogger.INFO, "Rows up to " + lastFlushedRowNum + " have already been flushed, skipping");\n            }\n            \n                        for (Row r : sheet) {\n                for (Cell c : r) {\n                    if (c.getCellType() == CellType.FORMULA) {\n                        eval.evaluateFormulaCell(c);\n                    }\n                }\n            }\n        }\n    }
555	private CellFormatPart getApplicableFormatPart(Object value) {\n        \n        if (value instanceof Number) {\n            \n            double val = ((Number) value).doubleValue();\n            \n            if (formatPartCount == 1) {\n                if (!posNumFmt.hasCondition()\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else {\n                    return new CellFormatPart(locale, "General");\n                }\n            } else if (formatPartCount == 2) {\n                if ((!posNumFmt.hasCondition() && val >= 0)\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else if (!negNumFmt.hasCondition()\n                        || (negNumFmt.hasCondition() && negNumFmt.applies(val))) {\n                    return negNumFmt;\n                } else {\n                                        return new CellFormatPart(QUOTE + INVALID_VALUE_FOR_FORMAT + QUOTE);\n                }\n            } else {\n                if ((!posNumFmt.hasCondition() && val > 0)\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else if ((!negNumFmt.hasCondition() && val < 0)\n                        || (negNumFmt.hasCondition() && negNumFmt.applies(val))) {\n                    return negNumFmt;\n                                } else {\n                    return zeroNumFmt;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException("value must be a Number");\n        }\n        \n    }
556	public void balancedTree(Object[] tokens, Object[] vals, int lo, int hi,\n          TernaryTreeNode root) {\n    if (lo > hi) return;\n    int mid = (lo + hi) / 2;\n    root = insert(root, (String) tokens[mid], vals[mid], 0);\n    balancedTree(tokens, vals, lo, mid - 1, root);\n    balancedTree(tokens, vals, mid + 1, hi, root);\n  }
557	public void replaceText( String newText, boolean addAfter )\n    {\n        if ( addAfter )\n        {\n            int originalEnd = getEndOffset();\n            insertAfter( newText );\n            new Range( getStartOffset(), originalEnd, this ).delete();\n        }\n        else\n        {\n            int originalStart = getStartOffset();\n            int originalEnd = getEndOffset();\n\n            insertBefore( newText );\n            new Range( originalStart + newText.length(), originalEnd\n                    + newText.length(), this ).delete();\n        }\n    }
558	public List<PackagePart> getPartsByName(final Pattern namePattern) {\n	    if (namePattern == null) {\n	        throw new IllegalArgumentException("name pattern must not be null");\n	    }\n	    Matcher matcher = namePattern.matcher("");\n	    ArrayList<PackagePart> result = new ArrayList<>();\n	    for (PackagePart part : partList.sortedValues()) {\n	        PackagePartName partName = part.getPartName();\n	        if (matcher.reset(partName.getName()).matches()) {\n	            result.add(part);\n	        }\n	    }\n	    return result;\n	}
559	private static void centerAcrossSelection(XSSFWorkbook wb, XSSFRow row,\n            int start_column, int end_column, VerticalAlignment valign) {\n        CreationHelper ch = wb.getCreationHelper();\n\n                XSSFCellStyle cellStyle = wb.createCellStyle();\n        cellStyle.setAlignment(HorizontalAlignment.CENTER_SELECTION);\n        cellStyle.setVerticalAlignment(valign);\n\n                for (int i = start_column; i <= end_column; i++) {\n            XSSFCell cell = row.createCell(i);\n            cell.setCellStyle(cellStyle);\n        }\n\n                XSSFCell cell = row.getCell(start_column);\n        cell.setCellValue(ch.createRichTextString("Align It"));\n\n                CTRowImpl ctRow = (CTRowImpl) row.getCTRow();\n\n                                        Object span = start_column + ":" + end_column;\n\n        List<Object> spanList = new ArrayList<>();\n        spanList.add(span);\n\n                ctRow.setSpans(spanList);\n    }
560	private void doQueryFirstScoring(Bits acceptDocs, LeafCollector collector, DocsAndCost[] dims) throws IOException {\n                int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      if (acceptDocs != null && acceptDocs.get(docID) == false) {\n        docID = baseIterator.nextDoc();\n        continue;\n      }\n      LeafCollector failedCollector = null;\n      for (DocsAndCost dim : dims) {\n                        if (dim.approximation.docID() < docID) {\n          dim.approximation.advance(docID);\n        }\n\n        boolean matches = false;\n        if (dim.approximation.docID() == docID) {\n          if (dim.twoPhase == null) {\n            matches = true;\n          } else {\n            matches = dim.twoPhase.matches();\n          }\n        }\n\n        if (matches == false) {\n          if (failedCollector != null) {\n                                                docID = baseIterator.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = dim.sidewaysLeafCollector;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n                  collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n                collectHit(collector, dims);\n      } else {\n                collectNearMiss(failedCollector);\n      }\n\n      docID = baseIterator.nextDoc();\n    }\n  }
561	private void finishCurrentState() {\n    int numTransitions = states[2*curState+1];\n    assert numTransitions > 0;\n\n    int offset = states[2*curState];\n    int start = offset/3;\n    destMinMaxSorter.sort(start, start+numTransitions);\n\n        int upto = 0;\n    int min = -1;\n    int max = -1;\n    int dest = -1;\n\n    for(int i=0;i<numTransitions;i++) {\n      int tDest = transitions[offset+3*i];\n      int tMin = transitions[offset+3*i+1];\n      int tMax = transitions[offset+3*i+2];\n\n      if (dest == tDest) {\n        if (tMin <= max+1) {\n          if (tMax > max) {\n            max = tMax;\n          }\n        } else {\n          if (dest != -1) {\n            transitions[offset+3*upto] = dest;\n            transitions[offset+3*upto+1] = min;\n            transitions[offset+3*upto+2] = max;\n            upto++;\n          }\n          min = tMin;\n          max = tMax;\n        }\n      } else {\n        if (dest != -1) {\n          transitions[offset+3*upto] = dest;\n          transitions[offset+3*upto+1] = min;\n          transitions[offset+3*upto+2] = max;\n          upto++;\n        }\n        dest = tDest;\n        min = tMin;\n        max = tMax;\n      }\n    }\n\n    if (dest != -1) {\n            transitions[offset+3*upto] = dest;\n      transitions[offset+3*upto+1] = min;\n      transitions[offset+3*upto+2] = max;\n      upto++;\n    }\n\n    nextTransition -= (numTransitions-upto)*3;\n    states[2*curState+1] = upto;\n\n        minMaxDestSorter.sort(start, start+upto);\n\n    if (deterministic && upto > 1) {\n      int lastMax = transitions[offset+2];\n      for(int i=1;i<upto;i++) {\n        min = transitions[offset + 3*i + 1];\n        if (min <= lastMax) {\n          deterministic = false;\n          break;\n        }\n        lastMax = transitions[offset + 3*i + 2];\n      }\n    }\n  }
562	public void addDataset(ValueDataset dataset, MeterNeedle needle) {\n\n        if (dataset != null) {\n            int i = this.datasets.length + 1;\n            ValueDataset[] t = new ValueDataset[i];\n            MeterNeedle[] p = new MeterNeedle[i];\n            i = i - 2;\n            for (; i >= 0; --i) {\n                t[i] = this.datasets[i];\n                p[i] = this.seriesNeedle[i];\n            }\n            i = this.datasets.length;\n            t[i] = dataset;\n            p[i] = ((needle != null) ? needle : p[i - 1]);\n\n            ValueDataset[] a = this.datasets;\n            MeterNeedle[] b = this.seriesNeedle;\n            this.datasets = t;\n            this.seriesNeedle = p;\n\n            for (--i; i >= 0; --i) {\n                a[i] = null;\n                b[i] = null;\n            }\n            dataset.addChangeListener(this);\n        }\n    }
563	public int stem(char text[], int length, boolean stemDerivational) {\n    flags = 0;\n    numSyllables = 0;\n    for (int i = 0; i < length; i++)\n      if (isVowel(text[i]))\n          numSyllables++;\n    \n    if (numSyllables > 2) length = removeParticle(text, length);\n    if (numSyllables > 2) length = removePossessivePronoun(text, length);\n    \n    if (stemDerivational)\n      length = stemDerivational(text, length);\n    return length;\n  }
564	private void updateBounds() {\n        this.maximumRangeValue = Double.NaN;\n        this.maximumRangeValueRow = -1;\n        this.maximumRangeValueColumn = -1;\n        this.minimumRangeValue = Double.NaN;\n        this.minimumRangeValueRow = -1;\n        this.minimumRangeValueColumn = -1;\n        this.maximumRangeValueIncStdDev = Double.NaN;\n        this.maximumRangeValueIncStdDevRow = -1;\n        this.maximumRangeValueIncStdDevColumn = -1;\n        this.minimumRangeValueIncStdDev = Double.NaN;\n        this.minimumRangeValueIncStdDevRow = -1;\n        this.minimumRangeValueIncStdDevColumn = -1;\n\n        int rowCount = this.data.getRowCount();\n        int columnCount = this.data.getColumnCount();\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                MeanAndStandardDeviation masd = (MeanAndStandardDeviation)\n                        this.data.getObject(r, c);\n                if (masd == null) {\n                    continue;\n                }\n                double m = masd.getMeanValue();\n                double sd = masd.getStandardDeviationValue();\n\n                if (!Double.isNaN(m)) {\n\n                                        if (Double.isNaN(this.maximumRangeValue)) {\n                        this.maximumRangeValue = m;\n                        this.maximumRangeValueRow = r;\n                        this.maximumRangeValueColumn = c;\n                    }\n                    else {\n                        if (m > this.maximumRangeValue) {\n                            this.maximumRangeValue = m;\n                            this.maximumRangeValueRow = r;\n                            this.maximumRangeValueColumn = c;\n                        }\n                    }\n\n                                        if (Double.isNaN(this.minimumRangeValue)) {\n                        this.minimumRangeValue = m;\n                        this.minimumRangeValueRow = r;\n                        this.minimumRangeValueColumn = c;\n                    }\n                    else {\n                        if (m < this.minimumRangeValue) {\n                            this.minimumRangeValue = m;\n                            this.minimumRangeValueRow = r;\n                            this.minimumRangeValueColumn = c;\n                        }\n                    }\n\n                    if (!Double.isNaN(sd)) {\n                                                if (Double.isNaN(this.maximumRangeValueIncStdDev)) {\n                            this.maximumRangeValueIncStdDev = m + sd;\n                            this.maximumRangeValueIncStdDevRow = r;\n                            this.maximumRangeValueIncStdDevColumn = c;\n                        }\n                        else {\n                            if (m + sd > this.maximumRangeValueIncStdDev) {\n                                this.maximumRangeValueIncStdDev = m + sd;\n                                this.maximumRangeValueIncStdDevRow = r;\n                                this.maximumRangeValueIncStdDevColumn = c;\n                            }\n                        }\n\n                                                if (Double.isNaN(this.minimumRangeValueIncStdDev)) {\n                            this.minimumRangeValueIncStdDev = m - sd;\n                            this.minimumRangeValueIncStdDevRow = r;\n                            this.minimumRangeValueIncStdDevColumn = c;\n                        }\n                        else {\n                            if (m - sd < this.minimumRangeValueIncStdDev) {\n                                this.minimumRangeValueIncStdDev = m - sd;\n                                this.minimumRangeValueIncStdDevRow = r;\n                                this.minimumRangeValueIncStdDevColumn = c;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }
565	public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n            reader = (LeafReader) readerIn;\n    } else {\n            List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException("the reader must be a SegmentReader or composite reader containing only SegmentReaders");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n                \n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n                                    changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }
566	private void caseFoldTitle(char word[], int length) {\n    titleBuffer = ArrayUtil.grow(titleBuffer, length);\n    System.arraycopy(word, 0, titleBuffer, 0, length);\n    for (int i = 1; i < length; i++) {\n      titleBuffer[i] = dictionary.caseFold(titleBuffer[i]);\n    }\n  }
567	public static double getColumnWidth(Sheet sheet, int column, boolean useMergedCells, int firstRow, int lastRow){\n        DataFormatter formatter = new DataFormatter();\n        int defaultCharWidth = getDefaultCharWidth(sheet.getWorkbook());\n\n        double width = -1;\n        for (int rowIdx = firstRow; rowIdx <= lastRow; ++rowIdx) {\n            Row row = sheet.getRow(rowIdx);\n            if( row != null ) {\n                double cellWidth = getColumnWidthForRow(row, column, defaultCharWidth, formatter, useMergedCells);\n                width = Math.max(width, cellWidth);\n            }\n        }\n        return width;\n    }
568	public synchronized long flush(int atLeastMarkerCount) throws IOException {\n    assert isPrimary;\n    try (Connection c = new Connection(tcpPort)) {\n      c.out.writeByte(SimplePrimaryNode.CMD_FLUSH);\n      c.out.writeVInt(atLeastMarkerCount);\n      c.flush();\n      c.s.shutdownOutput();\n      return c.in.readLong();\n    }\n  }
569	protected CTOleObject readOleObject(long shapeId) {\n        if (!getCTWorksheet().isSetOleObjects()) {\n            return null;\n        }\n\n                String xquery = "declare namespace p='"+XSSFRelation.NS_SPREADSHEETML+"' .//p:oleObject";\n        XmlCursor cur = getCTWorksheet().getOleObjects().newCursor();\n        try {\n            cur.selectPath(xquery);\n            CTOleObject coo = null;\n            while (cur.toNextSelection()) {\n                String sId = cur.getAttributeText(new QName(null, "shapeId"));\n                if (sId == null || Long.parseLong(sId)  != shapeId) {\n                    continue;\n                }\n\n                XmlObject xObj = cur.getObject();\n                if (xObj instanceof CTOleObject) {\n                                        coo = (CTOleObject)xObj;\n                } else {\n                    XMLStreamReader reader = cur.newXMLStreamReader();\n                    try {\n                        CTOleObjects coos = CTOleObjects.Factory.parse(reader);\n                        if (coos.sizeOfOleObjectArray() == 0) {\n                            continue;\n                        }\n                        coo = coos.getOleObjectArray(0);\n                    } catch (XmlException e) {\n                        logger.log(POILogger.INFO, "can't parse CTOleObjects", e);\n                    } finally {\n                        try {\n                            reader.close();\n                        } catch (XMLStreamException e) {\n                            logger.log(POILogger.INFO, "can't close reader", e);\n                        }\n                    }\n                }\n\n                                                if (cur.toChild(XSSFRelation.NS_SPREADSHEETML, "objectPr")) {\n                    break;\n                }\n            }\n            return (coo == null) ? null : coo;\n        } finally {\n            cur.dispose();\n        }\n    }
570	public ValueEval evaluate(String formula, CellReference ref) {\n        final String sheetName = ref == null ? null : ref.getSheetName();\n        int sheetIndex;\n        if (sheetName == null) {\n            sheetIndex = -1;         } else {\n            sheetIndex = getWorkbook().getSheetIndex(sheetName);\n        }\n        int rowIndex = ref == null ? -1 : ref.getRow();\n        short colIndex = ref == null ? -1 : ref.getCol();\n        final OperationEvaluationContext ec = new OperationEvaluationContext(\n                this, \n                getWorkbook(), \n                sheetIndex, \n                rowIndex, \n                colIndex, \n                new EvaluationTracker(_cache)\n            );\n        Ptg[] ptgs = FormulaParser.parse(formula, (FormulaParsingWorkbook) getWorkbook(), FormulaType.CELL, sheetIndex, rowIndex);\n        return evaluateNameFormula(ptgs, ec);\n    }
571	Query makeIntersects(Rectangle bbox) {\n\n        \n        \n        Query qHasEnv;\n    if (ctx.isGeo()) {\n      Query qIsNonXDL = this.makeXDL(false);\n      Query qIsXDL = ctx.isGeo() ? this.makeXDL(true) : null;\n      qHasEnv = this.makeQuery(BooleanClause.Occur.SHOULD, qIsNonXDL, qIsXDL);\n    } else {\n      qHasEnv = this.makeXDL(false);\n    }\n\n    BooleanQuery.Builder qNotDisjoint = new BooleanQuery.Builder();\n    qNotDisjoint.add(qHasEnv, BooleanClause.Occur.MUST);\n    Query qDisjoint = makeDisjoint(bbox);\n    qNotDisjoint.add(qDisjoint, BooleanClause.Occur.MUST_NOT);\n\n                    return qNotDisjoint.build();\n  }
572	public static Font makeFont(HSSFFont font) {\n    boolean isbold = font.getBold();\n    boolean isitalics = font.getItalic();\n    int fontstyle = Font.PLAIN;\n    if (isbold) {\n      fontstyle = Font.BOLD;\n    }\n    if (isitalics) {\n      fontstyle = fontstyle | Font.ITALIC;\n    }\n\n    int fontheight = font.getFontHeightInPoints();\n    if (fontheight == 9) {\n            fontheight = 10;\n    }\n\n    return new Font(font.getFontName(), fontstyle, fontheight);\n  }
573	public void addThumbnail(String filename, InputStream data) throws IOException {\n                if (filename == null || filename.isEmpty()) {\n            throw new IllegalArgumentException("filename");\n        }\n\n                String contentType = ContentTypes\n                .getContentTypeFromFileExtension(filename);\n        PackagePartName thumbnailPartName;\n        try {\n            thumbnailPartName = PackagingURIHelper.createPartName("/docProps/"\n                    + filename);\n        } catch (InvalidFormatException e) {\n            String partName = "/docProps/thumbnail" +\n                    filename.substring(filename.lastIndexOf(".") + 1);\n            try {\n                thumbnailPartName = PackagingURIHelper.createPartName(partName);\n            } catch (InvalidFormatException e2) {\n                throw new InvalidOperationException(\n                        "Can't add a thumbnail file named '" + filename + "'", e2);\n            }\n        }\n\n                if (this.getPart(thumbnailPartName) != null) {\n            throw new InvalidOperationException(\n                    "You already add a thumbnail named '" + filename + "'");\n        }\n\n                PackagePart thumbnailPart = this.createPart(thumbnailPartName,\n                contentType, false);\n\n                this.addRelationship(thumbnailPartName, TargetMode.INTERNAL,\n                PackageRelationshipTypes.THUMBNAIL);\n\n                StreamHelper.copyStream(data, thumbnailPart.getOutputStream());\n    }
574	protected short processRecord(Record rec) throws HSSFUserException {\n		List<HSSFListener> listeners = _records.get(Short.valueOf(rec.getSid()));\n		short userCode = 0;\n\n		if (listeners != null) {\n\n			for (int k = 0; k < listeners.size(); k++) {\n				Object listenObj = listeners.get(k);\n				if (listenObj instanceof AbortableHSSFListener) {\n					AbortableHSSFListener listener = (AbortableHSSFListener) listenObj;\n					userCode = listener.abortableProcessRecord(rec);\n					if (userCode != 0)\n						break;\n				} else {\n					HSSFListener listener = (HSSFListener) listenObj;\n					listener.processRecord(rec);\n				}\n			}\n		}\n		return userCode;\n	}
575	public void updateColumnWidths(Row row) {\n                implicitlyTrackColumnsInRow(row);\n        \n                                if (maxColumnWidths.size() < row.getPhysicalNumberOfCells()) {\n                        for (final Entry<Integer, ColumnWidthPair> e : maxColumnWidths.entrySet()) {\n                final int column = e.getKey();\n                final Cell cell = row.getCell(column); \n                                \n                                \n                if (cell != null) {\n                    final ColumnWidthPair pair = e.getValue();\n                    updateColumnWidth(cell, pair);\n                }\n            }\n        }\n        else {\n                        for (final Cell cell : row) {\n                final int column = cell.getColumnIndex();\n\n                                \n                                \n                if (maxColumnWidths.containsKey(column)) {\n                    final ColumnWidthPair pair = maxColumnWidths.get(column);\n                    updateColumnWidth(cell, pair);\n                }\n            }\n        }\n    }
576	public static void optimiseCellStyles(HSSFWorkbook workbook) {\n                     short[] newPos = new short[workbook.getWorkbook().getNumExFormats()];\n       boolean[] isUsed = new boolean[newPos.length];\n       boolean[] zapRecords = new boolean[newPos.length];\n       for(int i=0; i<newPos.length; i++) {\n           isUsed[i] = false;\n           newPos[i] = (short)i;\n           zapRecords[i] = false;\n       }\n\n                     ExtendedFormatRecord[] xfrs = new ExtendedFormatRecord[newPos.length];\n       for(int i=0; i<newPos.length; i++) {\n           xfrs[i] = workbook.getWorkbook().getExFormatAt(i);\n       }\n\n	   	   	   	   	   	   for (int i = 21; i < newPos.length; i++) {\n		   		   		   int earlierDuplicate = -1;\n		   for (int j = 0; j < i && earlierDuplicate == -1; j++) {\n			   ExtendedFormatRecord xfCheck = workbook.getWorkbook().getExFormatAt(j);\n			   if (xfCheck.equals(xfrs[i]) &&\n					   					   !isUserDefined(workbook, j)) {\n				   earlierDuplicate = j;\n			   }\n		   }\n\n                      if(earlierDuplicate != -1) {\n               newPos[i] = (short)earlierDuplicate;\n               zapRecords[i] = true;\n           }\n       }\n\n	   	   	   for (int sheetNum = 0; sheetNum < workbook.getNumberOfSheets(); sheetNum++) {\n		   HSSFSheet s = workbook.getSheetAt(sheetNum);\n		   for (Row row : s) {\n			   for (Cell cellI : row) {\n				   HSSFCell cell = (HSSFCell) cellI;\n				   short oldXf = cell.getCellValueRecord().getXFIndex();\n				   				   if(oldXf < newPos.length) {\n					   isUsed[oldXf] = true;\n				   }\n			   }\n\n			   			   short oldXf = ((HSSFRow) row).getRowRecord().getXFIndex();\n			   			   if(oldXf < newPos.length) {\n				   isUsed[oldXf] = true;\n			   }\n		   }\n\n		   		   for (int col = s.getSheet().getMinColumnIndex(); col <= s.getSheet().getMaxColumnIndex(); col++) {\n			   short oldXf = s.getSheet().getXFIndexForColAt((short) col);\n			   			   if(oldXf < newPos.length) {\n				   isUsed[oldXf] = true;\n			   }\n		   }\n	   }\n\n	   	   for (int i = 21; i < isUsed.length; i++) {\n		   		   if (isUserDefined(workbook, i)) {\n			   isUsed[i] = true;\n		   }\n\n		   		   if(newPos[i] != i && isUsed[i]) {\n		   		isUsed[newPos[i]] = true;\n		   }\n	   }\n\n              for (int i=21; i<isUsed.length; i++) {\n           if (! isUsed[i]) {\n                              zapRecords[i] = true;\n               newPos[i] = 0;\n           }\n       }\n\n                                   for(int i=21; i<newPos.length; i++) {\n                                 short preDeletePos = newPos[i];\n           short newPosition = preDeletePos;\n           for(int j=0; j<preDeletePos; j++) {\n               if(zapRecords[j]) newPosition--;\n           }\n\n		   		   newPos[i] = newPosition;\n		   		   if (i != newPosition && newPosition != 0) {\n			   workbook.getWorkbook().updateStyleRecord(i, newPosition);\n\n			   ExtendedFormatRecord exFormat = workbook.getWorkbook().getExFormatAt(i);\n			   short oldParent = exFormat.getParentIndex();\n			   			   if(oldParent < newPos.length) {\n				   short newParent = newPos[oldParent];\n				   exFormat.setParentIndex(newParent);\n			   }\n		   }\n	   }\n\n                            int max = newPos.length;\n       int removed = 0;        for(int i=21; i<max; i++) {\n           if(zapRecords[i + removed]) {\n               workbook.getWorkbook().removeExFormatRecord(i);\n               i--;\n               max--;\n               removed++;\n           }\n       }\n\n	   	   for (int sheetNum = 0; sheetNum < workbook.getNumberOfSheets(); sheetNum++) {\n		   HSSFSheet s = workbook.getSheetAt(sheetNum);\n		   for (Row row : s) {\n			   for (Cell cell : row) {\n				   short oldXf = ((HSSFCell) cell).getCellValueRecord().getXFIndex();\n				   				   if(oldXf >= newPos.length) {\n				   		continue;\n				   }\n				   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n				   cell.setCellStyle(newStyle);\n			   }\n\n			   			   short oldXf = ((HSSFRow) row).getRowRecord().getXFIndex();\n			   			   if(oldXf >= newPos.length) {\n				   continue;\n			   }\n			   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n			   row.setRowStyle(newStyle);\n		   }\n\n		   		   for (int col = s.getSheet().getMinColumnIndex(); col <= s.getSheet().getMaxColumnIndex(); col++) {\n			   short oldXf = s.getSheet().getXFIndexForColAt((short) col);\n			   			   if(oldXf >= newPos.length) {\n				   continue;\n			   }\n			   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n			   s.setDefaultColumnStyle(col, newStyle);\n		   }\n	   }\n   }
577	public void convertExcelToCSV(String strSource, String strDestination,\n                                  String separator, int formattingConvention)\n                       throws FileNotFoundException, IOException,\n                              IllegalArgumentException {\n        File source = new File(strSource);\n        File destination = new File(strDestination);\n        File[] filesList;\n        String destinationFilename;\n\n                if(!source.exists()) {\n            throw new IllegalArgumentException("The source for the Excel " +\n                    "file(s) cannot be found.");\n        }\n\n                                if(!destination.exists()) {\n            throw new IllegalArgumentException("The folder/directory for the " +\n                    "converted CSV file(s) does not exist.");\n        }\n        if(!destination.isDirectory()) {\n            throw new IllegalArgumentException("The destination for the CSV " +\n                    "file(s) is not a directory/folder.");\n        }\n\n                        if(formattingConvention != ToCSV.EXCEL_STYLE_ESCAPING &&\n           formattingConvention != ToCSV.UNIX_STYLE_ESCAPING) {\n            throw new IllegalArgumentException("The value passed to the " +\n                    "formattingConvention parameter is out of range.");\n        }\n\n                        this.separator = separator;\n        this.formattingConvention = formattingConvention;\n\n                        if(source.isDirectory()) {\n                                    filesList = source.listFiles(new ExcelFilenameFilter());\n        }\n        else {\n                                                filesList = new File[]{source};\n        }\n\n                                                                                                if (filesList != null) {\n            for(File excelFile : filesList) {\n                                this.openWorkbook(excelFile);\n    \n                                this.convertToCSV();\n    \n                                                destinationFilename = excelFile.getName();\n                destinationFilename = destinationFilename.substring(\n                        0, destinationFilename.lastIndexOf(".")) +\n                        ToCSV.CSV_FILE_EXTENSION;\n    \n                                                this.saveCSVFile(new File(destination, destinationFilename));\n            }\n        }\n    }
578	private synchronized long flushBuffer() throws IOException {\n    long pos = channel.position();\n    int len = (int) buffer.getFilePointer();\n    byte[] bytes = new byte[len];\n    buffer.writeTo(bytes, 0);\n    buffer.reset();\n\n    intBuffer[0] = (byte) (len >> 24);\n    intBuffer[1] = (byte) (len >> 16);\n    intBuffer[2] = (byte) (len >> 8);\n    intBuffer[3] = (byte) len;\n    intByteBuffer.limit(4);\n    intByteBuffer.position(0);\n\n    writeBytesToChannel(intByteBuffer);\n    writeBytesToChannel(ByteBuffer.wrap(bytes));\n\n    return pos;\n  }
579	private void addRow(HSSFRow row, boolean addLow) {\n        _rows.put(Integer.valueOf(row.getRowNum()), row);\n        if (addLow) {\n            _sheet.addRow(row.getRowRecord());\n        }\n        boolean firstRow = _rows.size() == 1;\n        if (row.getRowNum() > getLastRowNum() || firstRow) {\n            _lastrow = row.getRowNum();\n        }\n        if (row.getRowNum() < getFirstRowNum() || firstRow) {\n            _firstrow = row.getRowNum();\n        }\n    }
580	private Date correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position) {\n        Date result = time;\n        switch (unit.getUnit()) {\n            case DateTickUnit.MILLISECOND :\n            case DateTickUnit.SECOND :\n            case DateTickUnit.MINUTE :\n            case DateTickUnit.HOUR :\n            case DateTickUnit.DAY :\n                break;\n            case DateTickUnit.MONTH :\n                result = calculateDateForPosition(new Month(time,\n                        this.timeZone, this.locale), position);\n                break;\n            case DateTickUnit.YEAR :\n                result = calculateDateForPosition(new Year(time,\n                        this.timeZone, this.locale), position);\n                break;\n\n            default: break;\n        }\n        return result;\n    }
581	public static ParsePathType pathType(Path f) {\n    int pathLength = 0;\n    while (f != null && f.getFileName() != null && ++pathLength < MAX_PATH_LENGTH) {\n      ParsePathType ppt = pathName2Type.get(f.getFileName().toString().toUpperCase(Locale.ROOT));\n      if (ppt!=null) {\n        return ppt;\n      }\n      f = f.getParent();\n    }\n    return DEFAULT_PATH_TYPE;\n  }
582	public void build(InputIterator iterator, double ramBufferSizeMB) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException("this suggester doesn't support payloads");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException("this suggester doesn't support contexts");\n    }\n\n    String prefix = getClass().getSimpleName();\n    Path tempIndexPath = Files.createTempDirectory(prefix + ".index.");\n\n    Directory dir = FSDirectory.open(tempIndexPath);\n\n    IndexWriterConfig iwc = new IndexWriterConfig(indexAnalyzer);\n    iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n    iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n    IndexWriter writer = new IndexWriter(dir, iwc);\n\n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    ft.setOmitNorms(true);\n    ft.freeze();\n\n    Document doc = new Document();\n    Field field = new Field("body", "", ft);\n    doc.add(field);\n\n    totTokens = 0;\n    IndexReader reader = null;\n\n    boolean success = false;\n    count = 0;\n    try {\n      while (true) {\n        BytesRef surfaceForm = iterator.next();\n        if (surfaceForm == null) {\n          break;\n        }\n        field.setStringValue(surfaceForm.utf8ToString());\n        writer.addDocument(doc);\n        count++;\n      }\n      reader = DirectoryReader.open(writer);\n\n      Terms terms = MultiFields.getTerms(reader, "body");\n      if (terms == null) {\n        throw new IllegalArgumentException("need at least one suggestion");\n      }\n\n            TermsEnum termsEnum = terms.iterator();\n\n      Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n      Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      while (true) {\n        BytesRef term = termsEnum.next();\n        if (term == null) {\n          break;\n        }\n        int ngramCount = countGrams(term);\n        if (ngramCount > grams) {\n          throw new IllegalArgumentException("tokens must not contain separator byte; got token=" + term + " but gramCount=" + ngramCount + ", which is greater than expected max ngram size=" + grams);\n        }\n        if (ngramCount == 1) {\n          totTokens += termsEnum.totalTermFreq();\n        }\n\n        builder.add(Util.toIntsRef(term, scratchInts), encodeWeight(termsEnum.totalTermFreq()));\n      }\n\n      fst = builder.finish();\n      if (fst == null) {\n        throw new IllegalArgumentException("need at least one suggestion");\n      }\n      \n      "/x/tmp/out.dot"\n\n                        writer.rollback();\n      success = true;\n    } finally {\n      try {\n        if (success) {\n          IOUtils.close(reader, dir);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, writer, dir);\n        }\n      } finally {\n        IOUtils.rm(tempIndexPath);\n      }\n    }\n  }
583	@SuppressWarnings("WeakerAccess")\n	public HSLFSlide removeSlide(int index) {\n		int lastSlideIdx = _slides.size() - 1;\n		if (index < 0 || index > lastSlideIdx) {\n			throw new IllegalArgumentException("Slide index (" + index + ") is out of range (0.."\n					+ lastSlideIdx + ")");\n		}\n\n		SlideListWithText slwt = _documentRecord.getSlideSlideListWithText();\n		if (slwt == null) {\n			throw new IllegalStateException("Slide record not defined.");\n		}\n		SlideAtomsSet[] sas = slwt.getSlideAtomsSets();\n\n		List<Record> records = new ArrayList<>();\n		List<SlideAtomsSet> sa = new ArrayList<>(Arrays.asList(sas));\n\n		HSLFSlide removedSlide = _slides.remove(index);\n		_notes.remove(removedSlide.getNotes());\n		sa.remove(index);\n\n		int i=0;\n		for (HSLFSlide s : _slides) {\n            s.setSlideNumber(i++);\n        }\n\n		for (SlideAtomsSet s : sa) {\n            records.add(s.getSlidePersistAtom());\n            records.addAll(Arrays.asList(s.getSlideRecords()));\n		}\n		if (sa.isEmpty()) {\n			_documentRecord.removeSlideListWithText(slwt);\n		} else {\n			slwt.setSlideAtomsSets(sa.toArray(new SlideAtomsSet[0]));\n			slwt.setChildRecord(records.toArray(new Record[0]));\n		}\n\n		\n        int notesId = removedSlide.getSlideRecord().getSlideAtom().getNotesID();\n		if (notesId != 0) {\n			SlideListWithText nslwt = _documentRecord.getNotesSlideListWithText();\n			records = new ArrayList<>();\n			ArrayList<SlideAtomsSet> na = new ArrayList<>();\n			if (nslwt != null) {\n				for (SlideAtomsSet ns : nslwt.getSlideAtomsSets()) {\n					if (ns.getSlidePersistAtom().getSlideIdentifier() == notesId) {\n						continue;\n					}\n					na.add(ns);\n					records.add(ns.getSlidePersistAtom());\n					if (ns.getSlideRecords() != null) {\n						records.addAll(Arrays.asList(ns.getSlideRecords()));\n					}\n				}\n\n				if (!na.isEmpty()) {\n					nslwt.setSlideAtomsSets(na.toArray(new SlideAtomsSet[0]));\n					nslwt.setChildRecord(records.toArray(new Record[0]));\n				}\n			}\n			if (na.isEmpty()) {\n				_documentRecord.removeSlideListWithText(nslwt);\n			}\n		}\n\n		return removedSlide;\n	}
584	private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n        final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    double maxArcDistance = points.get(0).arcDistance(points.get(1));\n    double trialArcDistance = points.get(0).arcDistance(points.get(2));\n    if (trialArcDistance > maxArcDistance) {\n      maxArcDistance = trialArcDistance;\n    }\n    final double arcDistance = maxArcDistance - generator.nextDouble() * maxArcDistance;\n        final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n        final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n                                                                                    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n        return planetModel.createSurfacePoint(x2, y2, z2);\n  }
585	public static DocumentBuilderFactory getDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setExpandEntityReferences(false);\n        trySetSAXFeature(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        trySetSAXFeature(factory, "http://xml.org/sax/features/external-general-entities", false);\n        trySetSAXFeature(factory, "http://xml.org/sax/features/external-parameter-entities", false);\n        trySetSAXFeature(factory, "http://apache.org/xml/features/nonvalidating/load-external-dtd", false);\n        trySetSAXFeature(factory, "http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false);\n        return factory;\n    }
586	protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n                final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n            return NO_POINTS;\n    }\n\n                                                                                double x0;\n    double y0;\n    double z0;\n        final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n            if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n            if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n            if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n                                final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n            return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n            final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n            final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n            return NO_POINTS;\n    }\n  }
587	public static void transformCriteria(Properties formProperties, InputStream xslIs, Result result)\n      throws SAXException, IOException, ParserConfigurationException, TransformerException {\n    dbf.setNamespaceAware(true);\n    DocumentBuilder builder = dbf.newDocumentBuilder();\n    org.w3c.dom.Document xslDoc = builder.parse(xslIs);\n    DOMSource ds = new DOMSource(xslDoc);\n\n    Transformer transformer = null;\n    synchronized (tFactory) {\n      transformer = tFactory.newTransformer(ds);\n    }\n    transformCriteria(formProperties, transformer, result);\n  }
588	private StrokeLineCap awtToJavaFXLineCap(int c) {\n        if (c == BasicStroke.CAP_BUTT) {\n            return StrokeLineCap.BUTT;\n        } else if (c == BasicStroke.CAP_ROUND) {\n            return StrokeLineCap.ROUND;\n        } else if (c == BasicStroke.CAP_SQUARE) {\n            return StrokeLineCap.SQUARE;\n        } else {\n            throw new IllegalArgumentException("Unrecognised cap code: " + c);\n        }\n    }
589	public Data transform(Data data, XMLCryptoContext context) throws TransformException {\n        LOG.log(POILogger.DEBUG, "transform(data,context)");\n        LOG.log(POILogger.DEBUG, "data java type: " + data.getClass().getName());\n        OctetStreamData octetStreamData = (OctetStreamData) data;\n        LOG.log(POILogger.DEBUG, "URI: " + octetStreamData.getURI());\n        InputStream octetStream = octetStreamData.getOctetStream();\n        \n        Document doc;\n        try {\n            doc = DocumentHelper.readDocument(octetStream);\n        } catch (Exception e) {\n            throw new TransformException(e.getMessage(), e);\n        }\n        \n                Element root = doc.getDocumentElement();\n        NodeList nl = root.getChildNodes();\n        TreeMap<String,Element> rsList = new TreeMap<>();\n        for (int i=nl.getLength()-1; i>=0; i--) {\n            Node n = nl.item(i);\n            if ("Relationship".equals(n.getLocalName())) {\n                Element el = (Element)n;\n                String id = el.getAttribute("Id");\n                if (sourceIds.contains(id)) {\n                    String targetMode = el.getAttribute("TargetMode");\n                    if (targetMode == null || targetMode.isEmpty()) {\n                        el.setAttribute("TargetMode", "Internal");\n                    }\n                    rsList.put(id, el);\n                }\n            }\n            root.removeChild(n);\n        }\n\n        for (Element el : rsList.values()) {\n            root.appendChild(el);\n        }\n        \n        LOG.log(POILogger.DEBUG, "# Relationship elements: ", rsList.size());\n        \n        return new ApacheNodeSetData(new XMLSignatureInput(root));\n    }
590	public static short[] getShortArray( byte[] data, int offset, int size )\n    {\n        short[] result = new short[size / SHORT_SIZE];\n        for ( int i = 0; i < result.length; i++ )\n        {\n            result[i] = getShort( data, offset + i * SHORT_SIZE );\n        }\n        return result;\n    }
591	static Boolean parseBoolean(String strRep) {\n        if (strRep.length() < 1) {\n            return null;\n        }\n        switch(strRep.charAt(0)) {\n            case 't':\n            case 'T':\n                if("TRUE".equalsIgnoreCase(strRep)) {\n                    return Boolean.TRUE;\n                }\n                break;\n            case 'f':\n            case 'F':\n                if("FALSE".equalsIgnoreCase(strRep)) {\n                    return Boolean.FALSE;\n                }\n                break;\n        }\n        return null;\n    }
592	private static String[] separateAreaRefs(String reference) {\n                                                        \n        \n        int len = reference.length();\n        int delimiterPos = -1;\n        boolean insideDelimitedName = false;\n        for(int i=0; i<len; i++) {\n            switch(reference.charAt(i)) {\n                case CELL_DELIMITER:\n                    if(!insideDelimitedName) {\n                        if(delimiterPos >=0) {\n                            throw new IllegalArgumentException("More than one cell delimiter '" \n                                    + CELL_DELIMITER + "' appears in area reference '" + reference + "'");\n                        }\n                        delimiterPos = i;\n                    }\n                    continue;                 case SPECIAL_NAME_DELIMITER:\n                    break;\n                default:\n                    continue;             }\n            if(!insideDelimitedName) {\n                insideDelimitedName = true;\n                continue;\n            }\n            \n            if(i >= len-1) {\n                                                throw new IllegalArgumentException("Area reference '" + reference \n                        + "' ends with special name delimiter '"  + SPECIAL_NAME_DELIMITER + "'");\n            }\n            if(reference.charAt(i+1) == SPECIAL_NAME_DELIMITER) {\n                                i++;             } else {\n                                insideDelimitedName = false;\n            }\n        }\n        if(delimiterPos < 0) {\n            return new String[] { reference, };\n        }\n\n        String partA = reference.substring(0, delimiterPos);\n        String partB = reference.substring(delimiterPos+1);\n        if(partB.indexOf(SHEET_NAME_DELIMITER) >= 0) {\n                                                \n            throw new RuntimeException("Unexpected " + SHEET_NAME_DELIMITER \n                    + " in second cell reference of '" + reference + "'");\n        }\n        \n        int plingPos = partA.lastIndexOf(SHEET_NAME_DELIMITER);\n        if(plingPos < 0) {\n            return new String [] { partA, partB, };\n        }\n        \n        String sheetName = partA.substring(0, plingPos + 1);         \n        return new String [] { partA, sheetName + partB, };\n    }
593	private DisiWrapper insertTailWithOverFlow(DisiWrapper s) {\n    if (tailSize < tail.length) {\n      addTail(s);\n      return null;\n    } else if (tail.length >= 1) {\n      final DisiWrapper top = tail[0];\n      if (top.cost < s.cost) {\n        tail[0] = s;\n        downHeapCost(tail, tailSize);\n        return top;\n      }\n    }\n    return s;\n  }
594	public String buildExtensionField(String extensionKey, String field) {\n    StringBuilder builder = new StringBuilder(field);\n    builder.append(this.extensionFieldDelimiter);\n    builder.append(extensionKey);\n    return escapeExtensionField(builder.toString());\n  }
595	private void enableOrDisableControls() {\n        boolean enabled = (this.showTitle == true);\n        this.titleField.setEnabled(enabled);\n        this.selectFontButton.setEnabled(enabled);\n        this.selectPaintButton.setEnabled(enabled);\n    }
596	FieldDoc fillFields(final Entry entry) {\n    final int n = comparators.length;\n    final Object[] fields = new Object[n];\n    for (int i = 0; i < n; ++i) {\n      fields[i] = comparators[i].value(entry.slot);\n    }\n        return new FieldDoc(entry.doc, entry.score, fields);\n  }
597	public void postSign(final DOMSignContext xmlSignContext, final String signatureValue)\n    throws MarshalException {\n        LOG.log(POILogger.DEBUG, "postSign");\n\n        final Document document = (Document)xmlSignContext.getParent();\n\n        \n        String signatureId = signatureConfig.getPackageSignatureId();\n        if (!signatureId.equals(document.getDocumentElement().getAttribute("Id"))) {\n            throw new RuntimeException("ds:Signature not found for @Id: " + signatureId);\n        }\n\n        \n        final Element signatureNode = getDsigElement(document, "SignatureValue"); \n        if (signatureNode == null) {\n            throw new RuntimeException("preSign has to be called before postSign");\n        }\n        signatureNode.setTextContent(signatureValue);\n\n        \n        for (SignatureFacet signatureFacet : signatureConfig.getSignatureFacets()) {\n            signatureFacet.postSign(document);\n        }\n\n        writeDocument(document);\n    }
598	public void drawBorders(CellRangeAddress range, BorderStyle borderType,\n            BorderExtent extent) {\n        switch (extent) {\n        case NONE:\n            removeBorders(range);\n            break;\n        case ALL:\n            drawHorizontalBorders(range, borderType, BorderExtent.ALL);\n            drawVerticalBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case INSIDE:\n            drawHorizontalBorders(range, borderType, BorderExtent.INSIDE);\n            drawVerticalBorders(range, borderType, BorderExtent.INSIDE);\n            break;\n        case OUTSIDE:\n            drawOutsideBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case TOP:\n            drawTopBorder(range, borderType);\n            break;\n        case BOTTOM:\n            drawBottomBorder(range, borderType);\n            break;\n        case LEFT:\n            drawLeftBorder(range, borderType);\n            break;\n        case RIGHT:\n            drawRightBorder(range, borderType);\n            break;\n        case HORIZONTAL:\n            drawHorizontalBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case INSIDE_HORIZONTAL:\n            drawHorizontalBorders(range, borderType, BorderExtent.INSIDE);\n            break;\n        case OUTSIDE_HORIZONTAL:\n            drawOutsideBorders(range, borderType, BorderExtent.HORIZONTAL);\n            break;\n        case VERTICAL:\n            drawVerticalBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case INSIDE_VERTICAL:\n            drawVerticalBorders(range, borderType, BorderExtent.INSIDE);\n            break;\n        case OUTSIDE_VERTICAL:\n            drawOutsideBorders(range, borderType, BorderExtent.VERTICAL);\n            break;\n        }\n    }
599	private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited, int level) {\n    if (level > MAX_RECURSION_LEVEL) {\n      throw new IllegalArgumentException("input automaton is too large: " +  level);\n    }\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited, level+1))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }
600	public void addLonLine(double minLat, double maxLat, double lon) {\n    String name = "lonline" + nextShape;\n    nextShape++;\n\n    b.append("        var " + name + " = WE.polygon([\n");\n    double lat;\n    int steps = getStepCount(minLat, lon, maxLat, lon);\n    for(lat = minLat;lat<=maxLat;lat += (maxLat-minLat)/steps) {\n      b.append("          [" + lat + ", " + lon + "],\n");\n    }\n    b.append("          [" + maxLat + ", " + lon + "],\n");\n    lat -= (maxLat-minLat)/36;\n    for(;lat>=minLat;lat -= (maxLat-minLat)/steps) {\n      b.append("          [" + lat + ", " + lon + "],\n");\n    }\n    b.append("        ], {color: \"#ff0000\", fillColor: \"#ffffff\", opacity: 1, fillOpacity: 0.0001});\n");\n    b.append("        " + name + ".addTo(earth);\n");\n  }
601	public void copyBytes(DataInput input, long numBytes) throws IOException {\n    assert numBytes >= 0: "numBytes=" + numBytes;\n    long left = numBytes;\n    if (copyBuffer == null)\n      copyBuffer = new byte[COPY_BUFFER_SIZE];\n    while(left > 0) {\n      final int toCopy;\n      if (left > COPY_BUFFER_SIZE)\n        toCopy = COPY_BUFFER_SIZE;\n      else\n        toCopy = (int) left;\n      input.readBytes(copyBuffer, 0, toCopy);\n      writeBytes(copyBuffer, 0, toCopy);\n      left -= toCopy;\n    }\n  }
602	public int stem(final char s[], int len) {\n    if (len < 4)       return len;\n    \n    if (len > 5 && endsWith(s, len, "ища"))\n      return len - 3;\n    \n    len = removeArticle(s, len);\n    len = removePlural(s, len);\n    \n    if (len > 3) {\n      if (endsWith(s, len, "я"))\n        len--;\n      if (endsWith(s, len, "а") ||\n          endsWith(s, len, "о") ||\n          endsWith(s, len, "е"))\n        len--;\n    }\n    \n                if (len > 4 && endsWith(s, len, "ен")) {\n      s[len - 2] = 'н';       len--;\n    }\n    \n    if (len > 5 && s[len - 2] == 'ъ') {\n      s[len - 2] = s[len - 1];       len--;\n    }\n\n    return len;\n  }
603	private void unionTermGroups(ArrayList<FixedBitSet> bb) {\n    int incr;\n    for (int i=0; i<bb.size()-1; i+=incr) {\n      incr = 1;\n      int j = i+1;\n      while (j<bb.size()) {\n        if (bb.get(i).intersects(bb.get(j))) {\n          bb.get(i).or(bb.get(j));\n          bb.remove(j);\n          incr = 0;\n        } else {\n          ++j;\n        }\n      }\n    }\n  }
604	protected double getRectX(double x, double w1, double w2,\n                              RectangleEdge edge) {\n\n        double result = x;\n        if (edge == RectangleEdge.LEFT) {\n            result = result + w1;\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result = result + w2;\n        }\n        return result;\n\n    }
605	public static Document process( File xlsFile ) throws Exception\n    {\n        final HSSFWorkbook workbook = AbstractExcelUtils.loadXls( xlsFile );\n        try {\n            ExcelToFoConverter excelToHtmlConverter = new ExcelToFoConverter(\n                    XMLHelper.getDocumentBuilderFactory().newDocumentBuilder()\n                            .newDocument() );\n            excelToHtmlConverter.processWorkbook( workbook );\n            return excelToHtmlConverter.getDocument();\n        } finally {\n            workbook.close();\n        }\n    }
606	public int[][] lookup(char[] chars, int off, int len) throws IOException {\n        TreeMap<Integer, int[]> result = new TreeMap<>();     boolean found = false; \n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    FST.Arc<Long> arc = new FST.Arc<>();\n    int end = off + len;\n    for (int startOffset = off; startOffset < end; startOffset++) {\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      int remaining = end - startOffset;\n      for (int i = 0; i < remaining; i++) {\n        int ch = chars[startOffset+i];\n        if (fst.findTargetArc(ch, arc, arc, i == 0, fstReader) == null) {\n          break;         }\n        output += arc.output.intValue();\n        if (arc.isFinal()) {\n          final int finalOutput = output + arc.nextFinalOutput.intValue();\n          result.put(startOffset-off, segmentations[finalOutput]);\n          found = true;\n        }\n      }\n    }\n    \n    return found ? toIndexArray(result) : EMPTY_RESULT;\n  }
607	public void newFileLink() {\n        _range = new CellRangeAddress(0, 0, 0, 0);\n        _guid = STD_MONIKER;\n        _linkOpts = HLINK_URL | HLINK_LABEL;\n        _fileOpts = 0;\n        setLabel("");\n        _moniker = FILE_MONIKER;\n        setAddress(null);\n        setShortFilename("");\n        _uninterpretedTail = FILE_TAIL;\n    }
608	public void addValue(BytesRef value) throws IOException {    \n      int hash = hashFunction.hash(value);\n      if (hash < 0) {\n        hash = hash * -1;\n      }\n            int bloomPos = hash & bloomSize;\n      filter.set(bloomPos);\n  }
609	public void appendData(float[] newData, int insertionIndex, int refresh) {\n        int nDataPoints = newData.length;\n        if (nDataPoints > this.valueHistory.length) {\n            throw new IllegalArgumentException(\n                    "More data than series to put them in");\n        }\n        for (int s = 0; s < nDataPoints; s++) {\n            if (this.valueHistory[s] == null) {\n                this.valueHistory[s] = new ValueSequence(this.historyCount);\n            }\n            this.valueHistory[s].enterData(insertionIndex, newData[s]);\n        }\n        if (refresh > 0) {\n            insertionIndex++;\n            if (insertionIndex % refresh == 0) {\n                fireSeriesChanged();\n            }\n        }\n    }
610	public Record cloneViaReserialise() {\n                        byte[] b = serialize();\n        RecordInputStream rinp = new RecordInputStream(new ByteArrayInputStream(b));\n        rinp.nextRecord();\n\n        Record[] r = RecordFactory.createRecord(rinp);\n        if(r.length != 1) {\n            throw new IllegalStateException("Re-serialised a record to clone it, but got " + r.length + " records back!");\n        }\n        return r[0];\n    }
611	public static void exec(String[] args) {\n        if (args.length < 1) {\n      System.err.println("Usage: java Benchmark <algorithm file>");\n      System.exit(1);\n    }\n    \n        Path algFile = Paths.get(args[0]);\n    if (!Files.isReadable(algFile)) {\n      System.err.println("cannot find/read algorithm file: "+algFile.toAbsolutePath()); \n      System.exit(1);\n    }\n    \n    System.out.println("Running algorithm from: "+algFile.toAbsolutePath());\n    \n    Benchmark benchmark = null;\n    try {\n      benchmark = new Benchmark(Files.newBufferedReader(algFile, StandardCharsets.UTF_8));\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n\n    System.out.println("------------> algorithm:");\n    System.out.println(benchmark.getAlgorithm().toString());\n\n        try {\n      benchmark.execute();\n    } catch (Exception e) {\n      System.err.println("Error: cannot execute the algorithm! "+e.getMessage());\n      e.printStackTrace();\n    }\n\n    System.out.println("####################");\n    System.out.println("###  D O N E !!! ###");\n    System.out.println("####################");\n  }
612	public String toString()\n    {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append("[SHARED FORMULA (").append(HexDump.intToHex(sid)).append("]\n");\n        buffer.append("    .range      = ").append(getRange()).append("\n");\n        buffer.append("    .reserved    = ").append(HexDump.shortToHex(field_5_reserved)).append("\n");\n\n        Ptg[] ptgs = field_7_parsed_expr.getTokens();\n        for (int k = 0; k < ptgs.length; k++ ) {\n           buffer.append("Formula[").append(k).append("]");\n           Ptg ptg = ptgs[k];\n           buffer.append(ptg).append(ptg.getRVAType()).append("\n");\n        }\n\n        buffer.append("[/SHARED FORMULA]\n");\n        return buffer.toString();\n    }
613	private CharSequence toLowercase(CharSequence chs) {\n    final int length = chs.length();\n    scratch.setLength(length);\n    scratch.grow(length);\n\n    char buffer[] = scratch.chars();\n    for (int i = 0; i < length;) {\n      i += Character.toChars(\n          Character.toLowerCase(Character.codePointAt(chs, i)), buffer, i);      \n    }\n\n    return scratch.get();\n  }
614	private synchronized String generateTempFileName(File directory) {\n		File tmpFilename;\n		do {\n			tmpFilename = new File(directory.getAbsoluteFile() + File.separator\n					+ "OpenXML4J" + System.nanoTime());\n		} while (tmpFilename.exists());\n		return FileHelper.getFilename(tmpFilename.getAbsoluteFile());\n	}
615	protected FieldInfo getFieldInfo(String field) {\n    if (searcher == null) {\n      return null;\n    }\n        FieldInfos fieldInfos = this.fieldInfos;     if (fieldInfos == null) {\n      synchronized (this) {\n        fieldInfos = this.fieldInfos;\n        if (fieldInfos == null) {\n          fieldInfos = MultiFields.getMergedFieldInfos(searcher.getIndexReader());\n          this.fieldInfos = fieldInfos;\n        }\n\n      }\n\n    }\n    return fieldInfos.fieldInfo(field);\n  }
616	@SuppressWarnings("WeakerAccess")\n    protected static PaintStyle selectPaint(XSLFFillProperties fp, final CTSchemeColor phClr, final PackagePart parentPart, final XSLFTheme theme, boolean hasPlaceholder) {\n        if (fp == null || fp.isSetNoFill()) {\n            return null;\n        } else if (fp.isSetSolidFill()) {\n            return selectPaint(fp.getSolidFill(), phClr, theme);\n        } else if (fp.isSetBlipFill()) {\n            return selectPaint(fp.getBlipFill(), parentPart);\n        } else if (fp.isSetGradFill()) {\n            return selectPaint(fp.getGradFill(), phClr, theme);\n        } else if (fp.isSetMatrixStyle()) {\n            return selectPaint(fp.getMatrixStyle(), theme, fp.isLineStyle(), hasPlaceholder);\n        } else {\n            return null;\n        }\n    }
617	public static CFRule12Record createColorScale(HSSFSheet sheet) {\n        int numPoints = 3;\n        ExtendedColor[] colors = new ExtendedColor[numPoints];\n        ColorGradientThreshold[] ts = new ColorGradientThreshold[numPoints];\n        for (int i=0; i<ts.length; i++) {\n            ts[i] = new ColorGradientThreshold();\n            colors[i] = new ExtendedColor();\n        }\n        \n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_COLOR_SCALE, \n                                              ComparisonOperator.NO_COMPARISON);\n        ColorGradientFormatting cgf = r.createColorGradientFormatting();\n        cgf.setNumControlPoints(numPoints);\n        cgf.setThresholds(ts);\n        cgf.setColors(colors);\n        return r;\n    }
618	private static double[] RGB2HSL(Color color)\n    {\n        \n        float[] rgb = color.getRGBColorComponents( null );\n        double r = rgb[0];\n        double g = rgb[1];\n        double b = rgb[2];\n\n        \n        double min = Math.min(r, Math.min(g, b));\n        double max = Math.max(r, Math.max(g, b));\n\n        \n        double h = 0;\n\n        if (max == min) {\n            h = 0;\n        } else if (max == r) {\n            h = ((60d * (g - b) / (max - min)) + 360d) % 360d;\n        } else if (max == g) {\n            h = (60d * (b - r) / (max - min)) + 120d;\n        } else if (max == b) {\n            h = (60d * (r - g) / (max - min)) + 240d;\n        }\n\n        \n        double l = (max + min) / 2d;\n\n        \n        final double s;\n\n        if (max == min) {\n            s = 0;\n        } else if (l <= .5d) {\n            s = (max - min) / (max + min);\n        } else {\n            s = (max - min) / (2d - max - min);\n        }\n\n        return new double[] {h, s * 100, l * 100};\n    }
619	public void save(File targetFile) throws IOException {\n		if (targetFile == null) {\n			throw new IllegalArgumentException("targetFile");\n		}\n\n		this.throwExceptionIfReadOnly();\n		\n				if(targetFile.exists() && \n		        targetFile.getAbsolutePath().equals(this.originalPackagePath)) {\n		    throw new InvalidOperationException(\n		            "You can't call save(File) to save to the currently open " +\n		            "file. To save to the current file, please just call close()"\n		    );\n		}\n		\n				FileOutputStream fos = null;\n		try {\n			fos = new FileOutputStream(targetFile);\n			this.save(fos);\n		} finally {\n			if (fos != null) {\n                fos.close();\n            }\n		}\n	}
620	protected void drawInterval(Graphics2D g2,\n                                 CategoryItemRendererState state,\n                                 Rectangle2D dataArea,\n                                 CategoryPlot plot,\n                                 CategoryAxis domainAxis,\n                                 ValueAxis rangeAxis,\n                                 IntervalCategoryDataset dataset,\n                                 int row,\n                                 int column) {\n\n        int visibleRow = state.getVisibleSeriesIndex(row);\n        if (visibleRow < 0) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        double rectX = 0.0;\n        double rectY = 0.0;\n\n        RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge();\n\n                Number value0 = dataset.getEndValue(row, column);\n        if (value0 == null) {\n            return;\n        }\n        double java2dValue0 = rangeAxis.valueToJava2D(value0.doubleValue(),\n                dataArea, rangeAxisLocation);\n\n                Number value1 = dataset.getStartValue(row, column);\n        if (value1 == null) {\n            return;\n        }\n        double java2dValue1 = rangeAxis.valueToJava2D(\n                value1.doubleValue(), dataArea, rangeAxisLocation);\n\n        if (java2dValue1 < java2dValue0) {\n            double temp = java2dValue1;\n            java2dValue1 = java2dValue0;\n            java2dValue0 = temp;\n        }\n\n                double rectWidth = state.getBarWidth();\n\n                double rectHeight = Math.abs(java2dValue1 - java2dValue0);\n\n        RectangleEdge barBase = RectangleEdge.LEFT;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n                        rectX = java2dValue0;\n            rectY = calculateBarW0(getPlot(), orientation, dataArea, \n                    domainAxis, state, visibleRow, column);\n            rectHeight = state.getBarWidth();\n            rectWidth = Math.abs(java2dValue1 - java2dValue0);\n            barBase = RectangleEdge.LEFT;\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n                        rectX = calculateBarW0(getPlot(), orientation, dataArea, \n                    domainAxis, state, visibleRow, column);\n            rectY = java2dValue0;\n            barBase = RectangleEdge.BOTTOM;\n        }\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n                rectHeight);\n        BarPainter painter = getBarPainter();\n        if (getShadowsVisible()) {\n            painter.paintBarShadow(g2, this, row, column, bar, barBase, false);\n        }\n        getBarPainter().paintBar(g2, this, row, column, bar, barBase);\n\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n                    false);\n        }\n\n                EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }
621	public static final int hexToInt(String hex)\n    {\n        int len = hex.length();\n        if (len > 16)\n            throw new NumberFormatException();\n\n        int l = 0;\n        for (int i = 0; i < len; i++)\n        {\n            l <<= 4;\n            int c = Character.digit(hex.charAt(i), 16);\n            if (c < 0)\n                throw new NumberFormatException();\n            l |= c;\n        }\n        return l;\n    }
622	private void onWorkbookCreate() {\n        workbook = CTWorkbook.Factory.newInstance();\n\n                CTWorkbookPr workbookPr = workbook.addNewWorkbookPr();\n        workbookPr.setDate1904(false);\n\n        setBookViewsIfMissing();\n        workbook.addNewSheets();\n\n        POIXMLProperties.ExtendedProperties expProps = getProperties().getExtendedProperties();\n        expProps.getUnderlyingProperties().setApplication(DOCUMENT_CREATOR);\n\n        sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, this.xssfFactory);\n        stylesSource = (StylesTable)createRelationship(XSSFRelation.STYLES, this.xssfFactory);\n        stylesSource.setWorkbook(this);\n\n        namedRanges = new ArrayList<>();\n        namedRangesByName = new ArrayListValuedHashMap<>();\n        sheets = new ArrayList<>();\n        pivotTables = new ArrayList<>();\n    }
623	protected static void fixLineEndings(List<HSLFTextParagraph> paragraphs) {\n        HSLFTextRun lastRun = null;\n        for (HSLFTextParagraph p : paragraphs) {\n            if (lastRun != null && !lastRun.getRawText().endsWith("\r")) {\n                lastRun.setText(lastRun.getRawText() + "\r");\n            }\n            List<HSLFTextRun> ltr = p.getTextRuns();\n            if (ltr.isEmpty()) {\n                throw new HSLFException("paragraph without textruns found");\n            }\n            lastRun = ltr.get(ltr.size() - 1);\n            assert (lastRun.getRawText() != null);\n        }\n    }
624	protected void writeHeader(PrintWriter out) {\n    StringBuilder sb = threadBuffer.get();\n    if (sb == null) {\n      sb = new StringBuilder();\n      threadBuffer.set(sb);\n    }\n    sb.setLength(0);\n    sb.append(FIELDS_HEADER_INDICATOR);\n    for (String f : fieldsToWrite) {\n      sb.append(SEP).append(f);\n    }\n    out.println(sb.toString());\n  }
625	public static boolean matchesPngHeader(byte[] data, int offset) {\n        if (data == null || data.length - offset < PNG_FILE_HEADER.length) {\n            return false;\n        }\n\n        for (int i = 0; i < PNG_FILE_HEADER.length; i++) {\n            if (PNG_FILE_HEADER[i] != data[i + offset]) {\n                return false;\n            }\n        }\n\n        return true;\n    }
626	HSSFCell createCellFromRecord(CellValueRecordInterface cell) {\n        HSSFCell hcell = new HSSFCell(book, sheet, cell);\n\n        addCell(hcell);\n        int colIx = cell.getColumn();\n        if (row.isEmpty()) {\n            row.setFirstCol(colIx);\n            row.setLastCol(colIx + 1);\n        } else {\n            if (colIx < row.getFirstCol()) {\n                row.setFirstCol(colIx);\n            } else if (colIx > row.getLastCol()) {\n                row.setLastCol(colIx + 1);\n            } \n        }\n                return hcell;\n    }
627	private static int indexOf(byte[] data, int offset, byte[] pattern) {\n        int[] failure = computeFailure(pattern);\n\n        int j = 0;\n        if (data.length == 0) {\n            return -1;\n        }\n\n        for (int i = offset; i < data.length; i++) {\n            while (j > 0 && pattern[j] != data[i]) {\n                j = failure[j - 1];\n            }\n            if (pattern[j] == data[i]) { j++; }\n            if (j == pattern.length) {\n                return i - pattern.length + 1;\n            }\n        }\n        return -1;\n    }
628	private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n            long length = skipStream[0].readVLong();\n      \n            skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n                skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n                skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize(Math.max(BufferedIndexInput.MIN_BUFFER_SIZE, (int) length));\n        }\n        \n                skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n        skipPointer[0] = skipStream[0].getFilePointer();\n  }
629	protected String taskReportLine(String longestOp, TaskStats stat) {\n    PerfTask task = stat.getTask();\n    StringBuilder sb = new StringBuilder();\n    sb.append(Format.format(task.getName(), longestOp));\n    String round = (stat.getRound()>=0 ? ""+stat.getRound() : "-");\n    sb.append(Format.formatPaddLeft(round, ROUND));\n    sb.append(getRunData().getConfig().getColsValuesForValsByRound(stat.getRound()));\n    sb.append(Format.format(stat.getNumRuns(), RUNCNT)); \n    sb.append(Format.format(stat.getCount() / stat.getNumRuns(), RECCNT));\n    long elapsed = (stat.getElapsed()>0 ? stat.getElapsed() : 1);     sb.append(Format.format(2, (float) (stat.getCount() * 1000.0 / elapsed), RECSEC));\n    sb.append(Format.format(2, (float) stat.getElapsed() / 1000, ELAPSED));\n    sb.append(Format.format(0, (float) stat.getMaxUsedMem() / stat.getNumRuns(), USEDMEM)); \n    sb.append(Format.format(0, (float) stat.getMaxTotMem() / stat.getNumRuns(), TOTMEM));\n    return sb.toString();\n  }
630	public static void writeAsSVG(Drawable drawable, int w, int h, \n            File file) {\n        if (!ExportUtils.isJFreeSVGAvailable()) {\n            throw new IllegalStateException(\n                    "JFreeSVG is not present on the classpath.");\n        }\n        ParamChecks.nullNotPermitted(drawable, "drawable");\n        ParamChecks.nullNotPermitted(file, "file");\n        try {\n            Class<?> svg2Class = Class.forName(\n                    "org.jfree.graphics2d.svg.SVGGraphics2D");\n            Constructor<?> c1 = svg2Class.getConstructor(int.class, int.class);\n            Graphics2D svg2 = (Graphics2D) c1.newInstance(w, h);\n            Rectangle2D drawArea = new Rectangle2D.Double(0, 0, w, h);\n            drawable.draw(svg2, drawArea);\n            Class<?> svgUtilsClass = Class.forName(\n                    "org.jfree.graphics2d.svg.SVGUtils");\n            Method m1 = svg2Class.getMethod("getSVGElement", (Class[]) null);\n            String element = (String) m1.invoke(svg2, (Object[]) null);\n            Method m2 = svgUtilsClass.getMethod("writeToSVG", File.class, \n                    String.class);\n            m2.invoke(svgUtilsClass, file, element);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(ex);\n        } catch (InstantiationException ex) {\n            throw new RuntimeException(ex);\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(ex);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            throw new RuntimeException(ex);\n        }\n    }
631	public final int runAndMaybeStats(boolean reportStats) throws Exception {\n    if (!reportStats || shouldNotRecordStats()) {\n      setup();\n      int count = doLogic();\n      count = disableCounting ? 0 : count;\n      tearDown();\n      return count;\n    }\n    if (reportStats && depth <= maxDepthLogStart && !shouldNeverLogAtStart()) {\n      System.out.println("------------> starting task: " + getName());\n    }\n    setup();\n    Points pnts = runData.getPoints();\n    TaskStats ts = pnts.markTaskStart(this, runData.getConfig().getRoundNumber());\n    int count = doLogic();\n    count = disableCounting ? 0 : count;\n    pnts.markTaskEnd(ts, count);\n    tearDown();\n    return count;\n  }
632	private void writePropertySet(String name, PropertySet set, POIFSFileSystem outFS) throws IOException {\n        try {\n            PropertySet mSet = new PropertySet(set);\n            ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n\n            mSet.write(bOut);\n            byte[] data = bOut.toByteArray();\n            ByteArrayInputStream bIn = new ByteArrayInputStream(data);\n\n                        outFS.createOrUpdateDocument(bIn, name);\n\n            logger.log(POILogger.INFO, "Wrote property set " + name + " of size " + data.length);\n        } catch(org.apache.poi.hpsf.WritingNotSupportedException wnse) {\n            logger.log( POILogger.ERROR, "Couldn't write property set with name " + name + " as not supported by HPSF yet");\n        }\n    }
633	private static byte[] encode(double latitude, double longitude) {\n    byte[] bytes = new byte[2 * Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(latitude), bytes, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(longitude), bytes, Integer.BYTES);\n    return bytes;\n  }
634	public static String getQueryAsXmlString(Properties formProperties, InputStream xslIs)\n      throws SAXException, IOException, ParserConfigurationException, TransformerException {\n        StringWriter writer = new StringWriter();\n    StreamResult result = new StreamResult(writer);\n    transformCriteria(formProperties, xslIs, result);\n    return writer.toString();\n  }
635	private static double getColumnWidthForRow(\n            Row row, int column, int defaultCharWidth, DataFormatter formatter, boolean useMergedCells) {\n        if( row == null ) {\n            return -1;\n        }\n\n        Cell cell = row.getCell(column);\n\n        if (cell == null) {\n            return -1;\n        }\n\n        return getCellWidth(cell, defaultCharWidth, formatter, useMergedCells);\n    }
636	public static Number findMinimumDomainValue(XYDataset dataset) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        Number result;\n                if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainLowerBound(true));\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(minimum);\n            }\n        }\n\n        return result;\n    }
637	private static int lookupIndexOfExactValue(LookupValueComparer lookupComparer, ValueVector vector) {\n\n				int size = vector.getSize();\n		for (int i = 0; i < size; i++) {\n			if(lookupComparer.compareTo(vector.getItem(i)).isEqual()) {\n				return i;\n			}\n		}\n		return -1;\n	}
638	public boolean removeAbstractNum(BigInteger abstractNumID) {\n        if (abstractNumID.byteValue() < abstractNums.size()) {\n            ctNumbering.removeAbstractNum(abstractNumID.byteValue());\n            abstractNums.remove(abstractNumID.byteValue());\n            return true;\n        }\n        return false;\n    }
639	public List<Map.Entry<String,FileMetaData>> getFilesToCopy(Map<String,FileMetaData> files) throws IOException {\n\n    List<Map.Entry<String,FileMetaData>> toCopy = new ArrayList<>();\n    for (Map.Entry<String,FileMetaData> ent : files.entrySet()) {\n      String fileName = ent.getKey();\n      FileMetaData fileMetaData = ent.getValue();\n      if (fileIsIdentical(fileName, fileMetaData) == false) {\n        toCopy.add(ent);\n      }\n    }\n\n    return toCopy;\n  }
640	public XWPFRun insertNewRun(int pos) {\n        if (pos >= 0 && pos <= runs.size()) {\n                                                int rPos = 0;\n            for (int i = 0; i < pos; i++) {\n                XWPFRun currRun = runs.get(i);\n                if (!(currRun instanceof XWPFHyperlinkRun\n                        || currRun instanceof XWPFFieldRun)) {\n                    rPos++;\n                }\n            }\n\n            CTR ctRun = paragraph.insertNewR(rPos);\n            XWPFRun newRun = new XWPFRun(ctRun, (IRunBody) this);\n\n                                    int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != -1) {\n                    iPos = oldAt;\n                }\n            }\n            iruns.add(iPos, newRun);\n\n                        runs.add(pos, newRun);\n\n            return newRun;\n        }\n\n        return null;\n    }
641	static void shadeAlt(Sheet sheet) {\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("MOD(ROW(),2)");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.LIGHT_GREEN.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:Z100")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.createRow(0).createCell(1).setCellValue("Shade Alternating Rows");\n        sheet.createRow(1).createCell(1).setCellValue("Condition: Formula Is  =MOD(ROW(),2)   (Light Green Fill)");\n    }
642	protected Query getWildcardQuery(String field, String termStr) throws ParseException\n  {\n    if ("*".equals(field)) {\n      if ("*".equals(termStr)) return newMatchAllDocsQuery();\n    }\n    if (!allowLeadingWildcard && (termStr.startsWith("*") || termStr.startsWith("?")))\n      throw new ParseException("'*' or '?' not allowed as first character in WildcardQuery");\n\n    Term t = new Term(field, analyzeWildcard(field, termStr));\n    return newWildcardQuery(t);\n  }
643	public void removeTable(XSSFTable t) {\n        long id = t.getCTTable().getId();\n        Map.Entry<String, XSSFTable> toDelete = null;\n\n        for (Map.Entry<String, XSSFTable> entry : tables.entrySet()) {\n            if (entry.getValue().getCTTable().getId() == id) toDelete = entry;\n        }\n        if (toDelete != null) {\n            removeRelation(getRelationById(toDelete.getKey()), true);\n            tables.remove(toDelete.getKey());\n            toDelete.getValue().onTableDelete();\n        }\n    }
644	public void removeCustomProperties() {\n        if (getSectionCount() < 2) {\n            throw new HPSFRuntimeException("Illegal internal format of Document SummaryInformation stream: second section is missing.");\n        }\n\n        List<Section> l = new LinkedList<>(getSections());\n        clearSections();\n        int idx = 0;\n        for (Section s : l) {\n            if (idx++ != 1) {\n                addSection(s);\n            }\n        }\n    }
645	public int write(final OutputStream out, final int codepage)\n    throws IOException, WritingNotSupportedException {\n        int length = 0;\n        long variantType = getType();\n\n        \n\n        if (variantType == Variant.VT_LPSTR && codepage != CodePageUtil.CP_UTF16) {\n            String csStr = CodePageUtil.codepageToEncoding(codepage > 0 ? codepage : Property.DEFAULT_CODEPAGE);\n            if (!Charset.forName(csStr).newEncoder().canEncode((String)value)) {\n                variantType = Variant.VT_LPWSTR;\n            }\n        }\n\n        LittleEndian.putUInt(variantType, out);\n        length += LittleEndianConsts.INT_SIZE;\n        length += VariantSupport.write(out, variantType, getValue(), codepage);\n        return length;\n    }
646	private NotImplementedException addExceptionInfo(NotImplementedException inner, int sheetIndex, int rowIndex, int columnIndex) {\n\n        try {\n            String sheetName = _workbook.getSheetName(sheetIndex);\n            CellReference cr = new CellReference(sheetName, rowIndex, columnIndex, false, false);\n            String msg =  "Error evaluating cell " + cr.formatAsString();\n            return new NotImplementedException(msg, inner);\n        } catch (Exception e) {\n                        LOG.log(POILogger.ERROR, "Can't add exception info", e);\n            return inner;         }\n    }
647	public static void writeAsPNG(Drawable drawable, int w, int h, \n            File file) throws FileNotFoundException, IOException {\n        BufferedImage image = new BufferedImage(w, h, \n                BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = image.createGraphics();\n        drawable.draw(g2, new Rectangle(w, h));\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n        try {\n            ImageIO.write(image, "png", out);\n        }\n        finally {\n            out.close();\n        }\n    }
648	private Workbook loadWorkbook() {\n        if (excelFileName == null) {\n            throw new BuildException("fileName attribute must be set!", getLocation());\n        }\n\n        try {\n            try (FileInputStream fis = new FileInputStream(excelFileName)) {\n                workbook = WorkbookFactory.create(fis);\n            }\n        } catch(Exception e) {\n            throw new BuildException("Cannot load file " + excelFileName\n                    + ". Make sure the path and file permissions are correct.", e);\n        }\n\n        return workbook;\n    }
649	public ArrayList<PackagePart> getPartsByRelationshipType(\n			String relationshipType) {\n		if (relationshipType == null) {\n			throw new IllegalArgumentException("relationshipType");\n		}\n		ArrayList<PackagePart> retArr = new ArrayList<>();\n		for (PackageRelationship rel : getRelationshipsByType(relationshipType)) {\n			PackagePart part = getPart(rel);\n			if (part != null) {\n			    retArr.add(part);\n			}\n		}\n		Collections.sort(retArr);\n		return retArr;\n	}
650	public void changeTickFontSize(int delta) {\n        Font f = getTickLabelFont();\n        String fName = f.getFontName();\n        Font newFont = new Font(fName, f.getStyle(), (f.getSize() + delta));\n        setTickLabelFont(newFont);\n    }
651	private void makeValueIndex(Number max, Number min, Set uniqueValues) {\n        double valueRange = max.doubleValue() - min.doubleValue();\n        double valueStep = valueRange / this.paintLimit;\n        int paint = 0;\n        double cutPoint = min.doubleValue() + valueStep;\n        for (Iterator i = uniqueValues.iterator(); i.hasNext();) {\n            Number value = (Number) i.next();\n            while (value.doubleValue() > cutPoint) {\n                cutPoint += valueStep;\n                paint++;\n                if (paint > this.paintLimit) {\n                    paint = this.paintLimit;\n                }\n            }\n            this.paintIndex.put(value, new Integer(paint));\n        }\n    }
652	public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings("unchecked") List<IvyNode> dependencies = report.getDependencies();\n\n        for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n                                continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n        for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue;       }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n        root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }
653	public XDDFTextRun appendRegularRun(String text) {\n        CTRegularTextRun r = _p.addNewR();\n        r.setT(text);\n        CTTextCharacterProperties rPr = r.addNewRPr();\n        rPr.setLang(LocaleUtil.getUserLocale().toLanguageTag());\n        XDDFTextRun run = new XDDFTextRun(r, this);\n        _runs.add(run);\n        return run;\n    }
654	public void restoreProperties(int index) {\n        if (index == 0) {\n            return;\n        }\n        int stackIndex = index;\n        if (stackIndex < 0) {\n            int curIdx = propStack.indexOf(prop);\n            if (curIdx == -1) {\n                                curIdx = propStack.size();\n            }\n            stackIndex = curIdx + index;\n        }\n        if (stackIndex == -1) {\n                        stackIndex = propStack.size()-1;\n        }\n        prop = propStack.get(stackIndex);\n    }
655	public final synchronized long getRecomputedActualSizeInBytes() throws IOException {\n    if (!(in instanceof RAMDirectory))\n      return sizeInBytes();\n    long size = 0;\n    for (final RAMFile file : ((RAMDirectory)in).fileMap.values())\n      size += file.length;\n    return size;\n  }
656	public static JFreeChart createTimeSeriesChart(String title,\n            String timeAxisLabel, String valueAxisLabel, XYDataset dataset,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ValueAxis timeAxis = new DateAxis(timeAxisLabel);\n        timeAxis.setLowerMargin(0.02);          timeAxis.setUpperMargin(0.02);\n        NumberAxis valueAxis = new NumberAxis(valueAxisLabel);\n        valueAxis.setAutoRangeIncludesZero(false);          XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, null);\n\n        XYToolTipGenerator toolTipGenerator = null;\n        if (tooltips) {\n            toolTipGenerator\n                = StandardXYToolTipGenerator.getTimeSeriesInstance();\n        }\n\n        XYURLGenerator urlGenerator = null;\n        if (urls) {\n            urlGenerator = new StandardXYURLGenerator();\n        }\n\n        XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer(true,\n                false);\n        renderer.setBaseToolTipGenerator(toolTipGenerator);\n        renderer.setURLGenerator(urlGenerator);\n        plot.setRenderer(renderer);\n\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
657	public static void main(String[] args) throws Exception {\n    System.out.println("Sum associations example:");\n    System.out.println("-------------------------");\n    List<FacetResult> results = new AssociationsFacetsExample().runSumAssociations();\n    System.out.println("tags: " + results.get(0));\n    System.out.println("genre: " + results.get(1));\n  }
658	public HSSFComment createComment(HSSFAnchor anchor) {\n        HSSFComment shape = new HSSFComment(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
659	public static SortedDocValues wrap(SortedSetDocValues sortedSet, Type selector) {\n    if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n      throw new UnsupportedOperationException("fields containing more than " + (Integer.MAX_VALUE-1) + " unique terms are unsupported");\n    }\n    \n    SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n    if (singleton != null) {\n                        return singleton;\n    } else {\n      switch(selector) {\n        case MIN: return new MinValue(sortedSet);\n        case MAX: return new MaxValue(sortedSet);\n        case MIDDLE_MIN: return new MiddleMinValue(sortedSet);\n        case MIDDLE_MAX: return new MiddleMaxValue(sortedSet);\n        default: \n          throw new AssertionError();\n      }\n    }\n  }
660	protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea,\n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D,\n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D,\n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }
661	private void reorder(int from, int to, int[] startOffsets, int[] endOffsets, int k) {\n        for (int i = 0; i < HISTOGRAM_SIZE; ++i) {\n      final int limit = endOffsets[i];\n      for (int h1 = startOffsets[i]; h1 < limit; h1 = startOffsets[i]) {\n        final int b = getBucket(from + h1, k);\n        final int h2 = startOffsets[b]++;\n        swap(from + h1, from + h2);\n      }\n    }\n  }
662	public synchronized final long getRecomputedSizeInBytes() throws IOException {\n    if (!(in instanceof RAMDirectory))\n      return sizeInBytes();\n    long size = 0;\n    for(final RAMFile file: ((RAMDirectory)in).fileMap.values()) {\n      size += file.ramBytesUsed();\n    }\n    return size;\n  }
663	@Beta\n    @Internal\n    public void copyCellFrom(Cell srcCell, CellCopyPolicy policy) {\n                if (policy.isCopyCellValue()) {\n            if (srcCell != null) {\n                CellType copyCellType = srcCell.getCellType();\n                if (copyCellType == CellType.FORMULA && !policy.isCopyCellFormula()) {\n                                                            copyCellType = srcCell.getCachedFormulaResultType();\n                }\n                switch (copyCellType) {\n                    case NUMERIC:\n                                                if (DateUtil.isCellDateFormatted(srcCell)) {\n                            setCellValue(srcCell.getDateCellValue());\n                        }\n                        else {\n                            setCellValue(srcCell.getNumericCellValue());\n                        }\n                        break;\n                    case STRING:\n                        setCellValue(srcCell.getStringCellValue());\n                        break;\n                    case FORMULA:\n                        setCellFormula(srcCell.getCellFormula());\n                        break;\n                    case BLANK:\n                        setBlank();\n                        break;\n                    case BOOLEAN:\n                        setCellValue(srcCell.getBooleanCellValue());\n                        break;\n                    case ERROR:\n                        setCellErrorValue(srcCell.getErrorCellValue());\n                        break;\n\n                    default:\n                        throw new IllegalArgumentException("Invalid cell type " + srcCell.getCellType());\n                }\n            } else {                 setBlank();\n            }\n        }\n        \n                if (policy.isCopyCellStyle()) {\n            setCellStyle(srcCell == null ? null : srcCell.getCellStyle());\n        }\n        \n        final Hyperlink srcHyperlink = (srcCell == null) ? null : srcCell.getHyperlink();\n\n        if (policy.isMergeHyperlink()) {\n                        if (srcHyperlink != null) {\n                setHyperlink(new XSSFHyperlink(srcHyperlink));\n            }\n        } else if (policy.isCopyHyperlink()) {\n                                    setHyperlink(srcHyperlink == null ? null : new XSSFHyperlink(srcHyperlink));\n        }\n    }
664	public static double[] getLinearFit(Number[] xData, Number[] yData) {\n\n        ParamChecks.nullNotPermitted(xData, "xData");\n        ParamChecks.nullNotPermitted(yData, "yData");\n        if (xData.length != yData.length) {\n            throw new IllegalArgumentException(\n                "Statistics.getLinearFit(): array lengths must be equal.");\n        }\n\n        double[] result = new double[2];\n                result[1] = getSlope(xData, yData);\n                result[0] = calculateMean(yData) - result[1] * calculateMean(xData);\n\n        return result;\n\n    }
665	public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException("distErrPct " + distErrPct + " must be between [0 to 0.5]");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n                Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }
666	private boolean stretchToOrder() throws IOException {\n    Spans prevSpans = subSpans[0];\n    matchStart = prevSpans.startPosition();\n    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;\n    assert prevSpans.endPosition() != NO_MORE_POSITIONS;\n    matchWidth = 0;\n    for (int i = 1; i < subSpans.length; i++) {\n      Spans spans = subSpans[i];\n      assert spans.startPosition() != NO_MORE_POSITIONS;\n      assert spans.endPosition() != NO_MORE_POSITIONS;\n      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {\n        oneExhaustedInCurrentDoc = true;\n        return false;\n      }\n      matchWidth += (spans.startPosition() - prevSpans.endPosition());\n      prevSpans = spans;\n    }\n    matchEnd = subSpans[subSpans.length - 1].endPosition();\n    return true;   }
667	private XSSFPivotTable createPivotTable(CellReference position, Sheet sourceSheet, PivotTableReferenceConfigurator refConfig) {\n\n        XSSFPivotTable pivotTable = createPivotTable();\n                pivotTable.setDefaultPivotTableDefinition();\n\n                pivotTable.createSourceReferences(position, sourceSheet, refConfig);\n\n                pivotTable.getPivotCacheDefinition().createCacheFields(sourceSheet);\n        pivotTable.createDefaultDataColumns();\n\n        return pivotTable;\n    }
668	public Automaton toAutomaton(boolean unicodeAware) throws IOException {\n            Automaton automaton = null;\n    try {\n                        final TokenStreamToAutomaton tsta;\n      if (preserveSep) {\n        tsta = new EscapingTokenStreamToAutomaton((char) SEP_LABEL);\n      } else {\n                        tsta = new TokenStreamToAutomaton();\n      }\n      tsta.setPreservePositionIncrements(preservePositionIncrements);\n      tsta.setUnicodeArcs(unicodeAware);\n\n      automaton = tsta.toAutomaton(inputTokenStream);\n    } finally {\n      IOUtils.closeWhileHandlingException(inputTokenStream);\n    }\n\n            automaton = replaceSep(automaton, preserveSep, SEP_LABEL);\n        return Operations.determinize(automaton, maxGraphExpansions);\n  }
669	public static HSLFSoundData[] find(Document document){\n        ArrayList<HSLFSoundData> lst = new ArrayList<>();\n        Record[] ch = document.getChildRecords();\n        for (int i = 0; i < ch.length; i++) {\n            if(ch[i].getRecordType() == RecordTypes.SoundCollection.typeID){\n                RecordContainer col = (RecordContainer)ch[i];\n                Record[] sr = col.getChildRecords();\n                for (int j = 0; j < sr.length; j++) {\n                    if(sr[j] instanceof Sound){\n                        lst.add(new HSLFSoundData((Sound)sr[j]));\n                    }\n                }\n            }\n\n        }\n        return lst.toArray(new HSLFSoundData[lst.size()]);\n    }
670	public static CharArraySet getWordSet(Reader reader, String comment, CharArraySet result) throws IOException {\n    BufferedReader br = null;\n    try {\n      br = getBufferedReader(reader);\n      String word = null;\n      while ((word = br.readLine()) != null) {\n        if (word.startsWith(comment) == false){\n          result.add(word.trim());\n        }\n      }\n    }\n    finally {\n      IOUtils.close(br);\n    }\n    return result;\n  }
671	public static DVConstraint createTimeConstraint(int comparisonOperator, String expr1, String expr2) {\n		if (expr1 == null) {\n			throw new IllegalArgumentException("expr1 must be supplied");\n		}\n		OperatorType.validateSecondArg(comparisonOperator, expr1);\n		\n				String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertTime(expr1) : null;\n				String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertTime(expr2) : null;\n		return new DVConstraint(ValidationType.TIME, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
672	public static String mapMsCodepointString(String string) {\n        if (string == null || string.isEmpty()) return string;\n        initMsCodepointMap();\n\n        StringBuilder sb = new StringBuilder();\n        final int length = string.length();\n        for (int offset = 0; offset < length; ) {\n            Integer msCodepoint = string.codePointAt(offset);\n            Integer uniCodepoint = msCodepointToUnicode.get(msCodepoint);\n            sb.appendCodePoint(uniCodepoint == null ? msCodepoint : uniCodepoint);\n            offset += Character.charCount(msCodepoint);\n        }\n\n        return sb.toString();\n    }
673	private void shapeToPath(Shape s) {\n        double[] coords = new double[6];\n        this.gc.beginPath();\n        PathIterator iterator = s.getPathIterator(null);\n        while (!iterator.isDone()) {\n            int segType = iterator.currentSegment(coords);\n            switch (segType) {\n                case PathIterator.SEG_MOVETO:\n                    this.gc.moveTo(coords[0], coords[1]);\n                    break;\n                case PathIterator.SEG_LINETO:\n                    this.gc.lineTo(coords[0], coords[1]);\n                    break;\n                case PathIterator.SEG_QUADTO:\n                    this.gc.quadraticCurveTo(coords[0], coords[1], coords[2], \n                            coords[3]);\n                    break;\n                case PathIterator.SEG_CUBICTO:\n                    this.gc.bezierCurveTo(coords[0], coords[1], coords[2], \n                            coords[3], coords[4], coords[5]);\n                    break;\n                case PathIterator.SEG_CLOSE:\n                    this.gc.closePath();\n                    break;\n                default:\n                    throw new RuntimeException("Unrecognised segment type " \n                            + segType);\n            }\n            iterator.next();\n        }\n    }
674	protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {\n       boolean firstInStore = false;\n       if (_mini_stream.getStartBlock() == POIFSConstants.END_OF_CHAIN) {\n           firstInStore = true;\n       }\n       \n              if (! firstInStore) {\n           try {\n              return getBlockAt(offset);\n           } catch(IndexOutOfBoundsException e) {}\n       }\n       \n                     \n              int newBigBlock = _filesystem.getFreeBlock();\n       _filesystem.createBlockIfNeeded(newBigBlock);\n       \n              if (firstInStore) {\n           _filesystem._get_property_table().getRoot().setStartBlock(newBigBlock);\n           _mini_stream = new POIFSStream(_filesystem, newBigBlock);\n       } else {\n                      ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\n           int block = _mini_stream.getStartBlock();\n           while(true) {\n              loopDetector.claim(block);\n              int next = _filesystem.getNextBlock(block);\n              if(next == POIFSConstants.END_OF_CHAIN) {\n                 break;\n              }\n              block = next;\n           }\n           _filesystem.setNextBlock(block, newBigBlock);\n       }\n       \n              _filesystem.setNextBlock(newBigBlock, POIFSConstants.END_OF_CHAIN);\n\n              return createBlockIfNeeded(offset);\n    }
675	public void exorciseIndex(Status result) throws IOException {\n    ensureOpen();\n    if (result.partial) {\n      throw new IllegalArgumentException("can only exorcise an index that was fully checked (this status checked a subset of segments)");\n    }\n    result.newSegments.changed();\n    result.newSegments.commit(result.dir);\n  }
676	public static JFreeChart createHighLowChart(String title,\n            String timeAxisLabel, String valueAxisLabel, OHLCDataset dataset,\n            Timeline timeline, boolean legend) {\n\n        DateAxis timeAxis = new DateAxis(timeAxisLabel);\n        timeAxis.setTimeline(timeline);\n        NumberAxis valueAxis = new NumberAxis(valueAxisLabel);\n        HighLowRenderer renderer = new HighLowRenderer();\n        renderer.setBaseToolTipGenerator(new HighLowItemLabelGenerator());\n        XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, renderer);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
677	public static BATBlock createEmptyBATBlock(final POIFSBigBlockSize bigBlockSize, boolean isXBAT) {\n       BATBlock block = new BATBlock(bigBlockSize);\n       if(isXBAT) {\n           final int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();\n           block._values[ _entries_per_xbat_block ] = POIFSConstants.END_OF_CHAIN;\n       }\n       return block;\n    }
678	protected int translateGet(int toFetch) {\n        if (this.oldestAt == 0) {\n            return toFetch;          }\n                int newIndex = toFetch + this.oldestAt;\n        if (newIndex >= this.historyCount) {\n            newIndex -= this.historyCount;\n        }\n        return newIndex;\n    }
679	public static List<String> getLines(InputStream stream, Charset charset) throws IOException{\n    BufferedReader input = null;\n    ArrayList<String> lines;\n    boolean success = false;\n    try {\n      input = getBufferedReader(IOUtils.getDecodingReader(stream, charset));\n\n      lines = new ArrayList<>();\n      for (String word=null; (word=input.readLine())!=null;) {\n                if (lines.isEmpty() && word.length() > 0 && word.charAt(0) == '\uFEFF')\n          word = word.substring(1);\n                if (word.startsWith("#")) continue;\n        word=word.trim();\n                if (word.length()==0) continue;\n        lines.add(word);\n      }\n      success = true;\n      return lines;\n    } finally {\n      if (success) {\n        IOUtils.close(input);\n      } else {\n        IOUtils.closeWhileHandlingException(input);\n      }\n    }\n  }
680	public void waitApplyAll() throws IOException {\n\n    assert Thread.holdsLock(writer) == false;\n    \n    final long t0 = System.nanoTime();\n\n    Set<FrozenBufferedUpdates> waitFor;\n    synchronized (this) {\n      waitFor = new HashSet<>(updates);\n    }\n\n    waitApply(waitFor);\n  }
681	public boolean trackColumn(int column) {\n        untrackedColumns.remove(column);\n        if (!maxColumnWidths.containsKey(column)) {\n            maxColumnWidths.put(column, new ColumnWidthPair());\n            return true;\n        }\n        return false;\n    }
682	public void applyBorders(Sheet sheet) {\n        Workbook wb = sheet.getWorkbook();\n        for (Map.Entry<CellAddress, Map<String, Object>> entry : _propertyTemplate\n                .entrySet()) {\n            CellAddress cellAddress = entry.getKey();\n            if (cellAddress.getRow() < wb.getSpreadsheetVersion().getMaxRows()\n                    && cellAddress.getColumn() < wb.getSpreadsheetVersion()\n                            .getMaxColumns()) {\n                Map<String, Object> properties = entry.getValue();\n                Row row = CellUtil.getRow(cellAddress.getRow(), sheet);\n                Cell cell = CellUtil.getCell(row, cellAddress.getColumn());\n                CellUtil.setCellStyleProperties(cell, properties);\n            }\n        }\n    }
683	public XWPFHeader createHeader(HeaderFooterType type) {\n        XWPFHeaderFooterPolicy hfPolicy = createHeaderFooterPolicy();\n                if (type == HeaderFooterType.FIRST) {\n            CTSectPr ctSectPr = getSection();\n            if (!ctSectPr.isSetTitlePg()) {\n                CTOnOff titlePg = ctSectPr.addNewTitlePg();\n                titlePg.setVal(STOnOff.ON);\n            }\n                                }\n        return hfPolicy.createHeader(STHdrFtr.Enum.forInt(type.toInt()));\n    }
684	private void drawVerticalAxisTrace(Graphics2D g2, int y) {\n\n        Rectangle2D dataArea = getScreenDataArea();\n\n        g2.setXORMode(Color.orange);\n        if (((int) dataArea.getMinY() < y) && (y < (int) dataArea.getMaxY())) {\n\n            if (this.horizontalTraceLine != null) {\n                g2.draw(this.horizontalTraceLine);\n                this.horizontalTraceLine.setLine((int) dataArea.getMinX(), y,\n                        (int) dataArea.getMaxX(), y);\n            }\n            else {\n                this.horizontalTraceLine = new Line2D.Float(\n                        (int) dataArea.getMinX(), y, (int) dataArea.getMaxX(),\n                        y);\n            }\n            g2.draw(this.horizontalTraceLine);\n        }\n\n                g2.setPaintMode();\n    }
685	private void readCoreContents() throws IOException {\n              bigBlockSize = _header.getBigBlockSize();\n       \n                     ChainLoopDetector loopDetector = getChainLoopDetector();\n       \n              for(int fatAt : _header.getBATArray()) {\n          readBAT(fatAt, loopDetector);\n       }\n       \n              int remainingFATs = _header.getBATCount() - _header.getBATArray().length;\n       \n              BATBlock xfat; \n       int nextAt = _header.getXBATIndex();\n       for(int i=0; i<_header.getXBATCount(); i++) {\n          loopDetector.claim(nextAt);\n          ByteBuffer fatData = getBlockAt(nextAt);\n          xfat = BATBlock.createBATBlock(bigBlockSize, fatData);\n          xfat.setOurBlockIndex(nextAt);\n          nextAt = xfat.getValueAt(bigBlockSize.getXBATEntriesPerBlock());\n          _xbat_blocks.add(xfat);\n          \n                    int xbatFATs = Math.min(remainingFATs, bigBlockSize.getXBATEntriesPerBlock());\n          for(int j=0; j<xbatFATs; j++) {\n             int fatAt = xfat.getValueAt(j);\n             if(fatAt == POIFSConstants.UNUSED_BLOCK || fatAt == POIFSConstants.END_OF_CHAIN) break;\n             readBAT(fatAt, loopDetector);\n          }\n          remainingFATs -= xbatFATs;\n       }\n       \n                     _property_table = new PropertyTable(_header, this);\n       \n              BATBlock sfat;\n       List<BATBlock> sbats = new ArrayList<>();\n       _mini_store     = new POIFSMiniStore(this, _property_table.getRoot(), sbats, _header);\n       nextAt = _header.getSBATStart();\n       for(int i=0; i<_header.getSBATCount() && nextAt != POIFSConstants.END_OF_CHAIN; i++) {\n          loopDetector.claim(nextAt);\n          ByteBuffer fatData = getBlockAt(nextAt);\n          sfat = BATBlock.createBATBlock(bigBlockSize, fatData);\n          sfat.setOurBlockIndex(nextAt);\n          sbats.add(sfat);\n          nextAt = getNextBlock(nextAt);  \n       }\n    }
686	protected void drawMultipleEllipse(Point2D point, double boxWidth,\n                                       double oRadius, Graphics2D g2) {\n\n        Ellipse2D.Double dot1 = new Ellipse2D.Double(point.getX()\n                - (boxWidth / 2) + oRadius, point.getY(), oRadius, oRadius);\n        Ellipse2D.Double dot2 = new Ellipse2D.Double(point.getX()\n                + (boxWidth / 2), point.getY(), oRadius, oRadius);\n        g2.draw(dot1);\n        g2.draw(dot2);\n\n    }
687	protected void drawRadarPoly(Graphics2D g2,\n                                 Rectangle2D plotArea,\n                                 Point2D centre,\n                                 PlotRenderingInfo info,\n                                 int series, int catCount,\n                                 double headH, double headW) {\n\n        Polygon polygon = new Polygon();\n\n        EntityCollection entities = null;\n        if (info != null) {\n            entities = info.getOwner().getEntityCollection();\n        }\n\n                for (int cat = 0; cat < catCount; cat++) {\n\n            Number dataValue = getPlotValue(series, cat);\n\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n\n                if (value >= 0) { \n                    \n                    double angle = getStartAngle()\n                        + (getDirection().getFactor() * cat * 360 / catCount);\n\n                                                                                                                        \n                                                            \n                    Point2D point = getWebPoint(plotArea, angle,\n                            value / this.maxValue);\n                    polygon.addPoint((int) point.getX(), (int) point.getY());\n\n                    \n                    Paint paint = getSeriesPaint(series);\n                    Paint outlinePaint = getSeriesOutlinePaint(series);\n                    Stroke outlineStroke = getSeriesOutlineStroke(series);\n\n                    Ellipse2D head = new Ellipse2D.Double(point.getX()\n                            - headW / 2, point.getY() - headH / 2, headW,\n                            headH);\n                    g2.setPaint(paint);\n                    g2.fill(head);\n                    g2.setStroke(outlineStroke);\n                    g2.setPaint(outlinePaint);\n                    g2.draw(head);\n\n                    if (entities != null) {\n                        int row, col;\n                        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                            row = series;\n                            col = cat;\n                        }\n                        else {\n                            row = cat;\n                            col = series;\n                        }\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, row, col);\n                        }\n\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset,\n                                   row, col);\n                        }\n\n                        Shape area = new Rectangle(\n                                (int) (point.getX() - headW),\n                                (int) (point.getY() - headH),\n                                (int) (headW * 2), (int) (headH * 2));\n                        CategoryItemEntity entity = new CategoryItemEntity(\n                                area, tip, url, this.dataset,\n                                this.dataset.getRowKey(row),\n                                this.dataset.getColumnKey(col));\n                        entities.add(entity);\n                    }\n\n                }\n            }\n        }\n        \n        Paint paint = getSeriesPaint(series);\n        g2.setPaint(paint);\n        g2.setStroke(getSeriesOutlineStroke(series));\n        g2.draw(polygon);\n\n        \n        if (this.webFilled) {\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    0.1f));\n            g2.fill(polygon);\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getForegroundAlpha()));\n        }\n    }
688	protected AxisState drawTickLabels(int band, Graphics2D g2, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n                double delta1 = 0.0;\n        FontMetrics fm = g2.getFontMetrics(this.labelInfo[band].getLabelFont());\n        if (edge == RectangleEdge.BOTTOM) {\n            delta1 = this.labelInfo[band].getPadding().calculateTopOutset(\n                    fm.getHeight());\n        }\n        else if (edge == RectangleEdge.TOP) {\n            delta1 = this.labelInfo[band].getPadding().calculateBottomOutset(\n                    fm.getHeight());\n        }\n        state.moveCursor(delta1, edge);\n        long axisMin = this.first.getFirstMillisecond();\n        long axisMax = this.last.getLastMillisecond();\n        g2.setFont(this.labelInfo[band].getLabelFont());\n        g2.setPaint(this.labelInfo[band].getLabelPaint());\n\n                RegularTimePeriod p1 = this.labelInfo[band].createInstance(\n                new Date(axisMin), this.timeZone, this.locale);\n        RegularTimePeriod p2 = this.labelInfo[band].createInstance(\n                new Date(axisMax), this.timeZone, this.locale);\n        DateFormat df = this.labelInfo[band].getDateFormat();\n        df.setTimeZone(this.timeZone);\n        String label1 = df.format(new Date(p1.getMiddleMillisecond()));\n        String label2 = df.format(new Date(p2.getMiddleMillisecond()));\n        Rectangle2D b1 = TextUtilities.getTextBounds(label1, g2,\n                g2.getFontMetrics());\n        Rectangle2D b2 = TextUtilities.getTextBounds(label2, g2,\n                g2.getFontMetrics());\n        double w = Math.max(b1.getWidth(), b2.getWidth());\n        long ww = Math.round(java2DToValue(dataArea.getX() + w + 5.0,\n                dataArea, edge));\n        if (isInverted()) {\n            ww = axisMax - ww;\n        }\n        else {\n            ww = ww - axisMin;\n        }\n        long length = p1.getLastMillisecond()\n                      - p1.getFirstMillisecond();\n        int periods = (int) (ww / length) + 1;\n\n        RegularTimePeriod p = this.labelInfo[band].createInstance(\n                new Date(axisMin), this.timeZone, this.locale);\n        Rectangle2D b = null;\n        long lastXX = 0L;\n        float y = (float) (state.getCursor());\n        TextAnchor anchor = TextAnchor.TOP_CENTER;\n        float yDelta = (float) b1.getHeight();\n        if (edge == RectangleEdge.TOP) {\n            anchor = TextAnchor.BOTTOM_CENTER;\n            yDelta = -yDelta;\n        }\n        while (p.getFirstMillisecond() <= axisMax) {\n            float x = (float) valueToJava2D(p.getMiddleMillisecond(), dataArea,\n                    edge);\n            String label = df.format(new Date(p.getMiddleMillisecond()));\n            long first = p.getFirstMillisecond();\n            long last = p.getLastMillisecond();\n            if (last > axisMax) {\n                                                Rectangle2D bb = TextUtilities.getTextBounds(label, g2,\n                        g2.getFontMetrics());\n                if ((x + bb.getWidth() / 2) > dataArea.getMaxX()) {\n                    float xstart = (float) valueToJava2D(Math.max(first,\n                            axisMin), dataArea, edge);\n                    if (bb.getWidth() < (dataArea.getMaxX() - xstart)) {\n                        x = ((float) dataArea.getMaxX() + xstart) / 2.0f;\n                    }\n                    else {\n                        label = null;\n                    }\n                }\n            }\n            if (first < axisMin) {\n                                                Rectangle2D bb = TextUtilities.getTextBounds(label, g2,\n                        g2.getFontMetrics());\n                if ((x - bb.getWidth() / 2) < dataArea.getX()) {\n                    float xlast = (float) valueToJava2D(Math.min(last,\n                            axisMax), dataArea, edge);\n                    if (bb.getWidth() < (xlast - dataArea.getX())) {\n                        x = (xlast + (float) dataArea.getX()) / 2.0f;\n                    }\n                    else {\n                        label = null;\n                    }\n                }\n\n            }\n            if (label != null) {\n                g2.setPaint(this.labelInfo[band].getLabelPaint());\n                b = TextUtilities.drawAlignedString(label, g2, x, y, anchor);\n            }\n            if (lastXX > 0L) {\n                if (this.labelInfo[band].getDrawDividers()) {\n                    long nextXX = p.getFirstMillisecond();\n                    long mid = (lastXX + nextXX) / 2;\n                    float mid2d = (float) valueToJava2D(mid, dataArea, edge);\n                    g2.setStroke(this.labelInfo[band].getDividerStroke());\n                    g2.setPaint(this.labelInfo[band].getDividerPaint());\n                    g2.draw(new Line2D.Float(mid2d, y, mid2d, y + yDelta));\n                }\n            }\n            lastXX = last;\n            for (int i = 0; i < periods; i++) {\n                p = p.next();\n            }\n            p.peg(this.calendar);\n        }\n        double used = 0.0;\n        if (b != null) {\n            used = b.getHeight();\n                        if (edge == RectangleEdge.BOTTOM) {\n                used += this.labelInfo[band].getPadding().calculateBottomOutset(\n                        fm.getHeight());\n            }\n            else if (edge == RectangleEdge.TOP) {\n                used += this.labelInfo[band].getPadding().calculateTopOutset(\n                        fm.getHeight());\n            }\n        }\n        state.moveCursor(used, edge);\n        return state;\n    }
689	public static JFreeChart createWaferMapChart(String title,\n            WaferMapDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        WaferMapPlot plot = new WaferMapPlot(dataset);\n        WaferMapRenderer renderer = new WaferMapRenderer();\n        plot.setRenderer(renderer);\n\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n    }
690	public HSSFTextbox createTextbox(HSSFClientAnchor anchor) {\n        HSSFTextbox shape = new HSSFTextbox(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
691	private void attemptMergeColInfoRecords(int colInfoIx) {\n		int nRecords = records.size();\n		if (colInfoIx < 0 || colInfoIx >= nRecords) {\n			throw new IllegalArgumentException("colInfoIx " + colInfoIx\n					+ " is out of range (0.." + (nRecords-1) + ")");\n		}\n		ColumnInfoRecord currentCol = getColInfo(colInfoIx);\n		int nextIx = colInfoIx+1;\n		if (nextIx < nRecords) {\n			if (mergeColInfoRecords(currentCol, getColInfo(nextIx))) {\n    			records.remove(nextIx);\n			}\n		}\n		if (colInfoIx > 0) {\n			if (mergeColInfoRecords(getColInfo(colInfoIx - 1), currentCol)) {\n    			records.remove(colInfoIx);\n    		}\n		}\n	}
692	boolean makeRoomLRU() {\n    if (!isCacheFull()) {\n      return false;\n    }\n    int n = cache.size() - (2*maxCacheSize)/3;\n    if (n<=0) {\n      return false;\n    }\n    Iterator<Object> it = cache.keySet().iterator();\n    int i = 0;\n    while (i<n && it.hasNext()) {\n      it.next();\n      it.remove();\n      i++;\n    }\n    return true;\n  }
693	public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }
694	public XWPFTableRow insertNewTableRow(int pos) {\n        if (pos >= 0 && pos <= tableRows.size()) {\n            CTRow row = ctTbl.insertNewTr(pos);\n            XWPFTableRow tableRow = new XWPFTableRow(row, this);\n            tableRows.add(pos, tableRow);\n            return tableRow;\n        }\n        return null;\n    }
695	private Iterable<Map.Entry<String,String>> combinedCommitData(Iterable<Map.Entry<String,String>> commitData) {\n    Map<String,String> m = new HashMap<>();\n    if (commitData != null) {\n      for(Map.Entry<String,String> ent : commitData) {\n        m.put(ent.getKey(), ent.getValue());\n      }\n    }\n    m.put(INDEX_EPOCH, Long.toString(indexEpoch, 16));\n    return m.entrySet();\n  }
696	public void demonstrateMethodCalls(String outputFilename) throws IOException {\n        try (HSSFWorkbook workbook = new HSSFWorkbook()) {\n            HSSFSheet sheet = workbook.createSheet("In Cell Lists");\n            HSSFRow row = sheet.createRow(0);\n\n                                    HSSFCell cell = row.createCell(0);\n            this.bulletedItemInCell(workbook, "List Item", cell);\n\n                                    row = sheet.createRow(1);\n            cell = row.createCell(0);\n            ArrayList<String> listItems = new ArrayList<>();\n            listItems.add("List Item One.");\n            listItems.add("List Item Two.");\n            listItems.add("List Item Three.");\n            listItems.add("List Item Four.");\n            this.listInCell(workbook, listItems, cell);\n                                    row.setHeight((short) 1100);\n            sheet.setColumnWidth(0, 9500);\n\n                                                row = sheet.createRow(2);\n            cell = row.createCell(0);\n            listItems.add("List Item Five.");\n            listItems.add("List Item Six.");\n            this.numberedListInCell(workbook, listItems, cell, 1, 2);\n            row.setHeight((short) 1550);\n\n                                                row = sheet.createRow(3);\n            cell = row.createCell(0);\n            listItems.add("List Item Seven.");\n            listItems.add("List Item Eight.");\n            listItems.add("List Item Nine.");\n            listItems.add("List Item Ten.");\n            this.bulletedListInCell(workbook, listItems, cell);\n            row.setHeight((short) 2550);\n\n                                                                                                                        row = sheet.createRow(4);\n            cell = row.createCell(0);\n            ArrayList<MultiLevelListItem> multiLevelListItems = new ArrayList<>();\n            listItems = new ArrayList<>();\n            listItems.add("ML List Item One - Sub Item One.");\n            listItems.add("ML List Item One - Sub Item Two.");\n            listItems.add("ML List Item One - Sub Item Three.");\n            listItems.add("ML List Item One - Sub Item Four.");\n            multiLevelListItems.add(new MultiLevelListItem("List Item One.", listItems));\n                                                multiLevelListItems.add(new MultiLevelListItem("List Item Two.", null));\n            multiLevelListItems.add(new MultiLevelListItem("List Item Three.", null));\n            listItems = new ArrayList<>();\n            listItems.add("ML List Item Four - Sub Item One.");\n            listItems.add("ML List Item Four - Sub Item Two.");\n            listItems.add("ML List Item Four - Sub Item Three.");\n            multiLevelListItems.add(new MultiLevelListItem("List Item Four.", listItems));\n            this.multiLevelListInCell(workbook, multiLevelListItems, cell);\n            row.setHeight((short) 2800);\n\n                                                row = sheet.createRow(5);\n            cell = row.createCell(0);\n            this.multiLevelNumberedListInCell(workbook, multiLevelListItems,\n                    cell, 1, 1, 1, 2);\n            row.setHeight((short) 2800);\n\n                                                row = sheet.createRow(6);\n            cell = row.createCell(0);\n            this.multiLevelBulletedListInCell(workbook, multiLevelListItems, cell);\n            row.setHeight((short) 2800);\n\n                        try (FileOutputStream fos = new FileOutputStream(new File(outputFilename))) {\n                workbook.write(fos);\n            }\n        } catch (IOException ioEx) {\n            System.out.println("Caught a: " + ioEx.getClass().getName());\n            System.out.println("Message: " + ioEx.getMessage());\n            System.out.println("Stacktrace follows...........");\n            ioEx.printStackTrace(System.out);\n        }\n    }
697	public static ErrorEval valueOf(int errorCode) {\n        FormulaError error = FormulaError.forInt(errorCode);\n        ErrorEval eval = evals.get(error);\n        if (eval != null) {\n            return eval;\n        } else {\n            throw new RuntimeException("Unhandled error type for code " + errorCode);\n        }\n    }
698	public String getTextRecursively() {\n\n        StringBuilder text = new StringBuilder(64);\n        for (int i = 0; i < bodyElements.size(); i++) {\n            boolean isLast = (i == bodyElements.size() - 1);\n            appendBodyElementText(text, bodyElements.get(i), isLast);\n        }\n\n        return text.toString();\n    }
699	public static ValueEval getSingleValue(ValueEval arg, int srcCellRow, int srcCellCol)\n            throws EvaluationException {\n        final ValueEval result;\n        if (arg instanceof RefEval) {\n            result = chooseSingleElementFromRef((RefEval) arg);\n        } else if (arg instanceof AreaEval) {\n            result = chooseSingleElementFromArea((AreaEval) arg, srcCellRow, srcCellCol);\n        } else {\n            result = arg;\n        }\n        if (result instanceof ErrorEval) {\n            throw new EvaluationException((ErrorEval) result);\n        }\n        return result;\n    }
700	private boolean isCursorInFtn(XmlCursor cursor) {\n        XmlCursor verify = cursor.newCursor();\n        verify.toParent();\n        if (verify.getObject() == this.ctFtnEdn) {\n            return true;\n        }\n        return false;\n    }
701	protected int countDocsWithClass() throws IOException {\n    Terms terms = MultiFields.getTerms(this.indexReader, this.classFieldName);\n    int docCount;\n    if (terms == null || terms.getDocCount() == -1) {       TotalHitCountCollector classQueryCountCollector = new TotalHitCountCollector();\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, String.valueOf(WildcardQuery.WILDCARD_STRING))), BooleanClause.Occur.MUST));\n      if (query != null) {\n        q.add(query, BooleanClause.Occur.MUST);\n      }\n      indexSearcher.search(q.build(),\n          classQueryCountCollector);\n      docCount = classQueryCountCollector.getTotalHits();\n    } else {\n      docCount = terms.getDocCount();\n    }\n    return docCount;\n  }
702	public static double calculateMedian(List values, int start, int end,\n                                         boolean copyAndSort) {\n\n        double result = Double.NaN;\n        if (copyAndSort) {\n            List working = new ArrayList(end - start + 1);\n            for (int i = start; i <= end; i++) {\n                working.add(values.get(i));\n            }\n            Collections.sort(working);\n            result = calculateMedian(working, false);\n        }\n        else {\n            int count = end - start + 1;\n            if (count > 0) {\n                if (count % 2 == 1) {\n                    if (count > 1) {\n                        Number value\n                            = (Number) values.get(start + (count - 1) / 2);\n                        result = value.doubleValue();\n                    }\n                    else {\n                        Number value = (Number) values.get(start);\n                        result = value.doubleValue();\n                    }\n                }\n                else {\n                    Number value1 = (Number) values.get(start + count / 2 - 1);\n                    Number value2 = (Number) values.get(start + count / 2);\n                    result\n                        = (value1.doubleValue() + value2.doubleValue()) / 2.0;\n                }\n            }\n        }\n        return result;\n\n    }
703	public static long checkFooter(ChecksumIndexInput in) throws IOException {\n    validateFooter(in);\n    long actualChecksum = in.getChecksum();\n    long expectedChecksum = readCRC(in);\n    if (expectedChecksum != actualChecksum) {\n      throw new CorruptIndexException("checksum failed (hardware problem?) : expected=" + Long.toHexString(expectedChecksum) +  \n                                                       " actual=" + Long.toHexString(actualChecksum), in);\n    }\n    return actualChecksum;\n  }
704	public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }
705	public static IntsRef toUTF32(char[] s, int offset, int length, IntsRefBuilder scratch) {\n    int charIdx = offset;\n    int intIdx = 0;\n    final int charLimit = offset + length;\n    while(charIdx < charLimit) {\n      scratch.grow(intIdx+1);\n      final int utf32 = Character.codePointAt(s, charIdx, charLimit);\n      scratch.setIntAt(intIdx, utf32);\n      charIdx += Character.charCount(utf32);\n      intIdx++;\n    }\n    scratch.setLength(intIdx);\n    return scratch.get();\n  }
706	public Range findValueRange(Range xRange, TimePeriodAnchor xAnchor, \n            TimeZone zone) {\n        ParamChecks.nullNotPermitted(xRange, "xRange");\n        ParamChecks.nullNotPermitted(xAnchor, "xAnchor");\n        ParamChecks.nullNotPermitted(zone, "zone");\n        if (this.data.isEmpty()) {\n            return null;\n        }\n        Calendar calendar = Calendar.getInstance(zone);\n                        double lowY = Double.POSITIVE_INFINITY;\n        double highY = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < this.data.size(); i++) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n            long millis = item.getPeriod().getMillisecond(xAnchor, calendar);\n            if (xRange.contains(millis)) {\n                Number n = item.getValue();\n                if (n != null) {\n                    double v = n.doubleValue();\n                    lowY = Math.min(lowY, v);\n                    highY = Math.max(highY, v);\n                }\n            }\n        }\n        if (Double.isInfinite(lowY) && Double.isInfinite(highY)) {\n            if (lowY < highY) {\n                return new Range(lowY, highY);\n            } else {\n                return new Range(Double.NaN, Double.NaN);\n            }\n        }\n        return new Range(lowY, highY);\n    }
707	public void mapKeyToGroup(Comparable key, Comparable group) {\n        ParamChecks.nullNotPermitted(key, "key");\n        Comparable currentGroup = getGroup(key);\n        if (!currentGroup.equals(this.defaultGroup)) {\n            if (!currentGroup.equals(group)) {\n                int count = getKeyCount(currentGroup);\n                if (count == 1) {\n                    this.groups.remove(currentGroup);\n                }\n            }\n        }\n        if (group == null) {\n            this.keyToGroupMap.remove(key);\n        }\n        else {\n            if (!this.groups.contains(group)) {\n                if (!this.defaultGroup.equals(group)) {\n                    this.groups.add(group);\n                }\n            }\n            this.keyToGroupMap.put(key, group);\n        }\n    }
708	protected void drawLine(Graphics2D g2, State state,\n            PlotOrientation orientation, double x0, double y0, double x1,\n            double y1) {\n\n        if (orientation == PlotOrientation.VERTICAL) {\n            state.line.setLine(x0, y0, x1, y1);\n            g2.draw(state.line);\n        }\n        else if (orientation == PlotOrientation.HORIZONTAL) {\n            state.line.setLine(y0, x0, y1, x1);             g2.draw(state.line);\n        }\n\n    }
709	public boolean visit() throws IOException {\n        for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n                    dest.message("file " + tmpName + ": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=" + checksum + " vs expected=" + metaData.checksum + "; cancel job");\n          throw new IOException("file " + name + ": checksum mismatch after file copy");\n        }\n\n                        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message("file " + tmpName + ": checksum claimed by primary disagrees with the file's footer: claimed checksum=" + checksum + " vs actual=" + actualChecksumIn);\n          throw new IOException("file " + name + ": checksum mismatch after file copy");\n        }\n        out.writeLong(checksum);\n        bytesCopied += Long.BYTES;\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, "file %s: done copying [%s, %.3fms]",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n            bytesCopied += toCopy;\n    }\n\n    return false;\n  }
710	private CTHdrFtr buildHdrFtr(XWPFParagraph[] paragraphs, XWPFHeaderFooter wrapper) {\n        CTHdrFtr ftr = wrapper._getHdrFtr();\n        if (paragraphs != null) {\n            for (int i = 0; i < paragraphs.length; i++) {\n                 ftr.addNewP();\n                ftr.setPArray(i, paragraphs[i].getCTP());\n            }\n        }\n        return ftr;\n    }
711	protected Size2D arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(widthRange,\n                    heightRange);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Range heightRange2 = Range.shift(heightRange, -h[0], false);\n            RectangleConstraint c2 = new RectangleConstraint(widthRange,\n                    heightRange2);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(widthRange,\n                    heightRange3);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        Range widthRange2 = Range.shift(widthRange, -w[2], false);\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(widthRange2,\n                    heightRange3);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);\n        if (this.centerBlock != null) {\n            RectangleConstraint c5 = new RectangleConstraint(widthRange3,\n                    heightRange3);\n            Size2D size = this.centerBlock.arrange(g2, c5);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], h[3]));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], height - h[0] - h[1]));\n        }\n        return new Size2D(width, height);\n    }
712	public void setParentSize(int size) {\n        assert(size > 0);\n        int covered = 0;\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TextSpecInfoRun runs[] = getTextSpecInfoRuns();\n        assert(runs.length > 0);\n        for (int i=0; i<runs.length && covered < size; i++) {\n            TextSpecInfoRun run = runs[i];\n            if (covered + run.getLength() > size || i == runs.length-1) {\n                run.setLength(size-covered);\n            }\n            covered += run.getLength();\n            try {\n                run.writeOut(bos);\n            } catch (IOException e) {\n                throw new HSLFException(e);\n            }\n        }\n        _data = bos.toByteArray();\n\n                LittleEndian.putInt(_header, 4, _data.length);\n    }
713	public static Hour parseHour(String s) {\n        Hour result = null;\n        s = s.trim();\n\n        String daystr = s.substring(0, Math.min(10, s.length()));\n        Day day = Day.parseDay(daystr);\n        if (day != null) {\n            String hourstr = s.substring(\n                Math.min(daystr.length() + 1, s.length()), s.length()\n            );\n            hourstr = hourstr.trim();\n            int hour = Integer.parseInt(hourstr);\n                        if ((hour >= FIRST_HOUR_IN_DAY) && (hour <= LAST_HOUR_IN_DAY)) {\n                result = new Hour(hour, day);\n            }\n        }\n\n        return result;\n    }
714	public InputStream getContents(PackagePart corePart) throws IOException, InvalidFormatException {\n        PackageRelationshipCollection prc =\n                corePart.getRelationshipsByType(getRelation());\n        Iterator<PackageRelationship> it = prc.iterator();\n        if(it.hasNext()) {\n            PackageRelationship rel = it.next();\n            PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n            PackagePart part = corePart.getPackage().getPart(relName);\n            return part.getInputStream();\n        }\n        log.log(POILogger.WARN, "No part " + getDefaultFileName() + " found");\n        return null;\n    }
715	public Bounds addYValue(final double y) {\n    final double small = y - FUDGE_FACTOR;\n    if (minY == null || minY > small) {\n      minY = new Double(small);\n    }\n    final double large = y + FUDGE_FACTOR;\n    if (maxY == null || maxY < large) {\n      maxY = new Double(large);\n    }\n    return this;\n  }
716	@Beta\n    public void addReportFilter(int columnIndex) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n                CTLocation location = pivotTableDefinition.getLocation();\n        AreaReference destination = new AreaReference(location.getRef(), SpreadsheetVersion.EXCEL2007);\n        if (destination.getFirstCell().getRow() < 2) {\n            AreaReference newDestination = new AreaReference(new CellReference(2, destination.getFirstCell().getCol()), new CellReference(\n                    3, destination.getFirstCell().getCol()+1), SpreadsheetVersion.EXCEL2007);\n            location.setRef(newDestination.formatAsString());\n       }\n\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_PAGE);\n        pivotField.setShowAll(false);\n        for(int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTPageFields pageFields;\n        if (pivotTableDefinition.getPageFields()!= null) {\n            pageFields = pivotTableDefinition.getPageFields();\n                        pivotTableDefinition.setMultipleFieldFilters(true);\n        } else {\n            pageFields = pivotTableDefinition.addNewPageFields();\n        }\n        CTPageField pageField = pageFields.addNewPageField();\n        pageField.setHier(-1);\n        pageField.setFld(columnIndex);\n\n        pageFields.setCount(pageFields.sizeOfPageFieldArray());\n        pivotTableDefinition.getLocation().setColPageCount(pageFields.getCount());\n    }
717	public int normalize(char s[], int len) {\n\n    for (int i = 0; i < len; i++) {\n      switch (s[i]) {\n              case '\u0928':\n        if (i + 1 < len && s[i + 1] == '\u094D') {\n          s[i] = '\u0902';\n          len = delete(s, i + 1, len);\n        }\n        break;\n            case '\u0901':\n        s[i] = '\u0902';\n        break;\n            case '\u093C':\n        len = delete(s, i, len);\n        i--;\n        break;      \n      case '\u0929':\n        s[i] = '\u0928';\n        break;\n      case '\u0931':\n        s[i] = '\u0930';\n        break;\n      case '\u0934':\n        s[i] = '\u0933';\n        break;\n      case '\u0958':\n        s[i] = '\u0915';\n        break;\n      case '\u0959':\n        s[i] = '\u0916';\n        break;\n      case '\u095A':\n        s[i] = '\u0917';\n        break;\n      case '\u095B':\n        s[i] = '\u091C';\n        break;\n      case '\u095C':\n        s[i] = '\u0921';\n        break;\n      case '\u095D':\n        s[i] = '\u0922';\n        break;\n      case '\u095E':\n        s[i] = '\u092B';\n        break;\n      case '\u095F':\n        s[i] = '\u092F';\n        break;\n              case '\u200D':\n      case '\u200C':\n        len = delete(s, i, len);\n        i--;\n        break;\n              case '\u094D':\n        len = delete(s, i, len);\n        i--;\n        break;\n              case '\u0945':\n      case '\u0946':\n        s[i] = '\u0947';\n        break;\n      case '\u0949':\n      case '\u094A':\n        s[i] = '\u094B';\n        break;\n      case '\u090D':\n      case '\u090E':\n        s[i] = '\u090F';\n        break;\n      case '\u0911':\n      case '\u0912':\n        s[i] = '\u0913';\n        break;\n      case '\u0972':\n        s[i] = '\u0905';\n        break;\n              case '\u0906':\n        s[i] = '\u0905';\n        break;\n      case '\u0908':\n        s[i] = '\u0907';\n        break;\n      case '\u090A':\n        s[i] = '\u0909';\n        break;\n      case '\u0960':\n        s[i] = '\u090B';\n        break;\n      case '\u0961':\n        s[i] = '\u090C';\n        break;\n      case '\u0910':\n        s[i] = '\u090F';\n        break;\n      case '\u0914':\n        s[i] = '\u0913';\n        break;\n              case '\u0940':\n        s[i] = '\u093F';\n        break;\n      case '\u0942':\n        s[i] = '\u0941';\n        break;\n      case '\u0944':\n        s[i] = '\u0943';\n        break;\n      case '\u0963':\n        s[i] = '\u0962';\n        break;\n      case '\u0948':\n        s[i] = '\u0947';\n        break;\n      case '\u094C':\n        s[i] = '\u094B';\n        break;\n      default:\n        break;\n      }\n    }\n\n    return len;\n  }
718	public double arcDistance(final PlanetModel planetModel, final double x, final double y, final double z, final Membership... bounds) {\n\n    if (evaluateIsZero(x,y,z)) {\n      if (meetsAllBounds(x,y,z, bounds))\n        return 0.0;\n      return Double.POSITIVE_INFINITY;\n    }\n    \n        final Plane perpPlane = new Plane(this.y * z - this.z * y, this.z * x - this.x * z, this.x * y - this.y * x, 0.0);\n\n                \n    final GeoPoint[] intersectionPoints = findIntersections(planetModel, perpPlane);\n    \n        double minDistance = Double.POSITIVE_INFINITY;\n    \n    for (final GeoPoint intersectionPoint : intersectionPoints) {\n      if (meetsAllBounds(intersectionPoint, bounds)) {\n        final double theDistance = intersectionPoint.arcDistance(x,y,z);\n        if (theDistance < minDistance) {\n          minDistance = theDistance;\n        }\n      }\n    }\n    return minDistance;\n\n  }
719	@SuppressWarnings("resource")\n    protected static List<HSLFHyperlink> find(List<HSLFTextParagraph> paragraphs){\n        List<HSLFHyperlink> lst = new ArrayList<>();\n        if (paragraphs == null || paragraphs.isEmpty()) return lst;\n\n        HSLFTextParagraph firstPara = paragraphs.get(0);\n\n        HSLFSlideShow ppt = firstPara.getSheet().getSlideShow();\n                ExObjList exobj = ppt.getDocumentRecord().getExObjList(false);\n        if (exobj != null) {\n            Record[] records = firstPara.getRecords();\n            find(Arrays.asList(records), exobj, lst);\n        }\n\n        return lst;\n    }
720	protected void drawWaferEdge(Graphics2D g2, Rectangle2D plotArea) {\n                Ellipse2D waferEdge = getWaferEdge(plotArea);\n        g2.setColor(Color.black);\n        g2.draw(waferEdge);\n                                Arc2D notch;\n        Rectangle2D waferFrame = waferEdge.getFrame();\n        double notchDiameter = waferFrame.getWidth() * 0.04;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            Rectangle2D notchFrame =\n                new Rectangle2D.Double(\n                    waferFrame.getX() + waferFrame.getWidth()\n                    - (notchDiameter / 2), waferFrame.getY()\n                    + (waferFrame.getHeight() / 2) - (notchDiameter / 2),\n                    notchDiameter, notchDiameter\n                );\n            notch = new Arc2D.Double(notchFrame, 90d, 180d, Arc2D.OPEN);\n        }\n        else {\n            Rectangle2D notchFrame =\n                new Rectangle2D.Double(\n                    waferFrame.getX() + (waferFrame.getWidth() / 2)\n                    - (notchDiameter / 2), waferFrame.getY()\n                    + waferFrame.getHeight() - (notchDiameter / 2),\n                    notchDiameter, notchDiameter\n                );\n            notch = new Arc2D.Double(notchFrame, 0d, 180d, Arc2D.OPEN);\n        }\n        g2.setColor(Color.white);\n        g2.fill(notch);\n        g2.setColor(Color.black);\n        g2.draw(notch);\n\n    }
721	public void serialize(ContinuableRecordOutput out) {\n        int numberOfRichTextRuns = 0;\n        int extendedDataSize = 0;\n        if (isRichText() && field_4_format_runs != null) {\n            numberOfRichTextRuns = field_4_format_runs.size();\n        }\n        if (isExtendedText() && field_5_ext_rst != null) {\n            extendedDataSize = 4 + field_5_ext_rst.getDataSize();\n        }\n       \n                        out.writeString(field_3_string, numberOfRichTextRuns, extendedDataSize);\n\n        if (numberOfRichTextRuns > 0) {\n\n                    for (int i=0;i<numberOfRichTextRuns;i++) {\n              if (out.getAvailableSpace() < 4) {\n                  out.writeContinue();\n              }\n              FormatRun r = field_4_format_runs.get(i);\n              r.serialize(out);\n          }\n        }\n\n        if (extendedDataSize > 0 && field_5_ext_rst != null) {\n           field_5_ext_rst.serialize(out);\n        }\n    }
722	protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (!isRangeZeroBaselineVisible()) {\n            return;\n        }\n        CategoryItemRenderer r = getRenderer();\n        if (r instanceof AbstractCategoryItemRenderer) {\n            AbstractCategoryItemRenderer aci = (AbstractCategoryItemRenderer) r;\n            aci.drawRangeLine(g2, this, getRangeAxis(), area, 0.0,\n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n        else {\n            r.drawRangeGridline(g2, this, getRangeAxis(), area, 0.0);\n        }\n    }
723	public XWPFTable insertNewTbl(XmlCursor cursor) {\n        if (isCursorInFtn(cursor)) {\n            String uri = CTTbl.type.getName().getNamespaceURI();\n            String localPart = "tbl";\n            cursor.beginElement(localPart, uri);\n            cursor.toParent();\n            CTTbl t = (CTTbl) cursor.getObject();\n            XWPFTable newT = new XWPFTable(t, this);\n            cursor.removeXmlContents();\n            XmlObject o = null;\n            while (!(o instanceof CTTbl) && (cursor.toPrevSibling())) {\n                o = cursor.getObject();\n            }\n            if (!(o instanceof CTTbl)) {\n                tables.add(0, newT);\n            } else {\n                int pos = tables.indexOf(getTable((CTTbl) o)) + 1;\n                tables.add(pos, newT);\n            }\n            int i = 0;\n            cursor = t.newCursor();\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (o instanceof CTP || o instanceof CTTbl)\n                    i++;\n            }\n            bodyElements.add(i, newT);\n            XmlCursor c2 = t.newCursor();\n            cursor.toCursor(c2);\n            cursor.toEndToken();\n            c2.dispose();\n            return newT;\n        }\n        return null;\n    }
724	public static int strcmp(String str, char[] a, int start) {\n    int i, d, len = str.length();\n    for (i = 0; i < len; i++) {\n      d = (int) str.charAt(i) - a[start + i];\n      if (d != 0) {\n        return d;\n      }\n      if (a[start + i] == 0) {\n        return d;\n      }\n    }\n    if (a[start + i] != 0) {\n      return -a[start + i];\n    }\n    return 0;\n\n  }
725	public static void xmlBeans(int numCols) {\n        int i = 0, cnt = 0;\n        printMemoryUsage("before");\n\n        CTWorksheet sh = CTWorksheet.Factory.newInstance();\n        CTSheetData data = sh.addNewSheetData();\n        try {\n            for (i = 0; ; i++) {\n                CTRow row = data.addNewRow();\n                row.setR(i);\n                for (int j = 0; j < numCols; j++) {\n                    CTCell cell = row.addNewC();\n                    cell.setT(STCellType.N);\n                    cell.setV(String.valueOf(j));\n                    cnt++;\n                }\n            }\n        } catch (OutOfMemoryError er) {\n            System.out.println("Failed at row=" + i + ", objects: " + cnt);\n        } catch (final Exception e) {\n            System.out.println("Unable to reach an OutOfMemoryError");\n            System.out.println(e.getClass().getName() + ": " + e.getMessage());\n        }\n        printMemoryUsage("after");\n    }
726	public NameXPtg getNameXPtg(String name, int sheetRefIndex) {\n                for (int i = 0; i < _externalBookBlocks.length; i++) {\n            int definedNameIndex = _externalBookBlocks[i].getIndexOfName(name);\n            if (definedNameIndex < 0) {\n                continue;\n            }\n\n                        int thisSheetRefIndex = findRefIndexFromExtBookIndex(i);\n            if (thisSheetRefIndex >= 0) {\n                                if (sheetRefIndex == -1 || thisSheetRefIndex == sheetRefIndex) {\n                    return new NameXPtg(thisSheetRefIndex, definedNameIndex);\n                }\n            }\n        }\n        return null;\n    }
727	public static JFreeChart createGanttChart(String title,\n            String categoryAxisLabel, String dateAxisLabel,\n            IntervalCategoryDataset dataset, boolean legend, boolean tooltips,\n            boolean urls) {\n\n        CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel);\n        DateAxis dateAxis = new DateAxis(dateAxisLabel);\n\n        CategoryItemRenderer renderer = new GanttRenderer();\n        if (tooltips) {\n            renderer.setBaseToolTipGenerator(\n                    new IntervalCategoryToolTipGenerator(\n                    "{3} - {4}", DateFormat.getDateInstance()));\n        }\n        if (urls) {\n            renderer.setBaseItemURLGenerator(\n                    new StandardCategoryURLGenerator());\n        }\n\n        CategoryPlot plot = new CategoryPlot(dataset, categoryAxis, dateAxis,\n                renderer);\n        plot.setOrientation(PlotOrientation.HORIZONTAL);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
728	private Map<Integer, Integer> computeWidths(Sheet sheet) {\n        Map<Integer, Integer> ret = new TreeMap<>();\n        int tableWidth = 0;\n\n        ensureColumnBounds(sheet);\n        \n                int lastRowNum = sheet.getLastRowNum();\n        int headerCharCount = String.valueOf(lastRowNum).length();\n        int headerColWidth = widthToPixels((headerCharCount + 1) * 256);\n        ret.put(IDX_HEADER_COL_WIDTH, headerColWidth);\n        tableWidth += headerColWidth;\n\n        for (int i = firstColumn; i < endColumn; i++) {\n            int colWidth = widthToPixels(sheet.getColumnWidth(i));\n            ret.put(i, colWidth);\n            tableWidth += colWidth;\n        }\n        \n        ret.put(IDX_TABLE_WIDTH, tableWidth);\n        return ret ;\n    }
729	private double mapValueToFixedRange(double value) {\n        double lower = this.fixedRange.getLowerBound();\n        double length = this.fixedRange.getLength();\n        if (value < lower) {\n            return lower + length + ((value - lower) % length);\n        }\n        else {\n            return lower + ((value - lower) % length);\n        }\n    }
730	public static int toCodePoints(char[] src, int srcOff, int srcLen, int[] dest, int destOff) {\n    if (srcLen < 0) {\n      throw new IllegalArgumentException("srcLen must be >= 0");\n    }\n    int codePointCount = 0;\n    for (int i = 0; i < srcLen; ) {\n      final int cp = Character.codePointAt(src, srcOff + i, srcOff + srcLen);\n      final int charCount = Character.charCount(cp);\n      dest[destOff + codePointCount++] = cp;\n      i += charCount;\n    }\n    return codePointCount;\n  }
731	public Set<CellPosition> getPosition(int rowInd, int colInd) {\n	    Set<CellPosition> positions = EnumSet.noneOf(CellPosition.class);\n	    if (rowInd > getFirstRow() && rowInd < getLastRow() && colInd > getFirstColumn() && colInd < getLastColumn()) {\n	        positions.add(CellPosition.INSIDE);\n	        return positions; 	    }\n	    	    if (rowInd == getFirstRow()) positions.add(CellPosition.TOP);\n	    if (rowInd == getLastRow()) positions.add(CellPosition.BOTTOM);\n	    if (colInd == getFirstColumn()) positions.add(CellPosition.LEFT);\n	    if (colInd == getLastColumn()) positions.add(CellPosition.RIGHT);\n	    \n	    return positions;\n	}
732	public static String getBlipType(byte b) {\n        switch (b) {\n            case BT_ERROR:   return " ERROR";\n            case BT_UNKNOWN: return " UNKNOWN";\n            case BT_EMF:     return " EMF";\n            case BT_WMF:     return " WMF";\n            case BT_PICT:    return " PICT";\n            case BT_JPEG:    return " JPEG";\n            case BT_PNG:     return " PNG";\n            case BT_DIB:     return " DIB";\n        }\n        if ( b < 32 ) {\n            return " NotKnown";\n        }\n        return " Client";\n    }
733	protected int calculateNonWeekendHolidays(double start, double end, double[] holidays) {\n        int nonWeekendHolidays = 0;\n        double startDay = start < end ? start : end;\n        double endDay = end > start ? end : start;\n        for (double holiday : holidays) {\n            if (isInARange(startDay, endDay, holiday)) {\n                if (!isWeekend(holiday)) {\n                    nonWeekendHolidays++;\n                }\n            }\n        }\n        return start <= end ? nonWeekendHolidays : -nonWeekendHolidays;\n    }
734	public void remove( Object record ) {\n	   	   int i = 0;\n	   for (Record r : records) {\n	       if (r == record) {\n	           remove(i);\n	           break;\n	       }\n	       i++;\n	   }\n	}
735	private static int[] computeFailure(byte[] pattern) {\n        int[] failure = new int[pattern.length];\n\n        int j = 0;\n        for (int i = 1; i < pattern.length; i++) {\n            while (j > 0 && pattern[j] != pattern[i]) {\n                j = failure[j - 1];\n            }\n            if (pattern[j] == pattern[i]) {\n                j++;\n            }\n            failure[i] = j;\n        }\n\n        return failure;\n    }
736	@Beta\n    protected void createSourceReferences(CellReference position, Sheet sourceSheet, PivotTableReferenceConfigurator refConfig){\n        \n                AreaReference destination = new AreaReference(position, new CellReference(\n                position.getRow()+1, position.getCol()+1), SpreadsheetVersion.EXCEL2007);\n\n        CTLocation location;\n        if(pivotTableDefinition.getLocation() == null) {\n            location = pivotTableDefinition.addNewLocation();\n            location.setFirstDataCol(1);\n            location.setFirstDataRow(1);\n            location.setFirstHeaderRow(1);\n        } else {\n            location = pivotTableDefinition.getLocation();\n        }\n        location.setRef(destination.formatAsString());\n        pivotTableDefinition.setLocation(location);\n\n                CTPivotCacheDefinition cacheDef = getPivotCacheDefinition().getCTPivotCacheDefinition();\n        CTCacheSource cacheSource = cacheDef.addNewCacheSource();\n        cacheSource.setType(STSourceType.WORKSHEET);\n        CTWorksheetSource worksheetSource = cacheSource.addNewWorksheetSource();\n        worksheetSource.setSheet(sourceSheet.getSheetName());\n        setDataSheet(sourceSheet);\n\n        refConfig.configureReference(worksheetSource);\n        if (worksheetSource.getName() == null && worksheetSource.getRef() == null) throw new IllegalArgumentException("Pivot table source area reference or name must be specified.");\n    }
737	@SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})\n    public synchronized int appendRootLevelRecord(Record newRecord) {\n        int addedAt = -1;\n        Record[] r = new Record[_records.length + 1];\n        boolean added = false;\n        for (int i = (_records.length - 1); i >= 0; i--) {\n            if (added) {\n                                r[i] = _records[i];\n            } else {\n                r[(i + 1)] = _records[i];\n                if (_records[i] instanceof PersistPtrHolder) {\n                    r[i] = newRecord;\n                    added = true;\n                    addedAt = i;\n                }\n            }\n        }\n        _records = r;\n        return addedAt;\n    }
738	public void setAllBorders(Object... args) {\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = { BorderEdge.top, BorderEdge.left, null, null };\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[2] = (col == cols - 1) ? BorderEdge.right : null;\n                edges[3] = (row == rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
739	private short applyUserCellStyle(HSSFCellStyle style){\n        if(style.getUserStyleName() == null) {\n            throw new IllegalArgumentException("Expected user-defined style");\n        }\n\n        InternalWorkbook iwb = _book.getWorkbook();\n        short userXf = -1;\n        int numfmt = iwb.getNumExFormats();\n        for(short i = 0; i < numfmt; i++){\n            ExtendedFormatRecord xf = iwb.getExFormatAt(i);\n            if(xf.getXFType() == ExtendedFormatRecord.XF_CELL && xf.getParentIndex() == style.getIndex() ){\n                userXf = i;\n                break;\n            }\n        }\n        short styleIndex;\n        if (userXf == -1){\n            ExtendedFormatRecord xfr = iwb.createCellXF();\n            xfr.cloneStyleFrom(iwb.getExFormatAt(style.getIndex()));\n            xfr.setIndentionOptions((short)0);\n            xfr.setXFType(ExtendedFormatRecord.XF_CELL);\n            xfr.setParentIndex(style.getIndex());\n            styleIndex = (short)numfmt;\n        } else {\n            styleIndex = userXf;\n        }\n\n        return styleIndex;\n    }
740	private boolean handleFetchFiles(Random random, Socket socket, DataInput destIn, DataOutput destOut, BufferedOutputStream bos) throws IOException {\n    Thread.currentThread().setName("send");\n\n    int replicaID = destIn.readVInt();\n    message("top: start fetch for R" + replicaID + " socket=" + socket);\n    byte b = destIn.readByte();\n    CopyState copyState;\n    if (b == 0) {\n            copyState = null;\n    } else if (b == 1) {\n            copyState = getCopyState();\n      Thread.currentThread().setName("send-R" + replicaID + "-" + copyState.version);\n    } else {\n            throw new IllegalArgumentException("invalid CopyState byte=" + b);\n    }\n\n    try {\n      if (copyState != null) {\n                writeCopyState(copyState, destOut);\n        bos.flush();\n      }\n\n      byte[] buffer = new byte[16384];\n      int fileCount = 0;\n      long totBytesSent = 0;\n      while (true) {\n        byte done = destIn.readByte();\n        if (done == 1) {\n          break;\n        } else if (done != 0) {\n          throw new IllegalArgumentException("expected 0 or 1 byte but got " + done);\n        }\n\n                String fileName = destIn.readString();\n\n                long fpStart = destIn.readVLong();\n\n        try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          long len = in.length();\n                    destOut.writeVLong(len);\n          in.seek(fpStart);\n          long upto = fpStart;\n          while (upto < len) {\n            int chunk = (int) Math.min(buffer.length, (len-upto));\n            in.readBytes(buffer, 0, chunk);\n            if (doFlipBitsDuringCopy) {\n              if (random.nextInt(3000) == 17 && bitFlipped.contains(fileName) == false) {\n                bitFlipped.add(fileName);\n                message("file " + fileName + " to R" + replicaID + ": now randomly flipping a bit at byte=" + upto);\n                int x = random.nextInt(chunk);\n                int bit = random.nextInt(8);\n                buffer[x] ^= 1 << bit;\n              }\n            }\n            destOut.writeBytes(buffer, 0, chunk);\n            upto += chunk;\n            totBytesSent += chunk;\n          }\n        }\n\n        fileCount++;\n      }\n\n      message("top: done fetch files for R" + replicaID + ": sent " + fileCount + " files; sent " + totBytesSent + " bytes");\n    } catch (Throwable t) {\n      message("top: exception during fetch: " + t.getMessage() + "; now close socket");\n      socket.close();\n      return false;\n    } finally {\n      if (copyState != null) {\n        message("top: fetch: now release CopyState");\n        releaseCopyState(copyState);\n      }\n    }\n\n    return true;\n  }
741	public XWPFTable createTable(int rows, int cols) {\n        XWPFTable table = new XWPFTable(headerFooter.addNewTbl(), this, rows, cols);\n        tables.add(table);\n        bodyElements.add(table);\n        return table;\n    }
742	private static boolean fullfillsConditions(AreaEval db, int row, AreaEval cdb)\n            throws EvaluationException {\n                                final int height = cdb.getHeight();\n        for(int conditionRow = 1; conditionRow < height; ++conditionRow) {\n            boolean matches = true;\n            final int width = cdb.getWidth();\n            for(int column = 0; column < width; ++column) {                                                 boolean columnCondition = true;\n                ValueEval condition;\n                \n                                condition = resolveReference(cdb, conditionRow, column);\n                \n                                if(condition instanceof BlankEval)\n                    continue;\n                                ValueEval targetHeader = resolveReference(cdb, 0, column);\n\n                if(!(targetHeader instanceof StringValueEval)) {\n                    throw new EvaluationException(ErrorEval.VALUE_INVALID);\n                }\n                \n                if (getColumnForName(targetHeader, db) == -1)\n                                        columnCondition = false;\n\n                if(columnCondition) {                                         ValueEval value = resolveReference(db, row, getColumnForName(targetHeader, db));\n                    if(!testNormalCondition(value, condition)) {\n                        matches = false;\n                        break;\n                    }\n                } else {                                         if(OperandResolver.coerceValueToString(condition).isEmpty()) {\n                        throw new EvaluationException(ErrorEval.VALUE_INVALID);\n                    }\n                    throw new NotImplementedException(\n                            "D* function with formula conditions");\n                }\n            }\n            if (matches) {\n                return true;\n            }\n        }\n        return false;\n    }
743	public static Plane constructNormalizedXPlane(final Vector... planePoints) {\n        double bestDistance = 0.0;\n    Vector bestPoint = null;\n    for (final Vector point : planePoints) {\n      final double pointDist = point.y * point.y + point.z * point.z;\n      if (pointDist > bestDistance) {\n        bestDistance = pointDist;\n        bestPoint = point;\n      }\n    }\n    return constructNormalizedXPlane(bestPoint.y, bestPoint.z, 0.0);\n  }
744	private void transformNode(ParseNode node, byte desiredOperandClass,\n			boolean callerForceArrayFlag) {\n		Ptg token = node.getToken();\n		ParseNode[] children = node.getChildren();\n		boolean isSimpleValueFunc = isSimpleValueFunction(token);\n\n		if (isSimpleValueFunc) {\n			boolean localForceArray = desiredOperandClass == Ptg.CLASS_ARRAY;\n			for (int i = 0; i < children.length; i++) {\n				transformNode(children[i], desiredOperandClass, localForceArray);\n			}\n			setSimpleValueFuncClass((AbstractFunctionPtg) token, desiredOperandClass, callerForceArrayFlag);\n			return;\n		}\n\n		if (isSingleArgSum(token)) {\n									token = FuncVarPtg.SUM;\n								}\n		if (token instanceof ValueOperatorPtg || token instanceof ControlPtg\n				|| token instanceof MemFuncPtg\n				|| token instanceof MemAreaPtg\n				|| token instanceof UnionPtg\n				|| token instanceof IntersectionPtg) {\n						\n												byte localDesiredOperandClass = desiredOperandClass == Ptg.CLASS_REF ? Ptg.CLASS_VALUE : desiredOperandClass;\n			for (int i = 0; i < children.length; i++) {\n				transformNode(children[i], localDesiredOperandClass, callerForceArrayFlag);\n			}\n			return;\n		}\n		if (token instanceof AbstractFunctionPtg) {\n			transformFunctionNode((AbstractFunctionPtg) token, children, desiredOperandClass, callerForceArrayFlag);\n			return;\n		}\n		if (children.length > 0) {\n			if (token == RangePtg.instance) {\n								return;\n			}\n			throw new IllegalStateException("Node should not have any children");\n		}\n\n		if (token.isBaseToken()) {\n						return;\n		}\n		token.setClass(transformClass(token.getPtgClass(), desiredOperandClass, callerForceArrayFlag));\n	}
745	public Term[] getStopWords() {\n    List<Term> allStopWords = new ArrayList<>();\n    for (String fieldName : stopWordsPerField.keySet()) {\n      Set<String> stopWords = stopWordsPerField.get(fieldName);\n      for (String text : stopWords) {\n        allStopWords.add(new Term(fieldName, text));\n      }\n    }\n    return allStopWords.toArray(new Term[allStopWords.size()]);\n  }
746	protected void matchVariableSizedPropertiesToChunks() {\n                        Map<Integer, Chunk> chunks = new HashMap<>();\n        for (Chunk chunk : parentGroup.getChunks()) {\n            chunks.put(chunk.getChunkId(), chunk);\n        }\n\n                for (PropertyValue val : properties.values()) {\n            if (val instanceof ChunkBasedPropertyValue) {\n                ChunkBasedPropertyValue cVal = (ChunkBasedPropertyValue) val;\n                Chunk chunk = chunks.get(cVal.getProperty().id);\n                                \n                \n                if (chunk != null) {\n                    cVal.setValue(chunk);\n                } else {\n                    logger.log(POILogger.WARN, "No chunk found matching Property " + cVal);\n                }\n            }\n        }\n    }
747	protected Map<Axis, AxisState> drawAxes(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n                for (ValueAxis axis : this.domainAxes.values()) {\n            if (axis != null) {\n                int axisIndex = findDomainAxisIndex(axis);\n                axisCollection.add(axis, getDomainAxisEdge(axisIndex));\n            }\n        }\n\n                for (ValueAxis axis : this.rangeAxes.values()) {\n            if (axis != null) {\n                int axisIndex = findRangeAxisIndex(axis);\n                axisCollection.add(axis, getRangeAxisEdge(axisIndex));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n                double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n                cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n                cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n                cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }
748	private PriorityQueue<ScoreTerm> createQueue(Map<String, Map<String, Int>> perFieldTermFrequencies) throws IOException {\n        int numDocs = ir.numDocs();\n    final int limit = Math.min(maxQueryTerms, this.getTermsCount(perFieldTermFrequencies));\n    FreqQ queue = new FreqQ(limit);     for (Map.Entry<String, Map<String, Int>> entry : perFieldTermFrequencies.entrySet()) {\n      Map<String, Int> perWordTermFrequencies = entry.getValue();\n      String fieldName = entry.getKey();\n\n      for (Map.Entry<String, Int> tfEntry : perWordTermFrequencies.entrySet()) {         String word = tfEntry.getKey();\n        int tf = tfEntry.getValue().x;         if (minTermFreq > 0 && tf < minTermFreq) {\n          continue;         }\n\n        int docFreq = ir.docFreq(new Term(fieldName, word));\n\n        if (minDocFreq > 0 && docFreq < minDocFreq) {\n          continue;         }\n\n        if (docFreq > maxDocFreq) {\n          continue;         }\n\n        if (docFreq == 0) {\n          continue;         }\n\n        float idf = similarity.idf(docFreq, numDocs);\n        float score = tf * idf;\n\n        if (queue.size() < limit) {\n                    queue.add(new ScoreTerm(word, fieldName, score, idf, docFreq, tf));\n        } else {\n          ScoreTerm term = queue.top();\n          if (term.score < score) {             term.update(word, fieldName, score, idf, docFreq, tf);\n            queue.updateTop();\n          }\n        }\n      }\n    }\n    return queue;\n  }
749	public static CharArraySet getWordSet(Reader reader, CharArraySet result) throws IOException {\n    BufferedReader br = null;\n    try {\n      br = getBufferedReader(reader);\n      String word = null;\n      while ((word = br.readLine()) != null) {\n        result.add(word.trim());\n      }\n    }\n    finally {\n      IOUtils.close(br);\n    }\n    return result;\n  }
750	public static POITextExtractor createExtractor(OPCPackage pkg) throws IOException, OpenXML4JException, XmlException {\n        try {\n                        PackageRelationshipCollection core;\n            core = pkg.getRelationshipsByType(CORE_DOCUMENT_REL);\n              \n                        if (core.size() == 0) {\n                                core = pkg.getRelationshipsByType(STRICT_DOCUMENT_REL);\n            }\n            if (core.size() == 0) {\n                                core = pkg.getRelationshipsByType(VISIO_DOCUMENT_REL);\n                if (core.size() == 1)\n                    return new XDGFVisioExtractor(pkg);\n            }\n              \n                        if (core.size() != 1) {\n                throw new IllegalArgumentException("Invalid OOXML Package received - expected 1 core document, found " + core.size());\n            }\n     \n                        final PackagePart corePart = pkg.getPart(core.getRelationship(0));\n            final String contentType = corePart.getContentType();\n     \n                        for (XSSFRelation rel : XSSFExcelExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    if (getPreferEventExtractor()) {\n                        return new XSSFEventBasedExcelExtractor(pkg);\n                    }\n                    return new XSSFExcelExtractor(pkg);\n                }\n            }\n     \n                        for (XWPFRelation rel : XWPFWordExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    return new XWPFWordExtractor(pkg);\n                }\n            }\n     \n                        for (XSLFRelation rel : XSLFPowerPointExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    return new SlideShowExtractor<>(new XMLSlideShow(pkg));\n                }\n            }\n     \n                        if (XSLFRelation.THEME_MANAGER.getContentType().equals(contentType)) {\n                return new SlideShowExtractor<>(new XMLSlideShow(pkg));\n            }\n\n                        for (XSSFRelation rel : XSSFBEventBasedExcelExtractor.SUPPORTED_TYPES) {\n                if (rel.getContentType().equals(contentType)) {\n                    return new XSSFBEventBasedExcelExtractor(pkg);\n                }\n            }\n\n            throw new IllegalArgumentException("No supported documents found in the OOXML package (found "+contentType+")");\n\n        } catch (IOException | Error | RuntimeException | XmlException | OpenXML4JException e) {                                     pkg.revert();\n            throw e;\n        }\n    }
751	@Beta\n    public AreaReference getPivotArea(Workbook wb) throws IllegalArgumentException {\n        final CTWorksheetSource wsSource = ctPivotCacheDefinition.getCacheSource().getWorksheetSource();\n        \n        final String ref = wsSource.getRef();\n        final String name = wsSource.getName();\n        \n        if (ref == null && name == null) {\n            throw new IllegalArgumentException("Pivot cache must reference an area, named range, or table.");\n        }\n        \n                if (ref != null) {\n            return new AreaReference(ref, SpreadsheetVersion.EXCEL2007);\n        }\n        \n        assert (name != null);\n        \n                final Name range = wb.getName(name);\n        if (range != null) {\n            return new AreaReference(range.getRefersToFormula(), SpreadsheetVersion.EXCEL2007);\n        }\n        \n                        final XSSFSheet sheet = (XSSFSheet) wb.getSheet(wsSource.getSheet());\n        for (XSSFTable table : sheet.getTables()) {\n                        if (name.equals(table.getName())) {\n                return new AreaReference(table.getStartCellReference(), table.getEndCellReference(),\n                        SpreadsheetVersion.EXCEL2007);\n            }\n        }\n        \n        throw new IllegalArgumentException("Name '" + name + "' was not found.");\n    }
752	public static void main(String[] args) throws Exception {\n        try (HSLFSlideShow ppt = new HSLFSlideShow()) {\n                        Object[] def = new Object[]{\n                    Color.yellow, 40,\n                    Color.green, 60,\n                    Color.gray, 30,\n                    Color.red, 80,\n            };\n\n            HSLFSlide slide = ppt.createSlide();\n\n            HSLFGroupShape group = new HSLFGroupShape();\n                        Rectangle bounds = new Rectangle(200, 100, 350, 300);\n            group.setAnchor(bounds);\n            group.setInteriorAnchor(new Rectangle(0, 0, 100, 100));\n            slide.addShape(group);\n            Graphics2D graphics = new PPGraphics2D(group);\n\n                        int x = 10, y = 10;\n            graphics.setFont(new Font("Arial", Font.BOLD, 10));\n            for (int i = 0, idx = 1; i < def.length; i += 2, idx++) {\n                graphics.setColor(Color.black);\n                int width = ((Integer) def[i + 1]).intValue();\n                graphics.drawString("Q" + idx, x - 5, y + 10);\n                graphics.drawString(width + "%", x + width + 3, y + 10);\n                graphics.setColor((Color) def[i]);\n                graphics.fill(new Rectangle(x, y, width, 10));\n                y += 15;\n            }\n            graphics.setColor(Color.black);\n            graphics.setFont(new Font("Arial", Font.BOLD, 14));\n            graphics.draw(group.getInteriorAnchor());\n            graphics.drawString("Performance", x + 30, y + 10);\n\n            try (FileOutputStream out = new FileOutputStream("hslf-graphics.ppt")) {\n                ppt.write(out);\n            }\n        }\n    }
753	public boolean store(DataOutput output) throws IOException {\n    final FST<PairOutputs.Pair<Long, BytesRef>> build = builder.finish();\n    if (build == null) {\n      return false;\n    }\n    build.save(output);\n\n    \n    assert maxAnalyzedPathsPerOutput > 0;\n    output.writeVInt(maxAnalyzedPathsPerOutput);\n    output.writeVInt(END_BYTE);\n    output.writeVInt(PAYLOAD_SEP);\n    return true;\n  }
754	public Chunk createChunk(byte[] data, int offset) {\n				ChunkHeader header =\n			ChunkHeader.createChunkHeader(version, data, offset);\n				if(header.getLength() < 0) {\n			throw new IllegalArgumentException("Found a chunk with a negative length, which isn't allowed");\n		}\n\n				int endOfDataPos = offset + header.getLength() + header.getSizeInBytes();\n\n						if(endOfDataPos > data.length) {\n			logger.log(POILogger.WARN,\n				"Header called for " + header.getLength() +" bytes, but that would take us past the end of the data!");\n\n			endOfDataPos = data.length;\n			header.setLength(data.length - offset - header.getSizeInBytes());\n\n			if(header.hasTrailer()) {\n				header.setLength(header.getLength() - 8);\n				endOfDataPos  -= 8;\n			}\n			if(header.hasSeparator()) {\n                header.setLength(header.getLength() - 4);\n				endOfDataPos  -= 4;\n			}\n		}\n\n\n				ChunkTrailer trailer = null;\n		ChunkSeparator separator = null;\n		if(header.hasTrailer()) {\n			if(endOfDataPos <= data.length-8) {\n				trailer = new ChunkTrailer(\n					data, endOfDataPos);\n				endOfDataPos += 8;\n			} else {\n				logger.log(POILogger.ERROR, "Header claims a length to " + endOfDataPos + " there's then no space for the trailer in the data (" + data.length + ")");\n			}\n		}\n		if(header.hasSeparator()) {\n			if(endOfDataPos <= data.length-4) {\n				separator = new ChunkSeparator(\n						data, endOfDataPos);\n			} else {\n				logger.log(POILogger.ERROR, "Header claims a length to " + endOfDataPos + " there's then no space for the separator in the data (" + data.length + ")");\n			}\n		}\n\n				byte[] contents = IOUtils.safelyAllocate(header.getLength(), MAX_RECORD_LENGTH);\n		System.arraycopy(data, offset+header.getSizeInBytes(), contents, 0, contents.length);\n		Chunk chunk = new Chunk(header, trailer, separator, contents);\n\n				CommandDefinition[] defs = chunkCommandDefinitions.get(Integer.valueOf(header.getType()));\n		if (defs == null) {\n		    defs = new CommandDefinition[0];\n		}\n		chunk.commandDefinitions = defs;\n\n				chunk.processCommands();\n\n				return chunk;\n	}
755	public void setVBAProject(InputStream vbaProjectStream) throws IOException {\n        if (!isMacroEnabled()) {\n            setWorkbookType(XSSFWorkbookType.XLSM);\n        }\n\n        PackagePartName ppName;\n        try {\n            ppName = PackagingURIHelper.createPartName(XSSFRelation.VBA_MACROS.getDefaultFileName());\n        } catch (InvalidFormatException e) {\n            throw new POIXMLException(e);\n        }\n        OPCPackage opc = getPackage();\n        OutputStream outputStream;\n        if (!opc.containPart(ppName)) {\n            POIXMLDocumentPart relationship = createRelationship(XSSFRelation.VBA_MACROS, this.xssfFactory);\n            outputStream = relationship.getPackagePart().getOutputStream();\n        } else {\n            PackagePart part = opc.getPart(ppName);\n            outputStream = part.getOutputStream();\n        }\n        try {\n            IOUtils.copy(vbaProjectStream, outputStream);\n        } finally {\n            IOUtils.closeQuietly(outputStream);\n        }\n    }
756	public void setInsideBorders(Object... args) {\n        if (args.length == 0) return;\n\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = new BorderEdge[2];\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[0] = (col > 0 && col < cols - 1) ? BorderEdge.right : null;\n                edges[1] = (row > 0 && row < rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
757	private void extractRowKeyAndData(String line,\n                                      DefaultCategoryDataset dataset,\n                                      List columnKeys) {\n        Comparable rowKey = null;\n        int fieldIndex = 0;\n        int start = 0;\n        for (int i = 0; i < line.length(); i++) {\n            if (line.charAt(i) == this.fieldDelimiter) {\n                if (fieldIndex == 0) {                      String key = line.substring(start, i);\n                    rowKey = removeStringDelimiters(key);\n                }\n                else {                      Double value = Double.valueOf(\n                        removeStringDelimiters(line.substring(start, i))\n                    );\n                    dataset.addValue(\n                        value, rowKey,\n                        (Comparable) columnKeys.get(fieldIndex - 1)\n                    );\n                }\n                start = i + 1;\n                fieldIndex++;\n            }\n        }\n        Double value = Double.valueOf(\n            removeStringDelimiters(line.substring(start, line.length()))\n        );\n        dataset.addValue(\n            value, rowKey, (Comparable) columnKeys.get(fieldIndex - 1)\n        );\n    }
758	public ExtSSTRecord createExtSSTRecord(int sstOffset) {\n        if (bucketAbsoluteOffsets == null || bucketRelativeOffsets == null) {\n            throw new IllegalStateException("SST record has not yet been serialized.");\n        }\n\n        ExtSSTRecord extSST = new ExtSSTRecord();\n        extSST.setNumStringsPerBucket((short)8);\n        int[] absoluteOffsets = bucketAbsoluteOffsets.clone();\n        int[] relativeOffsets = bucketRelativeOffsets.clone();\n        for ( int i = 0; i < absoluteOffsets.length; i++ ) {\n            absoluteOffsets[i] += sstOffset;\n        }\n        extSST.setBucketOffsets(absoluteOffsets, relativeOffsets);\n        return extSST;\n    }
759	public InputStream openResourceAsStream(String sampleFileName) {\n\n        if (_sampleDataIsAvaliableOnClassPath) {\n            InputStream result = sampleFileName == null ? null :\n                    openClasspathResource(sampleFileName);\n            if(result == null) {\n                throw new RuntimeException("specified test sample file '" + sampleFileName\n                        + "' not found on the classpath");\n            }\n                        return new NonSeekableInputStream(result);\n        }\n        if (_resolvedDataDir == null) {\n            throw new RuntimeException("Must set system property '"\n                    + TEST_PROPERTY\n                    + "' properly before running tests");\n        }\n\n        File f = getFile(sampleFileName);\n        try {\n            return new FileInputStream(f);\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }
760	private boolean isCellTypeMatches(Locator loc1, Locator loc2) {\n        CellType type1 = loc1.cell.getCellType();\n        CellType type2 = loc2.cell.getCellType();\n        if (type1 == type2) return true;\n        addMessage(loc1, loc2,\n            "Cell Data-Type does not Match in :: ",\n            type1.name(), type2.name()\n        );\n        return false;\n    }
761	public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    int caseType = caseOf(word, length);\n    if (caseType == UPPER_CASE) {\n            caseFoldTitle(word, length);\n      caseFoldLower(titleBuffer, length);\n      List<CharsRef> list = doStem(word, length, false);\n      list.addAll(doStem(titleBuffer, length, true));\n      list.addAll(doStem(lowerBuffer, length, true));\n      return list;\n    } else if (caseType == TITLE_CASE) {\n            caseFoldLower(word, length);\n      List<CharsRef> list = doStem(word, length, false);\n      list.addAll(doStem(lowerBuffer, length, true));\n      return list;\n    } else {\n            return doStem(word, length, false);\n    }\n  }
762	protected Query newGraphSynonymQuery(Iterator<Query> queries) {\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    while (queries.hasNext()) {\n      builder.add(queries.next(), BooleanClause.Occur.SHOULD);\n    }\n    BooleanQuery bq = builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }
763	public static JFreeChart createXYStepAreaChart(String title, \n            String xAxisLabel, String yAxisLabel, XYDataset dataset,\n            PlotOrientation orientation, boolean legend, boolean tooltips,\n            boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        NumberAxis xAxis = new NumberAxis(xAxisLabel);\n        xAxis.setAutoRangeIncludesZero(false);\n        NumberAxis yAxis = new NumberAxis(yAxisLabel);\n\n        XYToolTipGenerator toolTipGenerator = null;\n        if (tooltips) {\n            toolTipGenerator = new StandardXYToolTipGenerator();\n        }\n\n        XYURLGenerator urlGenerator = null;\n        if (urls) {\n            urlGenerator = new StandardXYURLGenerator();\n        }\n        XYItemRenderer renderer = new XYStepAreaRenderer(\n                XYStepAreaRenderer.AREA_AND_SHAPES, toolTipGenerator,\n                urlGenerator);\n\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, null);\n        plot.setRenderer(renderer);\n        plot.setOrientation(orientation);\n        plot.setDomainCrosshairVisible(false);\n        plot.setRangeCrosshairVisible(false);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n    }
764	static void inList(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Codes");\n        sheet.createRow(1).createCell(0).setCellValue("AA");\n        sheet.createRow(2).createCell(0).setCellValue("BB");\n        sheet.createRow(3).createCell(0).setCellValue("GG");\n        sheet.createRow(4).createCell(0).setCellValue("AA");\n        sheet.createRow(5).createCell(0).setCellValue("FF");\n        sheet.createRow(6).createCell(0).setCellValue("XX");\n        sheet.createRow(7).createCell(0).setCellValue("CC");\n\n        sheet.getRow(0).createCell(2).setCellValue("Valid");\n        sheet.getRow(1).createCell(2).setCellValue("AA");\n        sheet.getRow(2).createCell(2).setCellValue("BB");\n        sheet.getRow(3).createCell(2).setCellValue("CC");\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("COUNTIF($C$2:$C$4,A2)");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.LIGHT_BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A8")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(3).setCellValue("<== Use Excel conditional formatting to highlight items that are in a list on the worksheet");\n    }
765	public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }
766	public String formatRawCellContents(double value, int formatIndex, String formatString, boolean use1904Windowing) {\n        localeChangedObservable.checkForLocaleChange();\n        \n                if(DateUtil.isADateFormat(formatIndex,formatString)) {\n            if(DateUtil.isValidExcelDate(value)) {\n                Format dateFormat = getFormat(value, formatIndex, formatString);\n                if(dateFormat instanceof ExcelStyleDateFormatter) {\n                                        ((ExcelStyleDateFormatter)dateFormat).setDateToBeFormatted(value);\n                }\n                Date d = DateUtil.getJavaDate(value, use1904Windowing);\n                return performDateFormatting(d, dateFormat);\n            }\n                        if (emulateCSV) {\n                return invalidDateTimeString;\n            }\n        }\n        \n                Format numberFormat = getFormat(value, formatIndex, formatString);\n        if (numberFormat == null) {\n            return String.valueOf(value);\n        }\n        \n                                                String result;\n        final String textValue = NumberToTextConverter.toText(value);\n        if (textValue.indexOf('E') > -1) {\n            result = numberFormat.format(Double.valueOf(value));\n        }\n        else {\n            result = numberFormat.format(new BigDecimal(textValue));\n        }\n                if (result.indexOf('E') > -1 && !result.contains("E-")) {\n            result = result.replaceFirst("E", "E+");\n        }\n        return result;\n    }
767	private double calculateIntervalForSeries(int series) {\n        double result = Double.POSITIVE_INFINITY;\n        int itemCount = this.dataset.getItemCount(series);\n        if (itemCount > 1) {\n            double prev = this.dataset.getXValue(series, 0);\n            for (int item = 1; item < itemCount; item++) {\n                double x = this.dataset.getXValue(series, item);\n                result = Math.min(result, x - prev);\n                prev = x;\n            }\n        }\n        return result;\n    }
768	public XWPFFootnotes createFootnotes() {\n        if (footnotes == null) {\n            FootnotesDocument footnotesDoc = FootnotesDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.FOOTNOTE;\n            int i = getRelationIndex(relation);\n\n            XWPFFootnotes wrapper = (XWPFFootnotes) createRelationship(relation, XWPFFactory.getInstance(), i);\n            wrapper.setFootnotes(footnotesDoc.addNewFootnotes());\n            wrapper.setIdManager(this.footnoteIdManager);\n            footnotes = wrapper;\n        }\n\n        return footnotes;\n    }
769	private boolean isBreak(int lastType, int type) {\n    if ((type & lastType) != 0) {\n      return false;\n    }\n    \n    if (!splitOnCaseChange && isAlpha(lastType) && isAlpha(type)) {\n            return false;\n    } else if (isUpper(lastType) && isAlpha(type)) {\n            return false;\n    } else if (!splitOnNumerics && ((isAlpha(lastType) && isDigit(type)) || (isDigit(lastType) && isAlpha(type)))) {\n            return false;\n    }\n\n    return true;\n  }
770	private static I_MatchPredicate createGeneralMatchPredicate(StringEval stringEval) {\n        String value = stringEval.getStringValue();\n        CmpOp operator = CmpOp.getOperator(value);\n        value = value.substring(operator.getLength());\n\n        Boolean booleanVal = parseBoolean(value);\n        if(booleanVal != null) {\n            return new BooleanMatcher(booleanVal.booleanValue(), operator);\n        }\n\n        Double doubleVal = OperandResolver.parseDouble(value);\n        if(doubleVal != null) {\n            return new NumberMatcher(doubleVal.doubleValue(), operator);\n        }\n        ErrorEval ee = parseError(value);\n        if (ee != null) {\n            return new ErrorMatcher(ee.getErrorCode(), operator);\n        }\n\n                return new StringMatcher(value, operator);\n    }
771	public String getText() {\n        try {\n            WordToTextConverter wordToTextConverter = new WordToTextConverter();\n\n            HeaderStories hs = new HeaderStories(doc);\n\n            if (hs.getFirstHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getFirstHeaderSubrange());\n            if (hs.getEvenHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getEvenHeaderSubrange());\n            if (hs.getOddHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getOddHeaderSubrange());\n\n            wordToTextConverter.processDocument(doc);\n            wordToTextConverter.processDocumentPart(doc,\n                    doc.getMainTextboxRange());\n\n            if (hs.getFirstFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getFirstFooterSubrange());\n            if (hs.getEvenFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getEvenFooterSubrange());\n            if (hs.getOddFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getOddFooterSubrange());\n\n            return wordToTextConverter.getText();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch ( Exception exc ) {\n            throw new RuntimeException( exc );\n        }\n    }
772	public void executeQuery(Connection con, String query) throws SQLException {\n\n        Statement statement = null;\n        ResultSet resultSet = null;\n\n        try {\n            statement = con.createStatement();\n            resultSet = statement.executeQuery(query);\n            ResultSetMetaData metaData = resultSet.getMetaData();\n\n            int columnCount = metaData.getColumnCount();\n            if (columnCount != 2) {\n                throw new SQLException(\n                    "Invalid sql generated.  PieDataSet requires 2 columns only"\n                );\n            }\n\n            int columnType = metaData.getColumnType(2);\n            double value;\n            while (resultSet.next()) {\n                Comparable key = resultSet.getString(1);\n                switch (columnType) {\n                    case Types.NUMERIC:\n                    case Types.REAL:\n                    case Types.INTEGER:\n                    case Types.DOUBLE:\n                    case Types.FLOAT:\n                    case Types.DECIMAL:\n                    case Types.BIGINT:\n                        value = resultSet.getDouble(2);\n                        setValue(key, value);\n                        break;\n\n                    case Types.DATE:\n                    case Types.TIME:\n                    case Types.TIMESTAMP:\n                        Timestamp date = resultSet.getTimestamp(2);\n                        value = date.getTime();\n                        setValue(key, value);\n                        break;\n\n                    default:\n                        System.err.println(\n                                "JDBCPieDataset - unknown data type");\n                        break;\n                }\n            }\n\n            fireDatasetChanged();\n\n        }\n        finally {\n            if (resultSet != null) {\n                try {\n                    resultSet.close();\n                }\n                catch (Exception e) {\n                    System.err.println("JDBCPieDataset: swallowing exception.");\n                }\n            }\n            if (statement != null) {\n                try {\n                    statement.close();\n                }\n                catch (Exception e) {\n                    System.err.println("JDBCPieDataset: swallowing exception.");\n                }\n            }\n        }\n    }
773	protected String generateSectionLabel(PieDataset dataset, Comparable key) {\n        String result = null;\n        if (dataset != null) {\n            Object[] items = createItemArray(dataset, key);\n            result = MessageFormat.format(this.labelFormat, items);\n        }\n        return result;\n    }
774	public XWPFTable createTable(int rows, int cols) {\n        XWPFTable table = new XWPFTable(ctDocument.getBody().addNewTbl(), this, rows, cols);\n        bodyElements.add(table);\n        tables.add(table);\n        return table;\n    }
775	private void findEscherChildren(DefaultEscherRecordFactory erf, byte[] source, int startPos, int lenToGo, List<EscherRecord> found) {\n\n		int escherBytes = LittleEndian.getInt( source, startPos + 4 ) + 8;\n\n				EscherRecord r = erf.createRecord(source,startPos);\n				r.fillFields( source, startPos, erf );\n				found.add(r);\n\n				int size = r.getRecordSize();\n		if(size < 8) {\n			logger.log(POILogger.WARN, "Hit short DDF record at " + startPos + " - " + size);\n		}\n\n		\n		if(size != escherBytes){\n			logger.log(POILogger.WARN, "Record length=" + escherBytes + " but getRecordSize() returned " + r.getRecordSize() + "; record: " + r.getClass());\n			size = escherBytes;\n		}\n		startPos += size;\n		lenToGo -= size;\n		if(lenToGo >= 8) {\n			findEscherChildren(erf, source, startPos, lenToGo, found);\n		}\n	}
776	static HSLFHyperlink createHyperlink(HSLFSimpleShape shape) {\n                ExHyperlink exHyper = new ExHyperlink();\n        int linkId = shape.getSheet().getSlideShow().addToObjListAtom(exHyper);\n        ExHyperlinkAtom obj = exHyper.getExHyperlinkAtom();\n        obj.setNumber(linkId);\n        InteractiveInfo info = new InteractiveInfo();\n        info.getInteractiveInfoAtom().setHyperlinkID(linkId);\n        HSLFEscherClientDataRecord cldata = shape.getClientData(true);\n        cldata.addChild(info);\n        HSLFHyperlink hyper = new HSLFHyperlink(exHyper, info);\n        hyper.linkToNextSlide();\n        shape.setHyperlink(hyper);\n        return hyper;\n    }
777	public int getNumBorderColors(CellAddress cell) {\n        Map<String, Object> cellProperties = _propertyTemplate.get(cell);\n        if (cellProperties == null) {\n            return 0;\n        }\n\n        int count = 0;\n        for (String property : cellProperties.keySet()) {\n            if (property.equals(CellUtil.TOP_BORDER_COLOR))\n                count += 1;\n            if (property.equals(CellUtil.BOTTOM_BORDER_COLOR))\n                count += 1;\n            if (property.equals(CellUtil.LEFT_BORDER_COLOR))\n                count += 1;\n            if (property.equals(CellUtil.RIGHT_BORDER_COLOR))\n                count += 1;\n        }\n        return count;\n    }
778	public Borders getBorderBetween() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getBetween();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
779	public static Version parseLeniently(String version) throws ParseException {\n    String versionOrig = version;\n    version = version.toUpperCase(Locale.ROOT);\n    switch (version) {\n      case "LATEST":\n      case "LUCENE_CURRENT":\n        return LATEST;\n      default:\n        version = version\n          .replaceFirst("^LUCENE_(\\d+)_(\\d+)_(\\d+)$", "$1.$2.$3")\n          .replaceFirst("^LUCENE_(\\d+)_(\\d+)$", "$1.$2.0")\n          .replaceFirst("^LUCENE_(\\d)(\\d)$", "$1.$2.0");\n        try {\n          return parse(version);\n        } catch (ParseException pe) {\n          ParseException pe2 = new ParseException("failed to parse lenient version string \"" + versionOrig + "\": " + pe.getMessage(), 0);\n          pe2.initCause(pe);\n          throw pe2;\n        }\n    }\n  }
780	private static int dateDiff(long startDateMS, long endDateMS) {\n		long msDiff = endDateMS - startDateMS;\n\n				int remainderHours = (int) ((msDiff % MS_PER_DAY) / MS_PER_HOUR);\n		switch (remainderHours) {\n			case 0:  				break;\n			case 1:  			case 23: 							default:\n				throw new RuntimeException("Unexpected date diff between " + startDateMS + " and " + endDateMS);\n\n		}\n		return (int) (0.5 + ((double)msDiff / MS_PER_DAY));\n	}
781	public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n                if (LuceneTestCase.VERBOSE) {\n          System.out.println("TEST: LineFileDocs: now rewind file...");\n        }\n        reader.close();\n        reader = null;\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException("line: [" + line + "] is in an invalid format !");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException("line: [" + line + "] is in an invalid format !");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n\n    if (random.nextInt(5) == 4) {\n            Document doc = new Document();\n      for(IndexableField field : docState.doc) {\n        doc.add(field);\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint("docLength" + x, line.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint("docTitleLength" + x, title.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new NumericDocValuesField("docLength" + x, line.length()));\n      }\n\n          }\n\n    return docState.doc;\n  }
782	private void isCellUnderLineMatches(Locator loc1, Locator loc2) {\n                if (!(loc1.cell instanceof XSSFCell)) return;\n        byte b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getUnderline();\n        byte b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getUnderline();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 == 1 ? "" : "NOT ")+"UNDERLINE",\n                (b2 == 1 ? "" : "NOT ")+"UNDERLINE"\n            );\n        }\n    }
783	public static void optimiseFonts(HSSFWorkbook workbook) {\n						short[] newPos = \n			new short[workbook.getWorkbook().getNumberOfFontRecords()+1];\n		boolean[] zapRecords = new boolean[newPos.length];\n		for(int i=0; i<newPos.length; i++) {\n			newPos[i] = (short)i;\n			zapRecords[i] = false;\n		}\n		\n						FontRecord[] frecs = new FontRecord[newPos.length]; \n		for(int i=0; i<newPos.length; i++) {\n						if(i == 4) continue;\n			\n			frecs[i] = workbook.getWorkbook().getFontRecordAt(i);\n		}\n		\n												for(int i=5; i<newPos.length; i++) {\n									int earlierDuplicate = -1;\n			for(int j=0; j<i && earlierDuplicate == -1; j++) {\n				if(j == 4) continue;\n				\n				FontRecord frCheck = workbook.getWorkbook().getFontRecordAt(j);\n				if(frCheck.sameProperties(frecs[i])) {\n					earlierDuplicate = j;\n				}\n			}\n			\n						if(earlierDuplicate != -1) {\n				newPos[i] = (short)earlierDuplicate;\n				zapRecords[i] = true;\n			}\n		}\n		\n										for(int i=5; i<newPos.length; i++) {\n									short preDeletePos = newPos[i];\n			short newPosition = preDeletePos;\n			for(int j=0; j<preDeletePos; j++) {\n				if(zapRecords[j]) newPosition--;\n			}\n			\n						newPos[i] = newPosition;\n		}\n		\n				for(int i=5; i<newPos.length; i++) {\n			if(zapRecords[i]) {\n				workbook.getWorkbook().removeFontRecord(\n						frecs[i]\n				);\n			}\n		}\n		\n						workbook.resetFontCache();\n		\n						for(int i=0; i<workbook.getWorkbook().getNumExFormats(); i++) {\n			ExtendedFormatRecord xfr = workbook.getWorkbook().getExFormatAt(i);\n			xfr.setFontIndex(\n					newPos[ xfr.getFontIndex() ]\n			);\n		}\n		\n										HashSet<UnicodeString> doneUnicodeStrings = new HashSet<>();\n		for(int sheetNum=0; sheetNum<workbook.getNumberOfSheets(); sheetNum++) {\n			HSSFSheet s = workbook.getSheetAt(sheetNum);\n			for (Row row : s) {\n			   for (Cell cell : row) {\n					if(cell.getCellType() == CellType.STRING) {\n						HSSFRichTextString rtr = (HSSFRichTextString)cell.getRichStringCellValue();\n						UnicodeString u = rtr.getRawUnicodeString();\n						\n												if(! doneUnicodeStrings.contains(u)) {\n														for(short i=5; i<newPos.length; i++) {\n								if(i != newPos[i]) {\n									u.swapFontUse(i, newPos[i]);\n								}\n							}\n							\n														doneUnicodeStrings.add(u);\n						}\n					}\n				}\n			}\n		}\n	}
784	final void mergeInit(MergePolicy.OneMerge merge) throws IOException {\n\n        bufferedUpdatesStream.waitApplyForMerge(merge.segments);\n\n    boolean success = false;\n    try {\n      _mergeInit(merge);\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled("IW")) {\n          infoStream.message("IW", "hit exception in mergeInit");\n        }\n        mergeFinish(merge);\n      }\n    }\n  }
785	private ParseNode additiveExpression() {\n        ParseNode result = Term();\n        while (true) {\n            SkipWhite();\n            Ptg operator;\n            switch(look) {\n                case '+':\n                    Match('+');\n                    operator = AddPtg.instance;\n                    break;\n                case '-':\n                    Match('-');\n                    operator = SubtractPtg.instance;\n                    break;\n                default:\n                    return result;             }\n            ParseNode other = Term();\n            result = new ParseNode(operator, result, other);\n        }\n    }
786	protected byte[] getDocumentEntryBytes(String name, int encryptionOffset, int len) throws IOException {\n        DirectoryNode dir = getDirectory();\n        DocumentEntry documentProps = (DocumentEntry)dir.getEntry(name);\n        DocumentInputStream dis = dir.createDocumentInputStream(documentProps);\n        EncryptionInfo ei = (encryptionOffset > -1) ? getEncryptionInfo() : null;\n        int streamSize = documentProps.getSize();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(Math.min(streamSize,len));\n\n        InputStream is = dis;\n        try {\n            if (ei != null) {\n                try {\n                    Decryptor dec = ei.getDecryptor();\n                    is = dec.getDataStream(dis, streamSize, 0);\n                    if (encryptionOffset > 0) {\n                        ChunkedCipherInputStream cis = (ChunkedCipherInputStream)is;\n                        byte plain[] = IOUtils.safelyAllocate(encryptionOffset, MAX_RECORD_LENGTH);\n                        cis.readPlain(plain, 0, encryptionOffset);\n                        bos.write(plain);\n                    }\n                } catch (GeneralSecurityException e) {\n                    throw new IOException(e.getMessage(), e);\n                }\n            }\n                                    if (len < Integer.MAX_VALUE) {\n                is = new BoundedInputStream(is, len);\n            }\n            IOUtils.copy(is, bos);\n            return bos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(dis);\n        }\n    }
787	void buildShapeTree() {\n        EscherContainerRecord dgContainer = _boundAggregate.getEscherContainer();\n        if (dgContainer == null) {\n            return;\n        }\n        EscherContainerRecord spgrConrainer = dgContainer.getChildContainers().get(0);\n        List<EscherContainerRecord> spgrChildren = spgrConrainer.getChildContainers();\n\n        for (int i = 0; i < spgrChildren.size(); i++) {\n            EscherContainerRecord spContainer = spgrChildren.get(i);\n            if (i != 0) {\n                HSSFShapeFactory.createShapeTree(spContainer, _boundAggregate, this, _sheet.getWorkbook().getDirectory());\n            }\n        }\n    }
788	protected static void storeText(List<HSLFTextParagraph> paragraphs) {\n        fixLineEndings(paragraphs);\n        updateTextAtom(paragraphs);\n        updateStyles(paragraphs);\n        updateHyperlinks(paragraphs);\n        refreshRecords(paragraphs);\n\n        for (HSLFTextParagraph p : paragraphs) {\n            p._dirty = false;\n        }\n    }
789	public void writeOut(byte headerA, byte headerB, long type, Record[] children, OutputStream out) throws IOException {\n				if(out instanceof MutableByteArrayOutputStream) {\n			MutableByteArrayOutputStream mout =\n				(MutableByteArrayOutputStream)out;\n\n						int oldSize = mout.getBytesWritten();\n\n						mout.write(new byte[] {headerA,headerB});\n			byte[] typeB = new byte[2];\n			LittleEndian.putShort(typeB, 0, (short)type);\n			mout.write(typeB);\n			mout.write(new byte[4]);\n\n						for (Record aChildren : children) {\n				aChildren.writeOut(mout);\n			}\n\n												int length = mout.getBytesWritten() - oldSize - 8;\n			byte[] size = new byte[4];\n			LittleEndian.putInt(size,0,length);\n			mout.overwrite(size, oldSize+4);\n		} else {\n						\n						ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n						baos.write(new byte[] {headerA,headerB});\n			byte[] typeB = new byte[2];\n			LittleEndian.putShort(typeB,0,(short)type);\n			baos.write(typeB);\n			baos.write(new byte[] {0,0,0,0});\n\n						for (Record aChildren : children) {\n				aChildren.writeOut(baos);\n			}\n\n						byte[] toWrite = baos.toByteArray();\n\n												LittleEndian.putInt(toWrite,4,(toWrite.length-8));\n\n						out.write(toWrite);\n		}\n	}
790	private static int calcRowsOrCols(double cellRange, double cellMin, double requestRange, double requestMin,\n                                    double worldRange) {\n    assert requestMin >= cellMin;\n        double range = (requestRange + (requestMin - cellMin));\n    if (range == 0) {\n      return 1;\n    }\n    final double intervals = Math.ceil(range / cellRange);\n    if (intervals > Integer.MAX_VALUE) {\n      return Integer.MAX_VALUE;    }\n        final long intervalsMax = Math.round(worldRange / cellRange);\n    if (intervalsMax > Integer.MAX_VALUE) {\n            return (int) intervals;\n    }\n    return Math.min((int)intervalsMax, (int)intervals);\n  }
791	public void createNotesMaster() {\n        RelationPart rp = createRelationship\n                (XSLFRelation.NOTES_MASTER, XSLFFactory.getInstance(), 1, false);\n        _notesMaster = rp.getDocumentPart();\n\n        CTNotesMasterIdList notesMasterIdList = _presentation.addNewNotesMasterIdLst();\n        CTNotesMasterIdListEntry notesMasterId = notesMasterIdList.addNewNotesMasterId();\n        notesMasterId.setId(rp.getRelationship().getId());\n\n        Integer themeIndex = 1;\n                List<Integer> themeIndexList = new ArrayList<>();\n        for (POIXMLDocumentPart p : getRelations()) {\n            if (p instanceof XSLFTheme) {\n                themeIndexList.add(XSLFRelation.THEME.getFileNameIndex(p));\n            }\n        }\n\n        if (!themeIndexList.isEmpty()) {\n            Boolean found = false;\n            for (Integer i = 1; i <= themeIndexList.size(); i++) {\n                if (!themeIndexList.contains(i)) {\n                    found = true;\n                    themeIndex = i;\n                }\n            }\n            if (!found) {\n                themeIndex = themeIndexList.size() + 1;\n            }\n        }\n\n        XSLFTheme theme = (XSLFTheme) createRelationship\n                (XSLFRelation.THEME, XSLFFactory.getInstance(), themeIndex);\n        theme.importTheme(getSlides().get(0).getTheme());\n\n        _notesMaster.addRelation(null, XSLFRelation.THEME, theme);\n    }
792	private ParseNode function(String name) {\n        Ptg nameToken = null;\n        if(!AbstractFunctionPtg.isBuiltInFunctionName(name)) {\n                        \n            if (_book == null) {\n                                throw new IllegalStateException("Need book to evaluate name '" + name + "'");\n            }\n                        EvaluationName hName = _book.getName(name, _sheetIndex);\n            if (hName != null) {\n                if (!hName.isFunctionName()) {\n                    throw new FormulaParseException("Attempt to use name '" + name\n                            + "' as a function, but defined name in workbook does not refer to a function");\n                }\n    \n                                                nameToken = hName.createPtg();\n            } else {\n                                nameToken = _book.getNameXPtg(name, null);\n                if (nameToken == null) {\n                                        if (log.check(POILogger.WARN)) {\n                        log.log(POILogger.WARN,\n                                "FormulaParser.function: Name '" + name + "' is completely unknown in the current workbook.");\n                    }\n                                        switch (_book.getSpreadsheetVersion()) {\n                        case EXCEL97:\n                                                        addName(name);\n                            hName = _book.getName(name, _sheetIndex);\n                            nameToken = hName.createPtg();\n                            break;\n                        case EXCEL2007:\n                                                        nameToken = new NameXPxg(name);\n                            break;\n                        default:\n                            throw new IllegalStateException("Unexpected spreadsheet version: " + _book.getSpreadsheetVersion().name());\n                    }\n                }\n            }\n        }\n\n        Match('(');\n        ParseNode[] args = Arguments();\n        Match(')');\n\n        return getFunction(name, nameToken, args);\n    }
793	public static Expression compile(String sourceText, Map<String,Method> functions, ClassLoader parent) throws ParseException {\n    if (parent == null) {\n      throw new NullPointerException("A parent ClassLoader must be given.");\n    }\n    for (Method m : functions.values()) {\n      checkFunctionClassLoader(m, parent);\n      checkFunction(m);\n    }\n    return new JavascriptCompiler(sourceText, functions).compileExpression(parent);\n  }
794	public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        Range result;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }
795	private static int findInsertPosForNewCondFormatTable(List<RecordBase> records) {\n\n		for (int i = records.size() - 2; i >= 0; i--) { 			Object rb = records.get(i);\n			if (rb instanceof MergedCellsTable) {\n				return i + 1;\n			}\n			if (rb instanceof DataValidityTable) {\n				continue;\n			}\n\n			Record rec = (Record) rb;\n			switch (rec.getSid()) {\n				case WindowTwoRecord.sid:\n				case SCLRecord.sid:\n				case PaneRecord.sid:\n				case SelectionRecord.sid:\n				case UnknownRecord.STANDARDWIDTH_0099:\n								case UnknownRecord.LABELRANGES_015F:\n				case UnknownRecord.PHONETICPR_00EF:\n										return i + 1;\n											}\n		}\n		throw new RuntimeException("Did not find Window2 record");\n	}
796	public synchronized long setTimeBase(RegularTimePeriod start) {\n        if (this.pointsInTime[0] == null) {\n            this.pointsInTime[0] = start;\n            for (int i = 1; i < this.historyCount; i++) {\n                this.pointsInTime[i] = this.pointsInTime[i - 1].next();\n            }\n        }\n        long oldestL = this.pointsInTime[0].getFirstMillisecond(\n                this.workingCalendar);\n        long nextL = this.pointsInTime[1].getFirstMillisecond(\n                this.workingCalendar);\n        this.deltaTime = nextL - oldestL;\n        this.oldestAt = 0;\n        this.newestAt = this.historyCount - 1;\n        findDomainLimits();\n        return this.deltaTime;\n    }
797	public void clearRect(int x, int y, int width, int height) {\n        Paint paint = getPaint();\n        setColor(getBackground());\n        fillRect(x, y, width, height);\n        setPaint(paint);\n    }
798	public static PackagePartName createPartName(String partName,\n			PackagePart relativePart) throws InvalidFormatException {\n		URI newPartNameURI;\n		try {\n			newPartNameURI = resolvePartUri(\n					relativePart.getPartName().getURI(), new URI(partName));\n		} catch (URISyntaxException e) {\n			throw new InvalidFormatException(e.getMessage());\n		}\n		return createPartName(newPartNameURI);\n	}
799	public void cloneStyleFrom(ExtendedFormatRecord source) {\n        field_1_font_index           = source.field_1_font_index;\n        field_2_format_index         = source.field_2_format_index;\n        field_3_cell_options         = source.field_3_cell_options;\n        field_4_alignment_options    = source.field_4_alignment_options;\n        field_5_indention_options    = source.field_5_indention_options;\n        field_6_border_options       = source.field_6_border_options;\n        field_7_palette_options      = source.field_7_palette_options;\n        field_8_adtl_palette_options = source.field_8_adtl_palette_options;\n        field_9_fill_palette_options = source.field_9_fill_palette_options;\n    }
800	protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);\n            w[2] = size.width;\n            h[2] = size.height;\n       }\n        if (this.rightBlock != null) {\n            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            Size2D size = this.centerBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\n        double height = h[0] + h[1] + centerHeight;\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    centerHeight));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], centerHeight));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], centerHeight));\n        }\n        return new Size2D(width, height);\n    }
801	public void addResult(int n, boolean isRelevant, long docNameExtractTime) {\n    if (Math.abs(numPoints+1 - n) > 1E-6) {\n      throw new IllegalArgumentException("point "+n+" illegal after "+numPoints+" points!");\n    }\n    if (isRelevant) {\n      numGoodPoints+=1;\n      recallPoints.add(new RecallPoint(n,numGoodPoints));\n      if (recallPoints.size()==1 && n<=5) {         mrr =  1.0 / n;\n      }\n    }\n    numPoints = n;\n    double p = numGoodPoints / numPoints;\n    if (isRelevant) {\n      pReleventSum += p;\n    }\n    if (n<pAt.length) {\n      pAt[n] = p;\n    }\n    recall = maxGoodPoints<=0 ? p : numGoodPoints/maxGoodPoints;\n    docNamesExtractTime += docNameExtractTime;\n  }
802	private void updateBoundsForRemovedItem(XYDataItem item) {\n        boolean itemContributesToXBounds = false;\n        boolean itemContributesToYBounds = false;\n        double x = item.getXValue();\n        if (!Double.isNaN(x)) {\n            if (x <= this.minX || x >= this.maxX) {\n                itemContributesToXBounds = true;\n            }\n        }\n        if (item.getY() != null) {\n            double y = item.getYValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    itemContributesToYBounds = true;\n                }\n            }\n        }\n        if (itemContributesToYBounds) {\n            findBoundsByIteration();\n        }\n        else if (itemContributesToXBounds) {\n            if (getAutoSort()) {\n                this.minX = getX(0).doubleValue();\n                this.maxX = getX(getItemCount() - 1).doubleValue();\n            }\n            else {\n                findBoundsByIteration();\n            }\n        }\n    }
803	public boolean removeSeries(VectorSeries series) {\n        ParamChecks.nullNotPermitted(series, "series");\n        boolean removed = this.data.remove(series);\n        if (removed) {\n            series.removeChangeListener(this);\n            fireDatasetChanged();\n        }\n        return removed;\n    }
804	public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n        char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) {         if (i == (1 + iIgnoreAtBeginning)) {\n                    iIgnoreAtBeginning++;\n        } else {\n                    bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n            return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n        String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n                  ArrayList<Object> hw = stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n                        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n            word[0] = '.';       word[len + 1] = '.';       word[len + 2] = 0;       byte[] il = new byte[len + 3];       for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n                              for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n            int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n                  res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }
805	public void removeColumn(Comparable columnKey) {\n        int index = getColumnIndex(columnKey);\n        if (index < 0) {\n            throw new UnknownKeyException("Column key (" + columnKey\n                    + ") not recognised.");\n        }\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            KeyedObjects rowData = (KeyedObjects) iterator.next();\n            int i = rowData.getIndex(columnKey);\n            if (i >= 0) {\n                rowData.removeValue(i);\n            }\n        }\n        this.columnKeys.remove(columnKey);\n    }
806	public QualityQuery[] readQueries(BufferedReader reader) throws IOException {\n    ArrayList<QualityQuery> res = new ArrayList<>();\n    String line;\n    try {\n      while (null!=(line=reader.readLine())) {\n        line = line.trim();\n        if (line.startsWith("#")) {\n          continue;\n        }\n                int k = line.indexOf(":");\n        String id = line.substring(0,k).trim();\n                String qtext = line.substring(k+1).trim();\n                HashMap<String,String> fields = new HashMap<>();\n        fields.put(name,qtext);\n                QualityQuery topic = new QualityQuery(id,fields);\n        res.add(topic);\n      }\n    } finally {\n      reader.close();\n    }\n        QualityQuery qq[] = res.toArray(new QualityQuery[0]);\n    Arrays.sort(qq);\n    return qq;\n  }
807	@Internal\n    public static void copyNodeRecursively( Entry entry, DirectoryEntry target )\n    throws IOException {\n        if ( entry.isDirectoryEntry() ) {\n        	DirectoryEntry dirEntry = (DirectoryEntry)entry;\n            DirectoryEntry newTarget = target.createDirectory( entry.getName() );\n            newTarget.setStorageClsid( dirEntry.getStorageClsid() );\n            Iterator<Entry> entries = dirEntry.getEntries();\n\n            while ( entries.hasNext() ) {\n                copyNodeRecursively( entries.next(), newTarget );\n            }\n        } else {\n            DocumentEntry dentry = (DocumentEntry) entry;\n            DocumentInputStream dstream = new DocumentInputStream( dentry );\n            target.createDocument( dentry.getName(), dstream );\n            dstream.close();\n        }\n    }
808	public static NumberRecord convertToNumberRecord(RKRecord rk) {\n        NumberRecord num = new NumberRecord();\n\n        num.setColumn(rk.getColumn());\n        num.setRow(rk.getRow());\n        num.setXFIndex(rk.getXFIndex());\n        num.setValue(rk.getRKNumber());\n        return num;\n    }
809	public static int serializePtgs(Ptg[] ptgs, byte[] array, int offset) {\n		LittleEndianByteArrayOutputStream out = new LittleEndianByteArrayOutputStream(array, offset); 		\n		List<Ptg> arrayPtgs = null;\n\n		for (Ptg ptg : ptgs) {\n			ptg.write(out);\n			if (ptg instanceof ArrayPtg) {\n				if (arrayPtgs == null) {\n					arrayPtgs = new ArrayList<>(5);\n				}\n				arrayPtgs.add(ptg);\n			}\n		}\n		if (arrayPtgs != null) {\n			for (Ptg arrayPtg : arrayPtgs) {\n				ArrayPtg p = (ArrayPtg) arrayPtg;\n				p.writeTokenValueBytes(out);\n			}\n		}\n		return out.getWriteIndex() - offset;\n	}
810	public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, SuggestMode suggestMode, float accuracy) throws IOException {\n        final IndexSearcher indexSearcher = obtainSearcher();\n    try {\n      if (ir == null || field == null) {\n        suggestMode = SuggestMode.SUGGEST_ALWAYS;\n      }\n      if (suggestMode == SuggestMode.SUGGEST_ALWAYS) {\n        ir = null;\n        field = null;\n      }\n\n      final int lengthWord = word.length();\n\n      final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n      final int goalFreq = suggestMode==SuggestMode.SUGGEST_MORE_POPULAR ? freq : 0;\n            if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && freq > 0) {\n        return new String[] { word };\n      }\n\n      BooleanQuery.Builder query = new BooleanQuery.Builder();\n      String[] grams;\n      String key;\n\n      for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n        key = "gram" + ng; \n        grams = formGrams(word, ng); \n        if (grams.length == 0) {\n          continue;         }\n\n        if (bStart > 0) {           add(query, "start" + ng, grams[0], bStart); \n        }\n        if (bEnd > 0) {           add(query, "end" + ng, grams[grams.length - 1], bEnd); \n        }\n        for (int i = 0; i < grams.length; i++) {\n          add(query, key, grams[i]);\n        }\n      }\n\n      int maxHits = 10 * numSug;\n\n        ScoreDoc[] hits = indexSearcher.search(query.build(), maxHits).scoreDocs;\n        SuggestWordQueue sugQueue = new SuggestWordQueue(numSug, comparator);\n\n            int stop = Math.min(hits.length, maxHits);\n      SuggestWord sugWord = new SuggestWord();\n      for (int i = 0; i < stop; i++) {\n\n        sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); \n                if (sugWord.string.equals(word)) {\n          continue;\n        }\n\n                sugWord.score = sd.getDistance(word,sugWord.string);\n        if (sugWord.score < accuracy) {\n          continue;\n        }\n\n        if (ir != null && field != null) {           sugWord.freq = ir.docFreq(new Term(field, sugWord.string));                     if ((suggestMode==SuggestMode.SUGGEST_MORE_POPULAR && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n            continue;\n          }\n        }\n        sugQueue.insertWithOverflow(sugWord);\n        if (sugQueue.size() == numSug) {\n                    accuracy = sugQueue.top().score;\n        }\n        sugWord = new SuggestWord();\n      }\n\n            String[] list = new String[sugQueue.size()];\n      for (int i = sugQueue.size() - 1; i >= 0; i--) {\n        list[i] = sugQueue.pop().string;\n      }\n\n      return list;\n    } finally {\n      releaseSearcher(indexSearcher);\n    }\n  }
811	static void writeDataRow(HSSFSheet sheet, int rowIx, double v0, double v1, int expRes) {\n        HSSFRow row = sheet.createRow(rowIx);\n\n        int rowNum = rowIx + 1;\n\n\n        row.createCell(0).setCellValue(formatDoubleAsHex(v0));\n        row.createCell(1).setCellValue(formatDoubleAsHex(v1));\n        row.createCell(2).setCellValue(v0);\n        row.createCell(3).setCellValue(v1);\n        row.createCell(4).setCellValue(expRes < 0 ? "LT" : expRes > 0 ? "GT" : "EQ");\n        row.createCell(5).setCellFormula("C" + rowNum + "<" + "D" + rowNum);\n        row.createCell(6).setCellFormula("C" + rowNum + "=" + "D" + rowNum);\n        row.createCell(7).setCellFormula("C" + rowNum + ">" + "D" + rowNum);\n                String frm = "if(or(" +\n            "and(E#='LT', F#      , G#=FALSE, H#=FALSE)," +\n            "and(E#='EQ', F#=FALSE, G#      , H#=FALSE)," +\n            "and(E#='GT', F#=FALSE, G#=FALSE, H#      )" +\n            "), 'OK', 'error')"    ;\n        row.createCell(8).setCellFormula(frm.replaceAll("#", String.valueOf(rowNum)).replace('\'', '"'));\n    }
812	public static void arrayMoveWithin(Object[] array, int moveFrom, int moveTo, int numToMove) {\n    	    	if(numToMove <= 0) { return; }\n    	if(moveFrom == moveTo) { return; }\n    	\n    	    	if(moveFrom < 0 || moveFrom >= array.length) {\n    		throw new IllegalArgumentException("The moveFrom must be a valid array index");\n    	}\n    	if(moveTo < 0 || moveTo >= array.length) {\n    		throw new IllegalArgumentException("The moveTo must be a valid array index");\n    	}\n    	if(moveFrom+numToMove > array.length) {\n    		throw new IllegalArgumentException("Asked to move more entries than the array has");\n    	}\n    	if(moveTo+numToMove > array.length) {\n    		throw new IllegalArgumentException("Asked to move to a position that doesn't have enough space");\n    	}\n    	\n    	    	Object[] toMove = new Object[numToMove];\n    	System.arraycopy(array, moveFrom, toMove, 0, numToMove);\n    	\n    	    	Object[] toShift;\n    	int shiftTo;\n    	if(moveFrom > moveTo) {\n    		    		    		toShift = new Object[(moveFrom-moveTo)];\n    		System.arraycopy(array, moveTo, toShift, 0, toShift.length);\n    		shiftTo = moveTo + numToMove;\n    	} else {\n    		    		    		toShift = new Object[(moveTo-moveFrom)];\n    		System.arraycopy(array, moveFrom+numToMove, toShift, 0, toShift.length);\n    		shiftTo = moveFrom;\n    	}\n    	\n    	    	System.arraycopy(toMove, 0, array, moveTo, toMove.length);\n    	\n    	    	System.arraycopy(toShift, 0, array, shiftTo, toShift.length);\n    	\n    	\n    	    }
813	public void writeOut(OutputStream out) throws IOException {\n												int size = 8 + 20 + 4 + (3 * lastEditUser.length());\n		_contents = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n\n				System.arraycopy(atomHeader,0,_contents,0,4);	\n				int atomSize = 20+4+lastEditUser.length();\n		LittleEndian.putInt(_contents,4,atomSize);\n\n				LittleEndian.putInt(_contents,8,20);\n\n				System.arraycopy((isEncrypted ? encHeaderToken : headerToken),0,_contents,12,4);\n\n				LittleEndian.putInt(_contents,16,(int)currentEditOffset);\n\n						byte[] asciiUN = IOUtils.safelyAllocate(lastEditUser.length(), MAX_RECORD_LENGTH);\n		StringUtil.putCompressedUnicode(lastEditUser,asciiUN,0);\n		\n				LittleEndian.putShort(_contents,20,(short)asciiUN.length);\n		\n				LittleEndian.putShort(_contents,22,(short)docFinalVersion);\n		_contents[24] = docMajorNo;\n		_contents[25] = docMinorNo;\n\n				_contents[26] = 0;\n		_contents[27] = 0;\n\n				System.arraycopy(asciiUN,0,_contents,28,asciiUN.length);\n\n				LittleEndian.putInt(_contents,28+asciiUN.length,(int)releaseVersion);\n\n				byte [] ucUN = IOUtils.safelyAllocate(lastEditUser.length()*2, MAX_RECORD_LENGTH);\n		StringUtil.putUnicodeLE(lastEditUser,ucUN,0);\n		System.arraycopy(ucUN,0,_contents,28+asciiUN.length+4,ucUN.length);\n\n				out.write(_contents);\n	}
814	@SuppressWarnings("WeakerAccess")\n    protected PropertySet getPropertySet(String setName, EncryptionInfo encryptionInfo) throws IOException {\n        DirectoryNode dirNode = directory;\n        \n        POIFSFileSystem encPoifs = null;\n        String step = "getting";\n        try {\n            if (encryptionInfo != null && encryptionInfo.isDocPropsEncrypted()) {\n                step = "getting encrypted";\n                String encryptedStream = getEncryptedPropertyStreamName();\n                if (!dirNode.hasEntry(encryptedStream)) {\n                    throw new EncryptedDocumentException("can't find encrypted property stream '"+encryptedStream+"'");\n                }\n                CryptoAPIDecryptor dec = (CryptoAPIDecryptor)encryptionInfo.getDecryptor();\n                encPoifs = dec.getSummaryEntries(dirNode, encryptedStream);\n                dirNode = encPoifs.getRoot();\n            }\n            \n                        if (dirNode == null || !dirNode.hasEntry(setName)) {\n                return null;\n            }\n    \n                        step = "getting";\n            try (DocumentInputStream dis = dirNode.createDocumentInputStream(dirNode.getEntry(setName))) {\n                                step = "creating";\n                return PropertySetFactory.create(dis);\n            }\n        } catch (IOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new IOException("Error "+step+" property set with name " + setName, e);\n        } finally {\n            IOUtils.closeQuietly(encPoifs);\n        }\n    }
815	public static Automaton removeDeadStates(Automaton a) {\n    int numStates = a.getNumStates();\n    BitSet liveSet = getLiveStates(a);\n\n    int[] map = new int[numStates];\n\n    Automaton result = new Automaton();\n        for(int i=0;i<numStates;i++) {\n      if (liveSet.get(i)) {\n        map[i] = result.createState();\n        result.setAccept(map[i], a.isAccept(i));\n      }\n    }\n\n    Transition t = new Transition();\n\n    for (int i=0;i<numStates;i++) {\n      if (liveSet.get(i)) {\n        int numTransitions = a.initTransition(i, t);\n                for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          if (liveSet.get(t.dest)) {\n            result.addTransition(map[i], map[t.dest], t.min, t.max);\n          }\n        }\n      }\n    }\n\n    result.finishState();\n    assert hasDeadStates(result) == false;\n    return result;\n  }
816	public float getAnchorHeightInPoints(HSSFSheet sheet) {\n        int y1 = getDy1();\n        int y2 = getDy2();\n        int row1 = Math.min(getRow1(), getRow2());\n        int row2 = Math.max(getRow1(), getRow2());\n\n        float points = 0;\n        if (row1 == row2) {\n            points = ((y2 - y1) / 256.0f) * getRowHeightInPoints(sheet, row2);\n        } else {\n            points += ((256.0f - y1) / 256.0f) * getRowHeightInPoints(sheet, row1);\n            for (int i = row1 + 1; i < row2; i++) {\n                points += getRowHeightInPoints(sheet, i);\n            }\n            points += (y2 / 256.0f) * getRowHeightInPoints(sheet, row2);\n        }\n\n        return points;\n    }
817	protected void onDocumentWrite(){\n        CTCell[] cArray = new CTCell[_cells.size()];\n        int i = 0;\n        for (XSSFCell xssfCell : _cells.values()) {\n            cArray[i] = (CTCell) xssfCell.getCTCell().copy();\n            \n                                                                        xssfCell.setCTCell(cArray[i]);\n            i++;\n        }\n\n        _row.setCArray(cArray);\n    }
818	protected Size2D arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        RectangleConstraint c1 = constraint.toUnconstrainedWidth();\n        Size2D size1 = arrange(container, g2, c1);\n\n        if (constraint.getWidthRange().contains(size1.getWidth())) {\n            return size1;\n        }\n        else {\n            double w = constraint.getWidthRange().constrain(size1.getWidth());\n            RectangleConstraint c2 = constraint.toFixedWidth(w);\n            return arrange(container, g2, c2);\n        }\n    }
819	private void outputUncompressed(byte b, OutputStream res) throws IOException {\n		nextMask += (1<<maskBitsSet);\n	maskBitsSet++;\n\n		buffer[bufferLen] = b;\n	bufferLen++;\n	dict[(posOut&4095)] = b;\n	posOut++;\n\n		if(maskBitsSet == 8) {\n		output8Codes(res);\n	}\n}
820	public void removeColumn(Comparable columnKey) {\n        ParamChecks.nullNotPermitted(columnKey, "columnKey");\n        if (!this.columnKeys.contains(columnKey)) {\n            throw new UnknownKeyException("Unknown key: " + columnKey);\n        }\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                rowData.removeValue(columnKey);\n            }\n        }\n        this.columnKeys.remove(columnKey);\n    }
821	protected Query newFuzzyQuery(String text, int fuzziness) {\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    for (Map.Entry<String,Float> entry : weights.entrySet()) {\n      final String fieldName = entry.getKey();\n      final BytesRef term = getAnalyzer().normalize(fieldName, text);\n      Query q = new FuzzyQuery(new Term(fieldName, term), fuzziness);\n      float boost = entry.getValue();\n      if (boost != 1f) {\n        q = new BoostQuery(q, boost);\n      }\n      bq.add(q, BooleanClause.Occur.SHOULD);\n    }\n    return simplify(bq.build());\n  }
822	public IndexSearcher createSearcher() {\n    MemoryIndexReader reader = new MemoryIndexReader();\n    IndexSearcher searcher = new IndexSearcher(reader);     searcher.setSimilarity(normSimilarity);\n    searcher.setQueryCache(null);\n    return searcher;\n  }
823	protected void drawVerticalItem(Graphics2D g2,\n                                    CategoryItemRendererState state,\n                                    Rectangle2D dataArea,\n                                    CategoryPlot plot,\n                                    CategoryAxis domainAxis,\n                                    ValueAxis rangeAxis,\n                                    StatisticalCategoryDataset dataset,\n                                    int visibleRow,\n                                    int row,\n                                    int column) {\n\n                double rectX = calculateBarW0(plot, PlotOrientation.VERTICAL, dataArea,\n                domainAxis, state, visibleRow, column);\n\n                Number meanValue = dataset.getMeanValue(row, column);\n        if (meanValue == null) {\n            return;\n        }\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {              if (value >= uclip) {\n                return;             }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) {             if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else {             if (value <= lclip) {\n                return;             }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n                yAxisLocation);\n        double rectY = Math.min(transY2, transY1);\n\n        double rectWidth = state.getBarWidth();\n        double rectHeight = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n                rectHeight);\n        Paint itemPaint = getItemPaint(row, column);\n        GradientPaintTransformer t = getGradientPaintTransformer();\n        if (t != null && itemPaint instanceof GradientPaint) {\n            itemPaint = t.transform((GradientPaint) itemPaint, bar);\n        }\n        g2.setPaint(itemPaint);\n        g2.fill(bar);\n                if (isDrawBarOutline()\n                && state.getBarWidth() > BAR_OUTLINE_WIDTH_THRESHOLD) {\n            Stroke stroke = getItemOutlineStroke(row, column);\n            Paint paint = getItemOutlinePaint(row, column);\n            if (stroke != null && paint != null) {\n                g2.setStroke(stroke);\n                g2.setPaint(paint);\n                g2.draw(bar);\n            }\n        }\n\n                Number n = dataset.getStdDevValue(row, column);\n        if (n != null) {\n            double valueDelta = n.doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);\n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));\n            }\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n\n            Line2D line;\n            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n                                     rectX + rectWidth / 2.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);\n            g2.draw(line);\n        }\n\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n                    (value < 0.0));\n        }\n\n                EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }
824	public String getSignatureMethodUri() {\n        switch (getDigestAlgo()) {\n        case sha1:   return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1;\n        case sha224: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA224;\n        case sha256: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA256;\n        case sha384: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA384;\n        case sha512: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA512;\n        case ripemd160: return XMLSignature.ALGO_ID_SIGNATURE_RSA_RIPEMD160;\n        default: throw new EncryptedDocumentException("Hash algorithm "\n            +getDigestAlgo()+" not supported for signing.");\n        }\n    }
825	public Pair<A,B> newPair(A a, B b) {\n    if (a.equals(outputs1.getNoOutput())) {\n      a = outputs1.getNoOutput();\n    }\n    if (b.equals(outputs2.getNoOutput())) {\n      b = outputs2.getNoOutput();\n    }\n\n    if (a == outputs1.getNoOutput() && b == outputs2.getNoOutput()) {\n      return NO_OUTPUT;\n    } else {\n      final Pair<A,B> p = new Pair<>(a, b);\n      assert valid(p);\n      return p;\n    }\n  }
826	public final String[] getBestFragments(\n    TokenStream tokenStream,\n    String text,\n    int maxNumFragments)\n    throws IOException, InvalidTokenOffsetsException\n  {\n    maxNumFragments = Math.max(1, maxNumFragments); \n    TextFragment[] frag =getBestTextFragments(tokenStream,text, true,maxNumFragments);\n\n        ArrayList<String> fragTexts = new ArrayList<>();\n    for (int i = 0; i < frag.length; i++)\n    {\n      if ((frag[i] != null) && (frag[i].getScore() > 0))\n      {\n        fragTexts.add(frag[i].toString());\n      }\n    }\n    return fragTexts.toArray(new String[0]);\n  }
827	public void display(PrintWriter w, int indent)\n    {\n        for (int i = 0; i < indent * 4; i++) {\n            w.print(' ');\n        }\n        w.println(getRecordName());\n    }
828	public Borders getBorderLeft() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getLeft();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
829	private static double getCellWidth(int defaultCharWidth, int colspan,\n            CellStyle style, double minWidth, AttributedString str) {\n        TextLayout layout = new TextLayout(str.getIterator(), fontRenderContext);\n        final Rectangle2D bounds;\n        if(style.getRotation() != 0){\n            \n            AffineTransform trans = new AffineTransform();\n            trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n            trans.concatenate(\n            AffineTransform.getScaleInstance(1, fontHeightMultiple)\n            );\n            bounds = layout.getOutline(trans).getBounds();\n        } else {\n            bounds = layout.getBounds();\n        }\n                final double frameWidth = bounds.getX() + bounds.getWidth();\n        return Math.max(minWidth, ((frameWidth / colspan) / defaultCharWidth) + style.getIndention());\n    }
830	public int addChildAfter(Record newChild, Record after) {\n				int loc = findChildLocation(after);\n		if(loc == -1) {\n			throw new IllegalArgumentException("Asked to add a new child after another record, but that record wasn't one of our children!");\n		}\n\n				addChildAt(newChild, loc+1);\n		return loc+1;\n	}
831	public void writeToFS(POIFSFileSystem fs) throws IOException {\n				ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		writeOut(baos);\n		ByteArrayInputStream bais = \n			new ByteArrayInputStream(baos.toByteArray());\n\n				fs.createOrUpdateDocument(bais,"Current User");\n	}
832	public void numberedListInCell(HSSFWorkbook workbook,\n                                   ArrayList<String> listItems,\n                                   HSSFCell cell,\n                                   int startingValue,\n                                   int increment) {\n        StringBuilder buffer = new StringBuilder();\n        int itemNumber = startingValue;\n                        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n                        for(String listItem : listItems) {\n            buffer.append(itemNumber).append(". ");\n            buffer.append(listItem);\n            buffer.append("\n");\n            itemNumber += increment;\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
833	public static BytesRef toBytesRef(IntsRef input, BytesRefBuilder scratch) {\n    scratch.grow(input.length);\n    for(int i=0;i<input.length;i++) {\n      int value = input.ints[i+input.offset];\n            assert value >= Byte.MIN_VALUE && value <= 255: "value " + value + " doesn't fit into byte";\n      scratch.setByteAt(i, (byte) value);\n    }\n    scratch.setLength(input.length);\n    return scratch.get();\n  }
834	void setType(CellType type)\n    {\n        switch(type)\n        {\n            case NUMERIC:\n            {\n                _value = new NumericValue();\n                break;\n            }\n            case STRING:\n            {\n                PlainStringValue sval = new PlainStringValue();\n                if(_value != null){\n                                        String str = convertCellValueToString();\n                    sval.setValue(str);\n                }\n                _value = sval;\n                break;\n            }\n            case FORMULA:\n            {\n                _value = new NumericFormulaValue();\n                break;\n            }\n            case BLANK:\n            {\n                _value = new BlankValue();\n                break;\n            }\n            case BOOLEAN:\n            {\n                BooleanValue bval = new BooleanValue();\n                if(_value != null){\n                                        boolean val = convertCellValueToBoolean();\n                    bval.setValue(val);\n                }\n                _value = bval;\n                break;\n            }\n            case ERROR:\n            {\n                _value = new ErrorValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException("Illegal type " + type);\n            }\n        }\n    }
835	public void delete(int start, int end) {\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        recalculateBounds();\n        fireSeriesChanged();\n    }
836	private ParseNode powerFactor() {\n        ParseNode result = percentFactor();\n        while(true) {\n            SkipWhite();\n            if(look != '^') {\n                return result;\n            }\n            Match('^');\n            ParseNode other = percentFactor();\n            result = new ParseNode(PowerPtg.instance, result, other);\n        }\n    }
837	public Point translateToJava2D(double angleDegrees, double radius,\n            ValueAxis axis, Rectangle2D dataArea) {\n\n        if (counterClockwise) {\n            angleDegrees = -angleDegrees;\n        }\n        double radians = Math.toRadians(angleDegrees + this.angleOffset);\n\n        double minx = dataArea.getMinX() + this.margin;\n        double maxx = dataArea.getMaxX() - this.margin;\n        double miny = dataArea.getMinY() + this.margin;\n        double maxy = dataArea.getMaxY() - this.margin;\n\n        double halfWidth = (maxx - minx) / 2.0;\n        double halfHeight = (maxy - miny) / 2.0;\n\n        double midX = minx + halfWidth;\n        double midY = miny + halfHeight;\n\n        double l = Math.min(halfWidth, halfHeight);\n        Rectangle2D quadrant = new Rectangle2D.Double(midX, midY, l, l);\n\n        double axisMin = axis.getLowerBound();\n        double adjustedRadius = Math.max(radius, axisMin);\n\n        double length = axis.valueToJava2D(adjustedRadius, quadrant, RectangleEdge.BOTTOM) - midX;\n        float x = (float) (midX + Math.cos(radians) * length);\n        float y = (float) (midY + Math.sin(radians) * length);\n\n        int ix = Math.round(x);\n        int iy = Math.round(y);\n\n        Point p = new Point(ix, iy);\n        return p;\n\n    }
838	private BooleanQuery addMinShouldMatchToBoolean(BooleanQuery query, float fraction) {\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setMinimumNumberShouldMatch((int) (fraction * query.clauses().size()));\n    for (BooleanClause clause : query) {\n      builder.add(clause);\n    }\n\n    return builder.build();\n  }
839	public boolean changeName(Property property, String newName)\n    {\n        boolean result;\n        String  oldName = property.getName();\n\n        property.setName(newName);\n        String cleanNewName = property.getName();\n\n        if (_children_names.contains(cleanNewName))\n        {\n\n                        property.setName(oldName);\n            result = false;\n        }\n        else\n        {\n            _children_names.add(cleanNewName);\n            _children_names.remove(oldName);\n            result = true;\n        }\n        return result;\n    }
840	public Arc<T> getFirstArc(Arc<T> arc) {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    if (emptyOutput != null) {\n      arc.flags = BIT_FINAL_ARC | BIT_LAST_ARC;\n      arc.nextFinalOutput = emptyOutput;\n      if (emptyOutput != NO_OUTPUT) {\n        arc.flags |= BIT_ARC_HAS_FINAL_OUTPUT;\n      }\n    } else {\n      arc.flags = BIT_LAST_ARC;\n      arc.nextFinalOutput = NO_OUTPUT;\n    }\n    arc.output = NO_OUTPUT;\n\n            arc.target = startNode;\n    return arc;\n  }
841	public static byte[] peekFirstNBytes(InputStream stream, int limit) throws IOException, EmptyFileException {\n        stream.mark(limit);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(limit);\n        copy(new BoundedInputStream(stream, limit), bos);\n\n        int readBytes = bos.size();\n        if (readBytes == 0) {\n            throw new EmptyFileException();\n        }\n\n        if (readBytes < limit) {\n            bos.write(new byte[limit-readBytes]);\n        }\n        byte peekedBytes[] = bos.toByteArray();\n        if(stream instanceof PushbackInputStream) {\n            PushbackInputStream pin = (PushbackInputStream)stream;\n            pin.unread(peekedBytes, 0, readBytes);\n        } else {\n            stream.reset();\n        }\n\n        return peekedBytes;\n    }
842	public void add(BytesRef utf8, int bucket) throws IOException {\n    if (bucket < 0 || bucket >= buckets) {\n      throw new IllegalArgumentException(\n          "Bucket outside of the allowed range [0, " + buckets + "): " + bucket);\n    }\n    \n    scratch.grow(utf8.length + 10);\n    scratch.clear();\n    scratch.append((byte) bucket);\n    scratch.append(utf8);\n    sorter.add(scratch.get());\n  }
843	public void clearObservations() {\n        Iterator iterator = this.bins.iterator();\n        while (iterator.hasNext()) {\n            SimpleHistogramBin bin = (SimpleHistogramBin) iterator.next();\n            bin.setItemCount(0);\n        }\n        notifyListeners(new DatasetChangeEvent(this, this));\n    }
844	private DocValuesProducer initDocValuesProducer() throws IOException {\n\n    if (fieldInfos.hasDocValues() == false) {\n      return null;\n    } else {\n      Directory dir;\n      if (core.cfsReader != null) {\n        dir = core.cfsReader;\n      } else {\n        dir = si.info.dir;\n      }\n      if (si.hasFieldUpdates()) {\n        return new SegmentDocValuesProducer(si, dir, core.coreFieldInfos, fieldInfos, segDocValues);\n      } else {\n                return segDocValues.getDocValuesProducer(-1L, si, dir, fieldInfos);\n      }\n    }\n  }
845	protected List<EvaluationConditionalFormatRule> getRules(Sheet sheet) {\n        final String sheetName = sheet.getSheetName();\n        List<EvaluationConditionalFormatRule> rules = formats.get(sheetName);\n        if (rules == null) {\n            if (formats.containsKey(sheetName)) {\n                return Collections.emptyList();\n            }\n            final SheetConditionalFormatting scf = sheet.getSheetConditionalFormatting();\n            final int count = scf.getNumConditionalFormattings();\n            rules = new ArrayList<>(count);\n            formats.put(sheetName, rules);\n            for (int i=0; i < count; i++) {\n                ConditionalFormatting f = scf.getConditionalFormattingAt(i);\n                                final CellRangeAddress[] regions = f.getFormattingRanges();\n                for (int r=0; r < f.getNumberOfRules(); r++) {\n                    ConditionalFormattingRule rule = f.getRule(r);\n                    rules.add(new EvaluationConditionalFormatRule(workbookEvaluator, sheet, f, i, rule, r, regions));\n                }\n            }\n                        Collections.sort(rules);\n        }\n        return Collections.unmodifiableList(rules);\n    }
846	protected static int comparePrefix(UnitNRShape a, UnitNRShape b) {\n    int minLevel = Math.min(a.getLevel(), b.getLevel());\n    for (int level = 1; level <= minLevel; level++) {\n      int diff = a.getValAtLevel(level) - b.getValAtLevel(level);\n      if (diff != 0)\n        return diff;\n    }\n    return 0;\n  }
847	public int countOfAllChildren() {\n        int count = shapes.size();\n        for (Iterator<HSSFShape> iterator = shapes.iterator(); iterator.hasNext(); ) {\n            HSSFShape shape = iterator.next();\n            count += shape.countOfAllChildren();\n        }\n        return count;\n    }
848	public synchronized CopyState getCopyState() throws IOException {\n    ensureOpen(false);\n        assert curInfos == copyState.infos;\n    writer.incRefDeleter(copyState.infos);\n    int count = copyingCount.incrementAndGet();\n    assert count > 0;\n    return copyState;\n  }
849	private ClientAnchorDetail fitImageToColumns(HSSFSheet sheet, int colNumber,\n            double reqImageWidthMM, int resizeBehaviour) {\n\n        double colWidthMM;\n        double colCoordinatesPerMM;\n        int pictureWidthCoordinates;\n        ClientAnchorDetail colClientAnchorDetail = null;\n\n                colWidthMM = ConvertImageUnits.widthUnits2Millimetres(\n                (short)sheet.getColumnWidth(colNumber));\n\n                                                if(colWidthMM < reqImageWidthMM) {\n\n                        if((resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                                                sheet.setColumnWidth(colNumber,\n                        ConvertImageUnits.millimetres2WidthUnits(reqImageWidthMM));\n                                                                                colWidthMM = reqImageWidthMM;\n                colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n                colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                        colNumber, pictureWidthCoordinates);\n            }\n                                                else if ((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                     (resizeBehaviour == AddDimensionedImage.EXPAND_ROW)) {\n                colClientAnchorDetail = this.calculateColumnLocation(sheet,\n                        colNumber, reqImageWidthMM);\n            }\n        }\n                else {\n                        colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                        pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n            colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                    colNumber, pictureWidthCoordinates);\n        }\n        return(colClientAnchorDetail);\n    }
850	protected double findMaximumTickLabelHeight(List ticks, Graphics2D g2,\n            Rectangle2D drawArea, boolean vertical) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        Font font = getTickLabelFont();\n        g2.setFont(font);\n        double maxHeight = 0.0;\n        if (vertical) {\n            FontMetrics fm = g2.getFontMetrics(font);\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                Tick tick = (Tick) iterator.next();\n                Rectangle2D labelBounds = null;\n                if (tick instanceof LogTick) {\n                    LogTick lt = (LogTick) tick;\n                    if (lt.getAttributedLabel() != null) {\n                        labelBounds = AttrStringUtils.getTextBounds(\n                                lt.getAttributedLabel(), g2);\n                    }\n                } else if (tick.getText() != null) {\n                    labelBounds = TextUtilities.getTextBounds(\n                            tick.getText(), g2, fm);\n                }\n                if (labelBounds != null && labelBounds.getWidth() \n                        + insets.getTop() + insets.getBottom() > maxHeight) {\n                    maxHeight = labelBounds.getWidth()\n                                + insets.getTop() + insets.getBottom();\n                }\n            }\n        } else {\n            LineMetrics metrics = font.getLineMetrics("ABCxyz",\n                    g2.getFontRenderContext());\n            maxHeight = metrics.getHeight()\n                        + insets.getTop() + insets.getBottom();\n        }\n        return maxHeight;\n\n    }
851	@SuppressWarnings("fallthrough")\n  public static Automaton toAutomaton(Term wildcardquery) {\n    List<Automaton> automata = new ArrayList<>();\n    \n    String wildcardText = wildcardquery.text();\n    \n    for (int i = 0; i < wildcardText.length();) {\n      final int c = wildcardText.codePointAt(i);\n      int length = Character.charCount(c);\n      switch(c) {\n        case WILDCARD_STRING: \n          automata.add(Automata.makeAnyString());\n          break;\n        case WILDCARD_CHAR:\n          automata.add(Automata.makeAnyChar());\n          break;\n        case WILDCARD_ESCAPE:\n                    if (i + length < wildcardText.length()) {\n            final int nextChar = wildcardText.codePointAt(i + length);\n            length += Character.charCount(nextChar);\n            automata.add(Automata.makeChar(nextChar));\n            break;\n          }         default:\n          automata.add(Automata.makeChar(c));\n      }\n      i += length;\n    }\n    \n    return Operations.concatenate(automata);\n  }
852	public static void main(String[] args) throws Exception {\n    String usage =\n      "Usage:\tjava org.apache.lucene.demo.SearchFiles [-index dir] [-field f] [-repeat n] [-queries file] [-query string] [-raw] [-paging hitsPerPage]\n\nSee http://lucene.apache.org/core/4_1_0/demo/ for details.";\n    if (args.length > 0 && ("-h".equals(args[0]) || "-help".equals(args[0]))) {\n      System.out.println(usage);\n      System.exit(0);\n    }\n\n    String index = "index";\n    String field = "contents";\n    String queries = null;\n    int repeat = 0;\n    boolean raw = false;\n    String queryString = null;\n    int hitsPerPage = 10;\n    \n    for(int i = 0;i < args.length;i++) {\n      if ("-index".equals(args[i])) {\n        index = args[i+1];\n        i++;\n      } else if ("-field".equals(args[i])) {\n        field = args[i+1];\n        i++;\n      } else if ("-queries".equals(args[i])) {\n        queries = args[i+1];\n        i++;\n      } else if ("-query".equals(args[i])) {\n        queryString = args[i+1];\n        i++;\n      } else if ("-repeat".equals(args[i])) {\n        repeat = Integer.parseInt(args[i+1]);\n        i++;\n      } else if ("-raw".equals(args[i])) {\n        raw = true;\n      } else if ("-paging".equals(args[i])) {\n        hitsPerPage = Integer.parseInt(args[i+1]);\n        if (hitsPerPage <= 0) {\n          System.err.println("There must be at least 1 hit per page.");\n          System.exit(1);\n        }\n        i++;\n      }\n    }\n    \n    IndexReader reader = DirectoryReader.open(FSDirectory.open(Paths.get(index)));\n    IndexSearcher searcher = new IndexSearcher(reader);\n    Analyzer analyzer = new StandardAnalyzer();\n\n    BufferedReader in = null;\n    if (queries != null) {\n      in = Files.newBufferedReader(Paths.get(queries), StandardCharsets.UTF_8);\n    } else {\n      in = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8));\n    }\n    QueryParser parser = new QueryParser(field, analyzer);\n    while (true) {\n      if (queries == null && queryString == null) {                                System.out.println("Enter query: ");\n      }\n\n      String line = queryString != null ? queryString : in.readLine();\n\n      if (line == null || line.length() == -1) {\n        break;\n      }\n\n      line = line.trim();\n      if (line.length() == 0) {\n        break;\n      }\n      \n      Query query = parser.parse(line);\n      System.out.println("Searching for: " + query.toString(field));\n            \n      if (repeat > 0) {                                   Date start = new Date();\n        for (int i = 0; i < repeat; i++) {\n          searcher.search(query, 100);\n        }\n        Date end = new Date();\n        System.out.println("Time: "+(end.getTime()-start.getTime())+"ms");\n      }\n\n      doPagingSearch(in, searcher, query, hitsPerPage, raw, queries == null && queryString == null);\n\n      if (queryString != null) {\n        break;\n      }\n    }\n    reader.close();\n  }
853	public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRefBuilder()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n                        continue;\n      }\n      \n      IntsRefBuilder currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(t.min);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n                                                                                FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + " "\n                + min;\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(nextArc.label);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label;             nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : "last: " + label\n                + " next: " + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }
854	public static Range combine(Range range1, Range range2) {\n        if (range1 == null) {\n            return range2;\n        }\n        if (range2 == null) {\n            return range1;\n        }\n        double l = Math.min(range1.getLowerBound(), range2.getLowerBound());\n        double u = Math.max(range1.getUpperBound(), range2.getUpperBound());\n        return new Range(l, u);\n    }
855	private static Edge createTree(double polyLats[], double polyLons[]) {\n    Edge edges[] = new Edge[polyLats.length - 1];\n    for (int i = 1; i < polyLats.length; i++) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      edges[i - 1] = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n    }\n        Arrays.sort(edges, (left, right) -> {\n      int ret = Double.compare(left.low, right.low);\n      if (ret == 0) {\n        ret = Double.compare(left.max, right.max);\n      }\n      return ret;\n    });\n    return createTree(edges, 0, edges.length - 1);\n  }
856	public void addOverlay(Overlay overlay) {\n        ParamChecks.nullNotPermitted(overlay, "overlay");\n        this.overlays.add(overlay);\n        overlay.addChangeListener(this);\n        repaint();\n    }
857	protected PackagePart[] getRelatedByType(String contentType) throws InvalidFormatException {\n        PackageRelationshipCollection partsC =\n            getPackagePart().getRelationshipsByType(contentType);\n\n        PackagePart[] parts = new PackagePart[partsC.size()];\n        int count = 0;\n        for (PackageRelationship rel : partsC) {\n            parts[count] = getPackagePart().getRelatedPart(rel);\n            count++;\n        }\n        return parts;\n    }
858	public void setValue(Comparable key, Number value) {\n        ParamChecks.nullNotPermitted(key, "key");\n        int keyIndex = getIndex(key);\n        if (keyIndex >= 0) {\n            this.keys.set(keyIndex, key);\n            this.values.set(keyIndex, value);\n        }\n        else {\n            this.keys.add(key);\n            this.values.add(value);\n            this.indexMap.put(key, new Integer(this.keys.size() - 1));\n        }\n    }
859	public void addFormatRun(FormatRun r) {\n      if (field_4_format_runs == null) {\n		field_4_format_runs = new ArrayList<>();\n	  }\n\n      int index = findFormatRunAt(r._character);\n      if (index != -1) {\n         field_4_format_runs.remove(index);\n      }\n\n      field_4_format_runs.add(r);\n                  Collections.sort(field_4_format_runs);\n\n            field_2_optionflags = richText.setByte(field_2_optionflags);\n    }
860	protected AttributedString createTickLabel(double value) {\n        if (this.numberFormatOverride != null) {\n            return new AttributedString(\n                    this.numberFormatOverride.format(value));\n        } else {\n            String baseStr = this.baseSymbol;\n            if (baseStr == null) {\n                baseStr = this.baseFormatter.format(this.base);\n            }\n            double logy = calculateLog(value);\n            String exponentStr = getTickUnit().valueToString(logy);\n            AttributedString as = new AttributedString(baseStr + exponentStr);\n            as.addAttributes(getTickLabelFont().getAttributes(), 0, (baseStr \n                    + exponentStr).length());\n            as.addAttribute(TextAttribute.SUPERSCRIPT, \n                    TextAttribute.SUPERSCRIPT_SUPER, baseStr.length(), \n                    baseStr.length() + exponentStr.length());\n            return as;\n        }\n    }
861	long add(Term term, DeleteSlice slice) {\n    final TermNode termNode = new TermNode(term);\n    long seqNo = add(termNode);\n    \n    slice.sliceTail = termNode;\n    assert slice.sliceHead != slice.sliceTail : "slice head and tail must differ after add";\n    tryApplyGlobalSlice();     \n    return seqNo;\n  }
862	public boolean removeBodyElement(int pos) {\n        if (pos >= 0 && pos < bodyElements.size()) {\n            BodyElementType type = bodyElements.get(pos).getElementType();\n            if (type == BodyElementType.TABLE) {\n                int tablePos = getTablePos(pos);\n                tables.remove(tablePos);\n                ctDocument.getBody().removeTbl(tablePos);\n            }\n            if (type == BodyElementType.PARAGRAPH) {\n                int paraPos = getParagraphPos(pos);\n                paragraphs.remove(paraPos);\n                ctDocument.getBody().removeP(paraPos);\n            }\n            bodyElements.remove(pos);\n            return true;\n        }\n        return false;\n    }
863	protected void addPrefixMatch(StringBuilder sb, String surface, String analyzed, String prefixToken) {\n            if (prefixToken.length() >= surface.length()) {\n      addWholeMatch(sb, surface, analyzed);\n      return;\n    }\n    sb.append("<b>");\n    sb.append(surface.substring(0, prefixToken.length()));\n    sb.append("</b>");\n    sb.append(surface.substring(prefixToken.length()));\n  }
864	private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException("cannot change previous indexSort=" + segmentIndexSort + " (from segment=" + info + ") to new indexSort=" + indexSort);\n        } else if (segmentIndexSort == null && info.info.getVersion().onOrAfter(Version.LUCENE_6_5_0)) {\n                    throw new CorruptIndexException("segment not sorted with indexSort=" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }
865	public int addPicture(InputStream is, int format) throws IOException {\n        int imageNumber = getAllPictures().size() + 1;\n        XSSFPictureData img = createRelationship(XSSFPictureData.RELATIONS[format], this.xssfFactory, imageNumber, true).getDocumentPart();\n        try (OutputStream out = img.getPackagePart().getOutputStream()) {\n            IOUtils.copy(is, out);\n        }\n        pictures.add(img);\n        return imageNumber - 1;\n    }
866	public void removeAllValuesForX(Number x) {\n        ParamChecks.nullNotPermitted(x, "x");\n        boolean savedState = this.propagateEvents;\n        this.propagateEvents = false;\n        for (int s = 0; s < this.data.size(); s++) {\n            XYSeries series = (XYSeries) this.data.get(s);\n            series.remove(x);\n        }\n        this.propagateEvents = savedState;\n        this.xPoints.remove(x);\n        fireDatasetChanged();\n    }
867	MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException("Merge would result in 0 document segment");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled("SM")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled("SM")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to merge stored fields [" + numMerged + " docs]");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): "numMerged=" + numMerged + " vs mergeState.segmentInfo.maxDoc()=" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled("SM")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled("SM")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to merge postings [" + numMerged + " docs]");\n    }\n\n    if (mergeState.infoStream.isEnabled("SM")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled("SM")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to merge doc values [" + numMerged + " docs]");\n    }\n\n    if (mergeState.infoStream.isEnabled("SM")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled("SM")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to merge points [" + numMerged + " docs]");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled("SM")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled("SM")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to merge norms [" + numMerged + " docs]");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled("SM")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled("SM")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to merge vectors [" + numMerged + " docs]");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n        if (mergeState.infoStream.isEnabled("SM")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, "", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled("SM")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message("SM", ((t1-t0)/1000000) + " msec to write field infos [" + numMerged + " docs]");\n    }\n\n    return mergeState;\n  }
868	public static Dimension getDimensionFromAnchor(Picture picture) {\n        ClientAnchor anchor = picture.getClientAnchor();\n        boolean isHSSF = (anchor instanceof HSSFClientAnchor);\n        Sheet sheet = picture.getSheet();\n\n        double w = 0;\n        int col2 = anchor.getCol1();\n\n                w = sheet.getColumnWidthInPixels(col2++);\n        if (isHSSF) {\n            w *= 1 - anchor.getDx1()/1024d;\n        } else {\n            w -= anchor.getDx1()/(double)EMU_PER_PIXEL;\n        }\n        \n        while(col2 < anchor.getCol2()){\n            w += sheet.getColumnWidthInPixels(col2++);\n        }\n        \n        if (isHSSF) {\n            w += sheet.getColumnWidthInPixels(col2) * anchor.getDx2()/1024d;\n        } else {\n            w += anchor.getDx2()/(double)EMU_PER_PIXEL;\n        }\n\n        double h = 0;\n        int row2 = anchor.getRow1();\n        \n        h = getRowHeightInPixels(sheet,row2++);\n        if (isHSSF) {\n            h *= 1 - anchor.getDy1()/256d;\n        } else {\n            h -= anchor.getDy1()/(double)EMU_PER_PIXEL;\n        }\n\n        while(row2 < anchor.getRow2()){\n            h += getRowHeightInPixels(sheet,row2++);\n        }\n        \n        if (isHSSF) {\n            h += getRowHeightInPixels(sheet,row2) * anchor.getDy2()/256;\n        } else {\n            h += anchor.getDy2()/(double)EMU_PER_PIXEL;\n        }\n\n        w *= EMU_PER_PIXEL;\n        h *= EMU_PER_PIXEL;\n        \n        return new Dimension((int)Math.rint(w), (int)Math.rint(h));\n    }
869	public void applyFont(short fontIndex) {\n        XSSFFont font;\n        if(styles == null) {\n            font = new XSSFFont();\n            font.setFontName("#" + fontIndex);\n        } else {\n            font = styles.getFontAt(fontIndex);\n        }\n        String text = getString();\n        applyFont(0, text.length(), font);\n    }
870	protected void update(Comparable x, Object y) {\n        int index = indexOf(x);\n        if (index < 0) {\n            throw new SeriesException("No observation for x = " + x);\n        }\n        else {\n            ComparableObjectItem item = getDataItem(index);\n            item.setObject(y);\n            fireSeriesChanged();\n        }\n    }
871	private void drawMultipleEllipse(Point2D point, double boxWidth,\n                                     double oRadius, Graphics2D g2)  {\n\n        Ellipse2D dot1 = new Ellipse2D.Double(point.getX() - (boxWidth / 2)\n                + oRadius, point.getY(), oRadius, oRadius);\n        Ellipse2D dot2 = new Ellipse2D.Double(point.getX() + (boxWidth / 2),\n                point.getY(), oRadius, oRadius);\n        g2.draw(dot1);\n        g2.draw(dot2);\n    }
872	protected Query analyzeMultiPhrase(String field, TokenStream stream, int slop) throws IOException {\n    MultiPhraseQuery.Builder mpqb = newMultiPhraseQueryBuilder();\n    mpqb.setSlop(slop);\n    \n    TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n\n    PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n    int position = -1;  \n    \n    List<Term> multiTerms = new ArrayList<>();\n    stream.reset();\n    while (stream.incrementToken()) {\n      int positionIncrement = posIncrAtt.getPositionIncrement();\n      \n      if (positionIncrement > 0 && multiTerms.size() > 0) {\n        if (enablePositionIncrements) {\n          mpqb.add(multiTerms.toArray(new Term[0]), position);\n        } else {\n          mpqb.add(multiTerms.toArray(new Term[0]));\n        }\n        multiTerms.clear();\n      }\n      position += positionIncrement;\n      multiTerms.add(new Term(field, termAtt.getBytesRef()));\n    }\n    \n    if (enablePositionIncrements) {\n      mpqb.add(multiTerms.toArray(new Term[0]), position);\n    } else {\n      mpqb.add(multiTerms.toArray(new Term[0]));\n    }\n    return mpqb.build();\n  }
873	private List<? extends DataValidation> getValidations(Sheet sheet) {\n        List<? extends DataValidation> dvs = validations.get(sheet.getSheetName());\n        if (dvs == null && !validations.containsKey(sheet.getSheetName())) {\n            dvs = sheet.getDataValidations();\n            validations.put(sheet.getSheetName(), dvs);\n        }\n        return dvs;\n    }
874	public static Area3DPxg parseStructuredReference(String tableText, FormulaParsingWorkbook workbook, int rowIndex) {\n        final int sheetIndex = -1;         Ptg[] arr = FormulaParser.parse(tableText, workbook, FormulaType.CELL, sheetIndex, rowIndex);\n        if (arr.length != 1 || !(arr[0] instanceof Area3DPxg) ) {\n            throw new IllegalStateException("Illegal structured reference");\n        }\n        return (Area3DPxg) arr[0];\n    }
875	public int stem(char s[], int len) {\n    if (len < 4)       return len;\n    \n    final int origLen = len;\n        len = rule0(s, len);\n    len = rule1(s, len);\n    len = rule2(s, len);\n    len = rule3(s, len);\n    len = rule4(s, len);\n    len = rule5(s, len);\n    len = rule6(s, len);\n    len = rule7(s, len);\n    len = rule8(s, len);\n    len = rule9(s, len);\n    len = rule10(s, len);\n    len = rule11(s, len);\n    len = rule12(s, len);\n    len = rule13(s, len);\n    len = rule14(s, len);\n    len = rule15(s, len);\n    len = rule16(s, len);\n    len = rule17(s, len);\n    len = rule18(s, len);\n    len = rule19(s, len);\n    len = rule20(s, len);\n        if (len == origLen)\n      len = rule21(s, len);\n    \n    return rule22(s, len);\n  }
876	public static String geoTermToString(long term) {\n    StringBuilder s = new StringBuilder(64);\n    final int numberOfLeadingZeros = Long.numberOfLeadingZeros(term);\n    for (int i = 0; i < numberOfLeadingZeros; i++) {\n      s.append('0');\n    }\n    if (term != 0) {\n      s.append(Long.toBinaryString(term));\n    }\n    return s.toString();\n  }
877	public void drawShape(Graphics2D graphics, Shape<?,?> shape, Rectangle2D bounds) {\n        Rectangle2D shapeBounds = shape.getAnchor();\n        if (shapeBounds.isEmpty() || (bounds != null && bounds.isEmpty())) {\n            return;\n        }\n\n        AffineTransform txg = (AffineTransform)graphics.getRenderingHint(Drawable.GROUP_TRANSFORM);\n        AffineTransform tx = new AffineTransform();\n        try {\n            if (bounds != null) {\n                double scaleX = bounds.getWidth()/shapeBounds.getWidth();\n                double scaleY = bounds.getHeight()/shapeBounds.getHeight();\n                tx.translate(bounds.getCenterX(), bounds.getCenterY());\n                tx.scale(scaleX, scaleY);\n                tx.translate(-shapeBounds.getCenterX(), -shapeBounds.getCenterY());\n            }\n            graphics.setRenderingHint(Drawable.GROUP_TRANSFORM, tx);\n            \n            Drawable d = getDrawable(shape);\n            d.applyTransform(graphics);\n            d.draw(graphics);\n        } finally {\n            graphics.setRenderingHint(Drawable.GROUP_TRANSFORM, txg);\n        }\n    }
878	public void fixFonts(Graphics2D graphics) {\n        if (!JvmBugs.hasLineBreakMeasurerBug()) return;\n        @SuppressWarnings("unchecked")\n        Map<String,String> fontMap = (Map<String,String>)graphics.getRenderingHint(Drawable.FONT_MAP);\n        if (fontMap == null) {\n            fontMap = new HashMap<>();\n            graphics.setRenderingHint(Drawable.FONT_MAP, fontMap);\n        }\n        \n        String fonts[][] = {\n            { "Calibri", "Lucida Sans" },\n            { "Cambria", "Lucida Bright" },\n            { "Times New Roman", "Lucida Bright" },\n            { "serif", "Lucida Bright" }\n        };\n\n        for (String f[] : fonts) {\n            if (!fontMap.containsKey(f[0])) {\n                fontMap.put(f[0], f[1]);\n            }\n        }\n    }
879	private ArrayList<Completion> lookupSortedByWeight(BytesRef key, \n      int num, boolean collectAll) throws IOException {\n                final ArrayList<Completion> res = new ArrayList<>(Math.min(10, num));\n\n    final BytesRef output = BytesRef.deepCopyOf(key);\n    for (int i = 0; i < rootArcs.length; i++) {\n      final FST.Arc<Object> rootArc = rootArcs[i];\n      final FST.Arc<Object> arc = new FST.Arc<>().copyFrom(rootArc);\n\n            if (descendWithPrefix(arc, key)) {\n                                output.length = key.length - 1;\n        if (collect(res, num, rootArc.label, output, arc) && !collectAll) {\n                                        if (exactFirst) {\n            if (!checkExistingAndReorder(res, key)) {\n              int exactMatchBucket = getExactMatchStartingFromRootArc(i, key);\n              if (exactMatchBucket != -1) {\n                                while (res.size() >= num) {\n                  res.remove(res.size() - 1);\n                }\n                res.add(0, new Completion(key, exactMatchBucket));\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    return res;\n  }
880	static HSSFPatriarch createPatriarch(HSSFPatriarch patriarch, HSSFSheet sheet){\n        HSSFPatriarch newPatriarch = new HSSFPatriarch(sheet, new EscherAggregate(true));\n        newPatriarch.afterCreate();\n        for (HSSFShape shape: patriarch.getChildren()){\n            HSSFShape newShape;\n            if (shape instanceof HSSFShapeGroup){\n                newShape = ((HSSFShapeGroup)shape).cloneShape(newPatriarch);\n            } else {\n                newShape = shape.cloneShape();\n            }\n            newPatriarch.onCreate(newShape);\n            newPatriarch.addShape(newShape);\n        }\n        return newPatriarch;\n    }
881	protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }
882	public static CFRule12Record create(HSSFSheet sheet, byte comparisonOperation,\n            String formulaText1, String formulaText2, String formulaTextScale) {\n        Ptg[] formula1 = parseFormula(formulaText1, sheet);\n        Ptg[] formula2 = parseFormula(formulaText2, sheet);\n        Ptg[] formula3 = parseFormula(formulaTextScale, sheet);\n        return new CFRule12Record(CONDITION_TYPE_CELL_VALUE_IS, comparisonOperation, \n                formula1, formula2, formula3);\n    }
883	public void doCopy() {\n        Clipboard systemClipboard\n                = Toolkit.getDefaultToolkit().getSystemClipboard();\n        Insets insets = getInsets();\n        int w = getWidth() - insets.left - insets.right;\n        int h = getHeight() - insets.top - insets.bottom;\n        ChartTransferable selection = new ChartTransferable(this.chart, w, h,\n                getMinimumDrawWidth(), getMinimumDrawHeight(),\n                getMaximumDrawWidth(), getMaximumDrawHeight(), true);\n        systemClipboard.setContents(selection, null);\n    }
884	public void construct(CellValueRecordInterface rec, RecordStream rs, SharedValueManager sfh) {\n		if (rec instanceof FormulaRecord) {\n			FormulaRecord formulaRec = (FormulaRecord)rec;\n						StringRecord cachedText;\n			Class<? extends Record> nextClass = rs.peekNextClass();\n			if (nextClass == StringRecord.class) {\n				cachedText = (StringRecord) rs.getNext();\n			} else {\n				cachedText = null;\n			}\n			insertCell(new FormulaRecordAggregate(formulaRec, cachedText, sfh));\n		} else {\n			insertCell(rec);\n		}\n	}
885	public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n            IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new MultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new MultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }
886	protected boolean processSheet( HSSFWorkbook workbook, int sheetIndex )\n    {\n        String pageMasterName = "sheet-" + sheetIndex;\n\n        Element pageSequence = foDocumentFacade\n                .createPageSequence( pageMasterName );\n        Element flow = foDocumentFacade.addFlowToPageSequence( pageSequence,\n                "xsl-region-body" );\n\n        HSSFSheet sheet = workbook.getSheetAt( sheetIndex );\n        float tableWidthIn = processSheet( workbook, sheet, flow );\n\n        if ( tableWidthIn == 0 )\n            return false;\n\n        createPageMaster( tableWidthIn, pageMasterName );\n        foDocumentFacade.addPageSequence( pageSequence );\n        return true;\n    }
887	public XDDFTextRun appendField(String id, String type, String text) {\n        CTTextField f = _p.addNewFld();\n        f.setId(id);\n        f.setType(type);\n        f.setT(text);\n        CTTextCharacterProperties rPr = f.addNewRPr();\n        rPr.setLang(LocaleUtil.getUserLocale().toLanguageTag());\n        XDDFTextRun run = new XDDFTextRun(f, this);\n        _runs.add(run);\n        return run;\n    }
888	private void expandDelimiterData() {\n    int i;\n    int cnt;\n            int delimiterIndex = 3755 + GB2312_FIRST_CHAR;\n    i = 0;\n    while (i < wordItem_charArrayTable[delimiterIndex].length) {\n      char c = wordItem_charArrayTable[delimiterIndex][i][0];\n      int j = getGB2312Id(c);      if (wordItem_charArrayTable[j] == null) {\n\n        int k = i;\n                while (k < wordItem_charArrayTable[delimiterIndex].length\n            && wordItem_charArrayTable[delimiterIndex][k][0] == c) {\n          k++;\n        }\n                        cnt = k - i;\n        if (cnt != 0) {\n          wordItem_charArrayTable[j] = new char[cnt][];\n          wordItem_frequencyTable[j] = new int[cnt];\n        }\n\n                for (k = 0; k < cnt; k++, i++) {\n                    wordItem_frequencyTable[j][k] = wordItem_frequencyTable[delimiterIndex][i];\n          wordItem_charArrayTable[j][k] = new char[wordItem_charArrayTable[delimiterIndex][i].length - 1];\n          System.arraycopy(wordItem_charArrayTable[delimiterIndex][i], 1,\n              wordItem_charArrayTable[j][k], 0,\n              wordItem_charArrayTable[j][k].length);\n        }\n        setTableIndex(c, j);\n      }\n    }\n        wordItem_charArrayTable[delimiterIndex] = null;\n    wordItem_frequencyTable[delimiterIndex] = null;\n  }
889	@Internal\n    public XWPFFootnote addFootnote(CTFtnEdn note) {\n        CTFtnEdn newNote = ctFootnotes.addNewFootnote();\n        newNote.set(note);\n        XWPFFootnote xNote = new XWPFFootnote(newNote, this);\n        listFootnote.add(xNote);\n        return xNote;\n    }
890	private int allocSlice(final int[] slice, final int sliceOffset) {\n    final int level = slice[sliceOffset];\n    final int newLevel = NEXT_LEVEL_ARRAY[level-1];\n    final int newSize = LEVEL_SIZE_ARRAY[newLevel];\n        if (intUpto > INT_BLOCK_SIZE-newSize) {\n      nextBuffer();\n      assert assertSliceBuffer(buffer);\n    }\n\n    final int newUpto = intUpto;\n    final int offset = newUpto + intOffset;\n    intUpto += newSize;\n        slice[sliceOffset] = offset;\n        \n        buffer[intUpto-1] = newLevel;\n\n    return newUpto;\n  }
891	public String getText() {\n        DataFormatter formatter;\n        if(locale == null) {\n            formatter = new DataFormatter();\n        } else  {\n            formatter = new DataFormatter(locale);\n        }\n\n        StringBuilder text = new StringBuilder(64);\n        for(Sheet sh : workbook) {\n            XSSFSheet sheet = (XSSFSheet) sh;\n            if(includeSheetNames) {\n                text.append(sheet.getSheetName()).append("\n");\n            }\n\n                        if(includeHeadersFooters) {\n                text.append(\n                        extractHeaderFooter(sheet.getFirstHeader())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getOddHeader())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getEvenHeader())\n                        );\n            }\n\n                        for (Object rawR : sheet) {\n                Row row = (Row)rawR;\n                for(Iterator<Cell> ri = row.cellIterator(); ri.hasNext();) {\n                    Cell cell = ri.next();\n\n                                        if(cell.getCellType() == CellType.FORMULA) {\n                        if (formulasNotResults) {\n                            String contents = cell.getCellFormula();\n                            checkMaxTextSize(text, contents);\n                            text.append(contents);\n                        } else {\n                            if (cell.getCachedFormulaResultType() == CellType.STRING) {\n                                handleStringCell(text, cell);\n                            } else {\n                                handleNonStringCell(text, cell, formatter);\n                            }\n                        }\n                    } else if(cell.getCellType() == CellType.STRING) {\n                        handleStringCell(text, cell);\n                    } else {\n                        handleNonStringCell(text, cell, formatter);\n                    }\n\n                                        Comment comment = cell.getCellComment();\n                    if(includeCellComments && comment != null) {\n                                                                        String commentText = comment.getString().getString().replace('\n', ' ');\n                        checkMaxTextSize(text, commentText);\n                        text.append(" Comment by ").append(comment.getAuthor()).append(": ").append(commentText);\n                    }\n\n                    if(ri.hasNext()) {\n                        text.append("\t");\n                    }\n                }\n                text.append("\n");\n            }\n            \n                        if (includeTextBoxes){\n                XSSFDrawing drawing = sheet.getDrawingPatriarch();\n                if (drawing != null) {\n                    for (XSSFShape shape : drawing.getShapes()){\n                        if (shape instanceof XSSFSimpleShape){\n                            String boxText = ((XSSFSimpleShape)shape).getText();\n                            if (boxText.length() > 0){\n                                text.append(boxText);\n                                text.append('\n');\n                            }\n                        }\n                    }\n                }\n            }\n                        if(includeHeadersFooters) {\n                text.append(\n                        extractHeaderFooter(sheet.getFirstFooter())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getOddFooter())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getEvenFooter())\n                        );\n            }\n        }\n\n        return text.toString();\n    }
892	protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double width = constraint.getWidth() / this.columns;\n        double height = constraint.getHeight() / this.rows;\n        List blocks = container.getBlocks();\n        for (int c = 0; c < this.columns; c++) {\n            for (int r = 0; r < this.rows; r++) {\n                int index = r * this.columns + c;\n                if (index >= blocks.size()) {\n                    break;\n                }\n                Block b = (Block) blocks.get(index);\n                if (b != null) {\n                    b.setBounds(new Rectangle2D.Double(c * width, r * height,\n                            width, height));\n                }\n            }\n        }\n        return new Size2D(this.columns * width, this.rows * height);\n    }
893	public Sheet build() {\n        Sheet sheet = (sheetName == null) ? workbook.createSheet() : workbook.createSheet(sheetName);\n        Row currentRow;\n        Cell currentCell;\n\n        for (int rowIndex = 0; rowIndex < cells.length; ++rowIndex) {\n            Object[] rowArray = cells[rowIndex];\n            currentRow = sheet.createRow(rowIndex);\n\n            for (int cellIndex = 0; cellIndex < rowArray.length; ++cellIndex) {\n                Object cellValue = rowArray[cellIndex];\n                if (cellValue != null || shouldCreateEmptyCells) {\n                    currentCell = currentRow.createCell(cellIndex);\n                    setCellValue(currentCell, cellValue);\n                }\n            }\n        }\n        return sheet;\n    }
894	private boolean initComplex() throws IOException {\n        placeFirstPositions();\n    if (!advanceRepeatGroups()) {\n      return false;     }\n    fillQueue();\n    return true;   }
895	private static void checkTermRanges(String field, int maxDoc, Terms terms, long numTerms) throws IOException {\n\n        double currentInterval = numTerms;\n\n    FixedBitSet normalDocs = new FixedBitSet(maxDoc);\n    FixedBitSet intersectDocs = new FixedBitSet(maxDoc);\n\n    \n    while (currentInterval >= 10.0) {\n      \n            TermsEnum termsEnum = terms.iterator();\n\n      long termCount = 0;\n\n      Deque<BytesRef> termBounds = new LinkedList<>();\n\n      long lastTermAdded = Long.MIN_VALUE;\n\n      BytesRefBuilder lastTerm = null;\n\n      while (true) {\n        BytesRef term = termsEnum.next();\n        if (term == null) {\n          break;\n        }\n                if (termCount >= lastTermAdded + currentInterval/4) {\n          termBounds.add(BytesRef.deepCopyOf(term));\n          lastTermAdded = termCount;\n          if (termBounds.size() == 5) {\n            BytesRef minTerm = termBounds.removeFirst();\n            BytesRef maxTerm = termBounds.getLast();\n            checkSingleTermRange(field, maxDoc, terms, minTerm, maxTerm, normalDocs, intersectDocs);\n          }\n        }\n        termCount++;\n\n        if (lastTerm == null) {\n          lastTerm = new BytesRefBuilder();\n          lastTerm.copyBytes(term);\n        } else {\n          if (lastTerm.get().compareTo(term) >= 0) {\n            throw new RuntimeException("terms out of order: lastTerm=" + lastTerm.get() + " term=" + term);\n          }\n          lastTerm.copyBytes(term);\n        }\n      }\n      \n      if (lastTerm != null && termBounds.isEmpty() == false) {\n        BytesRef minTerm = termBounds.removeFirst();\n        BytesRef maxTerm = lastTerm.get();\n        checkSingleTermRange(field, maxDoc, terms, minTerm, maxTerm, normalDocs, intersectDocs);\n      }\n\n      currentInterval *= .75;\n    }\n  }
896	private void bufferWordParts() throws IOException {\n\n    saveState();\n\n            hasIllegalOffsets = (savedEndOffset - savedStartOffset != savedTermLength);\n\n    bufferedLen = 0;\n    lastConcatCount = 0;\n    wordPos = 0;\n\n    if (iterator.isSingleWord()) {\n      buffer(wordPos, wordPos+1, iterator.current, iterator.end);\n      wordPos++;\n      iterator.next();\n    } else {\n\n            while (iterator.end != WordDelimiterIterator.DONE) {\n        int wordType = iterator.type();\n      \n                if (concat.isNotEmpty() && (concat.type & wordType) == 0) {\n          flushConcatenation(concat);\n        }\n\n                if (shouldConcatenate(wordType)) {\n          concatenate(concat);\n        }\n      \n                if (has(CATENATE_ALL)) {\n          concatenate(concatAll);\n        }\n      \n                if (shouldGenerateParts(wordType)) {\n          buffer(wordPos, wordPos+1, iterator.current, iterator.end);\n          wordPos++;\n        }\n        iterator.next();\n      }\n\n      if (concat.isNotEmpty()) {\n                flushConcatenation(concat);\n      }\n        \n      if (concatAll.isNotEmpty()) {\n                if (concatAll.subwordCount > lastConcatCount) {\n          if (wordPos == concatAll.startPos) {\n                        wordPos++;\n          }\n          concatAll.write();\n        }\n        concatAll.clear();\n      }\n    }\n\n    if (has(PRESERVE_ORIGINAL)) {\n      if (wordPos == 0) {\n                wordPos++;\n      }\n            buffer(0, wordPos, 0, savedTermLength);\n    }\n            \n    sorter.sort(0, bufferedLen);\n    wordPos = 0;\n\n        bufferedPos = 0;\n  }
897	public static Automaton build(Collection<BytesRef> input) {\n    final DaciukMihovAutomatonBuilder builder = new DaciukMihovAutomatonBuilder();\n    \n    char[] chars = new char[0];\n    CharsRef ref = new CharsRef();\n    for (BytesRef b : input) {\n      chars = ArrayUtil.grow(chars, b.length);\n      final int len = UnicodeUtil.UTF8toUTF16(b, chars);\n      ref.chars = chars;\n      ref.length = len;\n      builder.add(ref);\n    }\n    \n    Automaton.Builder a = new Automaton.Builder();\n    convert(a,\n        builder.complete(), \n        new IdentityHashMap<State,Integer>());\n\n    return a.finish();\n  }
898	public static void dump(final byte [] data, final long offset,\n        final OutputStream stream, final int index, final int length)\n    throws IOException, ArrayIndexOutOfBoundsException, IllegalArgumentException {\n        if (stream == null) {\n            throw new IllegalArgumentException("cannot write to nullstream");\n        }\n\n        OutputStreamWriter osw = new OutputStreamWriter(stream, UTF8);\n        osw.write(dump(data, offset, index, length));\n        osw.flush();\n    }
899	public String generateLabelString(XYDataset dataset, int series, int item) {\n        String result;\n        Object[] items = createItemArray(dataset, series, item);\n        result = MessageFormat.format(this.formatString, items);\n        return result;\n    }
900	public static int strcmp(char[] a, int startA, char[] b, int startB) {\n    for (; a[startA] == b[startB]; startA++, startB++) {\n      if (a[startA] == 0) {\n        return 0;\n      }\n    }\n    return a[startA] - b[startB];\n  }
901	public String normalizeNumber(String number) {\n    try {\n      BigDecimal normalizedNumber = parseNumber(new NumberBuffer(number));\n      if (normalizedNumber == null) {\n        return number;\n      }\n      return normalizedNumber.stripTrailingZeros().toPlainString();\n    } catch (NumberFormatException | ArithmeticException e) {\n            return number;\n    }\n  }
902	protected String longestOp(Iterable<TaskStats> taskStats) {\n    String longest = OP;\n    for (final TaskStats stat : taskStats) {\n      if (stat.getElapsed()>=0) {         String name = stat.getTask().getName();\n        if (name.length() > longest.length()) {\n          longest = name;\n        }\n      }\n    }\n    return longest;\n  }
903	void clearButKeepProperties() {\n        CTTextParagraph thisP = getXmlObject();\n        for (int i=thisP.sizeOfBrArray(); i>0; i--) {\n            thisP.removeBr(i-1);\n        }\n        for (int i=thisP.sizeOfFldArray(); i>0; i--) {\n            thisP.removeFld(i-1);\n        }\n        if (!_runs.isEmpty()) {\n            int size = _runs.size();\n            XSLFTextRun lastRun = _runs.get(size-1);\n            CTTextCharacterProperties cpOther = lastRun.getRPr(false);\n            if (cpOther != null) {\n                if (thisP.isSetEndParaRPr()) {\n                    thisP.unsetEndParaRPr();\n                }\n                CTTextCharacterProperties cp = thisP.addNewEndParaRPr();\n                cp.set(cpOther);\n            }\n            for (int i=size; i>0; i--) {\n                thisP.removeR(i-1);\n            }\n            _runs.clear();\n        }\n    }
904	private static DefaultRowHeightRecord createDefaultRowHeight() {\n        DefaultRowHeightRecord retval = new DefaultRowHeightRecord();\n\n        retval.setOptionFlags(( short ) 0);\n        retval.setRowHeight(DefaultRowHeightRecord.DEFAULT_ROW_HEIGHT);\n        return retval;\n    }
905	public void setObject(Comparable key, Object object) {\n        int keyIndex = getIndex(key);\n        if (keyIndex >= 0) {\n            KeyedObject ko = (KeyedObject) this.data.get(keyIndex);\n            ko.setObject(object);\n        }\n        else {\n            KeyedObject ko = new KeyedObject(key, object);\n            this.data.add(ko);\n        }\n    }
906	char caseFold(char c) {\n    if (alternateCasing) {\n      if (c == 'I') {\n        return 'ı';\n      } else if (c == 'İ') {\n        return 'i';\n      } else {\n        return Character.toLowerCase(c);\n      }\n    } else {\n      return Character.toLowerCase(c);\n    }\n  }
907	public XSSFTableColumn createColumn(String columnName, int columnIndex) {\n                \n        int columnCount = getColumnCount();\n        if(columnIndex < 0 || columnIndex > columnCount) {\n            throw new IllegalArgumentException("Column index out of bounds");\n        }\n        \n                CTTableColumns columns = ctTable.getTableColumns();\n        if (columns == null) {\n            columns = ctTable.addNewTableColumns();\n        }\n        \n                long nextColumnId = 1; \n        for (XSSFTableColumn tableColumn : getColumns()) {\n            if (columnName != null && columnName.equalsIgnoreCase(tableColumn.getName())) {\n                throw new IllegalArgumentException("Column '" + columnName\n                        + "' already exists. Column names must be unique per table.");\n            }\n            nextColumnId = Math.max(nextColumnId, tableColumn.getId());\n        }\n        \n                CTTableColumn column = columns.insertNewTableColumn(columnIndex);\n        columns.setCount(columns.sizeOfTableColumnArray());\n        \n        column.setId(nextColumnId);\n        if(columnName != null) {\n            column.setName(columnName); \n        } else {\n            column.setName("Column " + nextColumnId);\n        }\n        \n        if (ctTable.getRef() != null) {\n                        int newColumnCount = columnCount + 1;\n            CellReference tableStart = getStartCellReference();\n            CellReference tableEnd = getEndCellReference();\n            SpreadsheetVersion version = getXSSFSheet().getWorkbook().getSpreadsheetVersion();\n            CellReference newTableEnd = new CellReference(tableEnd.getRow(),\n                    tableStart.getCol() + newColumnCount - 1);\n            AreaReference newTableArea = new AreaReference(tableStart, newTableEnd, version);\n\n            setCellRef(newTableArea);\n        }\n        \n        updateHeaders();\n        \n        return getColumns().get(columnIndex);\n    }
908	public List<Picture> getAllPictures() {\n    ArrayList<Picture> pictures = new ArrayList<>();\n\n    Range range = _document.getOverallRange();\n    for (int i = 0; i < range.numCharacterRuns(); i++) {\n    	CharacterRun run = range.getCharacterRun(i);\n\n        if (run==null) {\n            continue;\n        }\n\n    	Picture picture = extractPicture(run, false);\n    	if (picture != null) {\n    		pictures.add(picture);\n    	}\n	}\n\n    searchForPictures(_dgg.getEscherRecords(), pictures);\n\n    return pictures;\n  }
909	private ParseNode getFunction(String name, Ptg namePtg, ParseNode[] args) {\n\n        FunctionMetadata fm = FunctionMetadataRegistry.getFunctionByName(name.toUpperCase(Locale.ROOT));\n        int numArgs = args.length;\n        if(fm == null) {\n            if (namePtg == null) {\n                throw new IllegalStateException("NamePtg must be supplied for external functions");\n            }\n                        ParseNode[] allArgs = new ParseNode[numArgs+1];\n            allArgs[0] = new ParseNode(namePtg);\n            System.arraycopy(args, 0, allArgs, 1, numArgs);\n            return new ParseNode(FuncVarPtg.create(name, numArgs+1), allArgs);\n        }\n\n        if (namePtg != null) {\n            throw new IllegalStateException("NamePtg no applicable to internal functions");\n        }\n        boolean isVarArgs = !fm.hasFixedArgsLength();\n        int funcIx = fm.getIndex();\n        if (funcIx == FunctionMetadataRegistry.FUNCTION_INDEX_SUM && args.length == 1) {\n                                    return new ParseNode(AttrPtg.getSumSingle(), args);\n                    }\n        validateNumArgs(args.length, fm);\n\n        AbstractFunctionPtg retval;\n        if(isVarArgs) {\n            retval = FuncVarPtg.create(name, numArgs);\n        } else {\n            retval = FuncPtg.create(funcIx);\n        }\n        return new ParseNode(retval, args);\n    }
910	protected void drawArcForInterval(Graphics2D g2, Rectangle2D meterArea,\n                                      MeterInterval interval) {\n\n        double minValue = interval.getRange().getLowerBound();\n        double maxValue = interval.getRange().getUpperBound();\n        Paint outlinePaint = interval.getOutlinePaint();\n        Stroke outlineStroke = interval.getOutlineStroke();\n        Paint backgroundPaint = interval.getBackgroundPaint();\n\n        if (backgroundPaint != null) {\n            fillArc(g2, meterArea, minValue, maxValue, backgroundPaint, false);\n        }\n        if (outlinePaint != null) {\n            if (outlineStroke != null) {\n                drawArc(g2, meterArea, minValue, maxValue, outlinePaint,\n                        outlineStroke);\n            }\n            drawTick(g2, meterArea, minValue, true);\n            drawTick(g2, meterArea, maxValue, true);\n        }\n    }
911	private static int performBinarySearch(ValueVector vector, LookupValueComparer lookupComparer) {\n				BinarySearchIndexes bsi = new BinarySearchIndexes(vector.getSize());\n\n		while(true) {\n			int midIx = bsi.getMidIx();\n\n			if(midIx < 0) {\n				return bsi.getLowIx();\n			}\n			CompareResult cr = lookupComparer.compareTo(vector.getItem(midIx));\n			if(cr.isTypeMismatch()) {\n				int newMidIx = handleMidValueTypeMismatch(lookupComparer, vector, bsi, midIx);\n				if(newMidIx < 0) {\n					continue;\n				}\n				midIx = newMidIx;\n				cr = lookupComparer.compareTo(vector.getItem(midIx));\n			}\n			if(cr.isEqual()) {\n				return findLastIndexInRunOfEqualValues(lookupComparer, vector, midIx, bsi.getHighIx());\n			}\n			bsi.narrowSearch(midIx, cr.isLessThan());\n		}\n	}
912	@Internal\n    public CTComment newComment(CellAddress ref) {\n        CTComment ct = comments.getCommentList().addNewComment();\n        ct.setRef(ref.formatAsString());\n        ct.setAuthorId(DEFAULT_AUTHOR_ID);\n        \n        if(commentRefs != null) {\n           commentRefs.put(ref, ct);\n        }\n        return ct;\n    }
913	private static String processFormatPattern(String f) {\n        String t = f.replaceAll("MMMMM", MMMMM_START_SYMBOL + "MMM" + MMMMM_TRUNCATE_SYMBOL);\n        t = t.replaceAll("\\[H]", String.valueOf(H_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[HH]", String.valueOf(HH_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[m]", String.valueOf(M_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[mm]", String.valueOf(MM_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[s]", String.valueOf(S_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[ss]", String.valueOf(SS_BRACKET_SYMBOL));\n        t = t.replaceAll("s.000", "s.SSS");\n        t = t.replaceAll("s.00", "s." + LL_BRACKET_SYMBOL);\n        t = t.replaceAll("s.0", "s." + L_BRACKET_SYMBOL);\n        return t;\n    }
914	private void createCT( String term ) {\n    CT = changeTerm(term) ;\n\n    if (CT.length() < 2) return ;\n\n        if ((CT.charAt(0) == '"')  ||\n        (CT.charAt(0) == '\'') ||\n        (CT.charAt(0) == '-')  ||\n        (CT.charAt(0) == ',')  ||\n        (CT.charAt(0) == ';')  ||\n        (CT.charAt(0) == '.')  ||\n        (CT.charAt(0) == '?')  ||\n        (CT.charAt(0) == '!')\n        ) {\n        CT = CT.substring(1);\n    }\n\n    if (CT.length() < 2) return ;\n\n    // if the last character is ... , remove it\n    if ((CT.charAt(CT.length()-1) == '-') ||\n        (CT.charAt(CT.length()-1) == ',') ||\n        (CT.charAt(CT.length()-1) == ';') ||\n        (CT.charAt(CT.length()-1) == '.') ||\n        (CT.charAt(CT.length()-1) == '?') ||\n        (CT.charAt(CT.length()-1) == '!') ||\n        (CT.charAt(CT.length()-1) == '\'') ||\n        (CT.charAt(CT.length()-1) == '"')\n        ) {\n        CT = CT.substring(0,CT.length()-1);\n    }\n  }
915	public static PackagePartName createPartName(String partName)\n			throws InvalidFormatException {\n		URI partNameURI;\n		try {\n			partNameURI = toURI(partName);\n		} catch (URISyntaxException e) {\n			throw new InvalidFormatException(e.getMessage());\n		}\n		return createPartName(partNameURI);\n	}
916	@Beta\n    public void addRowLabel(int columnIndex) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        final int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_ROW);\n        pivotField.setShowAll(false);\n        for (int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTRowFields rowFields;\n        if(pivotTableDefinition.getRowFields() != null) {\n            rowFields = pivotTableDefinition.getRowFields();\n        } else {\n            rowFields = pivotTableDefinition.addNewRowFields();\n        }\n\n        rowFields.addNewField().setX(columnIndex);\n        rowFields.setCount(rowFields.sizeOfFieldArray());\n    }
917	public Pointer createPointer(byte[] data, int offset) {\n        Pointer p;\n        if(version >= 6) {\n            p = new PointerV6();\n            p.setType(LittleEndian.getInt(data, offset+0));\n            p.setAddress((int)LittleEndian.getUInt(data, offset+4));\n            p.setOffset((int)LittleEndian.getUInt(data, offset+8));\n            p.setLength((int)LittleEndian.getUInt(data, offset+12));\n            p.setFormat(LittleEndian.getShort(data, offset+16));\n\n            return p;\n        } else if(version == 5) {\n            p = new PointerV5();\n            p.setType(LittleEndian.getShort(data, offset+0));\n            p.setFormat(LittleEndian.getShort(data, offset+2));\n            p.setAddress((int)LittleEndian.getUInt(data, offset+4));\n            p.setOffset((int)LittleEndian.getUInt(data, offset+8));\n            p.setLength((int)LittleEndian.getUInt(data, offset+12));\n\n            return p;\n        } else {\n            throw new IllegalArgumentException("Visio files with versions below 5 are not supported, yours was " + version);\n        }\n    }
918	public Calendar toCalendar(UnitNRShape lv) {\n    if (lv.getLevel() == 0)\n      return newCal();\n    if (comparePrefix(lv, minLV) <= 0) {      return (Calendar) MINCAL.clone();    }\n    assert comparePrefix(lv, maxLV) <= 0;\n    Calendar cal = newCal();\n\n    int yearAdj = lv.getValAtLevel(1) * 1_000_000;\n    if (lv.getLevel() > 1) {\n      yearAdj += lv.getValAtLevel(2) * 1000;\n      if (lv.getLevel() > 2) {\n        yearAdj += lv.getValAtLevel(3);\n      }\n    }\n    if (yearAdj > AD_YEAR_BASE) {\n      cal.set(Calendar.ERA, 1);\n      cal.set(Calendar.YEAR, yearAdj - AD_YEAR_BASE);    } else {\n      cal.set(Calendar.ERA, 0);      cal.set(Calendar.YEAR, (AD_YEAR_BASE - yearAdj) + 1);\n    }\n    for (int level = YEAR_LEVEL + 1; level <= lv.getLevel(); level++) {\n      int field = FIELD_BY_LEVEL[level];\n      cal.set(field, lv.getValAtLevel(level) + cal.getActualMinimum(field));\n    }\n    assert yearAdj > AD_YEAR_BASE || ((Calendar)cal.clone()).get(Calendar.ERA) == 0 : "ERA / YEAR underflow";\n    return cal;\n  }
919	private boolean isBeforeDot(char s[], int pos, int len) {\n    for (int i = pos; i < len;) {\n      final int ch = Character.codePointAt(s, i, len);\n      if (Character.getType(ch) != Character.NON_SPACING_MARK)\n        return false;\n      if (ch == COMBINING_DOT_ABOVE)\n        return true;\n      i += Character.charCount(ch);\n    }\n    \n    return false;\n  }
920	private Set<ValueAndFormat> getMeaningfulValues(CellRangeAddress region, boolean withText, ValueFunction func) {\n        Set<ValueAndFormat> values = meaningfulRegionValues.get(region);\n        if (values != null) {\n            return values;\n        }\n        \n        List<ValueAndFormat> allValues = new ArrayList<>((region.getLastColumn() - region.getFirstColumn() + 1) * (region.getLastRow() - region.getFirstRow() + 1));\n        \n        for (int r=region.getFirstRow(); r <= region.getLastRow(); r++) {\n            final Row row = sheet.getRow(r);\n            if (row == null) {\n                continue;\n            }\n            for (int c = region.getFirstColumn(); c <= region.getLastColumn(); c++) {\n                Cell cell = row.getCell(c);\n                final ValueAndFormat cv = getCellValue(cell);\n                if (withText || cv.isNumber()) {\n                    allValues.add(cv);\n                }\n            }\n        }\n        \n        values = func.evaluate(allValues);\n        meaningfulRegionValues.put(region, values);\n        \n        return values;\n    }
921	public CFRecordsAggregate cloneCFAggregate() {\n        CFRuleBase[] newRecs = new CFRuleBase[rules.size()];\n        for (int i = 0; i < newRecs.length; i++) {\n            newRecs[i] = getRule(i).clone();\n        }\n        return new CFRecordsAggregate(header.clone(), newRecs);\n    }
922	void writeBytes(long dest, byte[] b, int offset, int len) {\n        assert dest + len <= getPosition(): "dest=" + dest + " pos=" + getPosition() + " len=" + len;\n\n                \n    "    cycle chunk="" len="\n\n    final long end = dest + len;\n    int blockIndex = (int) (end >> blockBits);\n    int downTo = (int) (end & blockMask);\n    if (downTo == 0) {\n      blockIndex--;\n      downTo = blockSize;\n    }\n    byte[] block = blocks.get(blockIndex);\n\n    while (len > 0) {\n            if (len <= downTo) {\n                System.arraycopy(b, offset, block, downTo-len, len);\n        break;\n      } else {\n        len -= downTo;\n                System.arraycopy(b, offset + len, block, 0, downTo);\n        blockIndex--;\n        block = blocks.get(blockIndex);\n        downTo = blockSize;\n      }\n    }\n  }
923	public PackageRelationship addRelationship(URI targetUri,\n            TargetMode targetMode, String relationshipType, String id) {\n      if (id == null) {\n                  if (nextRelationshipId == -1) {\n            nextRelationshipId = size() + 1;\n         }\n\n                  do {\n            id = "rId" + nextRelationshipId++;\n         } while (relationshipsByID.get(id) != null);\n      }\n\n        PackageRelationship rel = new PackageRelationship(container,\n                sourcePart, targetUri, targetMode, relationshipType, id);\n        addRelationship(rel);\n        if (targetMode == TargetMode.INTERNAL){\n            internalRelationshipsByTargetName.put(targetUri.toASCIIString(), rel);\n        }\n        return rel;\n    }
924	protected static OPCPackage newPackage() {\n        try {\n            OPCPackage pkg = OPCPackage.create(new ByteArrayOutputStream());                            PackagePartName corePartName = PackagingURIHelper.createPartName(XWPFRelation.DOCUMENT.getDefaultFileName());\n                        pkg.addRelationship(corePartName, TargetMode.INTERNAL, PackageRelationshipTypes.CORE_DOCUMENT);\n                        pkg.createPart(corePartName, XWPFRelation.DOCUMENT.getContentType());\n\n            pkg.getPackageProperties().setCreatorProperty(DOCUMENT_CREATOR);\n\n            return pkg;\n        } catch (Exception e) {\n            throw new POIXMLException(e);\n        }\n    }
925	public void clearStyles() {\n        paragraphStyles.clear();\n        charStyles.clear();\n        reserved = new byte[0];\n        initialised = true;\n    }
926	public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor,\n             ChartRenderingInfo info) {\n\n        notifyListeners(new ChartProgressEvent(this, this,\n                ChartProgressEvent.DRAWING_STARTED, 0));\n        \n        EntityCollection entities = null;\n                if (info != null) {\n            info.clear();\n            info.setChartArea(chartArea);\n            entities = info.getEntityCollection();\n        }\n        if (entities != null) {\n            entities.add(new JFreeChartEntity((Rectangle2D) chartArea.clone(),\n                    this));\n        }\n\n                Shape savedClip = g2.getClip();\n        g2.clip(chartArea);\n\n        g2.addRenderingHints(this.renderingHints);\n\n                if (this.backgroundPaint != null) {\n            g2.setPaint(this.backgroundPaint);\n            g2.fill(chartArea);\n        }\n\n        if (this.backgroundImage != null) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    this.backgroundImageAlpha));\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0,\n                    this.backgroundImage.getWidth(null),\n                    this.backgroundImage.getHeight(null));\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\n            g2.drawImage(this.backgroundImage, (int) dest.getX(),\n                    (int) dest.getY(), (int) dest.getWidth(),\n                    (int) dest.getHeight(), null);\n            g2.setComposite(originalComposite);\n        }\n\n        if (isBorderVisible()) {\n            Paint paint = getBorderPaint();\n            Stroke stroke = getBorderStroke();\n            if (paint != null && stroke != null) {\n                Rectangle2D borderArea = new Rectangle2D.Double(\n                        chartArea.getX(), chartArea.getY(),\n                        chartArea.getWidth() - 1.0, chartArea.getHeight()\n                        - 1.0);\n                g2.setPaint(paint);\n                g2.setStroke(stroke);\n                g2.draw(borderArea);\n            }\n        }\n\n                Rectangle2D nonTitleArea = new Rectangle2D.Double();\n        nonTitleArea.setRect(chartArea);\n        this.padding.trim(nonTitleArea);\n\n        if (this.title != null && this.title.isVisible()) {\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea,\n                    (entities != null));\n            if (e != null && entities != null) {\n                entities.addAll(e);\n            }\n        }\n\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title currentTitle = (Title) iterator.next();\n            if (currentTitle.isVisible()) {\n                EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea,\n                        (entities != null));\n                if (e != null && entities != null) {\n                    entities.addAll(e);\n                }\n            }\n        }\n\n        Rectangle2D plotArea = nonTitleArea;\n\n                PlotRenderingInfo plotInfo = null;\n        if (info != null) {\n            plotInfo = info.getPlotInfo();\n        }\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n\n        g2.setClip(savedClip);\n\n        notifyListeners(new ChartProgressEvent(this, this,\n                ChartProgressEvent.DRAWING_FINISHED, 100));\n    }
927	public void addSlideListWithText(SlideListWithText slwt) {\n						Record endDoc = _children[_children.length - 1];\n		if(endDoc.getRecordType() == RecordTypes.RoundTripCustomTableStyles12Atom.typeID) {\n		    		    endDoc = _children[_children.length - 2];\n		}\n		if(endDoc.getRecordType() != RecordTypes.EndDocument.typeID) {\n			throw new IllegalStateException("The last child record of a Document should be EndDocument, but it was " + endDoc);\n		}\n\n				addChildBefore(slwt, endDoc);\n\n				int newSize = slwts.length + 1;\n		SlideListWithText[] nl = new SlideListWithText[newSize];\n		System.arraycopy(slwts, 0, nl, 0, slwts.length);\n		nl[nl.length-1] = slwt;\n		slwts = nl;\n	}
928	private void convertToCSV() {\n        Sheet sheet;\n        Row row;\n        int lastRowNum;\n        this.csvData = new ArrayList<>();\n\n        System.out.println("Converting files contents to CSV format.");\n\n                int numSheets = this.workbook.getNumberOfSheets();\n\n                for(int i = 0; i < numSheets; i++) {\n\n                                    sheet = this.workbook.getSheetAt(i);\n            if(sheet.getPhysicalNumberOfRows() > 0) {\n\n                                                                                                                lastRowNum = sheet.getLastRowNum();\n                for(int j = 0; j <= lastRowNum; j++) {\n                    row = sheet.getRow(j);\n                    this.rowToCSV(row);\n                }\n            }\n        }\n    }
929	public static synchronized DocumentBuilder newDocumentBuilder() {\n        try {\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n            documentBuilder.setEntityResolver(SAXHelper.IGNORING_ENTITY_RESOLVER);\n            documentBuilder.setErrorHandler(new DocHelperErrorHandler());\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException("cannot create a DocumentBuilder", e);\n        }\n    }
930	protected static CTConnector prototype() {\n        if(prototype == null) {\n            CTConnector shape = CTConnector.Factory.newInstance();\n            CTConnectorNonVisual nv = shape.addNewNvCxnSpPr();\n            CTNonVisualDrawingProps nvp = nv.addNewCNvPr();\n            nvp.setId(1);\n            nvp.setName("Shape 1");\n            nv.addNewCNvCxnSpPr();\n\n            CTShapeProperties sp = shape.addNewSpPr();\n            CTTransform2D t2d = sp.addNewXfrm();\n            CTPositiveSize2D p1 = t2d.addNewExt();\n            p1.setCx(0);\n            p1.setCy(0);\n            CTPoint2D p2 = t2d.addNewOff();\n            p2.setX(0);\n            p2.setY(0);\n\n            CTPresetGeometry2D geom = sp.addNewPrstGeom();\n            geom.setPrst(STShapeType.LINE);\n            geom.addNewAvLst();\n\n            CTShapeStyle style = shape.addNewStyle();\n            CTSchemeColor scheme = style.addNewLnRef().addNewSchemeClr();\n            scheme.setVal(STSchemeColorVal.ACCENT_1);\n            style.getLnRef().setIdx(1);\n\n            CTStyleMatrixReference fillref = style.addNewFillRef();\n            fillref.setIdx(0);\n            fillref.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);\n\n            CTStyleMatrixReference effectRef = style.addNewEffectRef();\n            effectRef.setIdx(0);\n            effectRef.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);\n\n            CTFontReference fontRef = style.addNewFontRef();\n            fontRef.setIdx(STFontCollectionIndex.MINOR);\n            fontRef.addNewSchemeClr().setVal(STSchemeColorVal.TX_1);\n\n            prototype = shape;\n        }\n        return prototype;\n    }
931	static int[] buildTableCellEdgesArray( Table table )\n    {\n        Set<Integer> edges = new TreeSet<>();\n\n        for ( int r = 0; r < table.numRows(); r++ )\n        {\n            TableRow tableRow = table.getRow( r );\n            for ( int c = 0; c < tableRow.numCells(); c++ )\n            {\n                TableCell tableCell = tableRow.getCell( c );\n\n                edges.add( Integer.valueOf( tableCell.getLeftEdge() ) );\n                edges.add( Integer.valueOf( tableCell.getLeftEdge()\n                        + tableCell.getWidth() ) );\n            }\n        }\n\n        Integer[] sorted = edges.toArray( new Integer[edges.size()] );\n        int[] result = new int[sorted.length];\n        for ( int i = 0; i < sorted.length; i++ )\n        {\n            result[i] = sorted[i].intValue();\n        }\n\n        return result;\n    }
932	private Map<String, FileEntry> readEntries(byte[] segmentID, Directory dir, String entriesFileName) throws IOException {\n    Map<String,FileEntry> mapping = null;\n    try (ChecksumIndexInput entriesStream = dir.openChecksumInput(entriesFileName, IOContext.READONCE)) {\n      Throwable priorE = null;\n      try {\n        version = CodecUtil.checkIndexHeader(entriesStream, Lucene50CompoundFormat.ENTRY_CODEC, \n                                                              Lucene50CompoundFormat.VERSION_START, \n                                                              Lucene50CompoundFormat.VERSION_CURRENT, segmentID, "");\n        final int numEntries = entriesStream.readVInt();\n        mapping = new HashMap<>(numEntries);\n        for (int i = 0; i < numEntries; i++) {\n          final FileEntry fileEntry = new FileEntry();\n          final String id = entriesStream.readString();\n          FileEntry previous = mapping.put(id, fileEntry);\n          if (previous != null) {\n            throw new CorruptIndexException("Duplicate cfs entry id=" + id + " in CFS ", entriesStream);\n          }\n          fileEntry.offset = entriesStream.readLong();\n          fileEntry.length = entriesStream.readLong();\n        }\n      } catch (Throwable exception) {\n        priorE = exception;\n      } finally {\n        CodecUtil.checkFooter(entriesStream, priorE);\n      }\n    }\n    return Collections.unmodifiableMap(mapping);\n  }
933	private Query createQuery(PriorityQueue<ScoreTerm> q) {\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    ScoreTerm scoreTerm;\n    float bestScore = -1;\n\n    while ((scoreTerm = q.pop()) != null) {\n      Query tq = new TermQuery(new Term(scoreTerm.topField, scoreTerm.word));\n\n      if (boost) {\n        if (bestScore == -1) {\n          bestScore = (scoreTerm.score);\n        }\n        float myScore = (scoreTerm.score);\n        tq = new BoostQuery(tq, boostFactor * myScore / bestScore);\n      }\n\n      try {\n        query.add(tq, BooleanClause.Occur.SHOULD);\n      }\n      catch (BooleanQuery.TooManyClauses ignore) {\n        break;\n      }\n    }\n    return query.build();\n  }
934	@SuppressWarnings({"unused", "WeakerAccess"})\n    public static boolean isPropertySetStream(final byte[] src, final int offset, final int length) {\n        LittleEndianByteArrayInputStream leis = new LittleEndianByteArrayInputStream(src, offset, length);\n\n        \n        try {\n            final int byteOrder = leis.readUShort();\n            if (byteOrder != BYTE_ORDER_ASSERTION) {\n                return false;\n            }\n            final int format = leis.readUShort();\n            if (format != FORMAT_ASSERTION) {\n                return false;\n            }\n            final long osVersion = leis.readUInt();\n            byte[] clsBuf = new byte[ClassID.LENGTH];\n            leis.readFully(clsBuf);\n\n            final ClassID classID = new ClassID(clsBuf, 0);\n\n            final long sectionCount = leis.readUInt();\n            return (sectionCount >= 0);\n        } catch (RuntimeException e) {\n            return false;\n        }\n    }
935	private double recalculateInterval() {\n        double result = Double.POSITIVE_INFINITY;\n        int seriesCount = this.dataset.getSeriesCount();\n        for (int series = 0; series < seriesCount; series++) {\n            result = Math.min(result, calculateIntervalForSeries(series));\n        }\n        return result;\n    }
936	public void resize(Rectangle2D target, RectAlign align) {\n        PictureShape<?,?> ps = getShape();\n        Dimension dim = ps.getPictureData().getImageDimension();\n        if (dim.width <= 0 || dim.height <= 0) {\n                        ps.setAnchor(target);\n            return;\n        }\n\n        double w = target.getWidth();\n        double h = target.getHeight();\n\n                double sx = w / dim.width;\n        double sy = h / dim.height;\n\n                double dx = 0, dy = 0;\n\n        if (sx > sy) {\n                        w  = sy * dim.width;\n            dx = target.getWidth() - w;\n        } else if (sy > sx) {\n                        h  = sx * dim.height;\n            dy = target.getHeight() - h;\n        } else {\n                        ps.setAnchor(target);\n            return;\n        }\n\n                double x = target.getX();\n        double y = target.getY();\n        switch (align) {\n            case TOP:                           x += dx/2;\n                break;\n            case TOP_RIGHT:                     x += dx;\n                break;\n            case RIGHT:                         x += dx;\n                y += dy/2;\n                break;\n            case BOTTOM_RIGHT:                  x += dx;\n                y += dy;\n                break;\n            case BOTTOM:                        x += dx/2;\n                y += dy;\n                break;\n            case BOTTOM_LEFT:                   y += dy;\n                break;\n            case LEFT:                          y += dy/2;\n                break;\n            case TOP_LEFT:                      \n                break;\n            default:                            x += dx/2;\n                y += dy/2;\n                break;\n        }\n\n        ps.setAnchor(new Rectangle2D.Double(x, y, w, h));\n    }
937	private void outHex( int bytes, InputStream in, PrintStream out ) throws IOException, LittleEndian.BufferUnderrunException\n    {\n        switch ( bytes )\n        {\n            case 1:\n                out.print( HexDump.toHex( (byte) in.read() ) );\n                break;\n            case 2:\n                out.print( HexDump.toHex( LittleEndian.readShort( in ) ) );\n                break;\n            case 4:\n                out.print( HexDump.toHex( LittleEndian.readInt( in ) ) );\n                break;\n            default:\n                throw new IOException( "Unable to output variable of that width" );\n        }\n    }
938	private void writeAsPDF(File file, int w, int h) {\n        if (!isOrsonPDFAvailable()) {\n            throw new IllegalStateException(\n                    "OrsonPDF is not present on the classpath.");\n        }\n        ParamChecks.nullNotPermitted(file, "file");\n        try {\n            Class pdfDocClass = Class.forName("com.orsonpdf.PDFDocument");\n            Object pdfDoc = pdfDocClass.newInstance();\n            Method m = pdfDocClass.getMethod("createPage", Rectangle2D.class);\n            Rectangle2D rect = new Rectangle(w, h);\n            Object page = m.invoke(pdfDoc, rect);\n            Method m2 = page.getClass().getMethod("getGraphics2D");\n            Graphics2D g2 = (Graphics2D) m2.invoke(page);\n                                    g2.setRenderingHint(JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION, true);\n            Rectangle2D drawArea = new Rectangle2D.Double(0, 0, w, h);\n            this.chart.draw(g2, drawArea);\n            Method m3 = pdfDocClass.getMethod("writeToFile", File.class);\n            m3.invoke(pdfDoc, file);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(ex);\n        } catch (InstantiationException ex) {\n            throw new RuntimeException(ex);\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(ex);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            throw new RuntimeException(ex);\n        }\n    }
939	public static String getImageMap(String name, ChartRenderingInfo info,\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator) {\n\n        StringBuilder sb = new StringBuilder();\n        sb.append("<map id=\"").append(htmlEscape(name));\n        sb.append("\" name=\"").append(htmlEscape(name)).append("\">");\n        sb.append(StringUtils.getLineSeparator());\n        EntityCollection entities = info.getEntityCollection();\n        if (entities != null) {\n            int count = entities.getEntityCount();\n            for (int i = count - 1; i >= 0; i--) {\n                ChartEntity entity = entities.getEntity(i);\n                if (entity.getToolTipText() != null\n                        || entity.getURLText() != null) {\n                    String area = entity.getImageMapAreaTag(\n                            toolTipTagFragmentGenerator,\n                            urlTagFragmentGenerator);\n                    if (area.length() > 0) {\n                        sb.append(area);\n                        sb.append(StringUtils.getLineSeparator());\n                    }\n                }\n            }\n        }\n        sb.append("</map>");\n        return sb.toString();\n\n    }
940	public void ensureAtLeast(double space, RectangleEdge edge) {\n        if (edge == RectangleEdge.TOP) {\n            if (this.top < space) {\n                this.top = space;\n            }\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            if (this.bottom < space) {\n                this.bottom = space;\n            }\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            if (this.left < space) {\n                this.left = space;\n            }\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            if (this.right < space) {\n                this.right = space;\n            }\n        }\n        else {\n            throw new IllegalStateException(\n                "AxisSpace.ensureAtLeast(): unrecognised AxisLocation."\n            );\n        }\n    }
941	public static ValueEval getElementFromArray(AreaEval ae, EvaluationCell cell) {\n        CellRangeAddress range =  cell.getArrayFormulaRange();\n        int relativeRowIndex = cell.getRowIndex() - range.getFirstRow();\n        int relativeColIndex = cell.getColumnIndex() - range.getFirstColumn();\n                \n        if (ae.isColumn()) {\n            if (ae.isRow()) {\n                return ae.getRelativeValue(0, 0);\n            }\n            else if(relativeRowIndex < ae.getHeight()) {\n                return ae.getRelativeValue(relativeRowIndex, 0);\n            }\n        }\n        else if (!ae.isRow() && relativeRowIndex < ae.getHeight() && relativeColIndex < ae.getWidth()) {\n            return ae.getRelativeValue(relativeRowIndex, relativeColIndex);\n        }\n        else if (ae.isRow() && relativeColIndex < ae.getWidth()) {\n            return ae.getRelativeValue(0, relativeColIndex);\n        }\n        \n        return ErrorEval.NA;\n    }
942	protected double calculateTotalWidth(double contentWidth) {\n        double result = contentWidth;\n        result = this.padding.extendWidth(result);\n        result = this.frame.getInsets().extendWidth(result);\n        result = this.margin.extendWidth(result);\n        return result;\n    }
943	public void drawBackgroundImage(Graphics2D g2, Rectangle2D area) {\n        if (this.backgroundImage == null) {\n            return;          }\n        Composite savedComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                this.backgroundImageAlpha));\n        Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0,\n                this.backgroundImage.getWidth(null),\n                this.backgroundImage.getHeight(null));\n        Align.align(dest, area, this.backgroundImageAlignment);\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n        g2.drawImage(this.backgroundImage, (int) dest.getX(),\n                (int) dest.getY(), (int) dest.getWidth() + 1,\n                (int) dest.getHeight() + 1, null);\n        g2.setClip(savedClip);\n        g2.setComposite(savedComposite);\n    }
944	public String signDigest(final DOMSignContext xmlSignContext, final DOMSignedInfo signedInfo) {\n        final PrivateKey key = signatureConfig.getKey();\n        final HashAlgorithm algo = signatureConfig.getDigestAlgo();\n\n        if (algo.hashSize*4/3 > Base64.BASE64DEFAULTLENGTH && !XMLUtils.ignoreLineBreaks()) {\n            throw new EncryptedDocumentException("The hash size of the choosen hash algorithm ("+algo+" = "+algo.hashSize+" bytes), "+\n                "will motivate XmlSec to add linebreaks to the generated digest, which results in an invalid signature (... at least "+\n                "for Office) - please persuade it otherwise by adding '-Dorg.apache.xml.security.ignoreLineBreaks=true' to the JVM "+\n                "system properties.");\n        }\n        \n        try (final DigestOutputStream dos = getDigestStream(algo, key)) {\n            dos.init();\n\n            final Document document = (Document)xmlSignContext.getParent();\n            final Element el = getDsigElement(document, "SignedInfo");\n            final DOMSubTreeData subTree = new DOMSubTreeData(el, true);\n            signedInfo.getCanonicalizationMethod().transform(subTree, xmlSignContext, dos);\n\n            return DatatypeConverter.printBase64Binary(dos.sign());\n        } catch (GeneralSecurityException|IOException|TransformException e) {\n            throw new EncryptedDocumentException(e);\n        }\n    }
945	public void writeProtectWorkbook( String password, String username ) {\n        FileSharingRecord frec = getFileSharing();\n        WriteAccessRecord waccess = getWriteAccess();\n         getWriteProtect();\n        frec.setReadOnly((short)1);\n        frec.setPassword((short)CryptoFunctions.createXorVerifier1(password));\n        frec.setUsername(username);\n        waccess.setUsername(username);\n    }
946	private int appendBlock(RAMOutputStream writeBuffer, List<byte[]> blocks) throws IOException {\n    int pos = Math.toIntExact(writeBuffer.getFilePointer());\n    byte[] bytes = new byte[pos];\n    writeBuffer.writeTo(bytes, 0);\n    writeBuffer.reset();\n    blocks.add(bytes);\n    return pos;\n  }
947	static boolean tieBreakLessThan(ShardRef first, ScoreDoc firstDoc, ShardRef second, ScoreDoc secondDoc) {\n    final int firstShardIndex = first.getShardIndex(firstDoc);\n    final int secondShardIndex = second.getShardIndex(secondDoc);\n        if (firstShardIndex< secondShardIndex) {\n      return true;\n    } else if (firstShardIndex > secondShardIndex) {\n      return false;\n    } else {\n                  assert first.hitIndex != second.hitIndex;\n      return first.hitIndex < second.hitIndex;\n    }\n  }
948	public void unlink(SharedFormulaRecord sharedFormulaRecord) {\n		SharedFormulaGroup svg = _groupsBySharedFormulaRecord.remove(sharedFormulaRecord);\n		if (svg == null) {\n			throw new IllegalStateException("Failed to find formulas for shared formula");\n		}\n		_groupsCache = null; 		svg.unlinkSharedFormulas();\n	}
949	private static void setEdges(TableCell<?,?> cell, BorderEdge edges[], Object... args) {\n        if (cell == null) {\n            return;\n        }\n        for (BorderEdge be : edges) {\n            if (be != null) {\n                if (args.length == 0) {\n                    cell.removeBorder(be);\n                } else {\n                    for (Object o : args) {\n                        if (o instanceof Double) {\n                            cell.setBorderWidth(be, (Double)o);\n                        } else if (o instanceof Color) {\n                            cell.setBorderColor(be, (Color)o);\n                        } else if (o instanceof LineDash) {\n                            cell.setBorderDash(be, (LineDash)o);\n                        } else if (o instanceof LineCompound) {\n                            cell.setBorderCompound(be, (LineCompound)o);\n                        }\n                    }\n                }\n            }\n        }\n    }
950	protected final List<String> splitFileNames(String fileNames) {\n    if (fileNames == null)\n      return Collections.<String>emptyList();\n\n    List<String> result = new ArrayList<>();\n    for (String file : fileNames.split("(?<!\\\\),")) {\n      result.add(file.replaceAll("\\\\(?=,)", ""));\n    }\n\n    return result;\n  }
951	private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n                if (numDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n                                    long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    \n    RAMOutputStream writeBuffer = new RAMOutputStream();\n\n        List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numDims];\n        int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numDims], false);\n\n        byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }
952	private void parse() {\n        _pointer=0;\n        GetChar();\n        _rootNode = unionExpression();\n\n        if(_pointer <= _formulaLength) {\n            String msg = "Unused input [" + _formulaString.substring(_pointer-1)\n                + "] after attempting to parse the formula [" + _formulaString + "]";\n            throw new FormulaParseException(msg);\n        }\n    }
953	private String changeTerm( String value ) {\n    int     j;\n    String  r = "" ;\n\n        if (value == null) {\n      return null ;\n    }\n\n    value = value.toLowerCase(locale) ;\n    for (j=0 ; j < value.length() ; j++) {\n      if ((value.charAt(j) == 'á') ||\n          (value.charAt(j) == 'â') ||\n          (value.charAt(j) == 'ã')) {\n        r= r + "a" ; continue ;\n      }\n      if ((value.charAt(j) == 'é') ||\n          (value.charAt(j) == 'ê')) {\n        r= r + "e" ; continue ;\n      }\n      if (value.charAt(j) == 'í') {\n        r= r + "i" ; continue ;\n      }\n      if ((value.charAt(j) == 'ó') ||\n          (value.charAt(j) == 'ô') ||\n          (value.charAt(j) == 'õ')) {\n        r= r + "o" ; continue ;\n      }\n      if ((value.charAt(j) == 'ú') ||\n          (value.charAt(j) == 'ü')) {\n        r= r + "u" ; continue ;\n      }\n      if (value.charAt(j) == 'ç') {\n        r= r + "c" ; continue ;\n      }\n      if (value.charAt(j) == 'ñ') {\n        r= r + "n" ; continue ;\n      }\n\n      r= r+ value.charAt(j) ;\n    }\n\n    return r ;\n  }
954	public static boolean spins(Path path) throws IOException {\n        path = path.toRealPath();\n    \n        if (!Constants.LINUX) {\n      return true;     }\n\n    try {\n      return spinsLinux(path);\n    } catch (Exception exc) {\n            return true;\n    }\n  }
955	protected void updateCrosshairValues(CrosshairState crosshairState,\n            double x, double y, int domainAxisIndex, int rangeAxisIndex,\n            double transX, double transY, PlotOrientation orientation) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        if (crosshairState != null) {\n                        if (this.plot.isDomainCrosshairLockedOnData()) {\n                if (this.plot.isRangeCrosshairLockedOnData()) {\n                                        crosshairState.updateCrosshairPoint(x, y, domainAxisIndex,\n                            rangeAxisIndex, transX, transY, orientation);\n                }\n                else {\n                                        crosshairState.updateCrosshairX(x, domainAxisIndex);\n                }\n            }\n            else {\n                if (this.plot.isRangeCrosshairLockedOnData()) {\n                                        crosshairState.updateCrosshairY(y, rangeAxisIndex);\n                }\n            }\n        }\n\n    }
956	private static double evaluate(int year, int month, int pDay) throws EvaluationException {\n	   		if (year < 0) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n				while (month < 0) {\n		   year--;\n		   month += 12;\n		}\n				\n						if (year == 1900 && month == Calendar.FEBRUARY && pDay == 29) {\n			return 60.0;\n		}\n\n						int day = pDay;\n		if (year == 1900) {\n			if ((month == Calendar.JANUARY && day >= 60) ||\n					(month == Calendar.FEBRUARY && day >= 30)) {\n				day--;\n			}\n		}\n\n				Calendar c = LocaleUtil.getLocaleCalendar(year, month, day);\n		\n						if (pDay < 0 && c.get(Calendar.YEAR) == 1900 &&\n		      month > Calendar.FEBRUARY && \n		      c.get(Calendar.MONTH) < Calendar.MARCH) {\n		   c.add(Calendar.DATE, 1);\n		}\n\n				boolean use1904windowing = false;\n		\n				return DateUtil.getExcelDate(c.getTime(), use1904windowing);\n	}
957	public void copy(BytesRef bytes, BytesRef out) {\n    int left = blockSize - upto;\n    if (bytes.length > left || currentBlock==null) {\n      if (currentBlock != null) {\n        addBlock(currentBlock);\n        didSkipBytes = true;\n      }\n      currentBlock = new byte[blockSize];\n      upto = 0;\n      left = blockSize;\n      assert bytes.length <= blockSize;\n          }\n\n    out.bytes = currentBlock;\n    out.offset = upto;\n    out.length = bytes.length;\n\n    System.arraycopy(bytes.bytes, bytes.offset, currentBlock, upto, bytes.length);\n    upto += bytes.length;\n  }
958	protected void init(boolean onlyValidation) {\n        if (opcPackage == null) {\n            throw new EncryptedDocumentException("opcPackage is null");\n        }\n        if (uriDereferencer == null) {\n            uriDereferencer = new OOXMLURIDereferencer();\n        }\n        if (uriDereferencer instanceof SignatureConfigurable) {\n            ((SignatureConfigurable)uriDereferencer).setSignatureConfig(this);\n        }\n        if (namespacePrefixes.isEmpty()) {\n            \n                        namespacePrefixes.put(OO_DIGSIG_NS, "mdssi");\n            namespacePrefixes.put(XADES_132_NS, "xd");\n        }\n        \n        if (onlyValidation) {\n            return;\n        }\n\n        if (signatureMarshalListener == null) {\n            signatureMarshalListener = new SignatureMarshalListener();\n        }\n        \n        if (signatureMarshalListener instanceof SignatureConfigurable) {\n            ((SignatureConfigurable)signatureMarshalListener).setSignatureConfig(this);\n        }\n        \n        if (tspService != null) {\n            tspService.setSignatureConfig(this);\n        }\n        \n        if (signatureFacets.isEmpty()) {\n            addSignatureFacet(new OOXMLSignatureFacet());\n            addSignatureFacet(new KeyInfoSignatureFacet());\n            addSignatureFacet(new XAdESSignatureFacet());\n            addSignatureFacet(new Office2010SignatureFacet());\n        }\n\n        for (SignatureFacet sf : signatureFacets) {\n            sf.setSignatureConfig(this);\n        }\n    }
959	public String getTextFromPieces() {\n        String text = doc.getDocumentText();\n\n                text = text.replaceAll( "\r\r\r", "\r\n\r\n\r\n" );\n        text = text.replaceAll( "\r\r", "\r\n\r\n" );\n\n        if ( text.endsWith( "\r" )) {\n            text += "\n";\n        }\n\n        return text;\n    }
960	protected static void createTempDir() {\n        String tempDirName = System.getProperty("java.io.tmpdir");\n        if (tempDirName == null) {\n            throw new RuntimeException("Temporary directory system property "\n                    + "(java.io.tmpdir) is null.");\n        }\n\n                File tempDir = new File(tempDirName);\n        if (!tempDir.exists()) {\n            tempDir.mkdirs();\n        }\n    }
961	protected int invokeCipher(int posInChunk, boolean doFinal) throws GeneralSecurityException {\n        byte plain[] = (plainByteFlags.isEmpty()) ? null : chunk.clone();\n\n        int ciLen = (doFinal)\n            ? cipher.doFinal(chunk, 0, posInChunk, chunk)\n            : cipher.update(chunk, 0, posInChunk, chunk);\n\n        if (plain != null) {\n            int i = plainByteFlags.nextSetBit(0);\n            while (i >= 0 && i < posInChunk) {\n                chunk[i] = plain[i];\n                i = plainByteFlags.nextSetBit(i+1);\n            }\n        }\n        \n        return ciLen;\n    }
962	public static void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix) throws IOException {\n    if (id.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException("Invalid id: " + StringHelper.idToString(id));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(id, 0, id.length);\n    BytesRef suffixBytes = new BytesRef(suffix);\n    if (suffixBytes.length != suffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException("suffix must be simple ASCII, less than 256 characters in length [got " + suffix + "]");\n    }\n    out.writeByte((byte) suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }
963	protected void generateData() {\n		int size = 0;\n		for(int i=0; i<records.length; i++) {\n			size += records[i].getRecordSize();\n		}\n\n		byte data[] = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n		size = 0;\n		for(int i=0; i<records.length; i++) {\n			int thisSize =\n				records[i].serialize(size, data);\n			size += thisSize;\n		}\n		\n		setData(data);\n	}
964	private FST<Object> buildAutomaton(BytesRefSorter sorter) throws IOException {\n        final Outputs<Object> outputs = NoOutputs.getSingleton();\n    final Object empty = outputs.getNoOutput();\n    final Builder<Object> builder = new Builder<>(\n        FST.INPUT_TYPE.BYTE1, 0, 0, true, true, \n        shareMaxTailLength, outputs, true, 15);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n    BytesRef entry;\n    final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n    int count = 0;\n    BytesRefIterator iter = sorter.iterator();\n    while((entry = iter.next()) != null) {\n      count++;\n      if (scratch.get().compareTo(entry) != 0) {\n        builder.add(Util.toIntsRef(entry, scratchIntsRef), empty);\n        scratch.copyBytes(entry);\n      }\n    }\n    \n    return count == 0 ? null : builder.finish();\n  }
965	public static boolean clipLine(Line2D line, Rectangle2D rect) {\n\n        double x1 = line.getX1();\n        double y1 = line.getY1();\n        double x2 = line.getX2();\n        double y2 = line.getY2();\n\n        double minX = rect.getMinX();\n        double maxX = rect.getMaxX();\n        double minY = rect.getMinY();\n        double maxY = rect.getMaxY();\n\n        int f1 = rect.outcode(x1, y1);\n        int f2 = rect.outcode(x2, y2);\n\n        while ((f1 | f2) != 0) {\n            if ((f1 & f2) != 0) {\n                return false;\n            }\n            double dx = (x2 - x1);\n            double dy = (y2 - y1);\n                                    if (f1 != 0) {\n                                                if ((f1 & Rectangle2D.OUT_LEFT) == Rectangle2D.OUT_LEFT\n                        && dx != 0.0) {\n                    y1 = y1 + (minX - x1) * dy / dx;\n                    x1 = minX;\n                }\n                else if ((f1 & Rectangle2D.OUT_RIGHT) == Rectangle2D.OUT_RIGHT\n                        && dx != 0.0) {\n                    y1 = y1 + (maxX - x1) * dy / dx;\n                    x1 = maxX;\n                }\n                else if ((f1 & Rectangle2D.OUT_BOTTOM) == Rectangle2D.OUT_BOTTOM\n                        && dy != 0.0) {\n                    x1 = x1 + (maxY - y1) * dx / dy;\n                    y1 = maxY;\n                }\n                else if ((f1 & Rectangle2D.OUT_TOP) == Rectangle2D.OUT_TOP\n                        && dy != 0.0) {\n                    x1 = x1 + (minY - y1) * dx / dy;\n                    y1 = minY;\n                }\n                f1 = rect.outcode(x1, y1);\n            }\n            else if (f2 != 0) {\n                                                if ((f2 & Rectangle2D.OUT_LEFT) == Rectangle2D.OUT_LEFT\n                        && dx != 0.0) {\n                    y2 = y2 + (minX - x2) * dy / dx;\n                    x2 = minX;\n                }\n                else if ((f2 & Rectangle2D.OUT_RIGHT) == Rectangle2D.OUT_RIGHT\n                        && dx != 0.0) {\n                    y2 = y2 + (maxX - x2) * dy / dx;\n                    x2 = maxX;\n                }\n                else if ((f2 & Rectangle2D.OUT_BOTTOM) == Rectangle2D.OUT_BOTTOM\n                        && dy != 0.0) {\n                    x2 = x2 + (maxY - y2) * dx / dy;\n                    y2 = maxY;\n                }\n                else if ((f2 & Rectangle2D.OUT_TOP) == Rectangle2D.OUT_TOP\n                        && dy != 0.0) {\n                    x2 = x2 + (minY - y2) * dx / dy;\n                    y2 = minY;\n                }\n                f2 = rect.outcode(x2, y2);\n            }\n        }\n\n        line.setLine(x1, y1, x2, y2);\n        return true;                        \n    }
966	static void formatDuplicates(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Code");\n        sheet.createRow(1).createCell(0).setCellValue(4);\n        sheet.createRow(2).createCell(0).setCellValue(3);\n        sheet.createRow(3).createCell(0).setCellValue(6);\n        sheet.createRow(4).createCell(0).setCellValue(3);\n        sheet.createRow(5).createCell(0).setCellValue(5);\n        sheet.createRow(6).createCell(0).setCellValue(8);\n        sheet.createRow(7).createCell(0).setCellValue(0);\n        sheet.createRow(8).createCell(0).setCellValue(2);\n        sheet.createRow(9).createCell(0).setCellValue(8);\n        sheet.createRow(10).createCell(0).setCellValue(6);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("COUNTIF($A$2:$A$11,A2)>1");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontStyle(false, true);\n        font.setFontColorIndex(IndexedColors.BLUE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A11")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(1).setCellValue("<== Duplicates numbers in the column are highlighted.  " +\n                "Condition: Formula Is =COUNTIF($A$2:$A$11,A2)>1   (Blue Font)");\n    }
967	public String getRecipientEmailAddress() {\n                if (recipientSMTPChunk != null) {\n            return recipientSMTPChunk.getValue();\n        }\n\n                        if (recipientEmailChunk != null) {\n            String email = recipientEmailChunk.getValue();\n            int cne = email.indexOf("/CN=");\n            if (cne < 0) {\n                                return email;\n            } else {\n                                return email.substring(cne + 4);\n            }\n        }\n\n                if (recipientNameChunk != null) {\n            String name = recipientNameChunk.getValue();\n            if (name.contains("@")) {\n                                if (name.startsWith("'") && name.endsWith("'")) {\n                    return name.substring(1, name.length() - 1);\n                }\n                return name;\n            }\n        }\n\n                        if (recipientSearchChunk != null) {\n            String search = recipientSearchChunk.getAs7bitString();\n            int idx = search.indexOf("SMTP:");\n            if (idx >= 0) {\n                return search.substring(idx + 5);\n            }\n        }\n\n                return null;\n    }
968	public static JFreeChart createHighLowChart(String title,\n            String timeAxisLabel, String valueAxisLabel, OHLCDataset dataset,\n            boolean legend) {\n\n        ValueAxis timeAxis = new DateAxis(timeAxisLabel);\n        NumberAxis valueAxis = new NumberAxis(valueAxisLabel);\n        HighLowRenderer renderer = new HighLowRenderer();\n        renderer.setBaseToolTipGenerator(new HighLowItemLabelGenerator());\n        XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, renderer);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
969	public boolean bytesEquals(BytesRef other) {\n    assert other != null;\n    if (length == other.length) {\n      int otherUpto = other.offset;\n      final byte[] otherBytes = other.bytes;\n      final int end = offset + length;\n      for(int upto=offset;upto<end;upto++,otherUpto++) {\n        if (bytes[upto] != otherBytes[otherUpto]) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }
970	public static int getNearestSetSize(int maxNumberOfBits)\n  {\n    int result=usableBitSetSizes[0];\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      if(usableBitSetSizes[i]<=maxNumberOfBits)\n      {\n        result=usableBitSetSizes[i];\n      }\n    }\n    return result;\n  }
971	public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (getClass() != other.getClass()) return false;\n        \n        TextPropCollection o = (TextPropCollection)other;\n        if (o.maskSpecial != this.maskSpecial || o.indentLevel != this.indentLevel) {\n            return false;\n        }\n\n        return textProps.equals(o.textProps);\n    }
972	public BigInteger addNum(XWPFNum num) {\n        ctNumbering.addNewNum();\n        int pos = ctNumbering.sizeOfNumArray() - 1;\n        ctNumbering.setNumArray(pos, num.getCTNum());\n        nums.add(num);\n        return num.getCTNum().getNumId();\n    }
973	private static void verifyZipHeader(InputStream stream) throws NotOfficeXmlFileException, IOException {\n        InputStream is = FileMagic.prepareToCheckMagic(stream);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        switch (fm) {\n        case OLE2:\n            throw new OLE2NotOfficeXmlFileException(\n                "The supplied data appears to be in the OLE2 Format. " +\n                "You are calling the part of POI that deals with OOXML "+\n                "(Office Open XML) Documents. You need to call a different " +\n                "part of POI to process this data (eg HSSF instead of XSSF)");\n        case XML:\n            throw new NotOfficeXmlFileException(\n                "The supplied data appears to be a raw XML file. " +\n                "Formats such as Office 2003 XML are not supported");\n        default:\n        case OOXML:\n        case UNKNOWN:\n                                                break;\n        }\n    }
974	private Record getCoreRecordForRefID(int refID) {\n		Integer coreRecordId = _sheetIdToCoreRecordsLookup.get(refID);\n		if (coreRecordId != null) {\n			return _mostRecentCoreRecords[coreRecordId];\n		}\n		logger.log(POILogger.ERROR,\n				"We tried to look up a reference to a core record, but there was no core ID for reference ID "\n						+ refID);\n		return null;\n	}
975	private List<FacetResult> drillSideways() throws IOException {\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n            DrillDownQuery q = new DrillDownQuery(config);\n\n        q.add("Publish Date", "2010");\n\n    DrillSideways ds = new DrillSideways(searcher, config, taxoReader);\n    DrillSidewaysResult result = ds.search(q, 10);\n\n        List<FacetResult> facets = result.facets.getAllDims(10);\n\n    indexReader.close();\n    taxoReader.close();\n    \n    return facets;\n  }
976	public void reverse(long srcPos, long destPos) {\n    assert srcPos < destPos;\n    assert destPos < getPosition();\n    \n    int srcBlockIndex = (int) (srcPos >> blockBits);\n    int src = (int) (srcPos & blockMask);\n    byte[] srcBlock = blocks.get(srcBlockIndex);\n\n    int destBlockIndex = (int) (destPos >> blockBits);\n    int dest = (int) (destPos & blockMask);\n    byte[] destBlock = blocks.get(destBlockIndex);\n    \n    int limit = (int) (destPos - srcPos + 1)/2;\n    for(int i=0;i<limit;i++) {\n            byte b = srcBlock[src];\n      srcBlock[src] = destBlock[dest];\n      destBlock[dest] = b;\n      src++;\n      if (src == blockSize) {\n        srcBlockIndex++;\n        srcBlock = blocks.get(srcBlockIndex);\n                src = 0;\n      }\n\n      dest--;\n      if (dest == -1) {\n        destBlockIndex--;\n        destBlock = blocks.get(destBlockIndex);\n                dest = blockSize-1;\n      }\n    }\n  }
977	protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n    LeafSlice[] slices = new LeafSlice[leaves.size()];\n    for (int i = 0; i < slices.length; i++) {\n      slices[i] = new LeafSlice(leaves.get(i));\n    }\n    return slices;\n  }
978	protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        if (!isDomainGridlinesVisible()) {\n            return;\n        }\n        CategoryAnchor anchor = getDomainGridlinePosition();\n        RectangleEdge domainAxisEdge = getDomainAxisEdge();\n        CategoryDataset dataset = getDataset();\n        if (dataset == null) {\n            return;\n        }\n        CategoryAxis axis = getDomainAxis();\n        if (axis != null) {\n            int columnCount = dataset.getColumnCount();\n            for (int c = 0; c < columnCount; c++) {\n                double xx = axis.getCategoryJava2DCoordinate(anchor, c,\n                        columnCount, dataArea, domainAxisEdge);\n                CategoryItemRenderer renderer1 = getRenderer();\n                if (renderer1 != null) {\n                    renderer1.drawDomainGridline(g2, this, dataArea, xx);\n                }\n            }\n        }\n    }
979	private void updateXPoints(XYSeries series) {\n        ParamChecks.nullNotPermitted(series, "series");\n        HashSet seriesXPoints = new HashSet();\n        boolean savedState = this.propagateEvents;\n        this.propagateEvents = false;\n        for (int itemNo = 0; itemNo < series.getItemCount(); itemNo++) {\n            Number xValue = series.getX(itemNo);\n            seriesXPoints.add(xValue);\n            if (!this.xPoints.contains(xValue)) {\n                this.xPoints.add(xValue);\n                int seriesCount = this.data.size();\n                for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                    XYSeries dataSeries = (XYSeries) this.data.get(seriesNo);\n                    if (!dataSeries.equals(series)) {\n                        dataSeries.add(xValue, null);\n                    }\n                }\n            }\n        }\n        Iterator iterator = this.xPoints.iterator();\n        while (iterator.hasNext()) {\n            Number xPoint = (Number) iterator.next();\n            if (!seriesXPoints.contains(xPoint)) {\n                series.add(xPoint, null);\n            }\n        }\n        this.propagateEvents = savedState;\n    }
980	private static void copy(OPCPackage pkg, PackagePart part, OPCPackage tgt, PackagePart part_tgt) throws OpenXML4JException, IOException {\n        PackageRelationshipCollection rels = part.getRelationships();\n        if(rels != null) for (PackageRelationship rel : rels) {\n            PackagePart p;\n            if(rel.getTargetMode() == TargetMode.EXTERNAL){\n                part_tgt.addExternalRelationship(rel.getTargetURI().toString(), rel.getRelationshipType(), rel.getId());\n                                continue;\n            }\n            URI uri = rel.getTargetURI();\n\n            if(uri.getRawFragment() != null) {\n                part_tgt.addRelationship(uri, rel.getTargetMode(), rel.getRelationshipType(), rel.getId());\n                continue;\n            }\n            PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n            p = pkg.getPart(relName);\n            part_tgt.addRelationship(p.getPartName(), rel.getTargetMode(), rel.getRelationshipType(), rel.getId());\n\n            PackagePart dest;\n            if(!tgt.containPart(p.getPartName())){\n                dest = tgt.createPart(p.getPartName(), p.getContentType());\n                OutputStream out = dest.getOutputStream();\n                IOUtils.copy(p.getInputStream(), out);\n                out.close();\n                copy(pkg, p, tgt, dest);\n            }\n        }\n    }
981	@Beta\n    protected CTPivotCache addPivotCache(String rId) {\n        CTWorkbook ctWorkbook = getCTWorkbook();\n        CTPivotCaches caches;\n        if (ctWorkbook.isSetPivotCaches()) {\n            caches = ctWorkbook.getPivotCaches();\n        } else {\n            caches = ctWorkbook.addNewPivotCaches();\n        }\n        CTPivotCache cache = caches.addNewPivotCache();\n\n        int tableId = getPivotTables().size()+1;\n        cache.setCacheId(tableId);\n        cache.setId(rId);\n        if(pivotCaches == null) {\n            pivotCaches = new ArrayList<>();\n        }\n        pivotCaches.add(cache);\n        return cache;\n    }
982	public static Line2D extendLine(Line2D line, double startPercent,\n                              double endPercent) {\n        ParamChecks.nullNotPermitted(line, "line");\n        double x1 = line.getX1();\n        double x2 = line.getX2();\n        double deltaX = x2 - x1;\n        double y1 = line.getY1();\n        double y2 = line.getY2();\n        double deltaY = y2 - y1;\n        x1 = x1 - (startPercent * deltaX);\n        y1 = y1 - (startPercent * deltaY);\n        x2 = x2 + (endPercent * deltaX);\n        y2 = y2 + (endPercent * deltaY);\n        return new Line2D.Double(x1, y1, x2, y2);\n    }
983	private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log("Collecting external dependencies from: " + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n        String dependencyPath = "/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute("org");\n      String artifactId = dependency.getAttribute("name");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute("conf");\n      boolean confContainsTest = conf.contains("test");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate("artifact", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute("type");\n          String ext = artifact.getAttribute("ext");\n                    boolean isTestDependency = confContainsTest && (type.equals("test") || ! conf.contains("compile"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals("jar") || ext.equals("jar")) {\n            String classifier = artifact.getAttribute("maven:classifier");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else {             nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }
984	protected synchronized MergeThread getMergeThread(IndexWriter writer, OneMerge merge) throws IOException {\n    final MergeThread thread = new MergeThread(writer, merge);\n    thread.setDaemon(true);\n    thread.setName("Lucene Merge Thread #" + mergeThreadCount++);\n    return thread;\n  }
985	public static void setFont(Cell cell, Font font) {\n                Workbook wb = cell.getSheet().getWorkbook();\n        final int fontIndex = font.getIndexAsInt();\n        if (!wb.getFontAt(fontIndex).equals(font)) {\n            throw new IllegalArgumentException("Font does not belong to this workbook");\n        }\n\n                \n        setCellStyleProperty(cell, FONT, fontIndex);\n    }
986	private static GutsRecord createGuts() {\n        GutsRecord retval = new GutsRecord();\n\n        retval.setLeftRowGutter(( short ) 0);\n        retval.setTopColGutter(( short ) 0);\n        retval.setRowLevelMax(( short ) 0);\n        retval.setColLevelMax(( short ) 0);\n        return retval;\n    }
987	public void zoomOutDomain(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n                                                boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomDomainAxes(this.zoomOutFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }
988	public ValueEval evaluate(String sheetName, int rowIndex, int columnIndex) {\n		EvaluationCell cell = _sewb.getEvaluationCell(sheetName, rowIndex, columnIndex);\n\n		switch (cell.getCellType()) {\n			case BOOLEAN:\n				return BoolEval.valueOf(cell.getBooleanCellValue());\n			case ERROR:\n				return ErrorEval.valueOf(cell.getErrorCellValue());\n			case FORMULA:\n				return _evaluator.evaluate(cell);\n			case NUMERIC:\n				return new NumberEval(cell.getNumericCellValue());\n			case STRING:\n				return new StringEval(cell.getStringCellValue());\n			case BLANK:\n				return null;\n			default:\n				throw new IllegalStateException("Bad cell type (" + cell.getCellType() + ")");\n		}\n	}
989	public static GeoBBox makeGeoBBox(final PlanetModel planetModel, double topLat, double bottomLat, double leftLon, double rightLon) {\n        if (topLat > Math.PI * 0.5)\n      topLat = Math.PI * 0.5;\n    if (bottomLat < -Math.PI * 0.5)\n      bottomLat = -Math.PI * 0.5;\n    if (leftLon < -Math.PI)\n      leftLon = -Math.PI;\n    if (rightLon > Math.PI)\n      rightLon = Math.PI;\n    if ((Math.abs(leftLon + Math.PI) < Vector.MINIMUM_ANGULAR_RESOLUTION && Math.abs(rightLon - Math.PI) < Vector.MINIMUM_ANGULAR_RESOLUTION) ||\n        (Math.abs(rightLon + Math.PI) < Vector.MINIMUM_ANGULAR_RESOLUTION && Math.abs(leftLon - Math.PI) < Vector.MINIMUM_ANGULAR_RESOLUTION)) {\n      if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION && Math.abs(bottomLat + Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION)\n        return new GeoWorld(planetModel);\n      if (Math.abs(topLat - bottomLat) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION || Math.abs(topLat + Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION)\n          return new GeoDegeneratePoint(planetModel, topLat, 0.0);\n        return new GeoDegenerateLatitudeZone(planetModel, topLat);\n      }\n      if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION)\n        return new GeoNorthLatitudeZone(planetModel, bottomLat);\n      else if (Math.abs(bottomLat + Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION)\n        return new GeoSouthLatitudeZone(planetModel, topLat);\n      return new GeoLatitudeZone(planetModel, topLat, bottomLat);\n    }\n        double extent = rightLon - leftLon;\n    if (extent < 0.0)\n      extent += Math.PI * 2.0;\n    if (topLat == Math.PI * 0.5 && bottomLat == -Math.PI * 0.5) {\n      if (Math.abs(leftLon - rightLon) < Vector.MINIMUM_ANGULAR_RESOLUTION)\n        return new GeoDegenerateLongitudeSlice(planetModel, leftLon);\n\n      if (extent >= Math.PI)\n        return new GeoWideLongitudeSlice(planetModel, leftLon, rightLon);\n\n      return new GeoLongitudeSlice(planetModel, leftLon, rightLon);\n    }\n        if (Math.abs(leftLon - rightLon) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n      if (Math.abs(topLat - bottomLat) < Vector.MINIMUM_ANGULAR_RESOLUTION)\n        return new GeoDegeneratePoint(planetModel, topLat, leftLon);\n      return new GeoDegenerateVerticalLine(planetModel, topLat, bottomLat, leftLon);\n    }\n        if (extent >= Math.PI) {\n      if (Math.abs(topLat - bottomLat) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n          return new GeoDegeneratePoint(planetModel, topLat, 0.0);\n        } else if (Math.abs(bottomLat + Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n          return new GeoDegeneratePoint(planetModel, bottomLat, 0.0);\n        }\n                return new GeoWideDegenerateHorizontalLine(planetModel, topLat, leftLon, rightLon);\n      }\n      if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        return new GeoWideNorthRectangle(planetModel, bottomLat, leftLon, rightLon);\n      } else if (Math.abs(bottomLat + Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        return new GeoWideSouthRectangle(planetModel, topLat, leftLon, rightLon);\n      }\n            return new GeoWideRectangle(planetModel, topLat, bottomLat, leftLon, rightLon);\n    }\n    if (Math.abs(topLat - bottomLat) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n      if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        return new GeoDegeneratePoint(planetModel, topLat, 0.0);\n      } else if (Math.abs(bottomLat + Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n        return new GeoDegeneratePoint(planetModel, bottomLat, 0.0);\n      }\n            return new GeoDegenerateHorizontalLine(planetModel, topLat, leftLon, rightLon);\n    }\n    if (Math.abs(topLat - Math.PI * 0.5) < Vector.MINIMUM_ANGULAR_RESOLUTION) {\n      return new GeoNorthRectangle(planetModel, bottomLat, leftLon, rightLon);\n    } else if (Math.abs(bottomLat + Math.PI * 0.5) <  Vector.MINIMUM_ANGULAR_RESOLUTION) {\n      return new GeoSouthRectangle(planetModel, topLat, leftLon, rightLon);\n    }\n        return new GeoRectangle(planetModel, topLat, bottomLat, leftLon, rightLon);\n  }
990	protected Encoder getEncoder() {\n            try {\n      Encoder encoder = clazz.newInstance();\n            if(maxCodeLength != null && setMaxCodeLenMethod != null) {\n        setMaxCodeLenMethod.invoke(encoder, maxCodeLength);\n      }\n      return encoder;\n    } catch (Exception e) {\n      final Throwable t = (e instanceof InvocationTargetException) ? e.getCause() : e;\n      throw new IllegalArgumentException("Error initializing encoder: " + name + " / " + clazz, t);\n    }\n  }
991	private String tab2space(TextRun tr) {\n        AttributedString string = new AttributedString(" ");\n        String fontFamily = tr.getFontFamily();\n        if (fontFamily == null) {\n            fontFamily = "Lucida Sans";\n        }\n        string.addAttribute(TextAttribute.FAMILY, fontFamily);\n\n        Double fs = tr.getFontSize();\n        if (fs == null) {\n            fs = 12d;\n        }\n        string.addAttribute(TextAttribute.SIZE, fs.floatValue());\n\n        TextLayout l = new TextLayout(string.getIterator(), new FontRenderContext(null, true, true));\n        double wspace = l.getAdvance();\n\n        Double tabSz = paragraph.getDefaultTabSize();\n        if (tabSz == null) {\n            tabSz = wspace*4;\n        }\n\n        int numSpaces = (int)Math.ceil(tabSz / wspace);\n        StringBuilder buf = new StringBuilder();\n        for(int i = 0; i < numSpaces; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    }
992	int next() {\n    int next = rbbi.next();\n    while (next == BreakIterator.DONE && scriptIterator.next()) {\n      rbbi = getBreakIterator(scriptIterator.getScriptCode());\n      rbbi.setText(text, scriptIterator.getScriptStart(), \n          scriptIterator.getScriptLimit() - scriptIterator.getScriptStart());\n      next = rbbi.next();\n    }\n    return (next == BreakIterator.DONE) ? BreakIterator.DONE : next\n        + scriptIterator.getScriptStart();\n  }
993	protected void releaseGen(long gen) throws IOException {\n    if (!initCalled) {\n      throw new IllegalStateException("this instance is not being used by IndexWriter; be sure to use the instance returned from writer.getConfig().getIndexDeletionPolicy()");\n    }\n    Integer refCount = refCounts.get(gen);\n    if (refCount == null) {\n      throw new IllegalArgumentException("commit gen=" + gen + " is not currently snapshotted");\n    }\n    int refCountInt = refCount.intValue();\n    assert refCountInt > 0;\n    refCountInt--;\n    if (refCountInt == 0) {\n      refCounts.remove(gen);\n      indexCommits.remove(gen);\n    } else {\n      refCounts.put(gen, refCountInt);\n    }\n  }
994	private static DateTickUnitType intToUnitType(int unit) {\n        switch (unit) {\n            case YEAR: return DateTickUnitType.YEAR;\n            case MONTH: return DateTickUnitType.MONTH;\n            case DAY: return DateTickUnitType.DAY;\n            case HOUR: return DateTickUnitType.HOUR;\n            case MINUTE: return DateTickUnitType.MINUTE;\n            case SECOND: return DateTickUnitType.SECOND;\n            case MILLISECOND: return DateTickUnitType.MILLISECOND;\n            default: throw new IllegalArgumentException(\n                    "Unrecognised 'unit' value " + unit + ".");\n        }\n    }
995	public Bounds addZValue(final double z) {\n    final double small = z - FUDGE_FACTOR;\n    if (minZ == null || minZ > small) {\n      minZ = new Double(small);\n    }\n    final double large = z + FUDGE_FACTOR;\n    if (maxZ == null || maxZ < large) {\n      maxZ = new Double(large);\n    }\n    return this;\n  }
996	public void bulletedListInCell(HSSFWorkbook workbook,\n                                   ArrayList<String> listItems,\n                                   HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n                        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n                        for(String listItem : listItems) {\n            buffer.append(InCellLists.BULLET_CHARACTER + " ");\n            buffer.append(listItem);\n            buffer.append("\n");\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
997	public synchronized long updateDocument(String id, Document doc) throws IOException {\n    assert buffer.getFilePointer() == 0;\n    buffer.writeByte(OP_UPDATE_DOCUMENT);\n    encode(id, doc);\n    return flushBuffer();\n  }
998	public static void numberSpreadsheet(Workbook wb, int numCols){\n\n        System.out.println("Testing " + wb.getClass().getName());\n        printMemoryUsage("before");\n        int i=0, cnt=0;\n        try {\n            Sheet sh = wb.createSheet();\n            for(i=0; ; i++){\n                Row row = sh.createRow(i);\n                for(int j=0; j < numCols; j++){\n                    Cell cell = row.createCell(j);\n                    cell.setCellValue(j);\n                    cnt++;\n                }\n            }\n        } catch (OutOfMemoryError er){\n            System.out.println("Failed at row=" + i + ", objects : " + cnt);\n        } catch (final Exception e) {\n            System.out.println("Unable to reach an OutOfMemoryError");\n            System.out.println(e.getClass().getName() + ": " + e.getMessage());\n        }\n        printMemoryUsage("after");\n    }
999	protected JPopupMenu createPopupMenu(boolean properties,\n            boolean copy, boolean save, boolean print, boolean zoom) {\n\n        JPopupMenu result = new JPopupMenu(localizationResources.getString("Chart") + ":");\n        boolean separator = false;\n\n        if (properties) {\n            JMenuItem propertiesItem = new JMenuItem(\n                    localizationResources.getString("Properties..."));\n            propertiesItem.setActionCommand(PROPERTIES_COMMAND);\n            propertiesItem.addActionListener(this);\n            result.add(propertiesItem);\n            separator = true;\n        }\n\n        if (copy) {\n            if (separator) {\n                result.addSeparator();\n            }\n            JMenuItem copyItem = new JMenuItem(\n                    localizationResources.getString("Copy"));\n            copyItem.setActionCommand(COPY_COMMAND);\n            copyItem.addActionListener(this);\n            result.add(copyItem);\n            separator = !save;\n        }\n\n        if (save) {\n            if (separator) {\n                result.addSeparator();\n            }\n            JMenu saveSubMenu = new JMenu(localizationResources.getString(\n                    "Save_as"));\n            JMenuItem pngItem = new JMenuItem(localizationResources.getString(\n                    "PNG..."));\n            pngItem.setActionCommand("SAVE_AS_PNG");\n            pngItem.addActionListener(this);\n            saveSubMenu.add(pngItem);\n            \n            if (createSVGGraphics2D(10, 10) != null) {\n                JMenuItem svgItem = new JMenuItem(localizationResources.getString(\n                        "SVG..."));\n                svgItem.setActionCommand("SAVE_AS_SVG");\n                svgItem.addActionListener(this);\n                saveSubMenu.add(svgItem);                \n            }\n            \n            if (isOrsonPDFAvailable()) {\n                JMenuItem pdfItem = new JMenuItem(\n                        localizationResources.getString("PDF..."));\n                pdfItem.setActionCommand("SAVE_AS_PDF");\n                pdfItem.addActionListener(this);\n                saveSubMenu.add(pdfItem);\n            }\n            result.add(saveSubMenu);\n            separator = true;\n        }\n\n        if (print) {\n            if (separator) {\n                result.addSeparator();\n            }\n            JMenuItem printItem = new JMenuItem(\n                    localizationResources.getString("Print..."));\n            printItem.setActionCommand(PRINT_COMMAND);\n            printItem.addActionListener(this);\n            result.add(printItem);\n            separator = true;\n        }\n\n        if (zoom) {\n            if (separator) {\n                result.addSeparator();\n            }\n\n            JMenu zoomInMenu = new JMenu(\n                    localizationResources.getString("Zoom_In"));\n\n            this.zoomInBothMenuItem = new JMenuItem(\n                    localizationResources.getString("All_Axes"));\n            this.zoomInBothMenuItem.setActionCommand(ZOOM_IN_BOTH_COMMAND);\n            this.zoomInBothMenuItem.addActionListener(this);\n            zoomInMenu.add(this.zoomInBothMenuItem);\n\n            zoomInMenu.addSeparator();\n\n            this.zoomInDomainMenuItem = new JMenuItem(\n                    localizationResources.getString("Domain_Axis"));\n            this.zoomInDomainMenuItem.setActionCommand(ZOOM_IN_DOMAIN_COMMAND);\n            this.zoomInDomainMenuItem.addActionListener(this);\n            zoomInMenu.add(this.zoomInDomainMenuItem);\n\n            this.zoomInRangeMenuItem = new JMenuItem(\n                    localizationResources.getString("Range_Axis"));\n            this.zoomInRangeMenuItem.setActionCommand(ZOOM_IN_RANGE_COMMAND);\n            this.zoomInRangeMenuItem.addActionListener(this);\n            zoomInMenu.add(this.zoomInRangeMenuItem);\n\n            result.add(zoomInMenu);\n\n            JMenu zoomOutMenu = new JMenu(\n                    localizationResources.getString("Zoom_Out"));\n\n            this.zoomOutBothMenuItem = new JMenuItem(\n                    localizationResources.getString("All_Axes"));\n            this.zoomOutBothMenuItem.setActionCommand(ZOOM_OUT_BOTH_COMMAND);\n            this.zoomOutBothMenuItem.addActionListener(this);\n            zoomOutMenu.add(this.zoomOutBothMenuItem);\n\n            zoomOutMenu.addSeparator();\n\n            this.zoomOutDomainMenuItem = new JMenuItem(\n                    localizationResources.getString("Domain_Axis"));\n            this.zoomOutDomainMenuItem.setActionCommand(\n                    ZOOM_OUT_DOMAIN_COMMAND);\n            this.zoomOutDomainMenuItem.addActionListener(this);\n            zoomOutMenu.add(this.zoomOutDomainMenuItem);\n\n            this.zoomOutRangeMenuItem = new JMenuItem(\n                    localizationResources.getString("Range_Axis"));\n            this.zoomOutRangeMenuItem.setActionCommand(ZOOM_OUT_RANGE_COMMAND);\n            this.zoomOutRangeMenuItem.addActionListener(this);\n            zoomOutMenu.add(this.zoomOutRangeMenuItem);\n\n            result.add(zoomOutMenu);\n\n            JMenu autoRangeMenu = new JMenu(\n                    localizationResources.getString("Auto_Range"));\n\n            this.zoomResetBothMenuItem = new JMenuItem(\n                    localizationResources.getString("All_Axes"));\n            this.zoomResetBothMenuItem.setActionCommand(\n                    ZOOM_RESET_BOTH_COMMAND);\n            this.zoomResetBothMenuItem.addActionListener(this);\n            autoRangeMenu.add(this.zoomResetBothMenuItem);\n\n            autoRangeMenu.addSeparator();\n            this.zoomResetDomainMenuItem = new JMenuItem(\n                    localizationResources.getString("Domain_Axis"));\n            this.zoomResetDomainMenuItem.setActionCommand(\n                    ZOOM_RESET_DOMAIN_COMMAND);\n            this.zoomResetDomainMenuItem.addActionListener(this);\n            autoRangeMenu.add(this.zoomResetDomainMenuItem);\n\n            this.zoomResetRangeMenuItem = new JMenuItem(\n                    localizationResources.getString("Range_Axis"));\n            this.zoomResetRangeMenuItem.setActionCommand(\n                    ZOOM_RESET_RANGE_COMMAND);\n            this.zoomResetRangeMenuItem.addActionListener(this);\n            autoRangeMenu.add(this.zoomResetRangeMenuItem);\n\n            result.addSeparator();\n            result.add(autoRangeMenu);\n\n        }\n\n        return result;\n\n    }
1000	public int allocateShapeId(EscherDgRecord dg, boolean sort) {\n        final short drawingGroupId = dg.getDrawingGroupId();\n        field_3_numShapesSaved++;\n        \n                                FileIdCluster ficAdd = null;\n        int index = 1;\n        for (FileIdCluster fic : field_5_fileIdClusters) {\n            if (fic.getDrawingGroupId() == drawingGroupId\n                && fic.getNumShapeIdsUsed() < 1024) {\n                ficAdd = fic;\n                break;\n            }\n            index++;\n        }\n\n        if (ficAdd == null) {\n            ficAdd = addCluster( drawingGroupId, 0, sort );\n            maxDgId = Math.max(maxDgId, drawingGroupId);\n        }\n        \n        int shapeId = index*1024 + ficAdd.getNumShapeIdsUsed();\n        ficAdd.incrementUsedShapeId();\n        \n        dg.setNumShapes( dg.getNumShapes() + 1 );\n        dg.setLastMSOSPID( shapeId );\n        field_1_shapeIdMax = Math.max(field_1_shapeIdMax, shapeId + 1);\n        \n        return shapeId;\n    }
1001	private static CharSequence replaceIgnoreCase(CharSequence string,\n      CharSequence sequence1, CharSequence escapeChar, Locale locale) {\n    if (escapeChar == null || sequence1 == null || string == null)\n      throw new NullPointerException();\n\n        int count = string.length();\n    int sequence1Length = sequence1.length();\n    if (sequence1Length == 0) {\n      StringBuilder result = new StringBuilder((count + 1)\n          * escapeChar.length());\n      result.append(escapeChar);\n      for (int i = 0; i < count; i++) {\n        result.append(string.charAt(i));\n        result.append(escapeChar);\n      }\n      return result.toString();\n    }\n\n        StringBuilder result = new StringBuilder();\n    char first = sequence1.charAt(0);\n    int start = 0, copyStart = 0, firstIndex;\n    while (start < count) {\n      if ((firstIndex = string.toString().toLowerCase(locale).indexOf(first,\n          start)) == -1)\n        break;\n      boolean found = true;\n      if (sequence1.length() > 1) {\n        if (firstIndex + sequence1Length > count)\n          break;\n        for (int i = 1; i < sequence1Length; i++) {\n          if (string.toString().toLowerCase(locale).charAt(firstIndex + i) != sequence1\n              .charAt(i)) {\n            found = false;\n            break;\n          }\n        }\n      }\n      if (found) {\n        result.append(string.toString().substring(copyStart, firstIndex));\n        result.append(escapeChar);\n        result.append(string.toString().substring(firstIndex,\n            firstIndex + sequence1Length));\n        copyStart = start = firstIndex + sequence1Length;\n      } else {\n        start = firstIndex + 1;\n      }\n    }\n    if (result.length() == 0 && copyStart == 0)\n      return string;\n    result.append(string.toString().substring(copyStart));\n    return result.toString();\n  }
1002	public float hyperbolicTf(float freq) {\n    if (0.0f == freq) return 0.0f;\n\n    final float min = tf_hyper_min;\n    final float max = tf_hyper_max;\n    final double base = tf_hyper_base;\n    final float xoffset = tf_hyper_xoffset;\n    final double x = (double)(freq - xoffset);\n  \n    final float result = min +\n      (float)(\n              (max-min) / 2.0f\n              *\n              (\n               ( ( Math.pow(base,x) - Math.pow(base,-x) )\n                 / ( Math.pow(base,x) + Math.pow(base,-x) )\n                 )\n               + 1.0d\n               )\n              );\n\n    return Float.isNaN(result) ? max : result;\n    \n  }
1003	public void processSheet(\n            Styles styles,\n            SharedStrings strings,\n            SheetContentsHandler sheetHandler, \n            InputStream sheetInputStream) throws IOException, SAXException {\n        DataFormatter formatter = new DataFormatter();\n        InputSource sheetSource = new InputSource(sheetInputStream);\n        try {\n            XMLReader sheetParser = SAXHelper.newXMLReader();\n            ContentHandler handler = new XSSFSheetXMLHandler(\n                  styles, null, strings, sheetHandler, formatter, false);\n            sheetParser.setContentHandler(handler);\n            sheetParser.parse(sheetSource);\n         } catch(ParserConfigurationException e) {\n            throw new RuntimeException("SAX parser appears to be broken - " + e.getMessage());\n         }\n    }
1004	public Borders getBorderRight() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getRight();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
1005	@Beta\n    public XSSFPivotTable createPivotTable(AreaReference source, CellReference position){\n        final String sourceSheetName = source.getFirstCell().getSheetName();\n        if(sourceSheetName != null && !sourceSheetName.equalsIgnoreCase(this.getSheetName())) {\n            final XSSFSheet sourceSheet = getWorkbook().getSheet(sourceSheetName);\n            return createPivotTable(source, position, sourceSheet);\n        }\n        return createPivotTable(source, position, this);\n    }
1006	public InputStream getData() {\n        if (isCompressed()) {\n            int size = LittleEndian.getInt(_data);\n\n            InputStream compressedStream = new ByteArrayInputStream(_data, 4, _data.length);\n            return new BoundedInputStream(new InflaterInputStream(compressedStream), size);\n        } else {\n            return new ByteArrayInputStream(_data, 0, _data.length);\n        }\n    }
1007	@Beta\n    protected void createCacheFields(Sheet sheet) {\n                AreaReference ar = getPivotArea(sheet.getWorkbook());\n        CellReference firstCell = ar.getFirstCell();\n        CellReference lastCell = ar.getLastCell();\n        int columnStart = firstCell.getCol();\n        int columnEnd = lastCell.getCol();\n        Row row = sheet.getRow(firstCell.getRow());\n        CTCacheFields cFields;\n        if(ctPivotCacheDefinition.getCacheFields() != null) {\n            cFields = ctPivotCacheDefinition.getCacheFields();\n        } else {\n            cFields = ctPivotCacheDefinition.addNewCacheFields();\n        }\n                for(int i=columnStart; i<=columnEnd; i++) {\n            CTCacheField cf = cFields.addNewCacheField();\n            if(i==columnEnd){\n                cFields.setCount(cFields.sizeOfCacheFieldArray());\n            }\n                        cf.setNumFmtId(0);\n            Cell cell = row.getCell(i);\n            cell.setCellType(CellType.STRING);\n            cf.setName(row.getCell(i).getStringCellValue());\n            cf.addNewSharedItems();\n        }\n    }
1008	void syncWithDataSource() throws IOException {\n       int blocksUsed = 0;\n       for (BATBlock sbat : _sbat_blocks) {\n          ByteBuffer block = _filesystem.getBlockAt(sbat.getOurBlockIndex());\n          sbat.writeData(block);\n\n          if (!sbat.hasFreeSectors()) {\n              blocksUsed += _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\n          } else {\n              blocksUsed += sbat.getUsedSectors(false);\n          }\n       }\n                     _filesystem._get_property_table().getRoot().setSize(blocksUsed);\n    }
1009	public DrawingManager2 findDrawingGroup() {\n        if(drawingManager != null) {\n                      return drawingManager;\n        }\n\n                for(Record r : records.getRecords() ) {\n            if (!(r instanceof DrawingGroupRecord)) {\n                continue;\n            }\n            DrawingGroupRecord dg = (DrawingGroupRecord)r;\n            dg.processChildRecords();\n            drawingManager = findDrawingManager(dg, escherBSERecords);\n            if (drawingManager != null) {\n                return drawingManager;\n            }\n        }\n\n                        DrawingGroupRecord dg = (DrawingGroupRecord)findFirstRecordBySid(DrawingGroupRecord.sid);\n        drawingManager = findDrawingManager(dg, escherBSERecords);\n        return drawingManager;\n    }
1010	public static void main(final String[] args) {\n        PropertyIDMap s1 = getSummaryInformationProperties();\n        PropertyIDMap s2 = getDocumentSummaryInformationProperties();\n        System.out.println("s1: " + s1);\n        System.out.println("s2: " + s2);\n    }
1011	boolean requiresEviction() {\n    assert lock.isHeldByCurrentThread();\n    final int size = mostRecentlyUsedQueries.size();\n    if (size == 0) {\n      return false;\n    } else {\n      return size > maxSize || ramBytesUsed() > maxRamBytesUsed;\n    }\n  }
1012	private static void copyAttributes(Font font, AttributedString str, @SuppressWarnings("SameParameterValue") int startIdx, int endIdx) {\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\n        str.addAttribute(TextAttribute.SIZE, (float)font.getFontHeightInPoints());\n        if (font.getBold()) str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\n        if (font.getItalic() ) str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\n        if (font.getUnderline() == Font.U_SINGLE ) str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\n    }
1013	void appendCellReference(StringBuilder sb) {\n        if (_colIndex != -1) {\n            if(_isColAbs) {\n                sb.append(ABSOLUTE_REFERENCE_MARKER);\n            }\n            sb.append( convertNumToColString(_colIndex));\n        }\n        if (_rowIndex != -1) {\n            if(_isRowAbs) {\n                sb.append(ABSOLUTE_REFERENCE_MARKER);\n            }\n            sb.append(_rowIndex+1);\n        }\n    }
1014	private Map cloneMarkerMap(Map map) throws CloneNotSupportedException {\n        Map clone = new HashMap();\n        Set keys = map.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Object key = iterator.next();\n            List entry = (List) map.get(key);\n            Object toAdd = ObjectUtilities.deepClone(entry);\n            clone.put(key, toAdd);\n        }\n        return clone;\n    }
1015	private void popCurrentDoc() {\n    assert numSubsOnDoc == 0;\n    assert docIDQueue.size() > 0;\n    subsOnDoc[numSubsOnDoc++] = docIDQueue.pop();\n    docID = subsOnDoc[0].posEnum.docID();\n    while (docIDQueue.size() > 0 && docIDQueue.top().posEnum.docID() == docID) {\n      subsOnDoc[numSubsOnDoc++] = docIDQueue.pop();\n    }\n  }
1016	DocumentEntry createDocument(final POIFSDocument document)\n        throws IOException\n    {\n        DocumentProperty property = document.getDocumentProperty();\n        DocumentNode     rval     = new DocumentNode(property, this);\n\n        (( DirectoryProperty ) getProperty()).addChild(property);\n        _nfilesystem.addDocument(document);\n\n        _entries.add(rval);\n        _byname.put(property.getName(), rval);\n        return rval;\n    }
1017	public static JFreeChart createBoxAndWhiskerChart(String title,\n            String timeAxisLabel, String valueAxisLabel,\n            BoxAndWhiskerXYDataset dataset, boolean legend) {\n\n        ValueAxis timeAxis = new DateAxis(timeAxisLabel);\n        NumberAxis valueAxis = new NumberAxis(valueAxisLabel);\n        valueAxis.setAutoRangeIncludesZero(false);\n        XYBoxAndWhiskerRenderer renderer = new XYBoxAndWhiskerRenderer(10.0);\n        XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, renderer);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
1018	static void updateRowFormulas(XSSFRow row, FormulaShifter formulaShifter) {\n        XSSFSheet sheet = row.getSheet();\n        for (Cell c : row) {\n            XSSFCell cell = (XSSFCell) c;\n\n            CTCell ctCell = cell.getCTCell();\n            if (ctCell.isSetF()) {\n                CTCellFormula f = ctCell.getF();\n                String formula = f.getStringValue();\n                if (formula.length() > 0) {\n                    String shiftedFormula = shiftFormula(row, formula, formulaShifter);\n                    if (shiftedFormula != null) {\n                        f.setStringValue(shiftedFormula);\n                        if(f.getT() == STCellFormulaType.SHARED){\n                            int si = (int)f.getSi();\n                            CTCellFormula sf = sheet.getSharedFormula(si);\n                            sf.setStringValue(shiftedFormula);\n                            updateRefInCTCellFormula(row, formulaShifter, sf);\n                        }\n                    }\n\n                }\n\n                                updateRefInCTCellFormula(row, formulaShifter, f);\n            }\n\n        }\n    }
1019	public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackagePart part) {\n        final PackageRelationship rel = getPackageRelationship(parent, part);\n        final String relType = rel.getRelationshipType();\n        final POIXMLRelation descriptor = getDescriptor(relType);\n\n                        if (descriptor == null || descriptor.getRelationClass() == null || POIXMLDocument.PACK_OBJECT_REL_TYPE.equals(relType)) {\n            LOGGER.log(POILogger.DEBUG, "using default POIXMLDocumentPart for " + rel.getRelationshipType());\n            return new POIXMLDocumentPart(parent, part);\n        }\n\n        Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();\n        try {\n            try {\n                return createDocumentPart(cls, PARENT_PART, new Object[]{parent, part});\n            } catch (NoSuchMethodException e) {\n                return createDocumentPart(cls, ORPHAN_PART, new Object[]{part});\n            }\n        } catch (Exception e) {\n            throw new POIXMLException((e.getCause() != null ? e.getCause() : e).getMessage(), e);\n        }\n    }
1020	public static Query newPrefixQuery(String field, InetAddress value, int prefixLength) {\n    if (value == null) {\n      throw new IllegalArgumentException("InetAddress must not be null");\n    }\n    if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {\n      throw new IllegalArgumentException("illegal prefixLength '" + prefixLength + "'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges");\n    }\n        byte lower[] = value.getAddress();\n    byte upper[] = value.getAddress();\n    for (int i = prefixLength; i < 8 * lower.length; i++) {\n      int m = 1 << (7 - (i & 7));\n      lower[i >> 3] &= ~m;\n      upper[i >> 3] |= m;\n    }\n    try {\n      return newRangeQuery(field, InetAddress.getByAddress(lower), InetAddress.getByAddress(upper));\n    } catch (UnknownHostException e) {\n      throw new AssertionError(e);     }\n  }
1021	public Trie optimize(Trie orig) {\n    List<CharSequence> cmds = orig.cmds;\n    List<Row> rows = new ArrayList<>();\n    List<Row> orows = orig.rows;\n    int remap[] = new int[orows.size()];\n    \n    Arrays.fill(remap, -1);\n    rows = removeGaps(orig.root, rows, new ArrayList<Row>(), remap);\n    \n    return new Trie(orig.forward, remap[orig.root], cmds, rows);\n  }
1022	public int normalize(char text[], int len) {\n    for (int i = 0; i < len; i++) {\n      final Character.UnicodeBlock block = Character.UnicodeBlock.of(text[i]);\n      final ScriptData sd = scripts.get(block);\n      if (sd != null) {\n        final int ch = text[i] - sd.base;\n        if (sd.decompMask.get(ch))\n          len = compose(ch, block, sd, text, i, len);\n      }\n    }\n    return len;\n  }
1023	public void validateMinimum() {\n        double newMin;\n        try {\n            newMin = Double.parseDouble(this.minimumRangeValue.getText());\n            if (newMin >= this.maximumValue) {\n                newMin = this.minimumValue;\n            }\n        }\n        catch (NumberFormatException e) {\n            newMin = this.minimumValue;\n        }\n\n        this.minimumValue = newMin;\n        this.minimumRangeValue.setText(Double.toString(this.minimumValue));\n    }
1024	public void setDimensions(int firstrow, short firstcol, int lastrow, short lastcol)\n    {\n        if (log.check( POILogger.DEBUG ))\n        {\n            log.log(POILogger.DEBUG, "Sheet.setDimensions");\n            log.log(POILogger.DEBUG,\n                    (new StringBuffer("firstrow")).append(firstrow)\n                        .append("firstcol").append(firstcol).append("lastrow")\n                        .append(lastrow).append("lastcol").append(lastcol)\n                        .toString());\n        }\n        _dimensions.setFirstCol(firstcol);\n        _dimensions.setFirstRow(firstrow);\n        _dimensions.setLastCol(lastcol);\n        _dimensions.setLastRow(lastrow);\n        if (log.check( POILogger.DEBUG ))\n            log.log(POILogger.DEBUG, "Sheet.setDimensions exiting");\n    }
1025	private int removeArticle(final char s[], final int len) {\n    if (len > 6 && endsWith(s, len, "ият"))\n      return len - 3;\n    \n    if (len > 5) {\n      if (endsWith(s, len, "ът") ||\n          endsWith(s, len, "то") ||\n          endsWith(s, len, "те") ||\n          endsWith(s, len, "та") ||\n          endsWith(s, len, "ия"))\n        return len - 2;\n    }\n    \n    if (len > 4 && endsWith(s, len, "ят"))\n      return len - 2;\n\n    return len;\n  }
1026	public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled("IW")) {\n      infoStream.message("IW", "forceMergeDeletes: index now " + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException("this writer hit an unrecoverable error; cannot complete forceMergeDeletes", tragedy);\n          }\n\n                                        running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException("background merge hit exception: " + merge.segString(), t);\n            }\n          }\n\n                    if (running)\n            doWait();\n        }\n      }\n    }\n\n              }
1027	public NRShape toRangeShape(UnitNRShape startUnit, UnitNRShape endUnit) {\n            startUnit = startUnit.getShapeAtLevel(truncateStartVals(startUnit, 0));     endUnit = endUnit.getShapeAtLevel(truncateEndVals(endUnit, 0));         int cmp = comparePrefix(startUnit, endUnit);\n    if (cmp > 0) {\n      throw new IllegalArgumentException("Wrong order: "+ startUnit +" TO "+ endUnit);\n    }\n    if (cmp == 0) {      if (startUnit.getLevel() == endUnit.getLevel()) {\n                return startUnit;\n      } else if (endUnit.getLevel() > startUnit.getLevel()) {\n                if (truncateStartVals(endUnit, startUnit.getLevel()) == startUnit.getLevel()) {\n          return endUnit;\n        }\n      } else {                if (truncateEndVals(startUnit, endUnit.getLevel()) == endUnit.getLevel()) {\n          return startUnit;\n        }\n      }\n    }\n    return new SpanUnitsNRShape(startUnit, endUnit);\n  }
1028	public static int findLiveItemsUpperBound(XYDataset dataset, int series,\n            double xLow, double xHigh) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        if (xLow >= xHigh) {\n            throw new IllegalArgumentException("Requires xLow < xHigh.");\n        }\n        int itemCount = dataset.getItemCount(series);\n        if (itemCount <= 1) {\n            return 0;\n        }\n        if (dataset.getDomainOrder() == DomainOrder.ASCENDING) {\n            int low = 0;\n            int high = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue > xHigh) {\n                return low;\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue <= xHigh) {\n                return high;\n            }\n            int mid = (low + high) / 2;\n            while (high - low > 1) {\n                double midV = dataset.getXValue(series, mid);\n                if (midV <= xHigh) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n                mid = (low + high) / 2;\n            }\n            return mid;\n        }\n        else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) {\n                                    int low = 0;\n            int high = itemCount - 1;\n            int mid = (low + high) / 2;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue < xLow) {\n                return low;\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue >= xLow) {\n                return high;\n            }\n            while (high - low > 1) {\n                double midV = dataset.getXValue(series, mid);\n                if (midV >= xLow) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n                mid = (low + high) / 2;\n            }\n            return mid;\n        }\n        else {\n                                                int index = itemCount - 1;\n                        double x = dataset.getXValue(series, index);\n            while (index >= 0 && x > xHigh) {\n                index--;\n                if (index >= 0) {\n                    x = dataset.getXValue(series, index);\n                }\n            }\n            return Math.max(index, 0);\n        }\n    }
1029	public int putAll(K key, Collection<? extends V> vals) {\n    final Set<V> theSet;\n    if (theMap.containsKey(key)) {\n      theSet = theMap.get(key);\n    } else {\n      theSet = new HashSet<>(23);\n      theMap.put(key, theSet);\n    }\n    theSet.addAll(vals);\n    return theSet.size();\n  }
1030	public static HSLFSlideShowImpl create() {\n        InputStream is = HSLFSlideShowImpl.class.getResourceAsStream("/org/apache/poi/hslf/data/empty.ppt");\n        if (is == null) {\n            throw new HSLFException("Missing resource 'empty.ppt'");\n        }\n        try {\n            try {\n                return new HSLFSlideShowImpl(is);\n            } finally {\n                is.close();\n            }\n        } catch (IOException e) {\n            throw new HSLFException(e);\n        }\n    }
1031	@SuppressWarnings("fallthrough")\n  private void createAnalysisPipelineComponent\n      (StreamTokenizer stok, Class<? extends AbstractAnalysisFactory> clazz) {\n    Map<String,String> argMap = new HashMap<>();\n    boolean parenthetical = false;\n    try {\n      WHILE_LOOP: while (stok.nextToken() != StreamTokenizer.TT_EOF) {\n        switch (stok.ttype) {\n          case ',': {\n            if (parenthetical) {\n                            break;\n            } else {\n                            break WHILE_LOOP;\n            }\n          }\n          case '(': {\n            if (parenthetical) {\n              throw new RuntimeException\n                  ("Line #" + lineno(stok) + ": Unexpected opening parenthesis.");\n            }\n            parenthetical = true;\n            break;\n          }\n          case ')': {\n            if (parenthetical) {\n              parenthetical = false;\n            } else {\n              throw new RuntimeException\n                  ("Line #" + lineno(stok) + ": Unexpected closing parenthesis.");\n            }\n            break;\n          }\n          case StreamTokenizer.TT_WORD: {\n            if ( ! parenthetical) {\n              throw new RuntimeException("Line #" + lineno(stok) + ": Unexpected token '" + stok.sval + "'");\n            }\n            String argName = stok.sval;\n            stok.nextToken();\n            if (stok.ttype != ':') {\n              throw new RuntimeException\n                  ("Line #" + lineno(stok) + ": Missing ':' after '" + argName + "' param to " + clazz.getSimpleName());\n            }\n            stok.nextToken();\n            String argValue = stok.sval;\n            switch (stok.ttype) {\n              case StreamTokenizer.TT_NUMBER: {\n                  argValue = Double.toString(stok.nval);\n                                    argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst("");\n                                }\n              case '"':\n              case '\'':\n              case StreamTokenizer.TT_WORD: {\n                argMap.put(argName, argValue);\n                break;\n              }\n              case StreamTokenizer.TT_EOF: {\n                throw new RuntimeException("Unexpected EOF: " + stok.toString());\n              }\n              default: {\n                throw new RuntimeException\n                    ("Line #" + lineno(stok) + ": Unexpected token: " + stok.toString());\n              }\n            }\n          }\n        }\n      }\n      if (!argMap.containsKey("luceneMatchVersion")) {\n        argMap.put("luceneMatchVersion", Version.LATEST.toString());\n      }\n      final AbstractAnalysisFactory instance;\n      try {\n        instance = clazz.getConstructor(Map.class).newInstance(argMap);\n      } catch (Exception e) {\n        throw new RuntimeException("Line #" + lineno(stok) + ": ", e);\n      }\n      if (instance instanceof ResourceLoaderAware) {\n        Path baseDir = Paths.get(getRunData().getConfig().get("work.dir", "work"));\n        if (!Files.isDirectory(baseDir)) {\n          baseDir = Paths.get(".");\n        }\n        ((ResourceLoaderAware)instance).inform(new FilesystemResourceLoader(baseDir));\n      }\n      if (CharFilterFactory.class.isAssignableFrom(clazz)) {\n        charFilterFactories.add((CharFilterFactory)instance);\n      } else if (TokenizerFactory.class.isAssignableFrom(clazz)) {\n        tokenizerFactory = (TokenizerFactory)instance;\n      } else if (TokenFilterFactory.class.isAssignableFrom(clazz)) {\n        tokenFilterFactories.add((TokenFilterFactory)instance);\n      }\n    } catch (RuntimeException e) {\n      if (e.getMessage().startsWith("Line #")) {\n        throw (e);\n      } else {\n        throw new RuntimeException("Line #" + lineno(stok) + ": ", e);\n      }\n    } catch (Throwable t) {\n      throw new RuntimeException("Line #" + lineno(stok) + ": ", t);\n    }\n  }
1032	private int[][] toIndexArray(Map<Integer, int[]> input) {\n    ArrayList<int[]> result = new ArrayList<>();\n    for (int i : input.keySet()) {\n      int[] wordIdAndLength = input.get(i);\n      int wordId = wordIdAndLength[0];\n            int current = i;\n      for (int j = 1; j < wordIdAndLength.length; j++) {         int[] token = { wordId + j - 1, current, wordIdAndLength[j] };\n        result.add(token);\n        current += wordIdAndLength[j];\n      }\n    }\n    return result.toArray(new int[result.size()][]);\n  }
1033	public void walkEscherBasic(int indent, int pos, int len) throws IOException {\n	if(len < 8) { return; }\n\n	final String ind = (indent == 0) ? "%1$s" : "%1$"+indent+"s";\n\n	long type = LittleEndian.getUShort(docstream,pos+2);\n	long atomlen = LittleEndian.getUInt(docstream,pos+4);\n\n	String fmt = ind+"At position %2$d ($2$04x): type is %3$d (%3$04x), len is %4$d (%4$04x)";\n	out.println(String.format(Locale.ROOT, fmt, "", pos, type, atomlen));\n\n	String typeName = RecordTypes.forTypeID((short)type).name();\n	out.println(String.format(Locale.ROOT, ind+"%2$s", "That's an Escher Record: ", typeName));\n\n		if(type == 61453L) {\n			    HexDump.dump(docstream, 0, out, pos+8, 8);\n	    HexDump.dump(docstream, 0, out, pos+20, 8);\n		out.println();\n	}\n\n\n		out.println();\n\n		if(type == 61443L || type == 61444L) {\n		walkEscherBasic((indent+3), pos+8, (int)atomlen);\n	}\n\n		if(atomlen < len) {\n		int atomleni = (int)atomlen;\n		walkEscherBasic(indent, pos+atomleni+8, len-atomleni-8);\n	}\n  }
1034	Query makeEquals(Rectangle bbox) {\n\n        Query qMinX = makeNumberTermQuery(field_minX, bbox.getMinX());\n    Query qMinY = makeNumberTermQuery(field_minY, bbox.getMinY());\n    Query qMaxX = makeNumberTermQuery(field_maxX, bbox.getMaxX());\n    Query qMaxY = makeNumberTermQuery(field_maxY, bbox.getMaxY());\n    return makeQuery(BooleanClause.Occur.MUST, qMinX, qMinY, qMaxX, qMaxY);\n  }
1035	public static void storeDate(Date date, byte[] dest, int offset) {\n        Calendar cal = LocaleUtil.getLocaleCalendar();\n        cal.setTime(date);\n\n        LittleEndian.putShort(dest, offset + 0, (short) cal.get(Calendar.YEAR));\n        LittleEndian.putShort(dest, offset + 2, (short)(cal.get(Calendar.MONTH) + 1));\n        LittleEndian.putShort(dest, offset + 4, (short)(cal.get(Calendar.DAY_OF_WEEK)-1));\n        LittleEndian.putShort(dest, offset + 6, (short) cal.get(Calendar.DAY_OF_MONTH));\n        LittleEndian.putShort(dest, offset + 8, (short) cal.get(Calendar.HOUR_OF_DAY));\n        LittleEndian.putShort(dest, offset + 10,(short) cal.get(Calendar.MINUTE));\n        LittleEndian.putShort(dest, offset + 12,(short) cal.get(Calendar.SECOND));\n        LittleEndian.putShort(dest, offset + 14,(short) cal.get(Calendar.MILLISECOND));\n	}
1036	public void update(Observable observable, Object localeObj) {\n        if (!(localeObj instanceof Locale))  return;\n        Locale newLocale = (Locale)localeObj;\n        if (!localeIsAdapting || newLocale.equals(locale)) return;\n        \n        locale = newLocale;\n        \n        dateSymbols = DateFormatSymbols.getInstance(locale);\n        decimalSymbols = DecimalFormatSymbols.getInstance(locale);\n        generalNumberFormat = new ExcelGeneralNumberFormat(locale);\n\n                defaultDateformat = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", dateSymbols);\n        defaultDateformat.setTimeZone(LocaleUtil.getUserTimeZone());       \n\n        \n        formats.clear();\n        Format zipFormat = ZipPlusFourFormat.instance;\n        addFormat("00000\\-0000", zipFormat);\n        addFormat("00000-0000", zipFormat);\n\n        Format phoneFormat = PhoneFormat.instance;\n                addFormat("[<=9999999]###\\-####;\\(###\\)\\ ###\\-####", phoneFormat);\n        addFormat("[<=9999999]###-####;(###) ###-####", phoneFormat);\n        addFormat("###\\-####;\\(###\\)\\ ###\\-####", phoneFormat);\n        addFormat("###-####;(###) ###-####", phoneFormat);\n\n        Format ssnFormat = SSNFormat.instance;\n        addFormat("000\\-00\\-0000", ssnFormat);\n        addFormat("000-00-0000", ssnFormat);\n    }
1037	protected void preWrite()\n    {\n        if (_children.size() > 0)\n        {\n            Property[] children = _children.toArray(new Property[ 0 ]);\n\n            Arrays.sort(children, new PropertyComparator());\n            int midpoint = children.length / 2;\n\n            setChildProperty(children[ midpoint ].getIndex());\n            children[ 0 ].setPreviousChild(null);\n            children[ 0 ].setNextChild(null);\n            for (int j = 1; j < midpoint; j++)\n            {\n                children[ j ].setPreviousChild(children[ j - 1 ]);\n                children[ j ].setNextChild(null);\n            }\n            if (midpoint != 0)\n            {\n                children[ midpoint ]\n                    .setPreviousChild(children[ midpoint - 1 ]);\n            }\n            if (midpoint != (children.length - 1))\n            {\n                children[ midpoint ].setNextChild(children[ midpoint + 1 ]);\n                for (int j = midpoint + 1; j < children.length - 1; j++)\n                {\n                    children[ j ].setPreviousChild(null);\n                    children[ j ].setNextChild(children[ j + 1 ]);\n                }\n                children[ children.length - 1 ].setPreviousChild(null);\n                children[ children.length - 1 ].setNextChild(null);\n            }\n            else\n            {\n                children[ midpoint ].setNextChild(null);\n            }\n        }\n    }
1038	public void setValueWithMask(int val, int writeMask) {\n	    setWriteMask(writeMask);\n	    super.setValue(maskValue(val));\n	    if (val != super.getValue()) {\n	        logger.log(POILogger.WARN, "Style properties of '"+getName()+"' don't match mask - output will be sanitized");\n	        if (logger.check(POILogger.DEBUG)) {\n	            StringBuilder sb = new StringBuilder("The following style attributes of the '"+getName()+"' property will be ignored:\n");\n	            int i=0;\n	            for (int mask : subPropMasks) {\n	                if (!subPropMatches[i] && (val & mask) != 0) {\n	                    sb.append(subPropNames[i]).append(",");\n	                }\n	                i++;\n	            }\n	            logger.log(POILogger.DEBUG, sb.toString());\n	        }\n	    }\n	}
1039	public void updateCrosshairPoint(Comparable rowKey, Comparable columnKey,\n            double value, int datasetIndex, double transX, double transY,\n            PlotOrientation orientation) {\n\n        Point2D anchor = getAnchor();\n        if (anchor != null) {\n            double xx = anchor.getX();\n            double yy = anchor.getY();\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double temp = yy;\n                yy = xx;\n                xx = temp;\n            }\n            double d = (transX - xx) * (transX - xx)\n                    + (transY - yy) * (transY - yy);\n\n            if (d < getCrosshairDistance()) {\n                this.rowKey = rowKey;\n                this.columnKey = columnKey;\n                setCrosshairY(value);\n                setDatasetIndex(datasetIndex);\n                setCrosshairDistance(d);\n            }\n        }\n\n    }
1040	public void validate(SpreadsheetVersion ssVersion) {\n		validateRow(_firstRow, ssVersion);\n		validateRow(_lastRow, ssVersion);\n		validateColumn(_firstCol, ssVersion);\n		validateColumn(_lastCol, ssVersion);\n	}
1041	protected final void addAllDocVectors(Fields vectors, MergeState mergeState) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      finishDocument();\n      return;\n    }\n\n    int numFields = vectors.size();\n    if (numFields == -1) {\n            numFields = 0;\n      for (final Iterator<String> it = vectors.iterator(); it.hasNext(); ) {\n        it.next();\n        numFields++;\n      }\n    }\n    startDocument(numFields);\n    \n    String lastFieldName = null;\n    \n    TermsEnum termsEnum = null;\n    PostingsEnum docsAndPositionsEnum = null;\n    \n    int fieldCount = 0;\n    for(String fieldName : vectors) {\n      fieldCount++;\n      final FieldInfo fieldInfo = mergeState.mergeFieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: "lastFieldName=" + lastFieldName + " fieldName=" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = vectors.terms(fieldName);\n      if (terms == null) {\n                continue;\n      }\n      \n      final boolean hasPositions = terms.hasPositions();\n      final boolean hasOffsets = terms.hasOffsets();\n      final boolean hasPayloads = terms.hasPayloads();\n      assert !hasPayloads || hasPositions;\n      \n      int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n                numTerms = 0;\n        termsEnum = terms.iterator();\n        while(termsEnum.next() != null) {\n          numTerms++;\n        }\n      }\n      \n      startField(fieldInfo, numTerms, hasPositions, hasOffsets, hasPayloads);\n      termsEnum = terms.iterator();\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n        \n        startTerm(termsEnum.term(), freq);\n\n        if (hasPositions || hasOffsets) {\n          docsAndPositionsEnum = termsEnum.postings(docsAndPositionsEnum, PostingsEnum.OFFSETS | PostingsEnum.PAYLOADS);\n          assert docsAndPositionsEnum != null;\n          \n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            \n            final BytesRef payload = docsAndPositionsEnum.getPayload();\n\n            assert !hasPositions || pos >= 0 ;\n            addPosition(pos, startOffset, endOffset, payload);\n          }\n        }\n        finishTerm();\n      }\n      assert termCount == numTerms;\n      finishField();\n    }\n    assert fieldCount == numFields;\n    finishDocument();\n  }
1042	public Borders getBorderTop() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getTop();\n        }\n        STBorder.Enum ptrn = (ct != null) ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
1043	public static String dump(final byte [] data, final long offset, final int index, final int length) {\n        if (data == null || data.length == 0) {\n            return "No Data"+EOL;\n        }\n\n        int data_length = (length == Integer.MAX_VALUE || length < 0 || index+length < 0)\n            ? data.length\n            : Math.min(data.length,index+length);\n        \n        \n        if ((index < 0) || (index >= data.length)) {\n            String err = "illegal index: "+index+" into array of length "+data.length;\n            throw new ArrayIndexOutOfBoundsException(err);\n        }\n        \n        long  display_offset = offset + index;\n        StringBuilder buffer = new StringBuilder(74);\n        \n        for (int j = index; j < data_length; j += 16) {\n            int chars_read = data_length - j;\n\n            if (chars_read > 16) {\n                chars_read = 16;\n            }\n            \n            writeHex(buffer, display_offset, 8, "");\n            for (int k = 0; k < 16; k++) {\n                if (k < chars_read) {\n                    writeHex(buffer, data[ k + j ], 2, " ");\n                } else {\n                    buffer.append("   ");\n                }\n            }\n            buffer.append(' ');\n            for (int k = 0; k < chars_read; k++) {\n                buffer.append(toAscii(data[ k + j ]));\n            }\n            buffer.append(EOL);\n            display_offset += chars_read;\n        }\n        return buffer.toString();\n    }
1044	public static List<String> compare(Workbook wb1, Workbook wb2) {\n        Locator loc1 = new Locator();\n        Locator loc2 = new Locator();\n        loc1.workbook = wb1;\n        loc2.workbook = wb2;\n\n        ExcelComparator excelComparator = new ExcelComparator();\n        excelComparator.compareNumberOfSheets(loc1, loc2 );\n        excelComparator.compareSheetNames(loc1, loc2);\n        excelComparator.compareSheetData(loc1, loc2);\n\n        return excelComparator.listOfDifferences;\n    }
1045	private static void writeCopyState(CopyState state, DataOutput out) throws IOException {\n        out.writeVInt(state.infosBytes.length);\n    out.writeBytes(state.infosBytes, 0, state.infosBytes.length);\n    out.writeVLong(state.gen);\n    out.writeVLong(state.version);\n    SimpleServer.writeFilesMetaData(out, state.files);\n\n    out.writeVInt(state.completedMergeFiles.size());\n    for(String fileName : state.completedMergeFiles) {\n      out.writeString(fileName);\n    }\n    out.writeVLong(state.primaryGen);\n  }
1046	protected Range findDomainBoundsWithOffset(IntervalXYDataset dataset) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getStartXValue(series, item);\n                uvalue = dataset.getEndXValue(series, item);\n                double offset = (uvalue - lvalue) / 2.0;\n                lvalue = lvalue - offset;\n                uvalue = uvalue - offset;\n                minimum = Math.min(minimum, lvalue);\n                maximum = Math.max(maximum, uvalue);\n            }\n        }\n\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }
1047	public void sortTopLeftToBottomRight() {\n        if (getFirstRow() > getLastRow()) {\n                                    final int firstRow = getFirstRow();\n            final boolean firstRowRel = isFirstRowRelative();\n            setFirstRow(getLastRow());\n            setFirstRowRelative(isLastRowRelative());\n            setLastRow(firstRow);\n            setLastRowRelative(firstRowRel);\n        }\n        if (getFirstColumn() > getLastColumn()) {\n                                    final int firstCol = getFirstColumn();\n            final boolean firstColRel = isFirstColRelative();\n            setFirstColumn(getLastColumn());\n            setFirstColRelative(isLastColRelative());\n            setLastColumn(firstCol);\n            setLastColRelative(firstColRel);\n        }\n    }
1048	public Writer createWriter(File fd) throws IOException {\n        FileOutputStream fos = new FileOutputStream(fd);\n        OutputStream decorated;\n        try {\n            decorated = decorateOutputStream(fos);\n        } catch (final IOException e) {\n            fos.close();\n            throw e;\n        }\n        return new BufferedWriter(\n                new OutputStreamWriter(decorated, "UTF-8"));\n    }
1049	public static void assertVocabulary(Analyzer a, InputStream voc, InputStream out)\n  throws IOException {\n    BufferedReader vocReader = new BufferedReader(\n        new InputStreamReader(voc, StandardCharsets.UTF_8));\n    BufferedReader outputReader = new BufferedReader(\n        new InputStreamReader(out, StandardCharsets.UTF_8));\n    String inputWord = null;\n    while ((inputWord = vocReader.readLine()) != null) {\n      String expectedWord = outputReader.readLine();\n      Assert.assertNotNull(expectedWord);\n      BaseTokenStreamTestCase.checkOneTerm(a, inputWord, expectedWord);\n    }\n  }
1050	public int normalize(char s[], int len) {\n    for (int i = 0; i < len; i++) {\n      switch (s[i]) {\n        case YEH:\n        case DOTLESS_YEH:\n          s[i] = FARSI_YEH;\n          break;\n        case KAF:\n          s[i] = KEHEH;\n          break;\n        case ZWNJ:\n          if (i > 0 && s[i-1] == HEH) {\n            s[i-1] = AE;\n          }\n          len = delete(s, i, len);\n          i--;\n          break;\n        case HEH:\n          if (i == len-1) {\n            s[i] = AE;\n          }\n          break;\n        case TEH_MARBUTA:\n          s[i] = AE;\n          break;\n        case HEH_DOACHASHMEE:\n          s[i] = HEH;\n          break;\n        case REH:\n          if (i == 0) {\n            s[i] = RREH;\n          }\n          break;\n        case RREH_ABOVE:\n          s[i] = RREH;\n          break;\n        case TATWEEL:\n        case KASRATAN:\n        case DAMMATAN:\n        case FATHATAN:\n        case FATHA:\n        case DAMMA:\n        case KASRA:\n        case SHADDA:\n        case SUKUN:\n          len = delete(s, i, len);\n          i--;\n          break;\n        default:\n          if (Character.getType(s[i]) == Character.FORMAT) {\n            len = delete(s, i, len);\n            i--;\n          }\n      }\n    }\n    return len;\n  }
1051	public boolean removeEndnote(int pos) {\n        if (ctEndnotes.sizeOfEndnoteArray() >= pos - 1) {\n            ctEndnotes.removeEndnote(pos);\n            listFootnote.remove(pos);\n            return true;\n        } else {\n            return false;\n        }\n    }
1052	private boolean updateOutlierList(OutlierList list, Outlier outlier) {\n        boolean result = false;\n        result = list.add(outlier);\n        list.updateAveragedOutlier();\n        list.setMultiple(true);\n        return result;\n    }
1053	public static void main(String args[]) throws IOException\n	{\n		if(args.length < 1) {\n			System.err.println("Useage:");\n			System.err.println("\tQuickButCruddyTextExtractor <file>");\n			System.exit(1);\n		}\n\n		String file = args[0];\n\n		QuickButCruddyTextExtractor ppe = new QuickButCruddyTextExtractor(file);\n		System.out.println(ppe.getTextAsString());\n		ppe.close();\n	}
1054	public Query parse(String queryText) {\n    if ("*".equals(queryText.trim())) {\n      return new MatchAllDocsQuery();\n    }\n\n    char data[] = queryText.toCharArray();\n    char buffer[] = new char[data.length];\n\n    State state = new State(data, buffer, 0, data.length);\n    parseSubQuery(state);\n    if (state.top == null) {\n      return new MatchNoDocsQuery("empty string passed to query parser");\n    } else {\n      return state.top;\n    }\n  }
1055	private void initSections() {\n		if (!_sectionRangeFound) {\n			int[] point = findRange(_sections, _sectionStart, _start, _end);\n			_sectionStart = point[0];\n			_sectionEnd = point[1];\n			_sectionRangeFound = true;\n		}\n	}
1056	public void finishTerm() throws IOException {\n    int numArcs = 0;\n    int numDedupBytes = 1;\n    analyzed.grow(analyzed.length() + 1);\n    analyzed.setLength(analyzed.length() + 1);\n    for (Entry entry : entries) {\n      if (numArcs == maxNumArcsForDedupByte(numDedupBytes)) {\n        analyzed.setByteAt(analyzed.length() - 1, (byte) (numArcs));\n        analyzed.grow(analyzed.length() + 1);\n        analyzed.setLength(analyzed.length() + 1);\n        numArcs = 0;\n        numDedupBytes++;\n      }\n      analyzed.setByteAt(analyzed.length() - 1, (byte) numArcs++);\n      Util.toIntsRef(analyzed.get(), scratchInts);\n      builder.add(scratchInts.get(), outputs.newPair(entry.weight, entry.payload));\n    }\n    maxAnalyzedPathsPerOutput = Math.max(maxAnalyzedPathsPerOutput, entries.size());\n    entries.clear();\n  }
1057	public static void checkHits(\n        Random random,\n        Query query,\n        String defaultFieldName,\n        IndexSearcher searcher,\n        int[] results)\n          throws IOException {\n\n    ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n\n    Set<Integer> correct = new TreeSet<>();\n    for (int i = 0; i < results.length; i++) {\n      correct.add(Integer.valueOf(results[i]));\n    }\n\n    Set<Integer> actual = new TreeSet<>();\n    for (int i = 0; i < hits.length; i++) {\n      actual.add(Integer.valueOf(hits[i].doc));\n    }\n\n    Assert.assertEquals(query.toString(defaultFieldName), correct, actual);\n\n    QueryUtils.check(random, query,searcher, LuceneTestCase.rarely(random));\n  }
1058	public static double irr(double[] values, double guess) {\n        final int maxIterationCount = 20;\n        final double absoluteAccuracy = 1E-7;\n\n        double x0 = guess;\n        double x1;\n\n        int i = 0;\n        while (i < maxIterationCount) {\n\n                        final double factor = 1.0 + x0;\n            int k = 0;\n            double fValue = values[k];\n            double fDerivative = 0;\n            for (double denominator = factor; ++k < values.length; ) {\n                final double value = values[k];\n                fValue += value / denominator;\n                denominator *= factor;\n                fDerivative -= k * value / denominator;\n            }\n\n                        x1 = x0 - fValue/fDerivative;\n\n            if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n                return x1;\n            }\n\n            x0 = x1;\n            ++i;\n        }\n                return Double.NaN;\n    }
1059	protected void drawRightLabels(KeyedValues keys, Graphics2D g2,\n                                   Rectangle2D plotArea, Rectangle2D linkArea,\n                                   float maxLabelWidth, PiePlotState state) {\n\n                this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n\n        for (int i = 0; i < keys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, keys.getKey(i));\n\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label,\n                        this.labelFont, this.labelPaint, maxLabelWidth,\n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                if (this.shadowGenerator == null) {\n                    labelBox.setShadowPaint(this.labelShadowPaint);\n                }\n                else {\n                    labelBox.setShadowPaint(null);\n                }\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(keys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY()\n                              - Math.sin(theta) * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        keys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * Math.cos(theta),\n                        1.0 - getLabelLinkDepth()\n                        + getExplodePercent(keys.getKey(i))));\n            }\n        }\n        double hh = plotArea.getHeight();\n        double gap = 0.00;         this.labelDistributor.distributeLabels(plotArea.getMinY() + gap,\n                hh - 2 * gap);\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawRightLabel(g2, state,\n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n\n    }
1060	private static void encode(final InetAddress min, final InetAddress max, final byte[] bytes) {\n        final byte[] minEncoded = InetAddressPoint.encode(min);\n    final byte[] maxEncoded = InetAddressPoint.encode(max);\n        if (StringHelper.compare(BYTES, minEncoded, 0, maxEncoded, 0) > 0) {\n      throw new IllegalArgumentException("min value cannot be greater than max value for InetAddressRange field");\n    }\n    System.arraycopy(minEncoded, 0, bytes, 0, BYTES);\n    System.arraycopy(maxEncoded, 0, bytes, BYTES, BYTES);\n  }
1061	private double createCoefficient(IndexSearcher searcher, int doc, Set<String> matchedTokens, String prefixToken) throws IOException {\n\n    Terms tv = searcher.getIndexReader().getTermVector(doc, TEXT_FIELD_NAME);\n    TermsEnum it = tv.iterator();\n\n    Integer position = Integer.MAX_VALUE;\n    BytesRef term;\n        while ((term = it.next()) != null) {\n\n      String docTerm = term.utf8ToString();\n\n      if (matchedTokens.contains(docTerm) || (prefixToken != null && docTerm.startsWith(prefixToken))) {\n \n        PostingsEnum docPosEnum = it.postings(null, PostingsEnum.OFFSETS);\n        docPosEnum.nextDoc();\n\n                int p = docPosEnum.nextPosition();\n        if (p < position) {\n          position = p;\n        }\n      }\n    }\n\n        return calculateCoefficient(position);\n  }
1062	protected int pastDaysOfWeek(double start, double end, int dayOfWeek) {\n        int pastDaysOfWeek = 0;\n        int startDay = (int) Math.floor(start < end ? start : end);\n        int endDay = (int) Math.floor(end > start ? end : start);\n        for (; startDay <= endDay; startDay++) {\n            Calendar today = LocaleUtil.getLocaleCalendar();\n            today.setTime(DateUtil.getJavaDate(startDay));\n            if (today.get(Calendar.DAY_OF_WEEK) == dayOfWeek) {\n                pastDaysOfWeek++;\n            }\n        }\n        return start <= end ? pastDaysOfWeek : -pastDaysOfWeek;\n    }
1063	public int doCheck(Options opts) throws IOException, InterruptedException {\n    setCrossCheckTermVectors(opts.doCrossCheckTermVectors);\n    setChecksumsOnly(opts.doChecksumsOnly);\n    setInfoStream(opts.out, opts.verbose);\n\n    Status result = checkIndex(opts.onlySegments);\n    if (result.missingSegments) {\n      return 1;\n    }\n\n    if (!result.clean) {\n      if (!opts.doExorcise) {\n        opts.out.println("WARNING: would write new segments file, and " + result.totLoseDocCount + " documents would be lost, if -exorcise were specified\n");\n      } else {\n        opts.out.println("WARNING: " + result.totLoseDocCount + " documents will be lost\n");\n        opts.out.println("NOTE: will write new segments file in 5 seconds; this will remove " + result.totLoseDocCount + " docs from the index. YOU WILL LOSE DATA. THIS IS YOUR LAST CHANCE TO CTRL+C!");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          opts.out.println("  " + (5-s) + "...");\n        }\n        opts.out.println("Writing...");\n        exorciseIndex(result);\n        opts.out.println("OK");\n        opts.out.println("Wrote new segments file \"" + result.newSegments.getSegmentsFileName() + "\"");\n      }\n    }\n    opts.out.println("");\n\n    if (result.clean == true) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }
1064	private String encodeUtf(String text) {\n        if(text == null) {\n            return null;\n        }\n\n        StringBuilder builder = new StringBuilder();\n        for(char c : text.toCharArray()) {\n                        if(c < 32) {\n                builder.append("_x").append(c < 16 ? "000" : "00").append(Integer.toHexString(c)).append("_");\n            } else {\n                builder.append(c);\n            }\n        }\n\n        return builder.toString();\n    }
1065	public static String pathToString(String dim, String[] path) {\n    String[] fullPath = new String[1+path.length];\n    fullPath[0] = dim;\n    System.arraycopy(path, 0, fullPath, 1, path.length);\n    return pathToString(fullPath, fullPath.length);\n  }
1066	public static DVConstraint createNumericConstraint(int validationType, int comparisonOperator, \n			String expr1, String expr2) {\n		switch (validationType) {\n			case ValidationType.ANY:\n				if (expr1 != null || expr2 != null) {\n					throw new IllegalArgumentException("expr1 and expr2 must be null for validation type 'any'");\n				}\n				break;\n			case ValidationType.DECIMAL:\n			case ValidationType.INTEGER:\n			case ValidationType.TEXT_LENGTH:\n				if (expr1 == null) {\n					throw new IllegalArgumentException("expr1 must be supplied");\n				}\n				OperatorType.validateSecondArg(comparisonOperator, expr2);\n				break;\n			default:\n				throw new IllegalArgumentException("Validation Type ("\n						+ validationType + ") not supported with this method");\n		}\n				String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertNumber(expr1) : null;\n				String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertNumber(expr2) : null;\n		return new DVConstraint(validationType, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
1067	public void process() throws IOException {\n		MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener(this);\n		formatListener = new FormatTrackingHSSFListener(listener);\n\n		HSSFEventFactory factory = new HSSFEventFactory();\n		HSSFRequest request = new HSSFRequest();\n\n		if(outputFormulaValues) {\n			request.addListenerForAllRecords(formatListener);\n		} else {\n			workbookBuildingListener = new SheetRecordCollectingListener(formatListener);\n			request.addListenerForAllRecords(workbookBuildingListener);\n		}\n\n		factory.processWorkbookEvents(request, fs);\n	}
1068	public void walkEscherDDF(int indent, int pos, int len) {\n	if(len < 8) { return; }\n\n	final String ind = (indent == 0) ? "%1$s" : "%1$"+indent+"s";\n\n	byte[] contents = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n	System.arraycopy(docstream,pos,contents,0,len);\n	DefaultEscherRecordFactory erf = new HSLFEscherRecordFactory();\n	EscherRecord record = erf.createRecord(contents,0);\n\n		record.fillFields(contents,0,erf);\n\n	long atomType = LittleEndian.getUShort(contents,2);\n		long atomLen = LittleEndian.getUShort(contents,4);\n		int recordLen = record.getRecordSize();\n\n    String fmt = ind+"At position %2$d (%2$04x): type is %3$d (%3$04x), len is %4$d (%4$04x) (%5$d) - record claims %6$d";\n    out.println(String.format(Locale.ROOT, fmt, "", pos, atomType, atomLen, atomLen+8, recordLen));\n	\n	\n		if(recordLen != 8 && (recordLen != (atomLen+8))) {\n		out.println(String.format(Locale.ROOT, ind+"** Atom length of $2d ($3d) doesn't match record length of %4d", "", atomLen, atomLen+8, recordLen));\n	}\n\n	    String recordStr = record.toString().replace("\n", String.format(Locale.ROOT,  "\n"+ind, ""));\n    out.println(String.format(Locale.ROOT, ind+"%2$s", "", recordStr));\n\n    if(record instanceof EscherContainerRecord) {\n		walkEscherDDF((indent+3), pos + 8, (int)atomLen );\n	}\n\n		if(atomType == 61451L) {\n				recordLen = (int)atomLen + 8;\n	}\n	if(atomType == 61453L) {\n				recordLen = (int)atomLen + 8;\n		record.fillFields( contents, 0, erf );\n		if(! (record instanceof EscherTextboxRecord)) {\n			out.println(String.format(Locale.ROOT, ind+"%2$s", "", "** Really a msofbtClientTextbox !"));\n		}\n	}\n\n		if(recordLen == 8 && atomLen > 8 ) {\n				walkEscherDDF((indent+3), pos + 8, (int)atomLen );\n\n				pos += atomLen;\n		pos += 8;\n		len -= atomLen;\n		len -= 8;\n	} else {\n				pos += atomLen;\n		pos += 8;\n		len -= atomLen;\n		len -= 8;\n	}\n\n		if(len >= 8) {\n		walkEscherDDF(indent, pos, len );\n	}\n  }
1069	public void drawRangeLine(Graphics2D g2, CategoryPlot plot, ValueAxis axis,\n            Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {\n\n                        Range range = axis.getRange();\n        if (!range.contains(value)) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        Line2D line = null;\n        double v = axis.valueToJava2D(value, dataArea, plot.getRangeAxisEdge());\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(v, dataArea.getMinY(), v,\n                    dataArea.getMaxY());\n        } else if (orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), v,\n                    dataArea.getMaxX(), v);\n        }\n\n        g2.setPaint(paint);\n        g2.setStroke(stroke);\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        g2.draw(line);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }
1070	protected static CTGraphicalObjectFrame prototype() {\n		if (prototype == null) {\n			CTGraphicalObjectFrame graphicFrame = CTGraphicalObjectFrame.Factory.newInstance();\n\n			CTGraphicalObjectFrameNonVisual nvGraphic = graphicFrame.addNewNvGraphicFramePr();\n			CTNonVisualDrawingProps props = nvGraphic.addNewCNvPr();\n			props.setId(0);\n			props.setName("Diagramm 1");\n			nvGraphic.addNewCNvGraphicFramePr();\n\n			CTTransform2D transform = graphicFrame.addNewXfrm();\n			CTPositiveSize2D extPoint = transform.addNewExt();\n			CTPoint2D offPoint = transform.addNewOff();\n\n			extPoint.setCx(0);\n			extPoint.setCy(0);\n			offPoint.setX(0);\n			offPoint.setY(0);\n\n			 graphicFrame.addNewGraphic();\n\n			prototype = graphicFrame;\n		}\n		return prototype;\n	}
1071	public static JFreeChart createXYBarChart(String title, String xAxisLabel,\n            boolean dateAxis, String yAxisLabel, IntervalXYDataset dataset,\n            PlotOrientation orientation, boolean legend, boolean tooltips,\n            boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        ValueAxis domainAxis;\n        if (dateAxis) {\n            domainAxis = new DateAxis(xAxisLabel);\n        }\n        else {\n            NumberAxis axis = new NumberAxis(xAxisLabel);\n            axis.setAutoRangeIncludesZero(false);\n            domainAxis = axis;\n        }\n        ValueAxis valueAxis = new NumberAxis(yAxisLabel);\n\n        XYBarRenderer renderer = new XYBarRenderer();\n        if (tooltips) {\n            XYToolTipGenerator tt;\n            if (dateAxis) {\n                tt = StandardXYToolTipGenerator.getTimeSeriesInstance();\n            }\n            else {\n                tt = new StandardXYToolTipGenerator();\n            }\n            renderer.setBaseToolTipGenerator(tt);\n        }\n        if (urls) {\n            renderer.setURLGenerator(new StandardXYURLGenerator());\n        }\n\n        XYPlot plot = new XYPlot(dataset, domainAxis, valueAxis, renderer);\n        plot.setOrientation(orientation);\n\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
1072	public boolean stem(char[] wordBuffer, int offset, int wordLen) {\n    reset();\n    if (b.length < wordLen) {\n      b = new char[ArrayUtil.oversize(wordLen, Character.BYTES)];\n    }\n    System.arraycopy(wordBuffer, offset, b, 0, wordLen);\n    i = wordLen;\n    return stem(0);\n  }
1073	public boolean removeRow(int pos) throws IndexOutOfBoundsException {\n        if (pos >= 0 && pos < tableRows.size()) {\n            if (ctTbl.sizeOfTrArray() > 0) {\n                ctTbl.removeTr(pos);\n            }\n            tableRows.remove(pos);\n            return true;\n        }\n        return false;\n    }
1074	public void write() throws IOException {\n        POIFSFileSystem fs = getDirectory().getFileSystem();\n        \n        validateInPlaceWritePossible();        \n        writeProperties(fs, null);\n        fs.writeFilesystem();\n    }
1075	private static Object clone(Object object) {\n        if (object == null) {\n            return null;\n        }\n        Class c = object.getClass();\n        Object result = null;\n        try {\n            Method m = c.getMethod("clone", (Class[]) null);\n            if (Modifier.isPublic(m.getModifiers())) {\n                try {\n                    result = m.invoke(object, (Object[]) null);\n                }\n                catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        catch (NoSuchMethodException e) {\n            result = object;\n        }\n        return result;\n    }
1076	public synchronized void setMaxMergesAndThreads(int maxMergeCount, int maxThreadCount) {\n    if (maxMergeCount == AUTO_DETECT_MERGES_AND_THREADS && maxThreadCount == AUTO_DETECT_MERGES_AND_THREADS) {\n            this.maxMergeCount = AUTO_DETECT_MERGES_AND_THREADS;\n      this.maxThreadCount = AUTO_DETECT_MERGES_AND_THREADS;\n    } else if (maxMergeCount == AUTO_DETECT_MERGES_AND_THREADS) {\n      throw new IllegalArgumentException("both maxMergeCount and maxThreadCount must be AUTO_DETECT_MERGES_AND_THREADS");\n    } else if (maxThreadCount == AUTO_DETECT_MERGES_AND_THREADS) {\n      throw new IllegalArgumentException("both maxMergeCount and maxThreadCount must be AUTO_DETECT_MERGES_AND_THREADS");\n    } else {\n      if (maxThreadCount < 1) {\n        throw new IllegalArgumentException("maxThreadCount should be at least 1");\n      }\n      if (maxMergeCount < 1) {\n        throw new IllegalArgumentException("maxMergeCount should be at least 1");\n      }\n      if (maxThreadCount > maxMergeCount) {\n        throw new IllegalArgumentException("maxThreadCount should be <= maxMergeCount (= " + maxMergeCount + ")");\n      }\n      this.maxThreadCount = maxThreadCount;\n      this.maxMergeCount = maxMergeCount;\n    }\n  }
1077	private static String[] split(String text, String separator, int max)\n    {\n        StringTokenizer tok = new StringTokenizer(text, separator);\n        int listSize = tok.countTokens();\n        if(max != -1 && listSize > max)\n            listSize = max;\n        String list[] = new String[listSize];\n        for(int i = 0; tok.hasMoreTokens(); i++)\n        {\n            if(max != -1 && i == listSize - 1)\n            {\n                StringBuffer buf = new StringBuffer((text.length() * (listSize - i)) / listSize);\n                while(tok.hasMoreTokens())\n                {\n                    buf.append(tok.nextToken());\n                    if(tok.hasMoreTokens())\n                        buf.append(separator);\n                }\n                list[i] = buf.toString().trim();\n                break;\n            }\n            list[i] = tok.nextToken().trim();\n        }\n\n        return list;\n    }
1078	protected double findMaximumTickLabelWidth(List ticks, Graphics2D g2,\n            Rectangle2D drawArea, boolean vertical) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        Font font = getTickLabelFont();\n        double maxWidth = 0.0;\n        if (!vertical) {\n            FontMetrics fm = g2.getFontMetrics(font);\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                Tick tick = (Tick) iterator.next();\n                Rectangle2D labelBounds = null;\n                if (tick instanceof LogTick) {\n                    LogTick lt = (LogTick) tick;\n                    if (lt.getAttributedLabel() != null) {\n                        labelBounds = AttrStringUtils.getTextBounds(\n                                lt.getAttributedLabel(), g2);\n                    }\n                } else if (tick.getText() != null) {\n                    labelBounds = TextUtilities.getTextBounds(tick.getText(), \n                            g2, fm);\n                }\n                if (labelBounds != null \n                        && labelBounds.getWidth() + insets.getLeft()\n                        + insets.getRight() > maxWidth) {\n                    maxWidth = labelBounds.getWidth()\n                               + insets.getLeft() + insets.getRight();\n                }\n            }\n        } else {\n            LineMetrics metrics = font.getLineMetrics("ABCxyz",\n                    g2.getFontRenderContext());\n            maxWidth = metrics.getHeight()\n                       + insets.getTop() + insets.getBottom();\n        }\n        return maxWidth;\n\n    }
1079	protected static OPCPackage newPackage(XSSFWorkbookType workbookType) {\n        try {\n            OPCPackage pkg = OPCPackage.create(new ByteArrayOutputStream());                            PackagePartName corePartName = PackagingURIHelper.createPartName(XSSFRelation.WORKBOOK.getDefaultFileName());\n                        pkg.addRelationship(corePartName, TargetMode.INTERNAL, PackageRelationshipTypes.CORE_DOCUMENT);\n                        pkg.createPart(corePartName, workbookType.getContentType());\n\n            pkg.getPackageProperties().setCreatorProperty(DOCUMENT_CREATOR);\n\n            return pkg;\n        } catch (Exception e){\n            throw new POIXMLException(e);\n        }\n    }
1080	public void addListener(HSSFListener lsnr, short sid) {\n		List<HSSFListener> list = _records.get(Short.valueOf(sid));\n\n		if (list == null) {\n			list = new ArrayList<>(1); 			_records.put(Short.valueOf(sid), list);\n		}\n		list.add(lsnr);\n	}
1081	public static boolean canComputeColumnWidth(Font font) {\n                AttributedString str = new AttributedString("1w");\n        copyAttributes(font, str, 0, "1w".length());\n\n        TextLayout layout = new TextLayout(str.getIterator(), fontRenderContext);\n        return (layout.getBounds().getWidth() > 0);\n    }
1082	public TernaryTreeNode insert(TernaryTreeNode currentNode, CharSequence s,\n          Object val, int x) {\n    if (s == null || s.length() <= x) {\n      return currentNode;\n    }\n    if (currentNode == null) {\n      TernaryTreeNode newNode = new TernaryTreeNode();\n      newNode.splitchar = s.charAt(x);\n      currentNode = newNode;\n      if (x < s.length() - 1) {\n        currentNode.eqKid = insert(currentNode.eqKid, s, val, x + 1);\n      } else {\n        currentNode.token = s.toString();\n        currentNode.val = val;\n        return currentNode;\n      }\n    } else if (currentNode.splitchar > s.charAt(x)) {\n      currentNode.loKid = insert(currentNode.loKid, s, val, x);\n    } else if (currentNode.splitchar == s.charAt(x)) {\n      if (x < s.length() - 1) {\n        currentNode.eqKid = insert(currentNode.eqKid, s, val, x + 1);\n      } else {\n        currentNode.token = s.toString();\n        currentNode.val = val;\n        return currentNode;\n      }\n    } else {\n      currentNode.hiKid = insert(currentNode.hiKid, s, val, x);\n    }\n    return currentNode;\n  }
1083	public XSLFSlide createSlide(XSLFSlideLayout layout) {\n        int slideNumber = 256, cnt = 1;\n        CTSlideIdList slideList;\n        XSLFRelation relationType = XSLFRelation.SLIDE;\n        if (!_presentation.isSetSldIdLst()) {\n            slideList = _presentation.addNewSldIdLst();\n        } else {\n            slideList = _presentation.getSldIdLst();\n            for (CTSlideIdListEntry slideId : slideList.getSldIdArray()) {\n                slideNumber = (int) Math.max(slideId.getId() + 1, slideNumber);\n                cnt++;\n            }\n\n            cnt = findNextAvailableFileNameIndex(relationType, cnt);\n        }\n\n        RelationPart rp = createRelationship\n                (relationType, XSLFFactory.getInstance(), cnt, false);\n        XSLFSlide slide = rp.getDocumentPart();\n\n        CTSlideIdListEntry slideId = slideList.addNewSldId();\n        slideId.setId(slideNumber);\n        slideId.setId2(rp.getRelationship().getId());\n\n        layout.copyLayout(slide);\n        slide.getPackagePart().clearRelationships();\n        slide.addRelation(null, XSLFRelation.SLIDE_LAYOUT, layout);\n\n        _slides.add(slide);\n        return slide;\n    }
1084	protected Explanation explain(Weight weight, int doc) throws IOException {\n    int n = ReaderUtil.subIndex(doc, leafContexts);\n    final LeafReaderContext ctx = leafContexts.get(n);\n    int deBasedDoc = doc - ctx.docBase;\n    final Bits liveDocs = ctx.reader().getLiveDocs();\n    if (liveDocs != null && liveDocs.get(deBasedDoc) == false) {\n      return Explanation.noMatch("Document " + doc + " is deleted");\n    }\n    return weight.explain(ctx, deBasedDoc);\n  }
1085	public final int getRecordSize() {\n		ContinuableRecordOutput out = ContinuableRecordOutput.createForCountingOnly();\n		serialize(out);\n		out.terminate();\n		return out.getTotalSize();\n	}
1086	public static Record buildRecordAtOffset(byte[] b, int offset) {\n		long type = LittleEndian.getUShort(b,offset+2);\n		long rlen = LittleEndian.getUInt(b,offset+4);\n\n				int rleni = (int)rlen;\n		if(rleni < 0) { rleni = 0; }\n\n		return createRecordForType(type,b,offset,8+rleni);\n	}
1087	public static XMLInputFactory newXMLInputFactory() {\n        XMLInputFactory factory = XMLInputFactory.newFactory();\n        trySetProperty(factory, XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        trySetProperty(factory, XMLInputFactory.IS_VALIDATING, false);\n        trySetProperty(factory, XMLInputFactory.SUPPORT_DTD, false);\n        trySetProperty(factory, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        return factory;\n    }
1088	public int put(K key, V val) {\n    final Set<V> theSet;\n    if (theMap.containsKey(key)) {\n      theSet = theMap.get(key);\n    } else {\n      theSet = new HashSet<>(23);\n      theMap.put(key, theSet);\n    }\n    theSet.add(val);\n    return theSet.size();\n  }
1089	private CharsetDecoder getJavaEncoding(String encoding) {\n    if ("ISO8859-14".equals(encoding)) {\n      return new ISO8859_14Decoder();\n    }\n    String canon = CHARSET_ALIASES.get(encoding);\n    if (canon != null) {\n      encoding = canon;\n    }\n    Charset charset = Charset.forName(encoding);\n    return charset.newDecoder().onMalformedInput(CodingErrorAction.REPLACE);\n  }
1090	public void read(final POIFSFileSystem poifs) throws IOException {\n        registryClosed = true;\n\n                PropertyTable properties = poifs.getPropertyTable();\n\n                RootProperty root = properties.getRoot();\n        processProperties(poifs, root, new POIFSDocumentPath());\n    }
1091	private Range calculateYDataRange(float[][] data) {\n\n        Range result = null;\n        if (data != null) {\n            float lowest = Float.POSITIVE_INFINITY;\n            float highest = Float.NEGATIVE_INFINITY;\n            for (int i = 0; i < data[0].length; i++) {\n                float v = data[1][i];\n                if (v < lowest) {\n                    lowest = v;\n                }\n                if (v > highest) {\n                    highest = v;\n                }\n            }\n            if (lowest <= highest) {\n                result = new Range(lowest, highest);\n            }\n        }\n        return result;\n\n    }
1092	private static SimpleFraction buildFractionMaxDenominator(double value, double epsilon, int maxDenominator, int maxIterations)\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)Math.floor(r0);\n        if (a0 > overflow) {\n            throw new IllegalArgumentException("Overflow trying to convert "+value+" to fraction ("+a0+"/"+1l+")");\n        }\n\n                        if (Math.abs(a0 - value) < epsilon) {\n            return new SimpleFraction((int)a0, 1);\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2;\n        long q2;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)Math.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n                        if (epsilon == 0.0f && maxDenominator > 0 && Math.abs(q2) > maxDenominator &&\n                    Math.abs(q1) < maxDenominator){\n\n                return new SimpleFraction((int)p1, (int)q1);\n            }\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new RuntimeException("Overflow trying to convert "+value+" to fraction ("+p2+"/"+q2+")");\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new RuntimeException("Unable to convert "+value+" to fraction after "+maxIterations+" iterations");\n        }\n\n        if (q2 < maxDenominator) {\n            return new SimpleFraction((int) p2, (int)q2);\n        } else {\n            return new SimpleFraction((int)p1, (int)q1);\n        }\n\n    }
1093	public void commit() throws IOException {\n\n        if(extPart == null && ext != null && ext.props != null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n            try {\n                PackagePartName prtname = PackagingURIHelper.createPartName("/docProps/app.xml");\n                pkg.addRelationship(prtname, TargetMode.INTERNAL, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties");\n                extPart = pkg.createPart(prtname, "application/vnd.openxmlformats-officedocument.extended-properties+xml");\n            } catch (InvalidFormatException e){\n                throw new POIXMLException(e);\n            }\n        }\n        if(custPart == null && cust != null && cust.props != null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n            try {\n                PackagePartName prtname = PackagingURIHelper.createPartName("/docProps/custom.xml");\n                pkg.addRelationship(prtname, TargetMode.INTERNAL, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties");\n                custPart = pkg.createPart(prtname, "application/vnd.openxmlformats-officedocument.custom-properties+xml");\n            } catch (InvalidFormatException e){\n                throw new POIXMLException(e);\n            }\n        }\n        if(extPart != null){\n            try (OutputStream out = extPart.getOutputStream()) {\n                if (extPart.getSize() > 0) {\n                    extPart.clear();\n                }\n                ext.props.save(out, DEFAULT_XML_OPTIONS);\n            }\n        }\n        if(custPart != null){\n            try (OutputStream out = custPart.getOutputStream()) {\n                cust.props.save(out, DEFAULT_XML_OPTIONS);\n            }\n        }\n    }
1094	public SharedValueRecordBase getRecordForFirstCell(FormulaRecordAggregate agg) {\n		CellReference firstCell = agg.getFormulaRecord().getFormula().getExpReference();\n						if (firstCell == null) {\n						return null;\n		}\n\n\n		int row = firstCell.getRow();\n		int column = firstCell.getCol();\n		if (agg.getRow() != row || agg.getColumn() != column) {\n						return null;\n		}\n\n        if(!_groupsBySharedFormulaRecord.isEmpty()) {\n            SharedFormulaGroup sfg = findFormulaGroupForCell(firstCell);\n            if(null != sfg) {\n                return sfg.getSFR();\n            }\n        }\n\n						\n		for (TableRecord tr : _tableRecords) {\n			if (tr.isFirstCell(row, column)) {\n				return tr;\n			}\n		}\n		for (ArrayRecord ar : _arrayRecords) {\n			if (ar.isFirstCell(row, column)) {\n				return ar;\n			}\n		}\n		return null;\n	}
1095	private void isCellBorderMatches(Locator loc1, Locator loc2, char borderSide) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        XSSFCellStyle style1 = ((XSSFCell)loc1.cell).getCellStyle();\n        XSSFCellStyle style2 = ((XSSFCell)loc2.cell).getCellStyle();\n        boolean b1, b2;\n        String borderName;\n        switch (borderSide) {\n            case 't': default:\n                b1 = style1.getBorderTop() == BorderStyle.THIN;\n                b2 = style2.getBorderTop() == BorderStyle.THIN;\n                borderName = "TOP";\n                break;\n            case 'b':\n                b1 = style1.getBorderBottom() == BorderStyle.THIN;\n                b2 = style2.getBorderBottom() == BorderStyle.THIN;\n                borderName = "BOTTOM";\n                break;\n            case 'l':\n                b1 = style1.getBorderLeft() == BorderStyle.THIN;\n                b2 = style2.getBorderLeft() == BorderStyle.THIN;\n                borderName = "LEFT";\n                break;\n            case 'r':\n                b1 = style1.getBorderRight() == BorderStyle.THIN;\n                b2 = style2.getBorderRight() == BorderStyle.THIN;\n                borderName = "RIGHT";\n                break;\n        }\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                "Cell Border Attributes does not Match ::",\n                (b1 ? "" : "NOT ")+borderName+" BORDER",\n                (b2 ? "" : "NOT ")+borderName+" BORDER"\n            );\n        }\n    }
1096	protected int isGeoAreaShapeInsideShape(final GeoShape geoshape)  {\n    boolean foundOutside = false;\n    boolean foundInside = false;\n    for (GeoPoint p : getEdgePoints()) {\n      if (geoshape.isWithin(p)) {\n        foundInside = true;\n      } else {\n        foundOutside = true;\n      }\n      if (foundInside && foundOutside) {\n        return SOME_INSIDE;\n      }\n    }\n    if (!foundInside && !foundOutside)\n      return NONE_INSIDE;\n    if (foundInside && !foundOutside)\n      return ALL_INSIDE;\n    if (foundOutside && !foundInside)\n      return NONE_INSIDE;\n    return SOME_INSIDE;\n  }
1097	protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        Size2D s = arrangeFN(container, g2, constraint);\n        if (constraint.getHeightRange().contains(s.height)) {\n            return s;\n        }\n        else {\n            RectangleConstraint c = constraint.toFixedHeight(\n                constraint.getHeightRange().constrain(s.getHeight())\n            );\n            return arrangeFF(container, g2, c);\n        }\n    }
1098	private int writeHidden(RowRecord pRowRecord, int row) {\n        int rowIx = row;\n        RowRecord rowRecord = pRowRecord;\n        int level = rowRecord.getOutlineLevel();\n        while (rowRecord != null && getRow(rowIx).getOutlineLevel() >= level) {\n            rowRecord.setZeroHeight(true);\n            rowIx++;\n            rowRecord = getRow(rowIx);\n        }\n        return rowIx;\n    }
1099	public void add(long v) throws IOException {\n    if (v < previous) {\n      throw new IllegalArgumentException("Values do not come in order: " + previous + ", " + v);\n    }\n    if (bufferSize == buffer.length) {\n      flush();\n    }\n    buffer[bufferSize++] = v;\n    previous = v;\n    count++;\n  }
1100	public static Workbook create(final DirectoryNode root, String password) throws IOException {\n                if (root.hasEntry(Decryptor.DEFAULT_POIFS_ENTRY)) {\n            InputStream stream = null;\n            try {\n                stream = DocumentFactoryHelper.getDecryptedStream(root, password);\n\n                return createXSSFWorkbook(stream);\n            } finally {\n                IOUtils.closeQuietly(stream);\n\n                                                root.getFileSystem().close();\n            }\n        }\n\n                        boolean passwordSet = false;\n        if (password != null) {\n            Biff8EncryptionKey.setCurrentUserPassword(password);\n            passwordSet = true;\n        }\n        try {\n            return createHSSFWorkbook(root);\n        } finally {\n            if (passwordSet) {\n                Biff8EncryptionKey.setCurrentUserPassword(null);\n            }\n        }\n    }
1101	private String removeStringDelimiters(String key) {\n        String k = key.trim();\n        if (k.charAt(0) == this.textDelimiter) {\n            k = k.substring(1);\n        }\n        if (k.charAt(k.length() - 1) == this.textDelimiter) {\n            k = k.substring(0, k.length() - 1);\n        }\n        return k;\n    }
1102	private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n                    arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n        if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n                  assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    \n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n            arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n                int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n                    return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n        readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n                              if (arc.label == labelToMatch) {\n                return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }
1103	protected static Record[] normalizeRecords(Record records[]) {\n                \n        UserEditAtom uea = null;\n        PersistPtrHolder pph = null;\n        TreeMap<Integer,Integer> slideLocations = new TreeMap<>();\n        TreeMap<Integer,Record> recordMap = new TreeMap<>();\n        List<Integer> obsoleteOffsets = new ArrayList<>();\n        int duplicatedCount = 0;\n        for (Record r : records) {\n            assert(r instanceof PositionDependentRecord);\n            PositionDependentRecord pdr = (PositionDependentRecord)r;\n            if (pdr instanceof UserEditAtom) {\n                uea = (UserEditAtom)pdr;\n                continue;\n            }\n\n            if (pdr instanceof PersistPtrHolder) {\n                if (pph != null) {\n                    duplicatedCount++;\n                }\n                pph = (PersistPtrHolder)pdr;\n                for (Map.Entry<Integer,Integer> me : pph.getSlideLocationsLookup().entrySet()) {\n                    Integer oldOffset = slideLocations.put(me.getKey(), me.getValue());\n                    if (oldOffset != null) {\n                        obsoleteOffsets.add(oldOffset);\n                    }\n                }\n                continue;\n            }\n\n            recordMap.put(pdr.getLastOnDiskOffset(), r);\n        }\n\n        if (uea == null || pph == null || uea.getPersistPointersOffset() != pph.getLastOnDiskOffset()) {\n            throw new EncryptedDocumentException("UserEditAtom and PersistPtrHolder must exist and their offset need to match.");\n        }\n\n        recordMap.put(pph.getLastOnDiskOffset(), pph);\n        recordMap.put(uea.getLastOnDiskOffset(), uea);\n\n        if (duplicatedCount == 0 && obsoleteOffsets.isEmpty()) {\n            return records;\n        }\n\n        uea.setLastUserEditAtomOffset(0);\n        pph.clear();\n        for (Map.Entry<Integer,Integer> me : slideLocations.entrySet()) {\n            pph.addSlideLookup(me.getKey(), me.getValue());\n        }\n\n        for (Integer oldOffset : obsoleteOffsets) {\n            recordMap.remove(oldOffset);\n        }\n\n        return recordMap.values().toArray(new Record[recordMap.size()]);\n    }
1104	public byte[] read(final byte[] src, final int offset) {\n        \n        bytes[0] = src[3 + offset];\n        bytes[1] = src[2 + offset];\n        bytes[2] = src[1 + offset];\n        bytes[3] = src[0 + offset];\n\n        \n        bytes[4] = src[5 + offset];\n        bytes[5] = src[4 + offset];\n\n        \n        bytes[6] = src[7 + offset];\n        bytes[7] = src[6 + offset];\n\n        \n        System.arraycopy(src, 8 + offset, bytes, 8, 8);\n\n        return bytes;\n    }
1105	public static double product(double[] values) {\n        double product = 0;\n        if (values!=null && values.length > 0) {\n            product = 1;\n            for (int i=0, iSize=values.length; i<iSize; i++) {\n                product *= values[i];\n            }\n        }\n        return product;\n    }
1106	public void doSaveAs() throws IOException {\n        JFileChooser fileChooser = new JFileChooser();\n        fileChooser.setCurrentDirectory(this.defaultDirectoryForSaveAs);\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\n                    localizationResources.getString("PNG_Image_Files"), "png");\n        fileChooser.addChoosableFileFilter(filter);\n        fileChooser.setFileFilter(filter);\n\n        int option = fileChooser.showSaveDialog(this);\n        if (option == JFileChooser.APPROVE_OPTION) {\n            String filename = fileChooser.getSelectedFile().getPath();\n            if (isEnforceFileExtensions()) {\n                if (!filename.endsWith(".png")) {\n                    filename = filename + ".png";\n                }\n            }\n            ChartUtilities.saveChartAsPNG(new File(filename), this.chart,\n                    getWidth(), getHeight());\n        }\n    }
1107	public static String pathToString(String[] path, int length) {\n    if (length == 0) {\n      return "";\n    }\n    StringBuilder sb = new StringBuilder();\n    for(int i=0;i<length;i++) {\n      String s = path[i];\n      if (s.length() == 0) {\n        throw new IllegalArgumentException("each path component must have length > 0 (got: \"\")");\n      }\n      int numChars = s.length();\n      for(int j=0;j<numChars;j++) {\n        char ch = s.charAt(j);\n        if (ch == DELIM_CHAR || ch == ESCAPE_CHAR) {\n          sb.append(ESCAPE_CHAR);\n        }\n        sb.append(ch);\n      }\n      sb.append(DELIM_CHAR);\n    }\n\n        sb.setLength(sb.length()-1);\n    return sb.toString();\n  }
1108	boolean stem(char[] term, int len) {\n    \n    result = null;\n    \n    k = len - 1;\n    if ((k <= 1) || (k >= MaxWordLen - 1)) {\n      return false;     }\n    \n            DictEntry entry = dict_ht.get(term, 0, len);\n    if (entry != null) {\n      if (entry.root != null) {\n        result = entry.root;\n        return true;\n      }\n      return false;\n    }\n    \n    \n    \n    word.reset();\n        word.reserve(len + 10);\n    for (int i = 0; i < len; i++) {\n      char ch = term[i];\n      if (!isAlpha(ch)) return false;                   word.unsafeWrite(ch);\n    }\n    \n    matchedEntry = null;\n    \n    \n    \n    while (true) {\n                  plural();\n      if (matched()) break;\n      pastTense();\n      if (matched()) break;\n      aspect();\n      if (matched()) break;\n      ityEndings();\n      if (matched()) break;\n      nessEndings();\n      if (matched()) break;\n      ionEndings();\n      if (matched()) break;\n      erAndOrEndings();\n      if (matched()) break;\n      lyEndings();\n      if (matched()) break;\n      alEndings();\n      if (matched()) break;\n      entry = wordInDict();\n      iveEndings();\n      if (matched()) break;\n      izeEndings();\n      if (matched()) break;\n      mentEndings();\n      if (matched()) break;\n      bleEndings();\n      if (matched()) break;\n      ismEndings();\n      if (matched()) break;\n      icEndings();\n      if (matched()) break;\n      ncyEndings();\n      if (matched()) break;\n      nceEndings();\n      matched();\n      break;\n    }\n    \n    \n    entry = matchedEntry;\n    if (entry != null) {\n      result = entry.root;     }\n    \n    \n    \n    "CASE:"","\n    \n        return true;\n  }
1109	private void generatePart(boolean isSingleWord) {\n    clearAttributes();\n    termAttribute.copyBuffer(savedBuffer, iterator.current, iterator.end - iterator.current);\n    int startOffset = savedStartOffset + iterator.current;\n    int endOffset = savedStartOffset + iterator.end;\n    \n    if (hasIllegalOffsets) {\n                  if (isSingleWord && startOffset <= savedEndOffset) {\n        offsetAttribute.setOffset(startOffset, savedEndOffset);\n      } else {\n        offsetAttribute.setOffset(savedStartOffset, savedEndOffset);\n      }\n    } else {\n      offsetAttribute.setOffset(startOffset, endOffset);\n    }\n    posIncAttribute.setPositionIncrement(position(false));\n    typeAttribute.setType(savedType);\n  }
1110	public void clearDomainCrosshairs() {\n        if (this.xCrosshairs.isEmpty()) {\n            return;          }\n        List crosshairs = getDomainCrosshairs();\n        for (int i = 0; i < crosshairs.size(); i++) {\n            Crosshair c = (Crosshair) crosshairs.get(i);\n            this.xCrosshairs.remove(c);\n            c.removePropertyChangeListener(this);\n        }\n        fireOverlayChanged();\n    }
1111	public void writeInt(int i) throws IOException {\n    writeByte((byte)(i >> 24));\n    writeByte((byte)(i >> 16));\n    writeByte((byte)(i >>  8));\n    writeByte((byte) i);\n  }
1112	public void extractMessageBody(File dest) throws IOException {\n        MAPIAttribute body = getBodyAttribute();\n        if (body == null) {\n            System.err.println("No message body found, " + dest + " not created");\n            return;\n        }\n        if (body instanceof MAPIStringAttribute) {\n            String name = dest.toString();\n            if (name.endsWith(".rtf")) { \n                name = name.substring(0, name.length()-4);\n            }\n            dest = new File(name + ".txt");\n        }\n        \n        OutputStream fout = new FileOutputStream(dest);\n        try {\n            if (body instanceof MAPIStringAttribute) {\n                                String text = ((MAPIStringAttribute)body).getDataString();\n                fout.write(text.getBytes(StringUtil.UTF8));\n            } else {\n                                fout.write(body.getData());\n            }\n        } finally {\n            fout.close();\n        }\n    }
1113	protected <T extends TextProp> T getPropVal(TextPropCollection props, String propName) {\n        String propNames[] = propName.split(",");\n        for (String pn : propNames) {\n            T prop = props.findByName(pn);\n            if (isValidProp(prop)) {\n                return prop;\n            }\n        }\n\n        return getMasterPropVal(props, propName);\n    }
1114	public BigInteger addAbstractNum(XWPFAbstractNum abstractNum) {\n        int pos = abstractNums.size();\n        if (abstractNum.getAbstractNum() != null) {             ctNumbering.addNewAbstractNum().set(abstractNum.getAbstractNum());\n        } else {\n            ctNumbering.addNewAbstractNum();\n            abstractNum.getAbstractNum().setAbstractNumId(BigInteger.valueOf(pos));\n            ctNumbering.setAbstractNumArray(pos, abstractNum.getAbstractNum());\n        }\n        abstractNums.add(abstractNum);\n        return abstractNum.getCTAbstractNum().getAbstractNumId();\n    }
1115	private void write() {\n        int pos = 0;\n        _data = IOUtils.safelyAllocate(indents.size()*6, MAX_RECORD_LENGTH);\n        for (IndentProp prop : indents) {\n            LittleEndian.putInt(_data, pos, prop.getCharactersCovered());\n            LittleEndian.putShort(_data, pos+4, (short)prop.getIndentLevel());\n            pos += 6;\n        }\n    }
1116	public void addChildBefore(EscherRecord record, int insertBeforeRecordId) {\n        int idx = 0;\n        for (EscherRecord rec : this) {\n            if(rec.getRecordId() == (short)insertBeforeRecordId) {\n                break;\n            }\n                        idx++;\n        }\n        _childRecords.add(idx, record);\n    }
1117	public Borders getBorderBottom() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getBottom();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
1118	private static Record createRecord(RecordInputStream in) {\n        switch (in.getSid()) {\n            case AreaFormatRecord.sid:        return new AreaFormatRecord(in);\n            case AreaRecord.sid:              return new AreaRecord(in);\n            case ArrayRecord.sid:             return new ArrayRecord(in);\n            case AxisLineFormatRecord.sid:    return new AxisLineFormatRecord(in);\n            case AxisOptionsRecord.sid:       return new AxisOptionsRecord(in);\n            case AxisParentRecord.sid:        return new AxisParentRecord(in);\n            case AxisRecord.sid:              return new AxisRecord(in);\n            case AxisUsedRecord.sid:          return new AxisUsedRecord(in);\n            case AutoFilterInfoRecord.sid:    return new AutoFilterInfoRecord(in);\n            case BOFRecord.sid:               return new BOFRecord(in);\n            case BackupRecord.sid:            return new BackupRecord(in);\n            case BarRecord.sid:               return new BarRecord(in);\n            case BeginRecord.sid:             return new BeginRecord(in);\n            case BlankRecord.sid:             return new BlankRecord(in);\n            case BookBoolRecord.sid:          return new BookBoolRecord(in);\n            case BoolErrRecord.sid:           return new BoolErrRecord(in);\n            case BottomMarginRecord.sid:      return new BottomMarginRecord(in);\n            case BoundSheetRecord.sid:        return new BoundSheetRecord(in);\n            case CFHeaderRecord.sid:          return new CFHeaderRecord(in);\n            case CFHeader12Record.sid:        return new CFHeader12Record(in);\n            case CFRuleRecord.sid:            return new CFRuleRecord(in);\n            case CFRule12Record.sid:          return new CFRule12Record(in);\n                        case CalcCountRecord.sid:         return new CalcCountRecord(in);\n            case CalcModeRecord.sid:          return new CalcModeRecord(in);\n            case CategorySeriesAxisRecord.sid:return new CategorySeriesAxisRecord(in);\n            case ChartFormatRecord.sid:       return new ChartFormatRecord(in);\n            case ChartRecord.sid:             return new ChartRecord(in);\n            case CodepageRecord.sid:          return new CodepageRecord(in);\n            case ColumnInfoRecord.sid:        return new ColumnInfoRecord(in);\n            case ContinueRecord.sid:          return new ContinueRecord(in);\n            case CountryRecord.sid:           return new CountryRecord(in);\n            case DBCellRecord.sid:            return new DBCellRecord(in);\n            case DSFRecord.sid:               return new DSFRecord(in);\n            case DatRecord.sid:               return new DatRecord(in);\n            case DataFormatRecord.sid:        return new DataFormatRecord(in);\n            case DateWindow1904Record.sid:    return new DateWindow1904Record(in);\n            case DConRefRecord.sid:           return new DConRefRecord(in);\n            case DefaultColWidthRecord.sid:   return new DefaultColWidthRecord(in);\n            case DefaultDataLabelTextPropertiesRecord.sid: return new DefaultDataLabelTextPropertiesRecord(in);\n            case DefaultRowHeightRecord.sid:  return new DefaultRowHeightRecord(in);\n            case DeltaRecord.sid:             return new DeltaRecord(in);\n            case DimensionsRecord.sid:        return new DimensionsRecord(in);\n            case DrawingGroupRecord.sid:      return new DrawingGroupRecord(in);\n            case DrawingRecordForBiffViewer.sid: return new DrawingRecordForBiffViewer(in);\n            case DrawingSelectionRecord.sid:  return new DrawingSelectionRecord(in);\n            case DVRecord.sid:                return new DVRecord(in);\n            case DVALRecord.sid:              return new DVALRecord(in);\n            case EOFRecord.sid:               return new EOFRecord(in);\n            case EndRecord.sid:               return new EndRecord(in);\n            case ExtSSTRecord.sid:            return new ExtSSTRecord(in);\n            case ExtendedFormatRecord.sid:    return new ExtendedFormatRecord(in);\n            case ExternSheetRecord.sid:       return new ExternSheetRecord(in);\n            case ExternalNameRecord.sid:      return new ExternalNameRecord(in);\n            case FeatRecord.sid:              return new FeatRecord(in);\n            case FeatHdrRecord.sid:           return new FeatHdrRecord(in);\n            case FilePassRecord.sid:          return new FilePassRecord(in);\n            case FileSharingRecord.sid:       return new FileSharingRecord(in);\n            case FnGroupCountRecord.sid:      return new FnGroupCountRecord(in);\n            case FontBasisRecord.sid:         return new FontBasisRecord(in);\n            case FontIndexRecord.sid:         return new FontIndexRecord(in);\n            case FontRecord.sid:              return new FontRecord(in);\n            case FooterRecord.sid:            return new FooterRecord(in);\n            case FormatRecord.sid:            return new FormatRecord(in);\n            case FormulaRecord.sid:           return new FormulaRecord(in);\n            case FrameRecord.sid:             return new FrameRecord(in);\n            case GridsetRecord.sid:           return new GridsetRecord(in);\n            case GutsRecord.sid:              return new GutsRecord(in);\n            case HCenterRecord.sid:           return new HCenterRecord(in);\n            case HeaderRecord.sid:            return new HeaderRecord(in);\n            case HideObjRecord.sid:           return new HideObjRecord(in);\n            case HorizontalPageBreakRecord.sid: return new HorizontalPageBreakRecord(in);\n            case HyperlinkRecord.sid:         return new HyperlinkRecord(in);\n            case IndexRecord.sid:             return new IndexRecord(in);\n            case InterfaceEndRecord.sid:      return InterfaceEndRecord.create(in);\n            case InterfaceHdrRecord.sid:      return new InterfaceHdrRecord(in);\n            case IterationRecord.sid:         return new IterationRecord(in);\n            case LabelRecord.sid:             return new LabelRecord(in);\n            case LabelSSTRecord.sid:          return new LabelSSTRecord(in);\n            case LeftMarginRecord.sid:        return new LeftMarginRecord(in);\n            case LegendRecord.sid:            return new LegendRecord(in);\n            case LineFormatRecord.sid:        return new LineFormatRecord(in);\n            case LinkedDataRecord.sid:        return new LinkedDataRecord(in);\n            case MMSRecord.sid:               return new MMSRecord(in);\n            case MergeCellsRecord.sid:        return new MergeCellsRecord(in);\n            case MulBlankRecord.sid:          return new MulBlankRecord(in);\n            case MulRKRecord.sid:             return new MulRKRecord(in);\n            case NameRecord.sid:              return new NameRecord(in);\n            case NameCommentRecord.sid:       return new NameCommentRecord(in);\n            case NoteRecord.sid:              return new NoteRecord(in);\n            case NumberRecord.sid:            return new NumberRecord(in);\n            case ObjRecord.sid:               return new ObjRecord(in);\n            case ObjectLinkRecord.sid:        return new ObjectLinkRecord(in);\n            case PaletteRecord.sid:           return new PaletteRecord(in);\n            case PaneRecord.sid:              return new PaneRecord(in);\n            case PasswordRecord.sid:          return new PasswordRecord(in);\n            case PasswordRev4Record.sid:      return new PasswordRev4Record(in);\n            case PlotAreaRecord.sid:          return new PlotAreaRecord(in);\n            case PlotGrowthRecord.sid:        return new PlotGrowthRecord(in);\n            case PrecisionRecord.sid:         return new PrecisionRecord(in);\n            case PrintGridlinesRecord.sid:    return new PrintGridlinesRecord(in);\n            case PrintHeadersRecord.sid:      return new PrintHeadersRecord(in);\n            case PrintSetupRecord.sid:        return new PrintSetupRecord(in);\n            case ProtectRecord.sid:           return new ProtectRecord(in);\n            case ProtectionRev4Record.sid:    return new ProtectionRev4Record(in);\n            case RKRecord.sid:                return new RKRecord(in);\n            case RecalcIdRecord.sid:          return new RecalcIdRecord(in);\n            case RefModeRecord.sid:           return new RefModeRecord(in);\n            case RefreshAllRecord.sid:        return new RefreshAllRecord(in);\n            case RightMarginRecord.sid:       return new RightMarginRecord(in);\n            case RowRecord.sid:               return new RowRecord(in);\n            case SCLRecord.sid:               return new SCLRecord(in);\n            case SSTRecord.sid:               return new SSTRecord(in);\n            case SaveRecalcRecord.sid:        return new SaveRecalcRecord(in);\n            case SelectionRecord.sid:         return new SelectionRecord(in);\n            case SeriesIndexRecord.sid:       return new SeriesIndexRecord(in);\n            case SeriesListRecord.sid:        return new SeriesListRecord(in);\n            case SeriesRecord.sid:            return new SeriesRecord(in);\n            case SeriesTextRecord.sid:        return new SeriesTextRecord(in);\n            case SeriesToChartGroupRecord.sid:return new SeriesToChartGroupRecord(in);\n            case SharedFormulaRecord.sid:     return new SharedFormulaRecord(in);\n            case SheetPropertiesRecord.sid:   return new SheetPropertiesRecord(in);\n            case StringRecord.sid:            return new StringRecord(in);\n            case StyleRecord.sid:             return new StyleRecord(in);\n            case SupBookRecord.sid:           return new SupBookRecord(in);\n            case TabIdRecord.sid:             return new TabIdRecord(in);\n            case TableStylesRecord.sid:       return new TableStylesRecord(in);\n            case TableRecord.sid:             return new TableRecord(in);\n            case TextObjectRecord.sid:        return new TextObjectRecord(in);\n            case TextRecord.sid:              return new TextRecord(in);\n            case TickRecord.sid:              return new TickRecord(in);\n            case TopMarginRecord.sid:         return new TopMarginRecord(in);\n            case UncalcedRecord.sid:          return new UncalcedRecord(in);\n            case UnitsRecord.sid:             return new UnitsRecord(in);\n            case UseSelFSRecord.sid:          return new UseSelFSRecord(in);\n            case VCenterRecord.sid:           return new VCenterRecord(in);\n            case ValueRangeRecord.sid:        return new ValueRangeRecord(in);\n            case VerticalPageBreakRecord.sid: return new VerticalPageBreakRecord(in);\n            case WSBoolRecord.sid:            return new WSBoolRecord(in);\n            case WindowOneRecord.sid:         return new WindowOneRecord(in);\n            case WindowProtectRecord.sid:     return new WindowProtectRecord(in);\n            case WindowTwoRecord.sid:         return new WindowTwoRecord(in);\n            case WriteAccessRecord.sid:       return new WriteAccessRecord(in);\n            case WriteProtectRecord.sid:      return new WriteProtectRecord(in);\n\n                        case CatLabRecord.sid:            return new CatLabRecord(in);\n            case ChartEndBlockRecord.sid:     return new ChartEndBlockRecord(in);\n            case ChartEndObjectRecord.sid:    return new ChartEndObjectRecord(in);\n            case ChartFRTInfoRecord.sid:      return new ChartFRTInfoRecord(in);\n            case ChartStartBlockRecord.sid:   return new ChartStartBlockRecord(in);\n            case ChartStartObjectRecord.sid:  return new ChartStartObjectRecord(in);\n\n                        case StreamIDRecord.sid:           return new StreamIDRecord(in);\n            case ViewSourceRecord.sid:         return new ViewSourceRecord(in);\n            case PageItemRecord.sid:           return new PageItemRecord(in);\n            case ViewDefinitionRecord.sid:     return new ViewDefinitionRecord(in);\n            case ViewFieldsRecord.sid:         return new ViewFieldsRecord(in);\n            case DataItemRecord.sid:           return new DataItemRecord(in);\n            case ExtendedPivotTableViewFieldsRecord.sid: return new ExtendedPivotTableViewFieldsRecord(in);\n        }\n        return new UnknownRecord(in);\n    }
1119	public boolean eat(Row in, int remap[]) {\n    int sum = 0;\n    for (Iterator<Cell> i = in.cells.values().iterator(); i.hasNext();) {\n      Cell c = i.next();\n      sum += c.cnt;\n      if (c.ref >= 0) {\n        if (remap[c.ref] == 0) {\n          c.ref = -1;\n        }\n      }\n    }\n    int frame = sum / 10;\n    boolean live = false;\n    for (Iterator<Cell> i = in.cells.values().iterator(); i.hasNext();) {\n      Cell c = i.next();\n      if (c.cnt < frame && c.cmd >= 0) {\n        c.cnt = 0;\n        c.cmd = -1;\n      }\n      if (c.cmd >= 0 || c.ref >= 0) {\n        live |= true;\n      }\n    }\n    return !live;\n  }
1120	public void createSplitPane(int xSplitPos, int ySplitPos, int topRow, int leftmostColumn, int activePane) {\n        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n        if (paneLoc != -1)\n            _records.remove(paneLoc);\n\n        int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n        PaneRecord r = new PaneRecord();\n        r.setX((short)xSplitPos);\n        r.setY((short)ySplitPos);\n        r.setTopRow((short) topRow);\n        r.setLeftColumn((short) leftmostColumn);\n        r.setActivePane((short) activePane);\n        _records.add(loc+1, r);\n\n        windowTwo.setFreezePanes(false);\n        windowTwo.setFreezePanesNoSplit(false);\n\n        SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n        if (sel != null) {\n            sel.setPane(PANE_LOWER_RIGHT);\n        }\n\n    }
1121	public void writeOut(OutputStream out) throws IOException {\n                \n        @SuppressWarnings("resource")\n        LittleEndianOutputStream leosOut = new LittleEndianOutputStream(out);\n        \n        switch (mode) {\n        case parsed: {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            LittleEndianOutputStream leos = new LittleEndianOutputStream(bos);\n            \n            leos.writeShort(getFlags1());\n            leos.write(getLabel().getBytes(ISO1));\n            leos.write(0);\n            leos.write(getFileName().getBytes(ISO1));\n            leos.write(0);\n            leos.writeShort(getFlags2());\n            leos.writeShort(getUnknown1());\n            leos.writeInt(getCommand().length() + 1);\n            leos.write(getCommand().getBytes(ISO1));\n            leos.write(0);\n            leos.writeInt(getDataSize());\n            leos.write(getDataBuffer());\n            leos.writeShort(getFlags3());\n            leos.close();             \n            leosOut.writeInt(bos.size());             bos.writeTo(out);\n            break;\n        }\n        case compact:\n            leosOut.writeInt(getDataSize()+LittleEndianConsts.SHORT_SIZE);\n            leosOut.writeShort(getFlags1());\n            out.write(getDataBuffer());\n            break;\n        default:\n        case unparsed:\n            leosOut.writeInt(getDataSize());\n            out.write(getDataBuffer());\n            break;\n        }\n\n    }
1122	public XSSFSheet cloneSheet(int sheetNum, String newName) {\n        validateSheetIndex(sheetNum);\n        XSSFSheet srcSheet = sheets.get(sheetNum);\n\n        if (newName == null) {\n            String srcName = srcSheet.getSheetName();\n            newName = getUniqueSheetName(srcName);\n        } else {\n            validateSheetName(newName);\n        }\n\n        XSSFSheet clonedSheet = createSheet(newName);\n\n                List<RelationPart> rels = srcSheet.getRelationParts();\n                XSSFDrawing dg = null;\n        for(RelationPart rp : rels) {\n            POIXMLDocumentPart r = rp.getDocumentPart();\n                        if(r instanceof XSSFDrawing) {\n                dg = (XSSFDrawing)r;\n                continue;\n            }\n\n            addRelation(rp, clonedSheet);\n        }\n\n        try {\n            for(PackageRelationship pr : srcSheet.getPackagePart().getRelationships()) {\n                if (pr.getTargetMode() == TargetMode.EXTERNAL) {\n                    clonedSheet.getPackagePart().addExternalRelationship\n                            (pr.getTargetURI().toASCIIString(), pr.getRelationshipType(), pr.getId());\n                }\n            }\n        } catch (InvalidFormatException e) {\n            throw new POIXMLException("Failed to clone sheet", e);\n        }\n\n\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n            srcSheet.write(out);\n            try (ByteArrayInputStream bis = new ByteArrayInputStream(out.toByteArray())) {\n                clonedSheet.read(bis);\n            }\n        } catch (IOException e){\n            throw new POIXMLException("Failed to clone sheet", e);\n        }\n        CTWorksheet ct = clonedSheet.getCTWorksheet();\n        if(ct.isSetLegacyDrawing()) {\n            logger.log(POILogger.WARN, "Cloning sheets with comments is not yet supported.");\n            ct.unsetLegacyDrawing();\n        }\n        if (ct.isSetPageSetup()) {\n            logger.log(POILogger.WARN, "Cloning sheets with page setup is not yet supported.");\n            ct.unsetPageSetup();\n        }\n\n        clonedSheet.setSelected(false);\n\n                if (dg != null) {\n            if(ct.isSetDrawing()) {\n                                                ct.unsetDrawing();\n            }\n            XSSFDrawing clonedDg = clonedSheet.createDrawingPatriarch();\n                        clonedDg.getCTDrawing().set(dg.getCTDrawing());\n\n            clonedDg = clonedSheet.createDrawingPatriarch();\n\n                        List<RelationPart> srcRels = srcSheet.createDrawingPatriarch().getRelationParts();\n            for (RelationPart rp : srcRels) {\n                addRelation(rp, clonedDg);\n            }\n        }\n        return clonedSheet;\n    }
1123	public static void assertVocabulary(Analyzer a, InputStream vocOut)\n  throws IOException {\n    BufferedReader vocReader = new BufferedReader(\n        new InputStreamReader(vocOut, StandardCharsets.UTF_8));\n    String inputLine = null;\n    while ((inputLine = vocReader.readLine()) != null) {\n      if (inputLine.startsWith("#") || inputLine.trim().length() == 0)\n        continue; \n      String words[] = inputLine.split("\t");\n      BaseTokenStreamTestCase.checkOneTerm(a, words[0], words[1]);\n    }\n  }
1124	public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;        C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * inverseScale * A * (sigma - deltaSigma);\n  }
1125	private static int unpaddedLength(byte[] buf) {\n        final int end = (buf.length-(buf.length+3)%4);\n        for (int i = buf.length; i>end; i--) {\n            if (buf[i-1] != 0) {\n                return i;\n            }\n        }\n        return end;\n    }
1126	public static JFreeChart createBarChart3D(String title,\n            String categoryAxisLabel, String valueAxisLabel,\n            CategoryDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        CategoryAxis categoryAxis = new CategoryAxis3D(categoryAxisLabel);\n        ValueAxis valueAxis = new NumberAxis3D(valueAxisLabel);\n\n        BarRenderer3D renderer = new BarRenderer3D();\n        if (tooltips) {\n            renderer.setBaseToolTipGenerator(\n                    new StandardCategoryToolTipGenerator());\n        }\n        if (urls) {\n            renderer.setBaseItemURLGenerator(\n                    new StandardCategoryURLGenerator());\n        }\n\n        CategoryPlot plot = new CategoryPlot(dataset, categoryAxis, valueAxis,\n                renderer);\n        plot.setOrientation(orientation);\n        if (orientation == PlotOrientation.HORIZONTAL) {\n                                    plot.setRowRenderingOrder(SortOrder.DESCENDING);\n            plot.setColumnRenderingOrder(SortOrder.DESCENDING);\n        }\n        plot.setForegroundAlpha(0.75f);\n\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
1127	private static float[] deriveRotationAnchorOffsets(Graphics2D g2, \n            AttributedString text, TextAnchor anchor) {\n\n        float[] result = new float[2];\n        \n        TextLayout layout = new TextLayout(text.getIterator(), \n                g2.getFontRenderContext());\n        Rectangle2D bounds = layout.getBounds();\n        float ascent = layout.getAscent();\n        float halfAscent = ascent / 2.0f;\n        float descent = layout.getDescent();\n        float leading = layout.getLeading();\n        float xAdj = 0.0f;\n        float yAdj = 0.0f;\n\n        if (isHorizontalLeft(anchor)) {\n            xAdj = 0.0f;\n        }\n        else if (isHorizontalCenter(anchor)) {\n            xAdj = (float) bounds.getWidth() / 2.0f;\n        }\n        else if (isHorizontalRight(anchor)) {\n            xAdj = (float) bounds.getWidth();\n        }\n\n        if (isTop(anchor)) {\n            yAdj = descent + leading - (float) bounds.getHeight();\n        }\n        else if (isHalfHeight(anchor)) {\n            yAdj = descent + leading - (float) (bounds.getHeight() / 2.0);\n        }\n        else if (isHalfAscent(anchor)) {\n            yAdj = -halfAscent;\n        }\n        else if (isBaseline(anchor)) {\n            yAdj = 0.0f;\n        }\n        else if (isBottom(anchor)) {\n            yAdj = descent + leading;\n        }\n        result[0] = xAdj;\n        result[1] = yAdj;\n        return result;\n\n    }
1128	public void removeRow(Comparable rowKey) {\n        ParamChecks.nullNotPermitted(rowKey, "rowKey");\n        int index = getRowIndex(rowKey);\n        if (index >= 0) {\n            removeRow(index);\n        }\n        else {\n            throw new UnknownKeyException("Unknown key: " + rowKey);\n        }\n    }
1129	public void removeSeries(TimeSeries series) {\n        ParamChecks.nullNotPermitted(series, "series");\n        this.data.remove(series);\n        series.removeChangeListener(this);\n        series.removeVetoableChangeListener(this);\n        fireDatasetChanged();\n    }
1130	void decRef(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    Throwable firstThrowable = null;\n    for(final String file : files) {\n      try {\n        if (decRef(file)) {\n          toDelete.add(file);\n        }\n      } catch (Throwable t) {\n        if (firstThrowable == null) {\n                    firstThrowable = t;\n        }\n      }\n    }\n\n    try {\n      deleteFiles(toDelete);\n    } catch (Throwable t) {\n      if (firstThrowable == null) {\n                firstThrowable = t;\n      }\n    }\n\n    if (firstThrowable != null) {\n      throw IOUtils.rethrowAlways(firstThrowable);\n    }\n  }
1131	public void validateTickUnit() {\n        double newTickUnit;\n        try {\n            newTickUnit = Double.parseDouble(this.manualTickUnit.getText());\n        }\n        catch (NumberFormatException e) {\n            newTickUnit = this.manualTickUnitValue;\n        }\n\n        if (newTickUnit > 0.0) {\n            this.manualTickUnitValue = newTickUnit;\n        }\n        this.manualTickUnit.setText(Double.toString(this.manualTickUnitValue));\n    }
1132	public void writeInt(long pos, int value) {\n    int blockIndex = (int) (pos >> blockBits);\n    int upto = (int) (pos & blockMask);\n    byte[] block = blocks.get(blockIndex);\n    int shift = 24;\n    for(int i=0;i<4;i++) {\n      block[upto++] = (byte) (value >> shift);\n      shift -= 8;\n      if (upto == blockSize) {\n        upto = 0;\n        blockIndex++;\n        block = blocks.get(blockIndex);\n      }\n    }\n  }
1133	private int writeDataIntoDrawingRecord(byte[] drawingData, int writtenEscherBytes, int pos, byte[] data, int i) {\n        int temp = 0;\n                if (writtenEscherBytes + drawingData.length > RecordInputStream.MAX_RECORD_DATA_SIZE && i != 1) {\n            for (int j = 0; j < drawingData.length; j += RecordInputStream.MAX_RECORD_DATA_SIZE) {\n                byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];\n                System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));\n                ContinueRecord drawing = new ContinueRecord(buf);\n                temp += drawing.serialize(pos + temp, data);\n            }\n        } else {\n            for (int j = 0; j < drawingData.length; j += RecordInputStream.MAX_RECORD_DATA_SIZE) {\n                if (j == 0) {\n                    DrawingRecord drawing = new DrawingRecord();\n                    byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];\n                    System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));\n                    drawing.setData(buf);\n                    temp += drawing.serialize(pos + temp, data);\n                } else {\n                    byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];\n                    System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));\n                    ContinueRecord drawing = new ContinueRecord(buf);\n                    temp += drawing.serialize(pos + temp, data);\n                }\n            }\n        }\n        return temp;\n    }
1134	public static <\n        S extends Shape<S,P>,\n        P extends TextParagraph<S,P,? extends TextRun>\n    > SlideShow<S,P> create(final DirectoryNode root, String password) throws IOException {\n                if (root.hasEntry(Decryptor.DEFAULT_POIFS_ENTRY)) {\n            InputStream stream = null;\n            try {\n                stream = DocumentFactoryHelper.getDecryptedStream(root, password);\n\n                return createXSLFSlideShow(stream);\n            } finally {\n                IOUtils.closeQuietly(stream);\n\n                                                root.getFileSystem().close();\n            }\n        }\n\n                        boolean passwordSet = false;\n        if (password != null) {\n            Biff8EncryptionKey.setCurrentUserPassword(password);\n            passwordSet = true;\n        }\n        try {\n            return createHSLFSlideShow(root);\n        } finally {\n            if (passwordSet) {\n                Biff8EncryptionKey.setCurrentUserPassword(null);\n            }\n        }\n    }
1135	public static BATBlock createBATBlock(final POIFSBigBlockSize bigBlockSize, ByteBuffer data)\n    {\n              BATBlock block = new BATBlock(bigBlockSize);\n       \n              byte[] buffer = new byte[LittleEndian.INT_SIZE];\n       for(int i=0; i<block._values.length; i++) {\n          data.get(buffer);\n          block._values[i] = LittleEndian.getInt(buffer);\n       }\n       block.recomputeFree();\n       \n              return block;\n    }
1136	public void remove(XYPlot subplot) {\n        ParamChecks.nullNotPermitted(subplot, "subplot");\n        int position = -1;\n        int size = this.subplots.size();\n        int i = 0;\n        while (position == -1 && i < size) {\n            if (this.subplots.get(i) == subplot) {\n                position = i;\n            }\n            i++;\n        }\n        if (position != -1) {\n            this.subplots.remove(position);\n            subplot.setParent(null);\n            subplot.removeChangeListener(this);\n            ValueAxis domain = getDomainAxis();\n            if (domain != null) {\n                domain.configure();\n            }\n            fireChangeEvent();\n        }\n    }
1137	private void mergeContiguousFragments(TextFragment[] frag)\n  {\n    boolean mergingStillBeingDone;\n    if (frag.length > 1)\n      do\n      {\n        mergingStillBeingDone = false;                 for (int i = 0; i < frag.length; i++)\n        {\n          if (frag[i] == null)\n          {\n            continue;\n          }\n                    for (int x = 0; x < frag.length; x++)\n          {\n            if (frag[x] == null)\n            {\n              continue;\n            }\n            if (frag[i] == null)\n            {\n              break;\n            }\n            TextFragment frag1 = null;\n            TextFragment frag2 = null;\n            int frag1Num = 0;\n            int frag2Num = 0;\n            int bestScoringFragNum;\n            int worstScoringFragNum;\n                        if (frag[i].follows(frag[x]))\n            {\n              frag1 = frag[x];\n              frag1Num = x;\n              frag2 = frag[i];\n              frag2Num = i;\n            }\n            else\n              if (frag[x].follows(frag[i]))\n              {\n                frag1 = frag[i];\n                frag1Num = i;\n                frag2 = frag[x];\n                frag2Num = x;\n              }\n                        if (frag1 != null)\n            {\n              if (frag1.getScore() > frag2.getScore())\n              {\n                bestScoringFragNum = frag1Num;\n                worstScoringFragNum = frag2Num;\n              }\n              else\n              {\n                bestScoringFragNum = frag2Num;\n                worstScoringFragNum = frag1Num;\n              }\n              frag1.merge(frag2);\n              frag[worstScoringFragNum] = null;\n              mergingStillBeingDone = true;\n              frag[bestScoringFragNum] = frag1;\n            }\n          }\n        }\n      }\n      while (mergingStillBeingDone);\n  }
1138	public static DocIdSetIterator intersectIterators(List<DocIdSetIterator> iterators) {\n    if (iterators.size() < 2) {\n      throw new IllegalArgumentException("Cannot make a ConjunctionDISI of less than 2 iterators");\n    }\n    final List<DocIdSetIterator> allIterators = new ArrayList<>();\n    final List<TwoPhaseIterator> twoPhaseIterators = new ArrayList<>();\n    for (DocIdSetIterator iterator : iterators) {\n      addIterator(iterator, allIterators, twoPhaseIterators);\n    }\n\n    return createConjunction(allIterators, twoPhaseIterators);\n  }
1139	public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n                        if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher("");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n                        IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n                        if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, "cleanupOldIndexFiles(): failed on error " + t.getMessage());\n      }\n    }\n  }
1140	private static int findDataValidationTableInsertPos(List<RecordBase> records) {\n		int i = records.size() - 1;\n		if (!(records.get(i) instanceof EOFRecord)) {\n			throw new IllegalStateException("Last sheet record should be EOFRecord");\n		}\n		while (i > 0) {\n			i--;\n			RecordBase rb = records.get(i);\n			if (isDVTPriorRecord(rb)) {\n				Record nextRec = (Record) records.get(i + 1);\n				if (!isDVTSubsequentRecord(nextRec.getSid())) {\n					throw new IllegalStateException("Unexpected (" + nextRec.getClass().getName()\n							+ ") found after (" + rb.getClass().getName() + ")");\n				}\n				return i+1;\n			}\n			Record rec = (Record) rb;\n			if (!isDVTSubsequentRecord(rec.getSid())) {\n				throw new IllegalStateException("Unexpected (" + rec.getClass().getName()\n						+ ") while looking for DV Table insert pos");\n			}\n		}\n		return 0;\n	}
1141	public static String getQueryAsXmlString(Properties formProperties, Templates template)\n      throws ParserConfigurationException, TransformerException {\n        StringWriter writer = new StringWriter();\n    StreamResult result = new StreamResult(writer);\n    transformCriteria(formProperties, template, result);\n    return writer.toString();\n  }
1142	protected OffsetSource getOffsetSource(String field) {\n    FieldInfo fieldInfo = getFieldInfo(field);\n    if (fieldInfo != null) {\n      if (fieldInfo.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n        return fieldInfo.hasVectors() ? OffsetSource.POSTINGS_WITH_TERM_VECTORS : OffsetSource.POSTINGS;\n      }\n      if (fieldInfo.hasVectors()) {         return OffsetSource.TERM_VECTORS;\n      }\n    }\n    return OffsetSource.ANALYSIS;\n  }
1143	void waitIfStalled() {\n    if (stalled) {\n      synchronized (this) {\n        if (stalled) {                     try {\n            incWaiters();\n                                    wait(1000);\n            decrWaiters();\n          } catch (InterruptedException e) {\n            throw new ThreadInterruptedException(e);\n          }\n        }\n      }\n    }\n  }
1144	public void or(DocIdSetIterator iter) throws IOException {\n    checkUnpositioned(iter);\n    for (int doc = iter.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iter.nextDoc()) {\n      set(doc);\n    }\n  }
1145	public synchronized LiveIndexWriterConfig setRAMBufferSizeMB(double ramBufferSizeMB) {\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && ramBufferSizeMB <= 0.0) {\n      throw new IllegalArgumentException("ramBufferSize should be > 0.0 MB when enabled");\n    }\n    if (ramBufferSizeMB == IndexWriterConfig.DISABLE_AUTO_FLUSH\n        && maxBufferedDocs == IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      throw new IllegalArgumentException("at least one of ramBufferSize and maxBufferedDocs must be enabled");\n    }\n    this.ramBufferSizeMB = ramBufferSizeMB;\n    return this;\n  }
1146	protected void fillArc(Graphics2D g2, Rectangle2D area,\n            double minValue, double maxValue, Paint paint, boolean dial) {\n\n        ParamChecks.nullNotPermitted(paint, "paint");\n        double startAngle = valueToAngle(maxValue);\n        double endAngle = valueToAngle(minValue);\n        double extent = endAngle - startAngle;\n\n        double x = area.getX();\n        double y = area.getY();\n        double w = area.getWidth();\n        double h = area.getHeight();\n        int joinType = Arc2D.OPEN;\n        if (this.shape == DialShape.PIE) {\n            joinType = Arc2D.PIE;\n        }\n        else if (this.shape == DialShape.CHORD) {\n            if (dial && this.meterAngle > 180) {\n                joinType = Arc2D.CHORD;\n            }\n            else {\n                joinType = Arc2D.PIE;\n            }\n        }\n        else if (this.shape == DialShape.CIRCLE) {\n            joinType = Arc2D.PIE;\n            if (dial) {\n                extent = 360;\n            }\n        }\n        else {\n            throw new IllegalStateException("DialShape not recognised.");\n        }\n\n        g2.setPaint(paint);\n        Arc2D.Double arc = new Arc2D.Double(x, y, w, h, startAngle, extent,\n                joinType);\n        g2.fill(arc);\n    }
1147	private int findChildLocation(Record child) {\n	    int i=0;\n		for(Record r : _children) {\n			if (r.equals(child)) {\n				return i;\n			}\n			i++;\n		}\n		return -1;\n	}
1148	public XDDFTextRun appendLineBreak() {\n        CTTextLineBreak br = _p.addNewBr();\n                for (XDDFTextRun tr : new IteratorIterable<>(new ReverseListIterator<>(_runs))) {\n            CTTextCharacterProperties prevProps = tr.getProperties();\n                        if (prevProps != null) {\n                br.setRPr((CTTextCharacterProperties) prevProps.copy());\n                break;\n            }\n        }\n        XDDFTextRun run = new XDDFTextRun(br, this);\n        _runs.add(run);\n        return run;\n    }
1149	public XWPFFooter createFooter(HeaderFooterType type) {\n        XWPFHeaderFooterPolicy hfPolicy = createHeaderFooterPolicy();\n                if (type == HeaderFooterType.FIRST) {\n            CTSectPr ctSectPr = getSection();\n            if (!ctSectPr.isSetTitlePg()) {\n                CTOnOff titlePg = ctSectPr.addNewTitlePg();\n                titlePg.setVal(STOnOff.ON);\n            }\n                                }\n        return hfPolicy.createFooter(STHdrFtr.Enum.forInt(type.toInt()));\n    }
1150	private int calculateNewFirstCell(int firstcell) {\n        int cellIx = firstcell + 1;\n        HSSFCell r = retrieveCell(cellIx);\n\n        while (r == null) {\n            if (cellIx <= cells.length) {\n                return 0;\n            }\n            r = retrieveCell(++cellIx);\n        }\n        return cellIx;\n    }
1151	public int getPrefixMatch(char[] charArray, int knownStart) {\n    short index = getWordItemTableIndex(charArray[0]);\n    if (index == -1)\n      return -1;\n    char[][] items = wordItem_charArrayTable[wordIndexTable[index]];\n    int start = knownStart, end = items.length - 1;\n\n    int mid = (start + end) / 2, cmpResult;\n\n        while (start <= end) {\n      cmpResult = Utility.compareArrayByPrefix(charArray, 1, items[mid], 0);\n      if (cmpResult == 0) {\n                while (mid >= 0\n            && Utility.compareArrayByPrefix(charArray, 1, items[mid], 0) == 0)\n          mid--;\n        mid++;\n        return mid;      } else if (cmpResult < 0)\n        end = mid - 1;\n      else\n        start = mid + 1;\n      mid = (start + end) / 2;\n    }\n    return -1;\n  }
1152	private ParseNode parseRangeable() {\n        SkipWhite();\n        int savePointer = _pointer;\n        SheetIdentifier sheetIden = parseSheetName();\n        \n        if (sheetIden == null) {\n            resetPointer(savePointer);\n        } else {\n            SkipWhite();\n            savePointer = _pointer;\n        }\n\n        SimpleRangePart part1 = parseSimpleRangePart();\n        if (part1 == null) {\n            if (sheetIden != null) {\n                if(look == '#'){                      return new ParseNode(ErrPtg.valueOf(parseErrorLiteral()));  \n                } else {\n                                        String name = parseAsName();\n                    if (name.length() == 0) {\n                        throw new FormulaParseException("Cell reference or Named Range "\n                                + "expected after sheet name at index " + _pointer + ".");\n                    }\n                    Ptg nameXPtg = _book.getNameXPtg(name, sheetIden);\n                    if (nameXPtg == null) {\n                        throw new FormulaParseException("Specified name '" + name +\n                                "' for sheet " + sheetIden.asFormulaString() + " not found");\n                    }\n                    return new ParseNode(nameXPtg);\n                }\n            }\n            return parseNonRange(savePointer);\n        }\n        boolean whiteAfterPart1 = IsWhite(look);\n        if (whiteAfterPart1) {\n            SkipWhite();\n        }\n\n        if (look == ':') {\n            int colonPos = _pointer;\n            GetChar();\n            SkipWhite();\n            SimpleRangePart part2 = parseSimpleRangePart();\n            if (part2 != null && !part1.isCompatibleForArea(part2)) {\n                                \n                part2 = null;\n            }\n            if (part2 == null) {\n                                                resetPointer(colonPos);\n                if (!part1.isCell()) {\n                    String prefix = "";\n                    if (sheetIden != null) {\n                        prefix = "'" + sheetIden.getSheetIdentifier().getName() + '!';\n                    }\n                    throw new FormulaParseException(prefix + part1.getRep() + "' is not a proper reference.");\n                }\n            }\n            return createAreaRefParseNode(sheetIden, part1, part2);\n        }\n\n        if (look == '.') {\n            GetChar();\n            int dotCount = 1;\n            while (look =='.') {\n                dotCount ++;\n                GetChar();\n            }\n            boolean whiteBeforePart2 = IsWhite(look);\n\n            SkipWhite();\n            SimpleRangePart part2 = parseSimpleRangePart();\n            String part1And2 = _formulaString.substring(savePointer-1, _pointer-1);\n            if (part2 == null) {\n                if (sheetIden != null) {\n                    throw new FormulaParseException("Complete area reference expected after sheet name at index "\n                            + _pointer + ".");\n                }\n                return parseNonRange(savePointer);\n            }\n\n\n            if (whiteAfterPart1 || whiteBeforePart2) {\n                if (part1.isRowOrColumn() || part2.isRowOrColumn()) {\n                                                            throw new FormulaParseException("Dotted range (full row or column) expression '"\n                            + part1And2 + "' must not contain whitespace.");\n                }\n                return createAreaRefParseNode(sheetIden, part1, part2);\n            }\n\n            if (dotCount == 1 && part1.isRow() && part2.isRow()) {\n                                return parseNonRange(savePointer);\n            }\n\n            if (part1.isRowOrColumn() || part2.isRowOrColumn()) {\n                if (dotCount != 2) {\n                    throw new FormulaParseException("Dotted range (full row or column) expression '" + part1And2\n                            + "' must have exactly 2 dots.");\n                }\n            }\n            return createAreaRefParseNode(sheetIden, part1, part2);\n        }\n        if (part1.isCell() && isValidCellReference(part1.getRep())) {\n            return createAreaRefParseNode(sheetIden, part1, null);\n        }\n        if (sheetIden != null) {\n            throw new FormulaParseException("Second part of cell reference expected after sheet name at index "\n                    + _pointer + ".");\n        }\n\n        return parseNonRange(savePointer);\n    }
1153	public static void deleteFiles(Directory dir, Collection<String> names) throws IOException {\n    Throwable th = null;\n    for (String name : names) {\n      if (name != null) {\n        try {\n          dir.deleteFile(name);\n        } catch (Throwable t) {\n          addSuppressed(th, t);\n          if (th == null) {\n            th = t;\n          }\n        }\n      }\n    }\n\n    if (th != null) {\n      throw rethrowAlways(th);\n    }\n  }
1154	protected void drawTick(Graphics2D g2, Rectangle2D meterArea,\n                            double value, boolean label) {\n\n        double valueAngle = valueToAngle(value);\n\n        double meterMiddleX = meterArea.getCenterX();\n        double meterMiddleY = meterArea.getCenterY();\n\n        g2.setPaint(this.tickPaint);\n        g2.setStroke(new BasicStroke(2.0f));\n\n        double valueP2X;\n        double valueP2Y;\n\n        double radius = (meterArea.getWidth() / 2) + DEFAULT_BORDER_SIZE;\n        double radius1 = radius - 15;\n\n        double valueP1X = meterMiddleX\n                + (radius * Math.cos(Math.PI * (valueAngle / 180)));\n        double valueP1Y = meterMiddleY\n                - (radius * Math.sin(Math.PI * (valueAngle / 180)));\n\n        valueP2X = meterMiddleX\n                + (radius1 * Math.cos(Math.PI * (valueAngle / 180)));\n        valueP2Y = meterMiddleY\n                - (radius1 * Math.sin(Math.PI * (valueAngle / 180)));\n\n        Line2D.Double line = new Line2D.Double(valueP1X, valueP1Y, valueP2X,\n                valueP2Y);\n        g2.draw(line);\n\n        if (this.tickLabelsVisible && label) {\n\n            String tickLabel =  this.tickLabelFormat.format(value);\n            g2.setFont(this.tickLabelFont);\n            g2.setPaint(this.tickLabelPaint);\n\n            FontMetrics fm = g2.getFontMetrics();\n            Rectangle2D tickLabelBounds\n                = TextUtilities.getTextBounds(tickLabel, g2, fm);\n\n            double x = valueP2X;\n            double y = valueP2Y;\n            if (valueAngle == 90 || valueAngle == 270) {\n                x = x - tickLabelBounds.getWidth() / 2;\n            }\n            else if (valueAngle < 90 || valueAngle > 270) {\n                x = x - tickLabelBounds.getWidth();\n            }\n            if ((valueAngle > 135 && valueAngle < 225)\n                    || valueAngle > 315 || valueAngle < 45) {\n                y = y - tickLabelBounds.getHeight() / 2;\n            }\n            else {\n                y = y + tickLabelBounds.getHeight() / 2;\n            }\n            g2.drawString(tickLabel, (float) x, (float) y);\n        }\n    }
1155	protected Query newDefaultQuery(String text) {\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    for (Map.Entry<String,Float> entry : weights.entrySet()) {\n      Query q = createBooleanQuery(entry.getKey(), text, defaultOperator);\n      if (q != null) {\n        float boost = entry.getValue();\n        if (boost != 1f) {\n          q = new BoostQuery(q, boost);\n        }\n        bq.add(q, BooleanClause.Occur.SHOULD);\n      }\n    }\n    return simplify(bq.build());\n  }
1156	public static List<List<HSLFTextParagraph>> findTextParagraphs(PPDrawing ppdrawing, HSLFSheet sheet) {\n        List<List<HSLFTextParagraph>> runsV = new ArrayList<>();\n        for (EscherTextboxWrapper wrapper : ppdrawing.getTextboxWrappers()) {\n            List<HSLFTextParagraph> p = findTextParagraphs(wrapper, sheet);\n            if (p != null) {\n                runsV.add(p);\n            }\n        }\n        return runsV;\n    }
1157	Partition readPartition(ByteSequencesReader reader) throws IOException, InterruptedException {\n    if (partitionsInRAM != null) {\n      partitionsInRAM.acquire();\n    }\n    boolean success = false;\n    try {\n      long start = System.currentTimeMillis();\n      SortableBytesRefArray buffer;\n      boolean exhausted = false;\n      int count;\n      if (valueLength != -1) {\n                buffer = new FixedLengthBytesRefArray(valueLength);\n        int limit = ramBufferSize.bytes / valueLength;\n        for(int i=0;i<limit;i++) {\n          BytesRef item = null;\n          try {\n            item = reader.next();\n          } catch (Throwable t) {\n            verifyChecksum(t, reader);\n          }\n          if (item == null) {\n            exhausted = true;\n            break;\n          }\n          buffer.append(item);\n        }\n      } else {\n        Counter bufferBytesUsed = Counter.newCounter();\n        buffer = new BytesRefArray(bufferBytesUsed);\n        while (true) {\n          BytesRef item = null;\n          try {\n            item = reader.next();\n          } catch (Throwable t) {\n            verifyChecksum(t, reader);\n          }\n          if (item == null) {\n            exhausted = true;\n            break;\n          }\n          buffer.append(item);\n                              if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n            break;\n          }\n        }\n      }\n      sortInfo.readTimeMS += System.currentTimeMillis() - start;\n      success = true;\n      return new Partition(buffer, exhausted);\n    } finally {\n      if (success == false && partitionsInRAM != null) {\n        partitionsInRAM.release();\n      }\n    }\n  }
1158	public boolean save(OutputStream outStream) {\n        Document xmlOutDoc = DocumentHelper.createDocument();\n\n                Element typesElem = xmlOutDoc.createElementNS(TYPES_NAMESPACE_URI, TYPES_TAG_NAME);\n        xmlOutDoc.appendChild(typesElem);\n\n                for (Entry<String, String> entry : defaultContentType.entrySet()) {\n            appendDefaultType(typesElem, entry);\n        }\n\n                if (overrideContentType != null) {\n            for (Entry<PackagePartName, String> entry : overrideContentType\n                    .entrySet()) {\n                appendSpecificTypes(typesElem, entry);\n            }\n        }\n        xmlOutDoc.normalize();\n\n                return this.saveImpl(xmlOutDoc, outStream);\n    }
1159	private ClientAnchorDetail fitImageToRows(HSSFSheet sheet, int rowNumber,\n            double reqImageHeightMM, int resizeBehaviour) {\n        double rowCoordinatesPerMM;\n        int pictureHeightCoordinates;\n        ClientAnchorDetail rowClientAnchorDetail = null;\n\n                HSSFRow row = sheet.getRow(rowNumber);\n        if(row == null) {\n                        row = sheet.createRow(rowNumber);\n        }\n\n                double rowHeightMM = row.getHeightInPoints() / ConvertImageUnits.POINTS_PER_MILLIMETRE;\n\n                                        if(rowHeightMM < reqImageHeightMM) {\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_ROW) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                row.setHeightInPoints((float)(reqImageHeightMM *\n                        ConvertImageUnits.POINTS_PER_MILLIMETRE));\n                rowHeightMM = reqImageHeightMM;\n                rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n                pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n                rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n            }\n                                                else if((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                    (resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN)) {\n                rowClientAnchorDetail = this.calculateRowLocation(sheet,\n                        rowNumber, reqImageHeightMM);\n            }\n        }\n                else {\n            rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n            pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n            rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n        }\n        return(rowClientAnchorDetail);\n    }
1160	public ExHyperlink get(int id){\n        for(int i=0; i<_children.length; i++) {\n            if(_children[i] instanceof ExHyperlink) {\n                ExHyperlink rec = (ExHyperlink)_children[i];\n                if (rec.getExHyperlinkAtom().getNumber() == id){\n                    return rec;\n                }\n            }\n        }\n        return null;\n    }
1161	public static JFreeChart createHistogram(String title,\n            String xAxisLabel, String yAxisLabel, IntervalXYDataset dataset,\n            PlotOrientation orientation, boolean legend, boolean tooltips,\n            boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        NumberAxis xAxis = new NumberAxis(xAxisLabel);\n        xAxis.setAutoRangeIncludesZero(false);\n        ValueAxis yAxis = new NumberAxis(yAxisLabel);\n\n        XYItemRenderer renderer = new XYBarRenderer();\n        if (tooltips) {\n            renderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());\n        }\n        if (urls) {\n            renderer.setURLGenerator(new StandardXYURLGenerator());\n        }\n\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer);\n        plot.setOrientation(orientation);\n        plot.setDomainZeroBaselineVisible(true);\n        plot.setRangeZeroBaselineVisible(true);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
1162	public void drawColorBar(Graphics2D g2, Rectangle2D colorBarArea,\n                             RectangleEdge edge) {\n\n        Object antiAlias = g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                            RenderingHints.VALUE_ANTIALIAS_OFF);\n\n                \n        Stroke strokeSaved = g2.getStroke();\n        g2.setStroke(new BasicStroke(1.0f));\n\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            double y1 = colorBarArea.getY();\n            double y2 = colorBarArea.getMaxY();\n            double xx = colorBarArea.getX();\n            Line2D line = new Line2D.Double();\n            while (xx <= colorBarArea.getMaxX()) {\n                double value = this.axis.java2DToValue(xx, colorBarArea, edge);\n                line.setLine(xx, y1, xx, y2);\n                g2.setPaint(getPaint(value));\n                g2.draw(line);\n                xx += 1;\n            }\n        }\n        else {\n            double y1 = colorBarArea.getX();\n            double y2 = colorBarArea.getMaxX();\n            double xx = colorBarArea.getY();\n            Line2D line = new Line2D.Double();\n            while (xx <= colorBarArea.getMaxY()) {\n                double value = this.axis.java2DToValue(xx, colorBarArea, edge);\n                line.setLine(y1, xx, y2, xx);\n                g2.setPaint(getPaint(value));\n                g2.draw(line);\n                xx += 1;\n            }\n        }\n\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias);\n        g2.setStroke(strokeSaved);\n\n    }
1163	public static CFRule12Record create(HSSFSheet sheet, IconSet iconSet) {\n        Threshold[] ts = new Threshold[iconSet.num];\n        for (int i=0; i<ts.length; i++) {\n            ts[i] = new IconMultiStateThreshold();\n        }\n        \n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_ICON_SET, \n                                              ComparisonOperator.NO_COMPARISON);\n        IconMultiStateFormatting imf = r.createMultiStateFormatting();\n        imf.setIconSet(iconSet);\n        imf.setThresholds(ts);\n        return r;\n    }
1164	private static void sumHistogram(int[] histogram, int[] endOffsets) {\n    int accum = 0;\n    for (int i = 0; i < HISTOGRAM_SIZE; ++i) {\n      final int count = histogram[i];\n      histogram[i] = accum;\n      accum += count;\n      endOffsets[i] = accum;\n    }\n  }
1165	private void onSheetDelete(int index) {\n                final XSSFSheet sheet = getSheetAt(index);\n\n        sheet.onSheetDelete();\n\n                workbook.getSheets().removeSheet(index);\n\n                if(calcChain != null) {\n            removeRelation(calcChain);\n            calcChain = null;\n        }\n\n                List<XSSFName> toRemove = new ArrayList<>();\n        for (XSSFName nm : namedRanges) {\n            CTDefinedName ct = nm.getCTName();\n            if(!ct.isSetLocalSheetId()) {\n                continue;\n            }\n            if (ct.getLocalSheetId() == index) {\n                toRemove.add(nm);\n            } else if (ct.getLocalSheetId() > index){\n                                ct.setLocalSheetId(ct.getLocalSheetId()-1);\n            }\n        }\n        for (XSSFName nm : toRemove) {\n            removeName(nm);\n        }\n    }
1166	private static int propLen(\n        TreeBidiMap<Long,Long> offset2Id,\n        Long entryOffset,\n        long maxSize) {\n        Long nextKey = offset2Id.nextKey(entryOffset);\n        long begin = entryOffset;\n        long end = (nextKey != null) ? nextKey : maxSize;\n        return (int)(end - begin);\n    }
1167	public static boolean validatePassword(XmlObject xobj, String password, String prefix) {\n                if (password == null) return false;\n        \n        XmlCursor cur = xobj.newCursor();\n        String xorHashVal = cur.getAttributeText(getAttrName(prefix, "password"));\n        String algoName = cur.getAttributeText(getAttrName(prefix, "algorithmName"));\n        String hashVal = cur.getAttributeText(getAttrName(prefix, "hashValue"));\n        String saltVal = cur.getAttributeText(getAttrName(prefix, "saltValue"));\n        String spinCount = cur.getAttributeText(getAttrName(prefix, "spinCount"));\n        cur.dispose();\n\n        if (xorHashVal != null) {\n            int hash1 = Integer.parseInt(xorHashVal, 16);\n            int hash2 = CryptoFunctions.createXorVerifier1(password);\n            return hash1 == hash2;\n        } else {\n            if (hashVal == null || algoName == null || saltVal == null || spinCount == null) {\n                return false;\n            }\n            \n            byte hash1[] = DatatypeConverter.parseBase64Binary(hashVal);\n            HashAlgorithm hashAlgo = HashAlgorithm.fromString(algoName);\n            byte salt[] = DatatypeConverter.parseBase64Binary(saltVal);\n            int spinCnt = Integer.parseInt(spinCount);\n            byte hash2[] = CryptoFunctions.hashPassword(password, hashAlgo, salt, spinCnt, false);\n            return Arrays.equals(hash1, hash2);\n        }\n    }
1168	protected Point2D calculateDomainMarkerTextAnchorPoint(Graphics2D g2,\n            PlotOrientation orientation, Rectangle2D dataArea,\n            Rectangle2D markerArea, RectangleInsets markerOffset,\n            LengthAdjustmentType labelOffsetType, RectangleAnchor anchor) {\n\n        Rectangle2D anchorRect = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    LengthAdjustmentType.CONTRACT, labelOffsetType);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    labelOffsetType, LengthAdjustmentType.CONTRACT);\n        }\n        return RectangleAnchor.coordinates(anchorRect, anchor);\n\n    }
1169	public void update(int index, Number value) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        boolean iterate = false;\n        Number oldYN = item.getValue();\n        if (oldYN != null) {\n            double oldY = oldYN.doubleValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n        }\n        item.setValue(value);\n        if (iterate) {\n            updateMinMaxYByIteration();\n        }\n        else if (value != null) {\n            double yy = value.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }
1170	protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, \n            Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n                for (CategoryAxis xAxis : this.domainAxes.values()) {\n            if (xAxis != null) {\n                int index = getDomainAxisIndex(xAxis);\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n                for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis != null) {\n                int index = findRangeAxisIndex(yAxis);\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n                double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n                cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n                cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n                cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        return axisStateMap;\n\n    }
1171	public static byte[] randomId() {\n\n                                                    \n    byte bits[];\n    synchronized(idLock) {\n      bits = nextId.toByteArray();\n      nextId = nextId.add(BigInteger.ONE).and(mask128);\n    }\n    \n        if (bits.length > ID_LENGTH) {\n      assert bits.length == ID_LENGTH + 1;\n      assert bits[0] == 0;\n      return Arrays.copyOfRange(bits, 1, bits.length);\n    } else {\n      byte[] result = new byte[ID_LENGTH];\n      System.arraycopy(bits, 0, result, result.length - bits.length, bits.length);\n      return result;\n    }\n  }
1172	private Shape[] createVerticalBlock(double x0, double width, double y0,\n            double y1, boolean inverted) {\n        Shape[] result = new Shape[6];\n        Point2D p00 = new Point2D.Double(x0, y0);\n        Point2D p01 = new Point2D.Double(x0 + width, y0);\n        Point2D p02 = new Point2D.Double(p01.getX() + getXOffset(),\n                p01.getY() - getYOffset());\n        Point2D p03 = new Point2D.Double(p00.getX() + getXOffset(),\n                p00.getY() - getYOffset());\n\n\n        Point2D p0 = new Point2D.Double(x0, y1);\n        Point2D p1 = new Point2D.Double(x0 + width, y1);\n        Point2D p2 = new Point2D.Double(p1.getX() + getXOffset(),\n                p1.getY() - getYOffset());\n        Point2D p3 = new Point2D.Double(p0.getX() + getXOffset(),\n                p0.getY() - getYOffset());\n\n        GeneralPath right = new GeneralPath();\n        right.moveTo((float) p1.getX(), (float) p1.getY());\n        right.lineTo((float) p01.getX(), (float) p01.getY());\n        right.lineTo((float) p02.getX(), (float) p02.getY());\n        right.lineTo((float) p2.getX(), (float) p2.getY());\n        right.closePath();\n\n        GeneralPath left = new GeneralPath();\n        left.moveTo((float) p0.getX(), (float) p0.getY());\n        left.lineTo((float) p00.getX(), (float) p00.getY());\n        left.lineTo((float) p03.getX(), (float) p03.getY());\n        left.lineTo((float) p3.getX(), (float) p3.getY());\n        left.closePath();\n\n        GeneralPath back = new GeneralPath();\n        back.moveTo((float) p2.getX(), (float) p2.getY());\n        back.lineTo((float) p02.getX(), (float) p02.getY());\n        back.lineTo((float) p03.getX(), (float) p03.getY());\n        back.lineTo((float) p3.getX(), (float) p3.getY());\n        back.closePath();\n\n        GeneralPath front = new GeneralPath();\n        front.moveTo((float) p0.getX(), (float) p0.getY());\n        front.lineTo((float) p1.getX(), (float) p1.getY());\n        front.lineTo((float) p01.getX(), (float) p01.getY());\n        front.lineTo((float) p00.getX(), (float) p00.getY());\n        front.closePath();\n\n        GeneralPath top = new GeneralPath();\n        top.moveTo((float) p0.getX(), (float) p0.getY());\n        top.lineTo((float) p1.getX(), (float) p1.getY());\n        top.lineTo((float) p2.getX(), (float) p2.getY());\n        top.lineTo((float) p3.getX(), (float) p3.getY());\n        top.closePath();\n\n        GeneralPath bottom = new GeneralPath();\n        bottom.moveTo((float) p00.getX(), (float) p00.getY());\n        bottom.lineTo((float) p01.getX(), (float) p01.getY());\n        bottom.lineTo((float) p02.getX(), (float) p02.getY());\n        bottom.lineTo((float) p03.getX(), (float) p03.getY());\n        bottom.closePath();\n\n        result[0] = bottom;\n        result[1] = back;\n        result[2] = left;\n        result[3] = right;\n        result[4] = top;\n        result[5] = front;\n        if (inverted) {\n            result[0] = top;\n            result[4] = bottom;\n        }\n        return result;\n    }
1173	public XSSFPatternFormatting createPatternFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTFill fill;\n        if(!dxf.isSetFill()) {\n            fill = dxf.addNewFill();\n        } else {\n            fill = dxf.getFill();\n        }\n\n        return new XSSFPatternFormatting(fill, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
1174	public void removePointer(int index) {\n        DialPointer pointer = (DialPointer) this.pointers.get(index);\n        if (pointer != null) {\n            pointer.removeChangeListener(this);\n        }\n        this.pointers.remove(index);\n        fireChangeEvent();\n    }
1175	protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\n            return size1;\n        }\n        else {\n            double h = constraint.getHeightRange().constrain(size1.getHeight());\n            RectangleConstraint c2 = constraint.toFixedHeight(h);\n            return arrange(container, g2, c2);\n        }\n    }
1176	private BigDecimal parseMediumPair(NumberBuffer buffer) {\n\n    BigDecimal first = parseBasicNumber(buffer);\n    BigDecimal second = parseMediumKanjiNumeral(buffer);\n\n    if (first == null && second == null) {\n      return null;\n    }\n\n    if (second == null) {\n                  return first;\n    }\n\n    if (first == null) {\n                  return second;\n    }\n\n        return first.multiply(second);\n  }
1177	static void overlapping(Sheet sheet) {\n        for (int i=0; i<40; i++) {\n            int rn = i+1;\n            Row r = sheet.createRow(i);\n            r.createCell(0).setCellValue("This is row " + rn + " (" + i + ")");\n            String str = "";\n            if (rn%2 == 0) {\n                str = str + "even ";\n            }\n            if (rn%3 == 0) {\n                str = str + "x3 ";\n            }\n            if (rn%5 == 0) {\n                str = str + "x5 ";\n            }\n            if (rn%10 == 0) {\n                str = str + "x10 ";\n            }\n            if (str.length() == 0) {\n                str = "nothing special...";\n            }\n            r.createCell(1).setCellValue("It is " + str);\n        }\n        sheet.autoSizeColumn(0);\n        sheet.autoSizeColumn(1);\n        \n        sheet.getRow(1).createCell(3).setCellValue("Even rows are blue");\n        sheet.getRow(2).createCell(3).setCellValue("Multiples of 3 have a grey background");\n        sheet.getRow(4).createCell(3).setCellValue("Multiples of 5 are bold");\n        sheet.getRow(9).createCell(3).setCellValue("Multiples of 10 are red (beats even)");\n        \n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n                ConditionalFormattingRule rule1 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),10)=0");\n        FontFormatting font1 = rule1.createFontFormatting();\n        font1.setFontColorIndex(IndexedColors.RED.index);\n        \n                ConditionalFormattingRule rule2 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),2)=0");\n        FontFormatting font2 = rule2.createFontFormatting();\n        font2.setFontColorIndex(IndexedColors.BLUE.index);\n        \n                ConditionalFormattingRule rule3 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),5)=0");\n        FontFormatting font3 = rule3.createFontFormatting();\n        font3.setFontStyle(false, true);\n        \n                ConditionalFormattingRule rule4 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),3)=0");\n        PatternFormatting fill4 = rule4.createPatternFormatting();\n        fill4.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);\n        fill4.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n        \n                CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:F41")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        sheetCF.addConditionalFormatting(regions, rule3);\n        sheetCF.addConditionalFormatting(regions, rule4);\n    }
1178	public void removeOverlay(Overlay overlay) {\n        ParamChecks.nullNotPermitted(overlay, "overlay");\n        boolean removed = this.overlays.remove(overlay);\n        if (removed) {\n            overlay.removeChangeListener(this);\n            repaint();\n        }\n    }
1179	public int allocSlice(final byte[] slice, final int upto) {\n\n    final int level = slice[upto] & 15;\n    final int newLevel = NEXT_LEVEL_ARRAY[level];\n    final int newSize = LEVEL_SIZE_ARRAY[newLevel];\n\n        if (byteUpto > BYTE_BLOCK_SIZE-newSize) {\n      nextBuffer();\n    }\n\n    final int newUpto = byteUpto;\n    final int offset = newUpto + byteOffset;\n    byteUpto += newSize;\n\n            buffer[newUpto] = slice[upto-3];\n    buffer[newUpto+1] = slice[upto-2];\n    buffer[newUpto+2] = slice[upto-1];\n\n        slice[upto-3] = (byte) (offset >>> 24);\n    slice[upto-2] = (byte) (offset >>> 16);\n    slice[upto-1] = (byte) (offset >>> 8);\n    slice[upto] = (byte) offset;\n        \n        buffer[byteUpto-1] = (byte) (16|newLevel);\n\n    return newUpto+3;\n  }
1180	protected void writeDocument(Document document) throws MarshalException {\n        XmlOptions xo = new XmlOptions();\n        Map<String,String> namespaceMap = new HashMap<>();\n        for(Map.Entry<String,String> entry : signatureConfig.getNamespacePrefixes().entrySet()){\n            namespaceMap.put(entry.getValue(), entry.getKey());\n        }\n        xo.setSaveSuggestedPrefixes(namespaceMap);\n        xo.setUseDefaultNamespace();\n\n        LOG.log(POILogger.DEBUG, "output signed Office OpenXML document");\n\n        \n        OPCPackage pkg = signatureConfig.getOpcPackage();\n\n        PackagePartName sigPartName, sigsPartName;\n        try {\n                        sigPartName = PackagingURIHelper.createPartName("/_xmlsignatures/sig1.xml");\n                        sigsPartName = PackagingURIHelper.createPartName("/_xmlsignatures/origin.sigs");\n        } catch (InvalidFormatException e) {\n            throw new MarshalException(e);\n        }\n\n        PackagePart sigPart = pkg.getPart(sigPartName);\n        if (sigPart == null) {\n            sigPart = pkg.createPart(sigPartName, ContentTypes.DIGITAL_SIGNATURE_XML_SIGNATURE_PART);\n        }\n\n        try {\n            OutputStream os = sigPart.getOutputStream();\n            SignatureDocument sigDoc = SignatureDocument.Factory.parse(document, DEFAULT_XML_OPTIONS);\n            sigDoc.save(os, xo);\n            os.close();\n        } catch (Exception e) {\n            throw new MarshalException("Unable to write signature document", e);\n        }\n\n        PackagePart sigsPart = pkg.getPart(sigsPartName);\n        if (sigsPart == null) {\n                        sigsPart = pkg.createPart(sigsPartName, ContentTypes.DIGITAL_SIGNATURE_ORIGIN_PART);\n        }\n\n        PackageRelationshipCollection relCol = pkg.getRelationshipsByType(PackageRelationshipTypes.DIGITAL_SIGNATURE_ORIGIN);\n        for (PackageRelationship pr : relCol) {\n            pkg.removeRelationship(pr.getId());\n        }\n        pkg.addRelationship(sigsPartName, TargetMode.INTERNAL, PackageRelationshipTypes.DIGITAL_SIGNATURE_ORIGIN);\n\n        sigsPart.addRelationship(sigPartName, TargetMode.INTERNAL, PackageRelationshipTypes.DIGITAL_SIGNATURE);\n    }
1181	public synchronized void finished(FrozenBufferedUpdates packet) {\n                assert packet.applied.getCount() == 1: "packet=" + packet;\n\n    packet.applied.countDown();\n\n    updates.remove(packet);\n    numTerms.addAndGet(-packet.numTermDeletes);\n    assert numTerms.get() >= 0: "numTerms=" + numTerms + " packet=" + packet;\n    \n    bytesUsed.addAndGet(-packet.bytesUsed);\n\n    finishedSegment(packet.delGen());\n  }
1182	private XSLFNotes createNotesSlide(XSLFSlide slide) {\n\n        if (_notesMaster == null) {\n            createNotesMaster();\n        }\n\n        int slideIndex = XSLFRelation.SLIDE.getFileNameIndex(slide);\n\n        XSLFRelation relationType = XSLFRelation.NOTES;\n        slideIndex = findNextAvailableFileNameIndex(relationType, slideIndex);\n\n                XSLFNotes notesSlide = (XSLFNotes) createRelationship\n                (relationType, XSLFFactory.getInstance(), slideIndex);\n                slide.addRelation(null, relationType, notesSlide);\n        notesSlide.addRelation(null, XSLFRelation.NOTES_MASTER, _notesMaster);\n        notesSlide.addRelation(null, XSLFRelation.SLIDE, slide);\n\n        notesSlide.importContent(_notesMaster);\n\n        return notesSlide;\n    }
1183	public void bufferSkip(int df) throws IOException {\n\n    assert df % skipInterval == 0;\n    int numLevels = 1;\n    df /= skipInterval;\n   \n        while ((df % skipMultiplier) == 0 && numLevels < numberOfSkipLevels) {\n      numLevels++;\n      df /= skipMultiplier;\n    }\n    \n    long childPointer = 0;\n    \n    for (int level = 0; level < numLevels; level++) {\n      writeSkipData(level, skipBuffer[level]);\n      \n      long newChildPointer = skipBuffer[level].getFilePointer();\n      \n      if (level != 0) {\n                skipBuffer[level].writeVLong(childPointer);\n      }\n      \n            childPointer = newChildPointer;\n    }\n  }
1184	private void initSimple() throws IOException {\n        pq.clear();\n        for (PhrasePositions pp : phrasePositions) {\n      pp.firstPosition();\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n  }
1185	public static Year parseYear(String s) {\n\n                int y;\n        try {\n            y = Integer.parseInt(s.trim());\n        }\n        catch (NumberFormatException e) {\n            throw new TimePeriodFormatException("Cannot parse string.");\n        }\n\n                try {\n            return new Year(y);\n        }\n        catch (IllegalArgumentException e) {\n            throw new TimePeriodFormatException("Year outside valid range.");\n        }\n    }
1186	public void removeSeries(TimePeriodValues series) {\n        ParamChecks.nullNotPermitted(series, "series");\n        this.data.remove(series);\n        series.removeChangeListener(this);\n        fireDatasetChanged();\n\n    }
1187	public void setSelectedTabs(Collection<Integer> indexes) {\n\n        for (int index : indexes) {\n            validateSheetIndex(index);\n        }\n                Set<Integer> set = new HashSet<>(indexes);\n        int nSheets = _sheets.size();\n        for (int i=0; i<nSheets; i++) {\n            boolean bSelect = set.contains(i);\n            getSheetAt(i).setSelected(bSelect);\n        }\n                short nSelected = (short) set.size();\n        workbook.getWindowOne().setNumSelectedTabs(nSelected);\n    }
1188	private String parseAsColumnQuantifier() {\n        if ( look != '[') {\n            return null;\n        }\n        GetChar();\n        if (look == '#') {\n            return null;\n        }\n        if (look == '@') {\n            GetChar();\n        }\n        StringBuilder name = new StringBuilder();\n        while (look!=']') {\n           name.appendCodePoint(look);\n           GetChar();\n        }\n        Match(']');\n        return name.toString();\n    }
1189	public static Number[] createNumberArray(double[] data) {\n        Number[] result = new Number[data.length];\n        for (int i = 0; i < data.length; i++) {\n            result[i] = new Double(data[i]);\n        }\n        return result;\n    }
1190	protected Query newPhraseQuery(String text, int slop) {\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    for (Map.Entry<String,Float> entry : weights.entrySet()) {\n      Query q = createPhraseQuery(entry.getKey(), text, slop);\n      if (q != null) {\n        float boost = entry.getValue();\n        if (boost != 1f) {\n          q = new BoostQuery(q, boost);\n        }\n        bq.add(q, BooleanClause.Occur.SHOULD);\n      }\n    }\n    return simplify(bq.build());\n  }
1191	private static HorizontalAlignment getHorizontalAlignment(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        HorizontalAlignment align;\n        if (value instanceof HorizontalAlignment) {\n            align = (HorizontalAlignment) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map used a Short value for "\n                        + name + ". Should use HorizontalAlignment enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            align = HorizontalAlignment.forInt(code);\n        }\n        else if (value == null) {\n            align = HorizontalAlignment.GENERAL;\n        }\n        else {\n            throw new RuntimeException("Unexpected horizontal alignment style class. Must be HorizontalAlignment or Short (deprecated).");\n        }\n        return align;\n    }
1192	public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException("invalid path, must contain shard ID and action, e.g. */s1/update");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException("Unsupported action provided: " + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException("unrecognized shard ID " + pathElements[SHARD_IDX]);\n    }\n    \n        ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0);           } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR);       try {\n        "identified exceptions"\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException("Could not serialize", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }
1193	private static void validateFunctionName(String functionName) {\n		int len = functionName.length();\n		int ix = len - 1;\n		if (!Character.isDigit(functionName.charAt(ix))) {\n			return;\n		}\n		while(ix >= 0) {\n			if (!Character.isDigit(functionName.charAt(ix))) {\n				break;\n			}\n			ix--;\n		}\n		if(DIGIT_ENDING_FUNCTION_NAMES_SET.contains(functionName)) {\n			return;\n		}\n		throw new RuntimeException("Invalid function name '" + functionName\n				+ "' (is footnote number incorrectly appended)");\n	}
1194	public static long pop_andnot(long[] arr1, long[] arr2, int wordOffset, int numWords) {\n    long popCount = 0;\n    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {\n      popCount += Long.bitCount(arr1[i] & ~arr2[i]);\n    }\n    return popCount;\n  }
1195	public static Minute parseMinute(String s) {\n        Minute result = null;\n        s = s.trim();\n\n        String daystr = s.substring(0, Math.min(10, s.length()));\n        Day day = Day.parseDay(daystr);\n        if (day != null) {\n            String hmstr = s.substring(\n                Math.min(daystr.length() + 1, s.length()), s.length()\n            );\n            hmstr = hmstr.trim();\n\n            String hourstr = hmstr.substring(0, Math.min(2, hmstr.length()));\n            int hour = Integer.parseInt(hourstr);\n\n            if ((hour >= 0) && (hour <= 23)) {\n                String minstr = hmstr.substring(\n                    Math.min(hourstr.length() + 1, hmstr.length()),\n                    hmstr.length()\n                );\n                int minute = Integer.parseInt(minstr);\n                if ((minute >= 0) && (minute <= 59)) {\n                    result = new Minute(minute, new Hour(hour, day));\n                }\n            }\n        }\n        return result;\n    }
1196	public final BytesRef normalize(final String fieldName, final String text) {\n    try {\n            final String filteredText;\n      try (Reader reader = new StringReader(text)) {\n        Reader filterReader = initReaderForNormalization(fieldName, reader);\n        char[] buffer = new char[64];\n        StringBuilder builder = new StringBuilder();\n        for (;;) {\n          final int read = filterReader.read(buffer, 0, buffer.length);\n          if (read == -1) {\n            break;\n          }\n          builder.append(buffer, 0, read);\n        }\n        filteredText = builder.toString();\n      } catch (IOException e) {\n        throw new IllegalStateException("Normalization threw an unexpected exception", e);\n      }\n\n      final AttributeFactory attributeFactory = attributeFactory(fieldName);\n      try (TokenStream ts = normalize(fieldName,\n          new StringTokenStream(attributeFactory, filteredText, text.length()))) {\n        final TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n        ts.reset();\n        if (ts.incrementToken() == false) {\n          throw new IllegalStateException("The normalization token stream is "\n              + "expected to produce exactly 1 token, but got 0 for analyzer "\n              + this + " and input \"" + text + "\"");\n        }\n        final BytesRef term = BytesRef.deepCopyOf(termAtt.getBytesRef());\n        if (ts.incrementToken()) {\n          throw new IllegalStateException("The normalization token stream is "\n              + "expected to produce exactly 1 token, but got 2+ for analyzer "\n              + this + " and input \"" + text + "\"");\n        }\n        ts.end();\n        return term;\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException("Normalization threw an unexpected exception", e);\n    }\n  }
1197	public QualityQuery[] readQueries(BufferedReader reader) throws IOException {\n    ArrayList<QualityQuery> res = new ArrayList<>();\n    StringBuilder sb;\n    try {\n      while (null!=(sb=read(reader,"<top>",null,false,false))) {\n        HashMap<String,String> fields = new HashMap<>();\n                sb = read(reader,"<num>",null,true,false);\n        int k = sb.indexOf(":");\n        String id = sb.substring(k+1).trim();\n                sb = read(reader,"<title>",null,true,false);\n        k = sb.indexOf(">");\n        String title = sb.substring(k+1).trim();\n                read(reader,"<desc>",null,false,false);\n        sb.setLength(0);\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n          if (line.startsWith("<narr>"))\n            break;\n          if (sb.length() > 0) sb.append(' ');\n          sb.append(line);\n        }\n        String description = sb.toString().trim();\n                sb.setLength(0);\n        while ((line = reader.readLine()) != null) {\n          if (line.startsWith("</top>"))\n            break;\n          if (sb.length() > 0) sb.append(' ');\n          sb.append(line);\n        }\n        String narrative = sb.toString().trim();\n                fields.put("title",title);\n        fields.put("description",description);\n        fields.put("narrative", narrative);\n        QualityQuery topic = new QualityQuery(id,fields);\n        res.add(topic);\n      }\n    } finally {\n      reader.close();\n    }\n        QualityQuery qq[] = res.toArray(new QualityQuery[0]);\n    Arrays.sort(qq);\n    return qq;\n  }
1198	public boolean crosses(final PlanetModel planetModel, final Plane q, final GeoPoint[] notablePoints, final GeoPoint[] moreNotablePoints, final Membership[] bounds, final Membership... moreBounds) {\n                        if (isNumericallyIdentical(q)) {\n                        for (GeoPoint p : notablePoints) {\n        if (meetsAllBounds(p, bounds, moreBounds)) {\n                    return true;\n        }\n      }\n      for (GeoPoint p : moreNotablePoints) {\n        if (meetsAllBounds(p, bounds, moreBounds)) {\n                    return true;\n        }\n      }\n            return false;\n    }\n    \n                final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n                  return false;\n    }\n\n                                                                                double x0;\n    double y0;\n    double z0;\n        final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n            if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return false;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n            if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return false;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n            if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n                return false;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n                                final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n                  return false;\n    } else if (BsquaredMinus > 0.0) {\n            final double inverse2A = 1.0 / (2.0 * A);\n            final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n            final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      boolean point1Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      if (point1Valid) {\n        return true;\n      }\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          return false;\n        }\n      }\n      for (final Membership bound : moreBounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n            return false;\n    }\n  }
1199	synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : "IndexWriter lock should never be hold when aborting";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled("DW")) {\n        infoStream.message("DW", "abort");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled("DW")) {\n        infoStream.message("DW", "done abort success=" + success);\n      }\n    }\n  }
1200	protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, int datasetIndex,\n            Comparable rowKey, Comparable columnKey, Stroke stroke,\n            Paint paint) {\n\n        CategoryDataset dataset = getDataset(datasetIndex);\n        CategoryAxis axis = getDomainAxisForDataset(datasetIndex);\n        CategoryItemRenderer renderer = getRenderer(datasetIndex);\n        Line2D line;\n        if (orientation == PlotOrientation.VERTICAL) {\n            double xx = renderer.getItemMiddle(rowKey, columnKey, dataset, axis,\n                    dataArea, RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = renderer.getItemMiddle(rowKey, columnKey, dataset, axis,\n                    dataArea, RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }
1201	protected void adjustUpwards(double minY, double height) {\n        for (int i = this.labels.size() - 1; i > 0; i--) {\n            PieLabelRecord record0 = getPieLabelRecord(i);\n            PieLabelRecord record1 = getPieLabelRecord(i - 1);\n            if (record1.getUpperY() > record0.getLowerY()) {\n                record1.setAllocatedY(Math.max(minY\n                        + record1.getLabelHeight() / 2.0, record0.getLowerY()\n                        - this.minGap - record1.getLabelHeight() / 2.0));\n            }\n        }\n    }
1202	private Ptg rowCopyAreaPtg(AreaPtgBase aptg) {\n        boolean changed = false;\n    \n        final int aFirstRow = aptg.getFirstRow();\n        final int aLastRow = aptg.getLastRow();\n    \n        if (aptg.isFirstRowRelative()) {\n            final int destFirstRowIndex = aFirstRow + _amountToMove;\n            if (destFirstRowIndex < 0 || _version.getLastRowIndex() < destFirstRowIndex)\n                return createDeletedRef(aptg);\n            aptg.setFirstRow(destFirstRowIndex);\n            changed = true;\n        }\n        if (aptg.isLastRowRelative()) {\n            final int destLastRowIndex = aLastRow + _amountToMove;\n            if (destLastRowIndex < 0 || _version.getLastRowIndex() < destLastRowIndex)\n                return createDeletedRef(aptg);\n            aptg.setLastRow(destLastRowIndex);\n            changed = true;\n        }\n        if (changed) {\n            aptg.sortTopLeftToBottomRight();\n        }\n\n        return changed ? aptg : null;\n    }
1203	public void adjustForDelete(int start, int length) {\n        int end = start + length;\n\n        if (_cpEnd > start) {\n            \n            if (_cpStart < end) {\n                                _cpEnd = end >= _cpEnd ? start : _cpEnd - length;\n                _cpStart = Math.min(start, _cpStart);\n            } else {\n                                _cpEnd -= length;\n                _cpStart -= length;\n            }\n        }\n    }
1204	static void dataBars(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Data Bars");\n        Row r = sheet.createRow(1);\n        r.createCell(1).setCellValue("Green Positive");\n        r.createCell(2).setCellValue("Blue Mix");\n        r.createCell(3).setCellValue("Red Negative");\n        r = sheet.createRow(2);\n        r.createCell(1).setCellValue(0);\n        r.createCell(2).setCellValue(0);\n        r.createCell(3).setCellValue(0);\n        r = sheet.createRow(3);\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(-5);\n        r.createCell(3).setCellValue(-5);\n        r = sheet.createRow(4);\n        r.createCell(1).setCellValue(10);\n        r.createCell(2).setCellValue(10);\n        r.createCell(3).setCellValue(-10);\n        r = sheet.createRow(5);\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(5);\n        r.createCell(3).setCellValue(-5);\n        r = sheet.createRow(6);\n        r.createCell(1).setCellValue(20);\n        r.createCell(2).setCellValue(-10);\n        r.createCell(3).setCellValue(-20);\n        sheet.setColumnWidth(0, 3000);\n        sheet.setColumnWidth(1, 5000);\n        sheet.setColumnWidth(2, 5000);\n        sheet.setColumnWidth(3, 5000);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n        ExtendedColor color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FF63BE7B");\n        CellRangeAddress[] regions = { CellRangeAddress.valueOf("B2:B7") };\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db1 = rule1.getDataBarFormatting();\n        db1.getMinThreshold().setRangeType(RangeType.MIN);\n        db1.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule1);\n        \n        color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FF5A8AC6");\n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("C2:C7") };\n        ConditionalFormattingRule rule2 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db2 = rule2.getDataBarFormatting();\n        db2.getMinThreshold().setRangeType(RangeType.MIN);\n        db2.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        \n        color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FFF8696B");\n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("D2:D7") };\n        ConditionalFormattingRule rule3 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db3 = rule3.getDataBarFormatting();\n        db3.getMinThreshold().setRangeType(RangeType.MIN);\n        db3.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule3);\n    }
1205	protected void resetSkip() {\n    if (skipBuffer == null) {\n      init();\n    } else {\n      for (int i = 0; i < skipBuffer.length; i++) {\n        skipBuffer[i].reset();\n      }\n    }      \n  }
1206	public static String convertNumToColString(int col) {\n                        int excelColNum = col + 1;\n\n        StringBuilder colRef = new StringBuilder(2);\n        int colRemain = excelColNum;\n\n        while(colRemain > 0) {\n            int thisPart = colRemain % 26;\n            if(thisPart == 0) { thisPart = 26; }\n            colRemain = (colRemain - thisPart) / 26;\n\n                        char colChar = (char)(thisPart+64);\n            colRef.insert(0, colChar);\n        }\n\n        return colRef.toString();\n    }
1207	private void countMultiValued(String field, List<MatchingDocs> matchingDocs) throws IOException {\n\n    for (MatchingDocs hits : matchingDocs) {\n      SortedNumericDocValues values = hits.context.reader().getSortedNumericDocValues(field);\n      if (values == null) {\n                continue;\n      }\n\n      NumericDocValues singleValues = DocValues.unwrapSingleton(values);\n\n      if (singleValues != null) {\n        countOneSegment(singleValues, hits);\n      } else {\n\n        DocIdSetIterator it = ConjunctionDISI.intersectIterators(\n                                 Arrays.asList(hits.bits.iterator(), values));\n      \n        for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n          int limit = values.docValueCount();\n          totCount += limit;\n          for (int i = 0; i < limit; i++) {\n            increment(values.nextValue());\n          }\n        }\n      }\n    }\n  }
1208	private static int findSeparator(String s) {\n        int result = s.indexOf('-');\n        if (result == -1) {\n            result = s.indexOf(',');\n        }\n        if (result == -1) {\n            result = s.indexOf(' ');\n        }\n        if (result == -1) {\n            result = s.indexOf('.');\n        }\n        return result;\n    }
1209	private void saveAsPDF(File f) {\n        File file = f;\n        if (file == null) {\n            JFileChooser fileChooser = new JFileChooser();\n            fileChooser.setCurrentDirectory(this.defaultDirectoryForSaveAs);\n            FileNameExtensionFilter filter = new FileNameExtensionFilter(\n                    localizationResources.getString("PDF_Files"), "pdf");\n            fileChooser.addChoosableFileFilter(filter);\n            fileChooser.setFileFilter(filter);\n\n            int option = fileChooser.showSaveDialog(this);\n            if (option == JFileChooser.APPROVE_OPTION) {\n                String filename = fileChooser.getSelectedFile().getPath();\n                if (isEnforceFileExtensions()) {\n                    if (!filename.endsWith(".pdf")) {\n                        filename = filename + ".pdf";\n                    }\n                }\n                file = new File(filename);\n                if (file.exists()) {\n                    String fileExists = localizationResources.getString(\n                            "FILE_EXISTS_CONFIRM_OVERWRITE");\n                    int response = JOptionPane.showConfirmDialog(this, \n                            fileExists, "Save As PDF", \n                            JOptionPane.OK_CANCEL_OPTION);\n                    if (response == JOptionPane.CANCEL_OPTION) {\n                        file = null;\n                    }\n                }\n            }\n        }\n        \n        if (file != null) {\n            writeAsPDF(file, getWidth(), getHeight());\n        }\n    }
1210	public static Calendar getLocaleCalendar(int year, int month, int day, int hour, int minute, int second) {\n        Calendar cal = getLocaleCalendar();\n        cal.set(year,  month, day, hour, minute, second);\n        cal.clear(Calendar.MILLISECOND);\n        return cal;\n    }
1211	public ExtendedFormatRecord createCellXF() {\n        ExtendedFormatRecord xf = createExtendedFormat();\n\n        records.add(records.getXfpos()+1, xf);\n        records.setXfpos( records.getXfpos() + 1 );\n        numxfs++;\n        return xf;\n    }
1212	public synchronized void clear() {\n    updates.clear();\n    nextGen = 1;\n    finishedSegments.clear();\n    numTerms.set(0);\n    bytesUsed.set(0);\n  }
1213	protected PackageRelationship getPackageRelationship(POIXMLDocumentPart parent, PackagePart part) {\n         try {\n             String partName = part.getPartName().getName();\n             for (PackageRelationship pr : parent.getPackagePart().getRelationships()) {\n                 String packName = pr.getTargetURI().toASCIIString();\n                 if (packName.equalsIgnoreCase(partName)) {\n                     return pr;\n                 }\n             }\n         } catch (InvalidFormatException e) {\n             throw new POIXMLException("error while determining package relations", e);\n         }\n         \n         throw new POIXMLException("package part isn't a child of the parent document.");\n     }
1214	public static void printStats(TaxonomyReader r, PrintStream out, boolean printTree) throws IOException {\n    out.println(r.getSize() + " total categories.");\n\n    ChildrenIterator it = r.getChildren(TaxonomyReader.ROOT_ORDINAL);\n    int child;\n    while ((child = it.next()) != TaxonomyReader.INVALID_ORDINAL) {\n      ChildrenIterator chilrenIt = r.getChildren(child);\n      int numImmediateChildren = 0;\n      while (chilrenIt.next() != TaxonomyReader.INVALID_ORDINAL) {\n        numImmediateChildren++;\n      }\n      FacetLabel cp = r.getPath(child);\n      out.println("/" + cp.components[0] + ": " + numImmediateChildren + " immediate children; " + (1+countAllChildren(r, child)) + " total categories");\n      if (printTree) {\n        printAllChildren(out, r, child, "  ", 1);\n      }\n    }\n  }
1215	protected void spreadEvenly(double minY, double height) {\n        double y = minY;\n        double sumOfLabelHeights = 0.0;\n        for (int i = 0; i < this.labels.size(); i++) {\n            sumOfLabelHeights += getPieLabelRecord(i).getLabelHeight();\n        }\n        double gap = height - sumOfLabelHeights;\n        if (this.labels.size() > 1) {\n            gap = gap / (this.labels.size() - 1);\n        }\n        for (int i = 0; i < this.labels.size(); i++) {\n            PieLabelRecord record = getPieLabelRecord(i);\n            y = y + record.getLabelHeight() / 2.0;\n            record.setAllocatedY(y);\n            y = y + record.getLabelHeight() / 2.0 + gap;\n        }\n    }
1216	private void drawZoomRectangle(Graphics2D g2, boolean xor) {\n        if (this.zoomRectangle != null) {\n            if (xor) {\n                                 g2.setXORMode(Color.gray);\n            }\n            if (this.fillZoomRectangle) {\n                g2.setPaint(this.zoomFillPaint);\n                g2.fill(this.zoomRectangle);\n            }\n            else {\n                g2.setPaint(this.zoomOutlinePaint);\n                g2.draw(this.zoomRectangle);\n            }\n            if (xor) {\n                                g2.setPaintMode();\n            }\n        }\n    }
1217	public void clearRangeCrosshairs() {\n        if (this.yCrosshairs.isEmpty()) {\n            return;          }\n        List crosshairs = getRangeCrosshairs();\n        for (int i = 0; i < crosshairs.size(); i++) {\n            Crosshair c = (Crosshair) crosshairs.get(i);\n            this.yCrosshairs.remove(c);\n            c.removePropertyChangeListener(this);\n        }\n        fireOverlayChanged();\n    }
1218	protected static Map<String, String> parseMap(String body) {\n    Map<String, String> map = new HashMap<>();\n    StringTokenizer st = new StringTokenizer(body, " \n\t");\n    while (st.hasMoreTokens()) {\n      String a = st.nextToken();\n      int idx = a.indexOf('=');\n      if (idx > 0) {\n        String k = a.substring(0, idx);\n        String v = a.substring(idx + 1);\n        map.put(k, v);\n      } else {\n        map.put(a, a);\n      }\n    }\n    return map;\n  }
1219	static void readVIntBlock(IndexInput docIn, int[] docBuffer,\n      int[] freqBuffer, int num, boolean indexHasFreq) throws IOException {\n    if (indexHasFreq) {\n      for(int i=0;i<num;i++) {\n        final int code = docIn.readVInt();\n        docBuffer[i] = code >>> 1;\n        if ((code & 1) != 0) {\n          freqBuffer[i] = 1;\n        } else {\n          freqBuffer[i] = docIn.readVInt();\n        }\n      }\n    } else {\n      for(int i=0;i<num;i++) {\n        docBuffer[i] = docIn.readVInt();\n      }\n    }\n  }
1220	protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways,\n          String[] drillSidewaysDims) throws IOException {\n\n    Facets drillDownFacets;\n    Map<String, Facets> drillSidewaysFacets = new HashMap<>();\n\n    if (taxoReader != null) {\n      drillDownFacets = new FastTaxonomyFacetCounts(taxoReader, config, drillDowns);\n      if (drillSideways != null) {\n        for (int i = 0; i < drillSideways.length; i++) {\n          drillSidewaysFacets.put(drillSidewaysDims[i],\n                  new FastTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n        }\n      }\n    } else {\n      drillDownFacets = new SortedSetDocValuesFacetCounts(state, drillDowns);\n      if (drillSideways != null) {\n        for (int i = 0; i < drillSideways.length; i++) {\n          drillSidewaysFacets.put(drillSidewaysDims[i], new SortedSetDocValuesFacetCounts(state, drillSideways[i]));\n        }\n      }\n    }\n\n    if (drillSidewaysFacets.isEmpty()) {\n      return drillDownFacets;\n    } else {\n      return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n    }\n  }
1221	public static boolean isCellDateFormatted(Cell cell, ConditionalFormattingEvaluator cfEvaluator) {\n        if (cell == null) return false;\n        boolean bDate = false;\n\n        double d = cell.getNumericCellValue();\n        if ( DateUtil.isValidExcelDate(d) ) {\n            ExcelNumberFormat nf = ExcelNumberFormat.from(cell, cfEvaluator);\n            if(nf==null) return false;\n            bDate = isADateFormat(nf);\n        }\n        return bDate;\n    }
1222	private synchronized void updateIOThrottle(OneMerge newMerge, MergeRateLimiter rateLimiter) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n                  return;\n    }\n\n    long now = System.nanoTime();\n\n                boolean newBacklog = isBacklog(now, newMerge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n                curBacklog = true;\n      } else {\n                for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n            targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, "io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, "io throttle: new merge backlog; increase IO rate to %.1f MB/sec", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n            if (verbose()) {\n        message(String.format(Locale.ROOT, "io throttle: current merge backlog; leave IO rate at %.1f MB/sec",\n                              targetMBPerSec));\n      }\n    } else {\n            targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, "io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, "io throttle: no merge backlog; decrease IO rate to %.1f MB/sec", targetMBPerSec));\n        }\n      }\n    }\n\n    double rate;\n\n    if (newMerge.maxNumSegments != -1) {\n      rate = forceMergeMBPerSec;\n    } else {\n      rate = targetMBPerSec;\n    }\n    rateLimiter.setMBPerSec(rate);\n    targetMBPerSecChanged();\n  }
1223	public static void main(String[] args) throws IOException {\n        if(args.length < 2) {\n            System.err.println("Use:");\n            System.err.println("  HMEFContentsExtractor <filename> <output dir>");\n            System.err.println("");\n            System.err.println("");\n            System.err.println("Where <filename> is the winmail.dat file to extract,");\n            System.err.println(" and <output dir> is where to place the extracted files");\n            System.exit(2);\n        }\n        \n        final String filename = args[0];\n        final String outputDir = args[1];\n        \n        HMEFContentsExtractor ext = new HMEFContentsExtractor(new File(filename));\n        \n        File dir = new File(outputDir);\n        File rtf = new File(dir, "message.rtf");\n        if(! dir.exists()) {\n            throw new FileNotFoundException("Output directory " + dir.getName() + " not found");\n        }\n        \n        System.out.println("Extracting...");\n        ext.extractMessageBody(rtf);\n        ext.extractAttachments(dir);\n        System.out.println("Extraction completed");\n    }
1224	public static Month parseMonth(String s) {\n        Month result = null;\n        if (s == null) {\n            return result;\n        }\n                s = s.trim();\n        int i = Month.findSeparator(s);\n        String s1, s2;\n        boolean yearIsFirst;\n                        if (i == -1) {\n            yearIsFirst = true;\n            s1 = s.substring(0, 5);\n            s2 = s.substring(5);\n        }\n        else {\n            s1 = s.substring(0, i).trim();\n            s2 = s.substring(i + 1, s.length()).trim();\n                        Year y1 = Month.evaluateAsYear(s1);\n            if (y1 == null) {\n                yearIsFirst = false;\n            }\n            else {\n                Year y2 = Month.evaluateAsYear(s2);\n                if (y2 == null) {\n                    yearIsFirst = true;\n                }\n                else {\n                    yearIsFirst = (s1.length() > s2.length());\n                }\n            }\n        }\n        Year year;\n        int month;\n        if (yearIsFirst) {\n            year = Month.evaluateAsYear(s1);\n            month = SerialDate.stringToMonthCode(s2);\n        }\n        else {\n            year = Month.evaluateAsYear(s2);\n            month = SerialDate.stringToMonthCode(s1);\n        }\n        if (month == -1) {\n            throw new TimePeriodFormatException("Can't evaluate the month.");\n        }\n        if (year == null) {\n            throw new TimePeriodFormatException("Can't evaluate the year.");\n        }\n        result = new Month(month, year);\n        return result;\n    }
1225	public Path2D.Double getBoundsAsPath() {\n\n        Rectangle2D.Double rect = getTextBounds();\n        Double w = rect.getWidth();\n        Double h = rect.getHeight();\n\n        Path2D.Double bounds = new Path2D.Double();\n        bounds.moveTo(0, 0);\n        bounds.lineTo(w, 0);\n        bounds.lineTo(w, h);\n        bounds.lineTo(0, h);\n        bounds.lineTo(0, 0);\n\n        return bounds;\n    }
1226	public static JFreeChart createWaterfallChart(String title,\n            String categoryAxisLabel, String valueAxisLabel,\n            CategoryDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel);\n        categoryAxis.setCategoryMargin(0.0);\n\n        ValueAxis valueAxis = new NumberAxis(valueAxisLabel);\n\n        WaterfallBarRenderer renderer = new WaterfallBarRenderer();\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            ItemLabelPosition position = new ItemLabelPosition(\n                    ItemLabelAnchor.CENTER, TextAnchor.CENTER,\n                    TextAnchor.CENTER, Math.PI / 2.0);\n            renderer.setBasePositiveItemLabelPosition(position);\n            renderer.setBaseNegativeItemLabelPosition(position);\n         }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            ItemLabelPosition position = new ItemLabelPosition(\n                    ItemLabelAnchor.CENTER, TextAnchor.CENTER,\n                    TextAnchor.CENTER, 0.0);\n            renderer.setBasePositiveItemLabelPosition(position);\n            renderer.setBaseNegativeItemLabelPosition(position);\n        }\n        if (tooltips) {\n            StandardCategoryToolTipGenerator generator\n                = new StandardCategoryToolTipGenerator();\n            renderer.setBaseToolTipGenerator(generator);\n        }\n        if (urls) {\n            renderer.setBaseItemURLGenerator(\n                    new StandardCategoryURLGenerator());\n        }\n\n        CategoryPlot plot = new CategoryPlot(dataset, categoryAxis, valueAxis,\n                renderer);\n        plot.clearRangeMarkers();\n        Marker baseline = new ValueMarker(0.0);\n        baseline.setPaint(Color.black);\n        plot.addRangeMarker(baseline, Layer.FOREGROUND);\n        plot.setOrientation(orientation);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
1227	public void write(String baseDir) throws IOException {\n    final String baseName = getBaseFileName(baseDir);\n    writeDictionary(baseName + BinaryDictionary.DICT_FILENAME_SUFFIX);\n    writeTargetMap(baseName + BinaryDictionary.TARGETMAP_FILENAME_SUFFIX);\n    writePosDict(baseName + BinaryDictionary.POSDICT_FILENAME_SUFFIX);\n  }
1228	public void liftUp(Row in, List<Row> nodes) {\n    Iterator<Cell> i = in.cells.values().iterator();\n    for (; i.hasNext();) {\n      Cell c = i.next();\n      if (c.ref >= 0) {\n        Row to = nodes.get(c.ref);\n        int sum = to.uniformCmd(changeSkip);\n        if (sum >= 0) {\n          if (sum == c.cmd) {\n            if (changeSkip) {\n              if (c.skip != to.uniformSkip + 1) {\n                continue;\n              }\n              c.skip = to.uniformSkip + 1;\n            } else {\n              c.skip = 0;\n            }\n            c.cnt += to.uniformCnt;\n            c.ref = -1;\n          } else if (c.cmd < 0) {\n            c.cnt = to.uniformCnt;\n            c.cmd = sum;\n            c.ref = -1;\n            if (changeSkip) {\n              c.skip = to.uniformSkip + 1;\n            } else {\n              c.skip = 0;\n            }\n          }\n        }\n      }\n    }\n  }
1229	private void saveAsSVG(File f) throws IOException {\n        File file = f;\n        if (file == null) {\n            JFileChooser fileChooser = new JFileChooser();\n            fileChooser.setCurrentDirectory(this.defaultDirectoryForSaveAs);\n            FileNameExtensionFilter filter = new FileNameExtensionFilter(\n                    localizationResources.getString("SVG_Files"), "svg");\n            fileChooser.addChoosableFileFilter(filter);\n            fileChooser.setFileFilter(filter);\n\n            int option = fileChooser.showSaveDialog(this);\n            if (option == JFileChooser.APPROVE_OPTION) {\n                String filename = fileChooser.getSelectedFile().getPath();\n                if (isEnforceFileExtensions()) {\n                    if (!filename.endsWith(".svg")) {\n                        filename = filename + ".svg";\n                    }\n                }\n                file = new File(filename);\n                if (file.exists()) {\n                    String fileExists = localizationResources.getString(\n                            "FILE_EXISTS_CONFIRM_OVERWRITE");\n                    int response = JOptionPane.showConfirmDialog(this, \n                            fileExists, "Save As SVG", \n                            JOptionPane.OK_CANCEL_OPTION);\n                    if (response == JOptionPane.CANCEL_OPTION) {\n                        file = null;\n                    }\n                }\n            }\n        }\n        \n        if (file != null) {\n                        String svg = generateSVG(getWidth(), getHeight());\n            BufferedWriter writer = null;\n            try {\n                writer = new BufferedWriter(new FileWriter(file));\n                writer.write("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n");\n                writer.write(svg + "\n");\n                writer.flush();\n            } finally {\n                try {\n                    if (writer != null) {\n                        writer.close();\n                    }\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            } \n\n        }\n    }
1230	public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries("Overwritten values from: "\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }
1231	protected int getFreeBlock() throws IOException {\n       int sectorsPerSBAT = _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\n       \n              int offset = 0;\n        for (BATBlock sbat : _sbat_blocks) {\n                        if (sbat.hasFreeSectors()) {\n                                for (int j = 0; j < sectorsPerSBAT; j++) {\n                    int sbatValue = sbat.getValueAt(j);\n                    if (sbatValue == POIFSConstants.UNUSED_BLOCK) {\n                                                return offset + j;\n                    }\n                }\n            }\n\n                        offset += sectorsPerSBAT;\n        }\n       \n                            \n              BATBlock newSBAT = BATBlock.createEmptyBATBlock(_filesystem.getBigBlockSizeDetails(), false);\n       int batForSBAT = _filesystem.getFreeBlock();\n       newSBAT.setOurBlockIndex(batForSBAT);\n       \n              if(_header.getSBATCount() == 0) {\n                    _header.setSBATStart(batForSBAT);\n          _header.setSBATBlockCount(1);\n       } else {\n                    ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\n          int batOffset = _header.getSBATStart();\n          while(true) {\n             loopDetector.claim(batOffset);\n             int nextBat = _filesystem.getNextBlock(batOffset);\n             if(nextBat == POIFSConstants.END_OF_CHAIN) {\n                break;\n             }\n             batOffset = nextBat;\n          }\n          \n                    _filesystem.setNextBlock(batOffset, batForSBAT);\n          \n                    _header.setSBATBlockCount(\n                _header.getSBATCount() + 1\n          );\n       }\n       \n              _filesystem.setNextBlock(batForSBAT, POIFSConstants.END_OF_CHAIN);\n       _sbat_blocks.add(newSBAT);\n       \n              return offset;\n    }
1232	public BigDecimal parseMediumKanjiNumeral(NumberBuffer buffer) {\n    int i = buffer.position();\n\n    if (i >= buffer.length()) {\n      return null;\n    }\n\n    char c = buffer.charAt(i);\n    int power = exponents[c];\n\n    if (1 <= power && power <= 3) {\n      buffer.advance();\n      return BigDecimal.TEN.pow(power);\n    }\n\n    return null;\n  }
1233	protected void preSerialize(){\n        Map<Integer, NoteRecord> tailRecords = _boundAggregate.getTailRecords();\n        \n        Set<String> coordinates = new HashSet<>(tailRecords.size());\n        for(NoteRecord rec : tailRecords.values()){\n            String noteRef = new CellReference(rec.getRow(),\n                    rec.getColumn(), true, true).formatAsString();             if(coordinates.contains(noteRef )){\n                throw new IllegalStateException("found multiple cell comments for cell " + noteRef );\n            } else {\n                coordinates.add(noteRef);\n            }\n        }\n    }
1234	public static void removeCodeBase(URL codeBase,\n            URLClassLoader urlClassLoader) {\n        List urlsNoBase = new ArrayList();\n\n        URL[] urls = urlClassLoader.getURLs();\n        for (int i = 0; i < urls.length; i++) {\n            if (!urls[i].sameFile(codeBase)) {\n                urlsNoBase.add(urls[i]);\n            }\n        }\n                URL[] urlsNoBaseArray = (URL[]) urlsNoBase.toArray(new URL[0]);\n        noCodeBaseClassLoader = URLClassLoader.newInstance(urlsNoBaseArray);\n    }
1235	private void unhyphenate() {\n    restoreState(savedState);\n    savedState = null;\n    \n    char term[] = termAttribute.buffer();\n    int length = hyphenated.length();\n    if (length > termAttribute.length()) {\n      term = termAttribute.resizeBuffer(length);\n    }\n    \n    hyphenated.getChars(0, length, term, 0);\n    termAttribute.setLength(length);\n    offsetAttribute.setOffset(offsetAttribute.startOffset(), lastEndOffset);\n    hyphenated.setLength(0);\n  }
1236	public void moveCell(HSSFCell cell, short newColumn) {\n                if(cells.length > newColumn && cells[newColumn] != null) {\n            throw new IllegalArgumentException("Asked to move cell to column " + newColumn + " but there's already a cell there");\n        }\n\n                if(! cells[cell.getColumnIndex()].equals(cell)) {\n            throw new IllegalArgumentException("Asked to move a cell, but it didn't belong to our row");\n        }\n\n                        removeCell(cell, false);\n        cell.updateCellNum(newColumn);\n        addCell(cell);\n    }
1237	public void cloneDrawings(InternalSheet sheet){\n\n        findDrawingGroup();\n\n        if(drawingManager == null) {\n                        return;\n        }\n\n                int aggLoc = sheet.aggregateDrawingRecords(drawingManager, false);\n        if(aggLoc == -1) {\n            return;\n        }\n        \n        EscherAggregate agg = (EscherAggregate) sheet.findFirstRecordBySid(EscherAggregate.sid);\n        EscherContainerRecord escherContainer = agg.getEscherContainer();\n        if (escherContainer == null) {\n            return;\n        }\n\n        EscherDggRecord dgg = drawingManager.getDgg();\n\n                int dgId = drawingManager.findNewDrawingGroupId();\n        dgg.addCluster( dgId, 0 );\n        dgg.setDrawingsSaved(dgg.getDrawingsSaved() + 1);\n\n        EscherDgRecord dg = null;\n        for(EscherRecord er : escherContainer) {\n            if(er instanceof EscherDgRecord) {\n                dg = (EscherDgRecord)er;\n                                dg.setOptions( (short) ( dgId << 4 ) );\n            } else if (er instanceof EscherContainerRecord){\n                                for(EscherRecord er2 : (EscherContainerRecord)er) {\n                    for(EscherRecord shapeChildRecord : (EscherContainerRecord)er2) {\n                        int recordId = shapeChildRecord.getRecordId();\n                        if (recordId == EscherSpRecord.RECORD_ID){\n                            if (dg == null) {\n                                throw new RecordFormatException("EscherDgRecord wasn't set/processed before.");\n                            }\n                            EscherSpRecord sp = (EscherSpRecord)shapeChildRecord;\n                            int shapeId = drawingManager.allocateShapeId(dg);\n                                                        dg.setNumShapes(dg.getNumShapes()-1);\n                            sp.setShapeId(shapeId);\n                        } else if (recordId == EscherOptRecord.RECORD_ID){\n                            EscherOptRecord opt = (EscherOptRecord)shapeChildRecord;\n                            EscherSimpleProperty prop = opt.lookup(\n                                    EscherProperties.BLIP__BLIPTODISPLAY );\n                            if (prop != null){\n                                int pictureIndex = prop.getPropertyValue();\n                                                                EscherBSERecord bse = getBSERecord(pictureIndex);\n                                bse.setRef(bse.getRef() + 1);\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n    }
1238	protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n                        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }
1239	public boolean removeRun(int pos) {\n        if (pos >= 0 && pos < runs.size()) {\n                        XWPFRun run = runs.get(pos);\n            if (run instanceof XWPFHyperlinkRun ||\n                run instanceof XWPFFieldRun) {\n                                                throw new IllegalArgumentException("Removing Field or Hyperlink runs not yet supported");\n            }\n            runs.remove(pos);\n            iruns.remove(run);\n                                    int rPos = 0;\n            for(int i=0;i<pos;i++) {\n              XWPFRun currRun = runs.get(i);\n              if(!(currRun instanceof XWPFHyperlinkRun || currRun instanceof XWPFFieldRun)) {\n                rPos++;\n              }\n            }\n            getCTP().removeR(rPos);\n            return true;\n        }\n        return false;\n    }
1240	public synchronized RegularTimePeriod advanceTime() {\n        RegularTimePeriod nextInstant = this.pointsInTime[this.newestAt].next();\n        this.newestAt = this.oldestAt;                                                  \n                        boolean extremaChanged = false;\n        float oldMax = 0.0f;\n        if (this.maxValue != null) {\n            oldMax = this.maxValue.floatValue();\n        }\n        for (int s = 0; s < getSeriesCount(); s++) {\n            if (this.valueHistory[s].getData(this.oldestAt) == oldMax) {\n                extremaChanged = true;\n            }\n            if (extremaChanged) {\n                break;\n            }\n        }  \n        if (extremaChanged) {\n            invalidateRangeInfo();\n        }\n                float wiper = (float) 0.0;\n        for (int s = 0; s < getSeriesCount(); s++) {\n            this.valueHistory[s].enterData(this.newestAt, wiper);\n        }\n                this.pointsInTime[this.newestAt] = nextInstant;\n                this.oldestAt++;\n        if (this.oldestAt >= this.historyCount) {\n            this.oldestAt = 0;\n        }\n                long startL = this.domainStart.longValue();          this.domainStart = new Long(startL + this.deltaTime);\n        long endL = this.domainEnd.longValue();\n        this.domainEnd = new Long(endL + this.deltaTime);\n        this.domainRange = new Range(startL, endL);\n        fireSeriesChanged();\n        return nextInstant;\n    }
1241	public int stemSuffix(char s[], int len) {\n    for (int i = 0; i < suffixes.length; i++) \n      if (endsWithCheckLength(s, len, suffixes[i]))\n        len = deleteN(s, len - suffixes[i].length, len, suffixes[i].length);\n    return len;\n  }
1242	private BigDecimal parseMediumNumber(NumberBuffer buffer) {\n    BigDecimal sum = BigDecimal.ZERO;\n    BigDecimal result = parseMediumPair(buffer);\n\n    if (result == null) {\n      return null;\n    }\n\n    while (result != null) {\n      sum = sum.add(result);\n      result = parseMediumPair(buffer);\n    }\n\n    return sum;\n  }
1243	private DisiWrapper popTail() {\n    assert tailSize > 0;\n    final DisiWrapper result = tail[0];\n    tail[0] = tail[--tailSize];\n    downHeapCost(tail, tailSize);\n    return result;\n  }
1244	public static int toChars(int[] src, int srcOff, int srcLen, char[] dest, int destOff) {\n    if (srcLen < 0) {\n      throw new IllegalArgumentException("srcLen must be >= 0");\n    }\n    int written = 0;\n    for (int i = 0; i < srcLen; ++i) {\n      written += Character.toChars(src[srcOff + i], dest, destOff + written);\n    }\n    return written;\n  }
1245	private int appendChild(Record newChild) {\n				Record[] nc = new Record[(_children.length + 1)];\n		System.arraycopy(_children, 0, nc, 0, _children.length);\n				nc[_children.length] = newChild;\n		_children = nc;\n		return _children.length;\n	}
1246	public static double calculateQ3(List values) {\n        ParamChecks.nullNotPermitted(values, "values");\n        double result = Double.NaN;\n        int count = values.size();\n        if (count > 0) {\n            if (count % 2 == 1) {\n                if (count > 1) {\n                    result = Statistics.calculateMedian(values, count / 2,\n                            count - 1);\n                }\n                else {\n                    result = Statistics.calculateMedian(values, 0, 0);\n                }\n            }\n            else {\n                result = Statistics.calculateMedian(values, count / 2,\n                        count - 1);\n            }\n        }\n        return result;\n    }
1247	public void drawDomainMarker(Graphics2D g2,\n                                 ContourPlot plot,\n                                 ValueAxis domainAxis,\n                                 Marker marker,\n                                 Rectangle2D dataArea) {\n\n        if (marker instanceof ValueMarker) {\n            ValueMarker vm = (ValueMarker) marker;\n            double value = vm.getValue();\n            Range range = domainAxis.getRange();\n            if (!range.contains(value)) {\n                return;\n            }\n\n            double x = domainAxis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(x, dataArea.getMinY(), x,\n                    dataArea.getMaxY());\n            Paint paint = marker.getOutlinePaint();\n            Stroke stroke = marker.getOutlineStroke();\n            g2.setPaint(paint != null ? paint : Plot.DEFAULT_OUTLINE_PAINT);\n            g2.setStroke(stroke != null ? stroke : Plot.DEFAULT_OUTLINE_STROKE);\n            g2.draw(line);\n        }\n\n    }
1248	String importBlip(String blipId, POIXMLDocumentPart parent) {\n        final XSLFPictureData parData = parent.getRelationPartById(blipId).getDocumentPart();\n        final XSLFPictureData pictureData;\n        if (getPackagePart().getPackage() == parent.getPackagePart().getPackage()) {\n                        pictureData = parData;\n        } else {\n            XMLSlideShow ppt = getSlideShow();\n            pictureData = ppt.addPicture(parData.getData(), parData.getType());\n        }\n\n        RelationPart rp = addRelation(blipId, XSLFRelation.IMAGES, pictureData);\n        return rp.getRelationship().getId();\n    }
1249	public void validateMaximum() {\n        double newMax;\n        try {\n            newMax = Double.parseDouble(this.maximumRangeValue.getText());\n            if (newMax <= this.minimumValue) {\n                newMax = this.maximumValue;\n            }\n        }\n        catch (NumberFormatException e) {\n            newMax = this.maximumValue;\n        }\n\n        this.maximumValue = newMax;\n        this.maximumRangeValue.setText(Double.toString(this.maximumValue));\n    }
1250	private Ptg rowCopyRefPtg(RefPtgBase rptg) {\n        final int refRow = rptg.getRow();\n        if (rptg.isRowRelative()) {\n                        final int destRowIndex = _firstMovedIndex + _amountToMove;\n            if (destRowIndex < 0 || _version.getLastRowIndex() < destRowIndex) {\n                return createDeletedRef(rptg);\n            }\n\n                        final int newRowIndex = refRow + _amountToMove;\n            if(newRowIndex < 0 || _version.getLastRowIndex() < newRowIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            rptg.setRow(newRowIndex);\n            return rptg;\n        }\n        return null;\n    }
1251	private static WriteAccessRecord createWriteAccess() {\n        WriteAccessRecord retval = new WriteAccessRecord();\n\n        String defaultUserName = "POI";\n        try {\n            String username = System.getProperty("user.name");\n                        if(username == null) {\n                username = defaultUserName;\n            }\n\n            retval.setUsername(username);\n        } catch (AccessControlException e) {\n            LOG.log(POILogger.WARN, "can't determine user.name", e);\n                                    retval.setUsername(defaultUserName);\n        }\n        return retval;\n    }
1252	public static int findLiveItemsLowerBound(XYDataset dataset, int series,\n            double xLow, double xHigh) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        if (xLow >= xHigh) {\n            throw new IllegalArgumentException("Requires xLow < xHigh.");\n        }\n        int itemCount = dataset.getItemCount(series);\n        if (itemCount <= 1) {\n            return 0;\n        }\n        if (dataset.getDomainOrder() == DomainOrder.ASCENDING) {\n                                    int low = 0;\n            int high = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue >= xLow) {\n                                return low;\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue < xLow) {\n                                return high;\n            }\n            while (high - low > 1) {\n                int mid = (low + high) / 2;\n                double midV = dataset.getXValue(series, mid);\n                if (midV >= xLow) {\n                    high = mid;\n                }\n                else {\n                    low = mid;\n                }\n            }\n            return high;\n        }\n        else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) {\n                                    int low = 0;\n            int high = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue <= xHigh) {\n                return low;\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue > xHigh) {\n                return high;\n            }\n            while (high - low > 1) {\n                int mid = (low + high) / 2;\n                double midV = dataset.getXValue(series, mid);\n                if (midV > xHigh) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n            }\n            return high;\n        }\n        else {\n                                                int index = 0;\n                        double x = dataset.getXValue(series, index);\n            while (index < itemCount && x < xLow) {\n                index++;\n                if (index < itemCount) {\n                    x = dataset.getXValue(series, index);\n                }\n            }\n            return Math.min(Math.max(0, index), itemCount - 1);\n        }\n    }
1253	private static String[] formGrams(String text, int ng) {\n    int len = text.length();\n    String[] res = new String[len - ng + 1];\n    for (int i = 0; i < len - ng + 1; i++) {\n      res[i] = text.substring(i, i + ng);\n    }\n    return res;\n  }
1254	private void interpolate() {\n    StringBuffer buffer = new StringBuffer();\n    for (Map.Entry<?,?> entry : entrySet()) {\n      buffer.setLength(0);\n      Matcher matcher = PROPERTY_REFERENCE_PATTERN.matcher(entry.getValue().toString());\n      while (matcher.find()) {\n        String interpolatedValue = getProperty(matcher.group(1));\n        if (null != interpolatedValue) {\n          matcher.appendReplacement(buffer, interpolatedValue);\n        }\n      }\n      matcher.appendTail(buffer);\n      setProperty((String) entry.getKey(), buffer.toString());\n    }\n  }
1255	public void addSubtitle(int index, Title subtitle) {\n        if (index < 0 || index > getSubtitleCount()) {\n            throw new IllegalArgumentException(\n                    "The 'index' argument is out of range.");\n        }\n        ParamChecks.nullNotPermitted(subtitle, "subtitle");\n        this.subtitles.add(index, subtitle);\n        subtitle.addChangeListener(this);\n        fireChartChanged();\n    }
1256	private TSTNode deleteNodeRecursion(TSTNode currentNode) {\n    if (currentNode == null) {\n      return null;\n    }\n    if (currentNode.relatives[TSTNode.EQKID] != null\n            || currentNode.data != null) {\n      return null;\n    }\n        TSTNode currentParent = currentNode.relatives[TSTNode.PARENT];\n    boolean lokidNull = currentNode.relatives[TSTNode.LOKID] == null;\n    boolean hikidNull = currentNode.relatives[TSTNode.HIKID] == null;\n    int childType;\n    if (currentParent.relatives[TSTNode.LOKID] == currentNode) {\n      childType = TSTNode.LOKID;\n    } else if (currentParent.relatives[TSTNode.EQKID] == currentNode) {\n      childType = TSTNode.EQKID;\n    } else if (currentParent.relatives[TSTNode.HIKID] == currentNode) {\n      childType = TSTNode.HIKID;\n    } else {\n      rootNode = null;\n      return null;\n    }\n    if (lokidNull && hikidNull) {\n      currentParent.relatives[childType] = null;\n      return currentParent;\n    }\n    if (lokidNull) {\n      currentParent.relatives[childType] = currentNode.relatives[TSTNode.HIKID];\n      currentNode.relatives[TSTNode.HIKID].relatives[TSTNode.PARENT] = currentParent;\n      return currentParent;\n    }\n    if (hikidNull) {\n      currentParent.relatives[childType] = currentNode.relatives[TSTNode.LOKID];\n      currentNode.relatives[TSTNode.LOKID].relatives[TSTNode.PARENT] = currentParent;\n      return currentParent;\n    }\n    int deltaHi = currentNode.relatives[TSTNode.HIKID].splitchar\n            - currentNode.splitchar;\n    int deltaLo = currentNode.splitchar\n            - currentNode.relatives[TSTNode.LOKID].splitchar;\n    int movingKid;\n    TSTNode targetNode;\n    if (deltaHi == deltaLo) {\n      if (Math.random() < 0.5) {\n        deltaHi++;\n      } else {\n        deltaLo++;\n      }\n    }\n    if (deltaHi > deltaLo) {\n      movingKid = TSTNode.HIKID;\n      targetNode = currentNode.relatives[TSTNode.LOKID];\n    } else {\n      movingKid = TSTNode.LOKID;\n      targetNode = currentNode.relatives[TSTNode.HIKID];\n    }\n    while (targetNode.relatives[movingKid] != null) {\n      targetNode = targetNode.relatives[movingKid];\n    }\n    targetNode.relatives[movingKid] = currentNode.relatives[movingKid];\n    currentParent.relatives[childType] = targetNode;\n    targetNode.relatives[TSTNode.PARENT] = currentParent;\n    if (!lokidNull) {\n      currentNode.relatives[TSTNode.LOKID] = null;\n    }\n    if (!hikidNull) {\n      currentNode.relatives[TSTNode.HIKID] = null;\n    }\n    return currentParent;\n  }
1257	public static <\n        S extends Shape<S,P>,\n        P extends TextParagraph<S,P,? extends TextRun>\n    > SlideShow<S,P> create(InputStream inp, String password) throws IOException, EncryptedDocumentException {\n        InputStream is = FileMagic.prepareToCheckMagic(inp);\n        FileMagic fm = FileMagic.valueOf(is);\n        \n        switch (fm) {\n        case OLE2:\n            POIFSFileSystem fs = new POIFSFileSystem(is);\n            return create(fs, password);\n        case OOXML:\n            return createXSLFSlideShow(is);\n        default:\n            throw new IOException("Your InputStream was neither an OLE2 stream, nor an OOXML stream");\n        }\n    }
1258	protected static void setDigestAlgAndValue(\n            DigestAlgAndValueType digestAlgAndValue,\n            byte[] data,\n            HashAlgorithm digestAlgo) {\n        DigestMethodType digestMethod = digestAlgAndValue.addNewDigestMethod();\n        digestMethod.setAlgorithm(SignatureConfig.getDigestMethodUri(digestAlgo));\n        \n        MessageDigest messageDigest = CryptoFunctions.getMessageDigest(digestAlgo);\n        byte[] digestValue = messageDigest.digest(data);\n        digestAlgAndValue.setDigestValue(digestValue);\n    }
1259	public Rectangle2D scale(Rectangle2D rect) {\n        Insets insets = getInsets();\n        double x = rect.getX() * getScaleX() + insets.left;\n        double y = rect.getY() * getScaleY() + insets.top;\n        double w = rect.getWidth() * getScaleX();\n        double h = rect.getHeight() * getScaleY();\n        return new Rectangle2D.Double(x, y, w, h);\n    }
1260	public void writeRow(int rownum, SXSSFRow row) throws IOException {\n        if (_numberOfFlushedRows == 0)\n            _lowestIndexOfFlushedRows = rownum;\n        _numberLastFlushedRow = Math.max(rownum, _numberLastFlushedRow);\n        _numberOfCellsOfLastFlushedRow = row.getLastCellNum();\n        _numberOfFlushedRows++;\n        beginRow(rownum, row);\n        Iterator<Cell> cells = row.allCellsIterator();\n        int columnIndex = 0;\n        while (cells.hasNext()) {\n            writeCell(columnIndex++, cells.next());\n        }\n        endRow();\n    }
1261	public static boolean hasLineBreakMeasurerBug() {\n        String version = System.getProperty("java.version");\n        String os = System.getProperty("os.name").toLowerCase(Locale.ROOT);\n        boolean ignore = Boolean.getBoolean("org.apache.poi.JvmBugs.LineBreakMeasurer.ignore");\n        boolean hasBug = (!ignore && (os.contains("win") && ("1.6.0_45".equals(version) || "1.7.0_21".equals(version))));\n        if (hasBug) {\n            LOG.log(POILogger.WARN, "JVM has LineBreakMeasurer bug - see POI bug #54904 - caller code might default to Lucida Sans");\n        }\n        return hasBug;\n    }
1262	public XWPFPicture addPicture(InputStream pictureData, int pictureType, String filename, int width, int height)\n            throws InvalidFormatException, IOException {\n        String relationId;\n        XWPFPictureData picData;\n\n                                if (parent.getPart() instanceof XWPFHeaderFooter) {\n            XWPFHeaderFooter headerFooter = (XWPFHeaderFooter) parent.getPart();\n            relationId = headerFooter.addPictureData(pictureData, pictureType);\n            picData = (XWPFPictureData) headerFooter.getRelationById(relationId);\n        } else {\n            @SuppressWarnings("resource")\n            XWPFDocument doc = parent.getDocument();\n            relationId = doc.addPictureData(pictureData, pictureType);\n            picData = (XWPFPictureData) doc.getRelationById(relationId);\n        }\n\n                try {\n            CTDrawing drawing = run.addNewDrawing();\n            CTInline inline = drawing.addNewInline();\n\n                                    String xml =\n                    "<a:graphic xmlns:a=\"" + CTGraphicalObject.type.getName().getNamespaceURI() + "\">" +\n                            "<a:graphicData uri=\"" + CTPicture.type.getName().getNamespaceURI() + "\">" +\n                            "<pic:pic xmlns:pic=\"" + CTPicture.type.getName().getNamespaceURI() + "\" />" +\n                            "</a:graphicData>" +\n                            "</a:graphic>";\n            InputSource is = new InputSource(new StringReader(xml));\n            org.w3c.dom.Document doc = DocumentHelper.readDocument(is);\n            inline.set(XmlToken.Factory.parse(doc.getDocumentElement(), DEFAULT_XML_OPTIONS));\n\n                        inline.setDistT(0);\n            inline.setDistR(0);\n            inline.setDistB(0);\n            inline.setDistL(0);\n\n            CTNonVisualDrawingProps docPr = inline.addNewDocPr();\n            long id = getParent().getDocument().getDrawingIdManager().reserveNew();\n            docPr.setId(id);\n            \n            docPr.setName("Drawing " + id);\n            docPr.setDescr(filename);\n\n            CTPositiveSize2D extent = inline.addNewExtent();\n            extent.setCx(width);\n            extent.setCy(height);\n\n                        CTGraphicalObject graphic = inline.getGraphic();\n            CTGraphicalObjectData graphicData = graphic.getGraphicData();\n            CTPicture pic = getCTPictures(graphicData).get(0);\n\n                        CTPictureNonVisual nvPicPr = pic.addNewNvPicPr();\n\n            CTNonVisualDrawingProps cNvPr = nvPicPr.addNewCNvPr();\n            "0"\n            cNvPr.setId(0L);\n            \n            cNvPr.setName("Picture " + id);\n            cNvPr.setDescr(filename);\n\n            CTNonVisualPictureProperties cNvPicPr = nvPicPr.addNewCNvPicPr();\n            cNvPicPr.addNewPicLocks().setNoChangeAspect(true);\n\n            CTBlipFillProperties blipFill = pic.addNewBlipFill();\n            CTBlip blip = blipFill.addNewBlip();\n            blip.setEmbed(parent.getPart().getRelationId(picData));\n            blipFill.addNewStretch().addNewFillRect();\n\n            CTShapeProperties spPr = pic.addNewSpPr();\n            CTTransform2D xfrm = spPr.addNewXfrm();\n\n            CTPoint2D off = xfrm.addNewOff();\n            off.setX(0);\n            off.setY(0);\n\n            CTPositiveSize2D ext = xfrm.addNewExt();\n            ext.setCx(width);\n            ext.setCy(height);\n\n            CTPresetGeometry2D prstGeom = spPr.addNewPrstGeom();\n            prstGeom.setPrst(STShapeType.RECT);\n            prstGeom.addNewAvLst();\n\n                        XWPFPicture xwpfPicture = new XWPFPicture(pic, this);\n            pictures.add(xwpfPicture);\n            return xwpfPicture;\n        } catch (XmlException | SAXException e) {\n            throw new IllegalStateException(e);\n        }\n    }
1263	public void update(int index, Number y) {\n        XYDataItem item = getRawDataItem(index);\n\n                boolean iterate = false;\n        double oldY = item.getYValue();\n        if (!Double.isNaN(oldY)) {\n            iterate = oldY <= this.minY || oldY >= this.maxY;\n        }\n        item.setY(y);\n\n        if (iterate) {\n            findBoundsByIteration();\n        }\n        else if (y != null) {\n            double yy = y.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }
1264	private void buildSlidesAndNotes() {\n						if (_documentRecord == null) {\n			throw new CorruptPowerPointFileException(\n					"The PowerPoint file didn't contain a Document Record in its PersistPtr blocks. It is probably corrupt.");\n		}\n\n																																\n		findMasterSlides();\n\n		        Map<Integer,Integer> slideIdToNotes = new HashMap<>();\n\n                findNotesSlides(slideIdToNotes);\n\n				findSlides(slideIdToNotes);\n	}
1265	public HSSFColor addColor( byte red, byte green, byte blue )\n    {\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        short i;\n        for (i = PaletteRecord.FIRST_COLOR_INDEX; i < PaletteRecord.STANDARD_PALETTE_SIZE + PaletteRecord.FIRST_COLOR_INDEX; b = _palette.getColor(++i))\n        {\n            if (b == null)\n            {\n                setColorAtIndex( i, red, green, blue );\n                return getColor(i);\n            }\n        }\n        throw new RuntimeException("Could not find free color index");\n    }
1266	public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n            \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n                        testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n        if (testPointShape == null) {\n      throw new IllegalArgumentException("couldn't find a non-degenerate polygon for in-set determination");\n    }\n    \n            final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n            final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n            final Boolean isPoleInside = isInsidePolygon(pole, testPointShape.points);\n      if (isPoleInside != null) {\n                if (isPoleInside == testPointShape.poleMustBeInside) {\n          return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n        } else {\n          return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-pole.x, -pole.y, -pole.z), !isPoleInside);\n        }\n      }\n          }\n    throw new IllegalArgumentException("cannot find a point that is inside the polygon "+testPointShape);\n\n  }
1267	static void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {\n    try (InputStream stream = Files.newInputStream(file)) {\n            Document doc = new Document();\n      \n                              Field pathField = new StringField("path", file.toString(), Field.Store.YES);\n      doc.add(pathField);\n      \n                                                doc.add(new LongPoint("modified", lastModified));\n      \n                              doc.add(new TextField("contents", new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));\n      \n      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {\n                System.out.println("adding " + file);\n        writer.addDocument(doc);\n      } else {\n                                System.out.println("updating " + file);\n        writer.updateDocument(new Term("path", file.toString()), doc);\n      }\n    }\n  }
1268	protected void breakText(Graphics2D graphics){\n        lines.clear();\n\n        DrawFactory fact = DrawFactory.getInstance(graphics);\n        fact.fixFonts(graphics);\n        StringBuilder text = new StringBuilder();\n        AttributedString at = getAttributedString(graphics, text);\n        boolean emptyParagraph = text.toString().trim().isEmpty();\n\n        AttributedCharacterIterator it = at.getIterator();\n        LineBreakMeasurer measurer = new LineBreakMeasurer(it, graphics.getFontRenderContext());\n        for (;;) {\n            int startIndex = measurer.getPosition();\n\n                        double wrappingWidth = getWrappingWidth(lines.isEmpty(), graphics) + 1;\n                        if(wrappingWidth < 0) {\n                wrappingWidth = 1;\n            }\n\n            int nextBreak = text.indexOf("\n", startIndex + 1);\n            if (nextBreak == -1) {\n                nextBreak = it.getEndIndex();\n            }\n\n            TextLayout layout = measurer.nextLayout((float)wrappingWidth, nextBreak, true);\n            if (layout == null) {\n                                                   layout = measurer.nextLayout((float)wrappingWidth, nextBreak, false);\n            }\n\n            if(layout == null) {\n                                break;\n            }\n\n            int endIndex = measurer.getPosition();\n                        if(endIndex < it.getEndIndex() && text.charAt(endIndex) == '\n'){\n                measurer.setPosition(endIndex + 1);\n            }\n\n            TextAlign hAlign = paragraph.getTextAlign();\n            if(hAlign == TextAlign.JUSTIFY || hAlign == TextAlign.JUSTIFY_LOW) {\n                layout = layout.getJustifiedLayout((float)wrappingWidth);\n            }\n\n            AttributedString str = (emptyParagraph)\n                ? null                 : new AttributedString(it, startIndex, endIndex);\n            DrawTextFragment line = fact.getTextFragment(layout, str);\n            lines.add(line);\n\n            maxLineHeight = Math.max(maxLineHeight, line.getHeight());\n\n            if(endIndex == it.getEndIndex()) {\n                break;\n            }\n        }\n\n        rawText = text.toString();\n    }
1269	public static InternalWorkbook createWorkbook() {\n        LOG.log( DEBUG, "creating new workbook from scratch" );\n\n        InternalWorkbook retval = new InternalWorkbook();\n        List<Record> records = new ArrayList<>(30);\n        retval.records.setRecords(records);\n        List<FormatRecord> formats = retval.formats;\n\n        records.add(createBOF());\n        records.add(new InterfaceHdrRecord(CODEPAGE));\n        records.add(createMMS());\n        records.add(InterfaceEndRecord.instance);\n        records.add(createWriteAccess());\n        records.add(createCodepage());\n        records.add(createDSF());\n        records.add(createTabId());\n        retval.records.setTabpos(records.size() - 1);\n        records.add(createFnGroupCount());\n        records.add(createWindowProtect());\n        records.add(createProtect());\n        retval.records.setProtpos(records.size() - 1);\n        records.add(createPassword());\n        records.add(createProtectionRev4());\n        records.add(createPasswordRev4());\n        retval.windowOne = createWindowOne();\n        records.add(retval.windowOne);\n        records.add(createBackup());\n        retval.records.setBackuppos(records.size() - 1);\n        records.add(createHideObj());\n        records.add(createDateWindow1904());\n        records.add(createPrecision());\n        records.add(createRefreshAll());\n        records.add(createBookBool());\n        records.add(createFont());\n        records.add(createFont());\n        records.add(createFont());\n        records.add(createFont());\n        retval.records.setFontpos( records.size() - 1 );           retval.numfonts = 4;\n\n                for (int i = 0; i <= 7; i++) {\n            FormatRecord rec = createFormat(i);\n            retval.maxformatid = retval.maxformatid >= rec.getIndexCode() ? retval.maxformatid : rec.getIndexCode();\n            formats.add(rec);\n            records.add(rec);\n        }\n\n        for (int k = 0; k < 21; k++) {\n            records.add(InternalWorkbook.createExtendedFormat(k));\n            retval.numxfs++;\n        }\n        retval.records.setXfpos( records.size() - 1 );\n        for (int k = 0; k < 6; k++) {\n            records.add(InternalWorkbook.createStyle(k));\n        }\n        records.add(InternalWorkbook.createUseSelFS());\n\n        int nBoundSheets = 1;         for (int k = 0; k < nBoundSheets; k++) {\n            BoundSheetRecord bsr = createBoundSheet(k);\n\n            records.add(bsr);\n            retval.boundsheets.add(bsr);\n            retval.records.setBspos(records.size() - 1);\n        }\n        records.add( InternalWorkbook.createCountry() );\n        for ( int k = 0; k < nBoundSheets; k++ ) {\n            retval.getOrCreateLinkTable().checkExternSheet(k);\n        }\n        retval.sst = new SSTRecord();\n        records.add(retval.sst);\n        records.add(InternalWorkbook.createExtendedSST());\n\n        records.add(EOFRecord.instance);\n        LOG.log( DEBUG, "exit create new workbook from scratch" );\n\n        return retval;\n    }
1270	protected Query analyzePhrase(String field, TokenStream stream, int slop) throws IOException {\n    PhraseQuery.Builder builder = new PhraseQuery.Builder();\n    builder.setSlop(slop);\n    \n    TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n    PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n    int position = -1;    \n    \n    stream.reset();\n    while (stream.incrementToken()) {\n      if (enablePositionIncrements) {\n        position += posIncrAtt.getPositionIncrement();\n      } else {\n        position += 1;\n      }\n      builder.add(new Term(field, termAtt.getBytesRef()), position);\n    }\n\n    return builder.build();\n  }
1271	public PackageRelationship addExternalRelationship(String target,\n            String relationshipType, String id) {\n        if (target == null) {\n            throw new IllegalArgumentException("target is null for type " + relationshipType);\n        }\n        if (relationshipType == null) {\n            throw new IllegalArgumentException("relationshipType");\n        }\n\n        if (_relationships == null) {\n            _relationships = new PackageRelationshipCollection();\n        }\n\n        URI targetURI;\n        try {\n            targetURI = new URI(target);\n        } catch (URISyntaxException e) {\n            throw new IllegalArgumentException("Invalid target - " + e);\n        }\n\n        return _relationships.addRelationship(targetURI, TargetMode.EXTERNAL,\n                relationshipType, id);\n    }
1272	public double getLongitude() {\n    double lon = this.longitude;    if (lon == Double.NEGATIVE_INFINITY) {\n      if (Math.abs(x) < MINIMUM_RESOLUTION && Math.abs(y) < MINIMUM_RESOLUTION)\n        this.longitude = lon = 0.0;\n      else\n        this.longitude = lon = Math.atan2(y,x);\n    }\n    return lon;\n  }
1273	public void setLogBase(double logBase) {\n        if (logBase < MIN_LOG_BASE || MAX_LOG_BASE < logBase) {\n            throw new IllegalArgumentException("Axis log base must be between 2 and 1000 (inclusive), got: " + logBase);\n        }\n        CTScaling scaling = getCTScaling();\n        if (scaling.isSetLogBase()) {\n            scaling.getLogBase().setVal(logBase);\n        } else {\n            scaling.addNewLogBase().setVal(logBase);\n        }\n    }
1274	@SuppressWarnings("WeakerAccess")\n	public void reorderSlide(int oldSlideNumber, int newSlideNumber) {\n				if (oldSlideNumber < 1 || newSlideNumber < 1) {\n			throw new IllegalArgumentException("Old and new slide numbers must be greater than 0");\n		}\n		if (oldSlideNumber > _slides.size() || newSlideNumber > _slides.size()) {\n			throw new IllegalArgumentException(\n					"Old and new slide numbers must not exceed the number of slides ("\n							+ _slides.size() + ")");\n		}\n\n						SlideListWithText slwt = _documentRecord.getSlideSlideListWithText();\n		if (slwt == null) {\n			throw new IllegalStateException("Slide record not defined.");\n		}\n		SlideAtomsSet[] sas = slwt.getSlideAtomsSets();\n\n		SlideAtomsSet tmp = sas[oldSlideNumber - 1];\n		sas[oldSlideNumber - 1] = sas[newSlideNumber - 1];\n		sas[newSlideNumber - 1] = tmp;\n\n		Collections.swap(_slides, oldSlideNumber - 1, newSlideNumber - 1);\n		_slides.get(newSlideNumber - 1).setSlideNumber(newSlideNumber);\n		_slides.get(oldSlideNumber - 1).setSlideNumber(oldSlideNumber);\n\n		ArrayList<Record> lst = new ArrayList<>();\n		for (SlideAtomsSet s : sas) {\n			lst.add(s.getSlidePersistAtom());\n			lst.addAll(Arrays.asList(s.getSlideRecords()));\n		}\n\n		Record[] r = lst.toArray(new Record[0]);\n		slwt.setChildRecord(r);\n	}
1275	static SerializableObject readObject(final InputStream inputStream, final Class<?> clazz) throws IOException {\n    try {\n            final Constructor<?> c = clazz.getDeclaredConstructor(InputStream.class);\n            final Object object = c.newInstance(inputStream);\n            if (!(object instanceof SerializableObject)) {\n        throw new IOException("Object "+clazz.getName()+" does not implement SerializableObject");\n      }\n      return (SerializableObject)object;\n    } catch (InstantiationException e) {\n      throw new IOException("Instantiation exception for class "+clazz.getName()+": "+e.getMessage(), e);\n    } catch (IllegalAccessException e) {\n      throw new IOException("Illegal access creating class "+clazz.getName()+": "+e.getMessage(), e);\n    } catch (NoSuchMethodException e) {\n      throw new IOException("No such method exception for class "+clazz.getName()+": "+e.getMessage(), e);\n    } catch (InvocationTargetException e) {\n      throw new IOException("Exception instantiating class "+clazz.getName()+": "+e.getMessage(), e);\n    }\n\n  }
1276	protected void drawHorizontal(Graphics2D g2, Rectangle2D area) {\n        Rectangle2D titleArea = (Rectangle2D) area.clone();\n        g2.setFont(this.font);\n        g2.setPaint(this.paint);\n        TextBlockAnchor anchor = null;\n        float x = 0.0f;\n        HorizontalAlignment horizontalAlignment = getHorizontalAlignment();\n        if (horizontalAlignment == HorizontalAlignment.LEFT) {\n            x = (float) titleArea.getX();\n            anchor = TextBlockAnchor.TOP_LEFT;\n        }\n        else if (horizontalAlignment == HorizontalAlignment.RIGHT) {\n            x = (float) titleArea.getMaxX();\n            anchor = TextBlockAnchor.TOP_RIGHT;\n        }\n        else if (horizontalAlignment == HorizontalAlignment.CENTER) {\n            x = (float) titleArea.getCenterX();\n            anchor = TextBlockAnchor.TOP_CENTER;\n        }\n        float y = 0.0f;\n        RectangleEdge position = getPosition();\n        if (position == RectangleEdge.TOP) {\n            y = (float) titleArea.getY();\n        }\n        else if (position == RectangleEdge.BOTTOM) {\n            y = (float) titleArea.getMaxY();\n            if (horizontalAlignment == HorizontalAlignment.LEFT) {\n                anchor = TextBlockAnchor.BOTTOM_LEFT;\n            }\n            else if (horizontalAlignment == HorizontalAlignment.CENTER) {\n                anchor = TextBlockAnchor.BOTTOM_CENTER;\n            }\n            else if (horizontalAlignment == HorizontalAlignment.RIGHT) {\n                anchor = TextBlockAnchor.BOTTOM_RIGHT;\n            }\n        }\n        this.content.draw(g2, x, y, anchor);\n    }
1277	public void updateEmbeddedDoc() throws OpenXML4JException, IOException {\n        List<PackagePart> embeddedDocs = this.doc.getAllEmbeddedParts();\n        for (PackagePart pPart : embeddedDocs) {\n            String ext = pPart.getPartName().getExtension();\n            if (BINARY_EXTENSION.equals(ext) || OPENXML_EXTENSION.equals(ext)) {\n                                                                                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is);\n                     OutputStream os = pPart.getOutputStream()) {\n                    Sheet sheet = workbook.getSheetAt(SHEET_NUM);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    cell.setCellValue(NEW_VALUE);\n                    workbook.write(os);\n                }\n            }\n        }\n\n        if (!embeddedDocs.isEmpty()) {\n                        try (FileOutputStream fos = new FileOutputStream(this.docFile)) {\n                this.doc.write(fos);\n            }\n        }\n    }
1278	public void protectSheet(String password, boolean shouldProtectObjects,\n			boolean shouldProtectScenarios) {\n		if (password == null) {\n			_passwordRecord = null;\n			_protectRecord = null;\n			_objectProtectRecord = null;\n			_scenarioProtectRecord = null;\n			return;\n		}\n\n		ProtectRecord prec = getProtect();\n		PasswordRecord pass = getPassword();\n		prec.setProtect(true);\n		pass.setPassword((short)CryptoFunctions.createXorVerifier1(password));\n		if (_objectProtectRecord == null && shouldProtectObjects) {\n			ObjectProtectRecord rec = createObjectProtect();\n			rec.setProtect(true);\n			_objectProtectRecord = rec;\n		}\n		if (_scenarioProtectRecord == null && shouldProtectScenarios) {\n			ScenarioProtectRecord srec = createScenarioProtect();\n			srec.setProtect(true);\n			_scenarioProtectRecord = srec;\n		}\n	}
1279	public GeneralPath generateClipPath(Rectangle2D dataArea,\n                                        ValueAxis horizontalAxis,\n                                        ValueAxis verticalAxis) {\n\n        GeneralPath generalPath = new GeneralPath();\n        double transX = horizontalAxis.valueToJava2D(\n            this.xValue[0], dataArea, RectangleEdge.BOTTOM\n        );\n        double transY = verticalAxis.valueToJava2D(\n            this.yValue[0], dataArea, RectangleEdge.LEFT\n        );\n        generalPath.moveTo((float) transX, (float) transY);\n        for (int k = 0; k < this.yValue.length; k++) {\n            transX = horizontalAxis.valueToJava2D(\n                this.xValue[k], dataArea, RectangleEdge.BOTTOM\n            );\n            transY = verticalAxis.valueToJava2D(\n                this.yValue[k], dataArea, RectangleEdge.LEFT\n            );\n            generalPath.lineTo((float) transX, (float) transY);\n        }\n        generalPath.closePath();\n\n        return generalPath;\n\n    }
1280	public XSSFTextBox createTextbox(XSSFClientAnchor anchor){\n        long shapeId = newShapeId();\n        CTTwoCellAnchor ctAnchor = createTwoCellAnchor(anchor);\n        CTShape ctShape = ctAnchor.addNewSp();\n        ctShape.set(XSSFSimpleShape.prototype());\n        ctShape.getNvSpPr().getCNvPr().setId(shapeId);\n        XSSFTextBox shape = new XSSFTextBox(this, ctShape);\n        shape.anchor = anchor;\n        return shape;\n\n    }
1281	protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea,\n                            PiePlotState state, int currentPass) {\n\n        Number n = this.dataset.getValue(section);\n        if (n == null) {\n            return;\n        }\n        double value = n.doubleValue();\n        double angle1 = 0.0;\n        double angle2 = 0.0;\n\n        if (this.direction == Rotation.CLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 - value / state.getTotal() * 360.0;\n        }\n        else if (this.direction == Rotation.ANTICLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 + value / state.getTotal() * 360.0;\n        }\n        else {\n            throw new IllegalStateException("Rotation type not recognised.");\n        }\n\n        double angle = (angle2 - angle1);\n        if (Math.abs(angle) > getMinimumArcAngleToDraw()) {\n            double ep = 0.0;\n            double mep = getMaximumExplodePercent();\n            if (mep > 0.0) {\n                ep = getExplodePercent(section) / mep;\n            }\n            Rectangle2D arcBounds = getArcBounds(state.getPieArea(),\n                    state.getExplodedPieArea(), angle1, angle, ep);\n            Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle,\n                    Arc2D.PIE);\n\n            if (currentPass == 0) {\n                if (this.shadowPaint != null && this.shadowGenerator == null) {\n                    Shape shadowArc = ShapeUtilities.createTranslatedShape(\n                            arc, (float) this.shadowXOffset,\n                            (float) this.shadowYOffset);\n                    g2.setPaint(this.shadowPaint);\n                    g2.fill(shadowArc);\n                }\n            }\n            else if (currentPass == 1) {\n                Comparable key = getSectionKey(section);\n                Paint paint = lookupSectionPaint(key, state);\n                g2.setPaint(paint);\n                g2.fill(arc);\n\n                Paint outlinePaint = lookupSectionOutlinePaint(key);\n                Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                if (this.sectionOutlinesVisible) {\n                    g2.setPaint(outlinePaint);\n                    g2.setStroke(outlineStroke);\n                    g2.draw(arc);\n                }\n\n                                                if (state.getInfo() != null) {\n                    EntityCollection entities = state.getEntityCollection();\n                    if (entities != null) {\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, key);\n                        }\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset,\n                                    key, this.pieIndex);\n                        }\n                        PieSectionEntity entity = new PieSectionEntity(\n                                arc, this.dataset, this.pieIndex, section, key,\n                                tip, url);\n                        entities.add(entity);\n                    }\n                }\n            }\n        }\n        state.setLatestAngle(angle2);\n    }
1282	@SuppressWarnings("resource")\n    protected static HSLFHyperlink find(HSLFShape shape){\n        HSLFSlideShow ppt = shape.getSheet().getSlideShow();\n                ExObjList exobj = ppt.getDocumentRecord().getExObjList(false);\n        HSLFEscherClientDataRecord cldata = shape.getClientData(false);\n\n        if (exobj != null && cldata != null) {\n            List<HSLFHyperlink> lst = new ArrayList<>();\n            find(cldata.getHSLFChildRecords(), exobj, lst);\n            return lst.isEmpty() ? null : lst.get(0);\n        }\n\n        return null;\n    }
1283	public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }
1284	protected synchronized void updateMergeThreads() {\n\n            final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n                mergeThreads.remove(threadIdx);\n        continue;\n      }\n      activeMerges.add(mergeThread);\n      threadIdx++;\n    }\n\n        CollectionUtil.timSort(activeMerges);\n\n    final int activeMergeCount = activeMerges.size();\n\n    int bigMergeCount = 0;\n\n    for (threadIdx=activeMergeCount-1;threadIdx>=0;threadIdx--) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n      if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB*1024*1024) {\n        bigMergeCount = 1+threadIdx;\n        break;\n      }\n    }\n\n    long now = System.nanoTime();\n\n    StringBuilder message;\n    if (verbose()) {\n      message = new StringBuilder();\n      message.append(String.format(Locale.ROOT, "updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec", doAutoIOThrottle, targetMBPerSec));\n    } else {\n      message = null;\n    }\n\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n\n      OneMerge merge = mergeThread.merge;\n\n            final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n\n      double newMBPerSec;\n      if (doPause) {\n        newMBPerSec = 0.0;\n      } else if (merge.maxNumSegments != -1) {\n        newMBPerSec = forceMergeMBPerSec;\n      } else if (doAutoIOThrottle == false) {\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB*1024*1024) {\n                newMBPerSec = Double.POSITIVE_INFINITY;\n      } else {\n        newMBPerSec = targetMBPerSec;\n      }\n\n      MergeRateLimiter rateLimiter = mergeThread.rateLimiter;\n      double curMBPerSec = rateLimiter.getMBPerSec();\n\n      if (verbose()) {\n        long mergeStartNS = merge.mergeStartNS;\n        if (mergeStartNS == -1) {\n                    mergeStartNS = now;\n        }\n        message.append('\n');\n        message.append(String.format(Locale.ROOT, "merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\n",\n                                     mergeThread.getName(),\n                                     bytesToMB(merge.estimatedMergeBytes),\n                                     bytesToMB(rateLimiter.getTotalBytesWritten()),\n                                     nsToSec(now - mergeStartNS),\n                                     nsToSec(rateLimiter.getTotalStoppedNS()),\n                                     nsToSec(rateLimiter.getTotalPausedNS()),\n                                     rateToString(rateLimiter.getMBPerSec())));\n\n        if (newMBPerSec != curMBPerSec) {\n          if (newMBPerSec == 0.0) {\n            message.append("  now stop");\n          } else if (curMBPerSec == 0.0) {\n            if (newMBPerSec == Double.POSITIVE_INFINITY) {\n              message.append("  now resume");\n            } else {\n              message.append(String.format(Locale.ROOT, "  now resume to %.1f MB/sec", newMBPerSec));\n            }\n          } else {\n            message.append(String.format(Locale.ROOT, "  now change from %.1f MB/sec to %.1f MB/sec", curMBPerSec, newMBPerSec));\n          }\n        } else if (curMBPerSec == 0.0) {\n          message.append("  leave stopped");\n        } else {\n          message.append(String.format(Locale.ROOT, "  leave running at %.1f MB/sec", curMBPerSec));\n        }\n      }\n\n      rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n      message(message.toString());\n    }\n  }
1285	protected static synchronized void initXmlProvider() {\n        if (isInitialized) {\n            return;\n        }\n        isInitialized = true;\n\n        try {\n            Init.init();\n            RelationshipTransformService.registerDsigProvider();\n            CryptoFunctions.registerBouncyCastle();\n        } catch (Exception e) {\n            throw new RuntimeException("Xml & BouncyCastle-Provider initialization failed", e);\n        }\n    }
1286	static void shadeBands(Sheet sheet) {\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("MOD(ROW(),6)<3");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:Z100")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.createRow(0).createCell(1).setCellValue("Shade Bands of Rows");\n        sheet.createRow(1).createCell(1).setCellValue("Condition: Formula Is  =MOD(ROW(),6)<2   (Light Grey Fill)");\n    }
1287	public static XSSFBCellRange parse(byte[] data, int offset, XSSFBCellRange cellRange) {\n        if (cellRange == null) {\n            cellRange = new XSSFBCellRange();\n        }\n        cellRange.firstRow = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.lastRow = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.firstCol = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.lastCol = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset));\n\n        return cellRange;\n    }
1288	public XYDataItem remove(int index) {\n        XYDataItem removed = (XYDataItem) this.data.remove(index);\n        updateBoundsForRemovedItem(removed);\n        fireSeriesChanged();\n        return removed;\n    }
1289	public static CharArraySet copy(final Set<?> set) {\n    if(set == EMPTY_SET)\n      return EMPTY_SET;\n    if(set instanceof CharArraySet) {\n      final CharArraySet source = (CharArraySet) set;\n      return new CharArraySet(CharArrayMap.copy(source.map));\n    }\n    return new CharArraySet(set, false);\n  }
1290	public boolean verifyPassword(KeyPair keyPair, X509Certificate x509) throws GeneralSecurityException {\n        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)getEncryptionInfo().getVerifier();\n        AgileEncryptionHeader header = (AgileEncryptionHeader)getEncryptionInfo().getHeader();\n        HashAlgorithm hashAlgo = header.getHashAlgorithm();\n        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();\n        int blockSize = header.getBlockSize();\n        \n        AgileCertificateEntry ace = null;\n        for (AgileCertificateEntry aceEntry : ver.getCertificates()) {\n            if (x509.equals(aceEntry.x509)) {\n                ace = aceEntry;\n                break;\n            }\n        }\n        if (ace == null) {\n            return false;\n        }\n        \n        Cipher cipher = Cipher.getInstance("RSA");\n        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        byte keyspec[] = cipher.doFinal(ace.encryptedKey);\n        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);\n        \n        Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);\n        x509Hmac.init(secretKey);\n        byte certVerifier[] = x509Hmac.doFinal(ace.x509.getEncoded());\n\n        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); \n        cipher = getCipher(secretKey, cipherAlgo, header.getChainingMode(), vec, Cipher.DECRYPT_MODE);\n        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());\n        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);\n\n        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);\n        cipher = getCipher(secretKey, cipherAlgo, header.getChainingMode(), vec, Cipher.DECRYPT_MODE);\n        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());\n        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);\n        \n        \n        if (Arrays.equals(ace.certVerifier, certVerifier)) {\n            setSecretKey(secretKey);\n            setIntegrityHmacKey(hmacKey);\n            setIntegrityHmacValue(hmacValue);\n            return true;\n        } else {\n            return false;\n        }\n    }
1291	protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        List blocks = container.getBlocks();\n        Block b = (Block) blocks.get(0);\n        Size2D s = b.arrange(g2, RectangleConstraint.NONE);\n        b.setBounds(new Rectangle2D.Double(0.0, 0.0, s.width, s.height));\n        return new Size2D(s.width, s.height);\n    }
1292	protected final CharArraySet getWordSet(ResourceLoader loader,\n      String wordFiles, boolean ignoreCase) throws IOException {\n    List<String> files = splitFileNames(wordFiles);\n    CharArraySet words = null;\n    if (files.size() > 0) {\n                  words = new CharArraySet(files.size() * 10, ignoreCase);\n      for (String file : files) {\n        List<String> wlist = getLines(loader, file.trim());\n        words.addAll(StopFilter.makeStopSet(wlist, ignoreCase));\n      }\n    }\n    return words;\n  }
1293	protected static GeoPoint[] glueTogether(final GeoPoint[]... pointArrays) {\n    int count = 0;\n    for (final GeoPoint[] pointArray : pointArrays) {\n      count += pointArray.length;\n    }\n    final GeoPoint[] rval = new GeoPoint[count];\n    count = 0;\n    for (final GeoPoint[] pointArray : pointArrays) {\n      for (final GeoPoint point : pointArray) {\n        rval[count++] = point;\n      }\n    }\n    return rval;\n  }
1294	public void reset(Reader reader) {\n    this.reader = reader;\n    nextPos = 0;\n    nextWrite = 0;\n    count = 0;\n    end = false;\n  }
1295	private void fixTabIdRecord() {\n        Record rec = records.get(records.getTabpos());\n\n                                if(records.getTabpos() <= 0) {\n            return;\n        }\n\n        TabIdRecord tir = ( TabIdRecord ) rec;\n        short[]     tia = new short[ boundsheets.size() ];\n\n        for (short k = 0; k < tia.length; k++) {\n            tia[ k ] = k;\n        }\n        tir.setTabIdArray(tia);\n    }
1296	public void trimToSize() {\n        balance();\n\n        redimNodeArrays(freenode);\n\n        CharVector kx = new CharVector();\n    kx.alloc(1);\n    TernaryTree map = new TernaryTree();\n    compact(kx, map, root);\n    kv = kx;\n    kv.trimToSize();\n  }
1297	protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n            final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n                  return;\n    }\n\n                                                                                    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n                  if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return;\n      }\n      final double denom = 1.0 / denomYZ;\n            recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n                  if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n                return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n                  if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n                return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }
1298	protected void shift(int n) {\n        int rownum = getRowNum() + n;\n        String msg = "Row[rownum=" + getRowNum() + "] contains cell(s) included in a multi-cell array formula. " +\n                "You cannot change part of an array.";\n        for(Cell c : this){\n            ((XSSFCell)c).updateCellReferencesForShifting(msg);\n          }\n        setRowNum(rownum);\n    }
1299	public static void main(String[] args) throws Exception {\n    System.out.println("Facet counting over multiple category lists example:");\n    System.out.println("-----------------------");\n    List<FacetResult> results = new MultiCategoryListsFacetsExample().runSearch();\n    System.out.println("Author: " + results.get(0));\n    System.out.println("Publish Date: " + results.get(1));\n  }
1300	public static void writeHeader(DataOutput out, String codec, int version) throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException("codec must be simple ASCII, less than 128 characters in length [got " + codec + "]");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }
1301	private void setRunAttributes(CTFont ctFont, CTRPrElt pr){\n        if(ctFont.sizeOfBArray() > 0) pr.addNewB().setVal(ctFont.getBArray(0).getVal());\n        if(ctFont.sizeOfUArray() > 0) pr.addNewU().setVal(ctFont.getUArray(0).getVal());\n        if(ctFont.sizeOfIArray() > 0) pr.addNewI().setVal(ctFont.getIArray(0).getVal());\n        if(ctFont.sizeOfColorArray() > 0) {\n            CTColor c1 = ctFont.getColorArray(0);\n            CTColor c2 = pr.addNewColor();\n            if(c1.isSetAuto()) c2.setAuto(c1.getAuto());\n            if(c1.isSetIndexed()) c2.setIndexed(c1.getIndexed());\n            if(c1.isSetRgb()) c2.setRgb(c1.getRgb());\n            if(c1.isSetTheme()) c2.setTheme(c1.getTheme());\n            if(c1.isSetTint()) c2.setTint(c1.getTint());\n        }\n        if(ctFont.sizeOfSzArray() > 0) pr.addNewSz().setVal(ctFont.getSzArray(0).getVal());\n        if(ctFont.sizeOfNameArray() > 0) pr.addNewRFont().setVal(ctFont.getNameArray(0).getVal());\n        if(ctFont.sizeOfFamilyArray() > 0) pr.addNewFamily().setVal(ctFont.getFamilyArray(0).getVal());\n        if(ctFont.sizeOfSchemeArray() > 0) pr.addNewScheme().setVal(ctFont.getSchemeArray(0).getVal());\n        if(ctFont.sizeOfCharsetArray() > 0) pr.addNewCharset().setVal(ctFont.getCharsetArray(0).getVal());\n        if(ctFont.sizeOfCondenseArray() > 0) pr.addNewCondense().setVal(ctFont.getCondenseArray(0).getVal());\n        if(ctFont.sizeOfExtendArray() > 0) pr.addNewExtend().setVal(ctFont.getExtendArray(0).getVal());\n        if(ctFont.sizeOfVertAlignArray() > 0) pr.addNewVertAlign().setVal(ctFont.getVertAlignArray(0).getVal());\n        if(ctFont.sizeOfOutlineArray() > 0) pr.addNewOutline().setVal(ctFont.getOutlineArray(0).getVal());\n        if(ctFont.sizeOfShadowArray() > 0) pr.addNewShadow().setVal(ctFont.getShadowArray(0).getVal());\n        if(ctFont.sizeOfStrikeArray() > 0) pr.addNewStrike().setVal(ctFont.getStrikeArray(0).getVal());\n    }
1302	public boolean nameAlreadyExists(NameRecord name) {\n                for (int i = getNumNames() - 1; i >= 0; i--) {\n            NameRecord rec = getNameRecord(i);\n            if (rec != name) {\n                if (isDuplicatedNames(name, rec))\n                    return true;\n            }\n        }\n        return false;\n    }
1303	private int collide(PhrasePositions pp) {\n    int tpPos = tpPos(pp);\n    PhrasePositions[] rg = rptGroups[pp.rptGroup];\n    for (int i=0; i<rg.length; i++) {\n      PhrasePositions pp2 = rg[i];\n      if (pp2 != pp && tpPos(pp2) == tpPos) {\n        return pp2.rptInd;\n      }\n    }\n    return -1;\n  }
1304	private boolean isValid(Document xml) throws SAXException{\n        try{\n            String language = "http://www.w3.org/2001/XMLSchema";\n            SchemaFactory factory = SchemaFactory.newInstance(language);\n\n            Source source = new DOMSource(map.getSchema());\n            Schema schema = factory.newSchema(source);\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(xml));\n            \n                        return true;\n        } catch(IOException e) {\n            LOG.log(POILogger.ERROR, "document is not valid", e);\n        }\n\n        return false;\n    }
1305	public void add(XYPlot subplot, int weight) {\n        ParamChecks.nullNotPermitted(subplot, "subplot");\n        if (weight <= 0) {\n            String msg = "The 'weight' must be positive.";\n            throw new IllegalArgumentException(msg);\n        }\n\n                subplot.setParent(this);\n        subplot.setWeight(weight);\n        subplot.setInsets(new RectangleInsets(0.0, 0.0, 0.0, 0.0));\n        subplot.setRangeAxis(null);\n        subplot.addChangeListener(this);\n        this.subplots.add(subplot);\n        configureRangeAxes();\n        fireChangeEvent();\n\n    }
1306	public void removeLayer(int index) {\n        DialLayer layer = (DialLayer) this.layers.get(index);\n        if (layer != null) {\n            layer.removeChangeListener(this);\n        }\n        this.layers.remove(index);\n        fireChangeEvent();\n    }
1307	public ArrayList<TernaryTreeNode> prefixCompletion(TernaryTreeNode root,\n          CharSequence s, int x) {\n\n    TernaryTreeNode p = root;\n    ArrayList<TernaryTreeNode> suggest = new ArrayList<>();\n\n    while (p != null) {\n      if (s.charAt(x) < p.splitchar) {\n        p = p.loKid;\n      } else if (s.charAt(x) == p.splitchar) {\n        if (x == s.length() - 1) {\n          break;\n        } else {\n          x++;\n        }\n        p = p.eqKid;\n      } else {\n        p = p.hiKid;\n      }\n    }\n\n    if (p == null) return suggest;\n    if (p.eqKid == null && p.token == null) return suggest;\n    if (p.eqKid == null && p.token != null) {\n      suggest.add(p);\n      return suggest;\n    }\n\n    if (p.token != null) {\n      suggest.add(p);\n    }\n    p = p.eqKid;\n\n    Stack<TernaryTreeNode> st = new Stack<>();\n    st.push(p);\n    while (!st.empty()) {\n      TernaryTreeNode top = st.peek();\n      st.pop();\n      if (top.token != null) {\n        suggest.add(top);\n      }\n      if (top.eqKid != null) {\n        st.push(top.eqKid);\n      }\n      if (top.loKid != null) {\n        st.push(top.loKid);\n      }\n      if (top.hiKid != null) {\n        st.push(top.hiKid);\n      }\n    }\n    return suggest;\n  }
1308	private void flushBigram() {\n    clearAttributes();\n    char termBuffer[] = termAtt.resizeBuffer(4);     int len1 = Character.toChars(buffer[index], termBuffer, 0);\n    int len2 = len1 + Character.toChars(buffer[index+1], termBuffer, len1);\n    termAtt.setLength(len2);\n    offsetAtt.setOffset(startOffset[index], endOffset[index+1]);\n    typeAtt.setType(DOUBLE_TYPE);\n        if (outputUnigrams) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(2);\n    }\n    index++;\n  }
1309	public void setBorderBetween(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetBetween() ? ct.getBetween() : ct.addNewBetween();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetBetween();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
1310	protected void drawNoDataMessage(Graphics2D g2, Rectangle2D area) {\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n        String message = this.noDataMessage;\n        if (message != null) {\n            g2.setFont(this.noDataMessageFont);\n            g2.setPaint(this.noDataMessagePaint);\n            TextBlock block = TextUtilities.createTextBlock(\n                    this.noDataMessage, this.noDataMessageFont,\n                    this.noDataMessagePaint, 0.9f * (float) area.getWidth(),\n                    new G2TextMeasurer(g2));\n            block.draw(g2, (float) area.getCenterX(),\n                    (float) area.getCenterY(), TextBlockAnchor.CENTER);\n        }\n        g2.setClip(savedClip);\n    }
1311	private void writeOutput(SortedSet<String> ASCIITLDs) throws IOException {\n    final DateFormat dateFormat = DateFormat.getDateTimeInstance\n      (DateFormat.FULL, DateFormat.FULL, Locale.ROOT);\n    dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));\n    final Writer writer = new OutputStreamWriter\n      (new FileOutputStream(outputFile), StandardCharsets.UTF_8);\n    try {\n      writer.write(APACHE_LICENSE);\n      writer.write("// Generated from IANA Root Zone Database <");\n      writer.write(tldFileURL.toString());\n      writer.write(">");\n      writer.write(NL);\n      if (tldFileLastModified > 0L) {\n        writer.write("// file version from ");\n        writer.write(dateFormat.format(tldFileLastModified));\n        writer.write(NL);\n      }\n      writer.write("// generated on ");\n      writer.write(dateFormat.format(new Date()));\n      writer.write(NL);\n      writer.write("// by ");\n      writer.write(this.getClass().getName());\n      writer.write(NL);\n      writer.write(NL);\n      writer.write("ASCIITLD = \".\" (");\n      writer.write(NL);\n      boolean isFirst = true;\n      for (String ASCIITLD : ASCIITLDs) {\n        writer.write("\t");\n        if (isFirst) {\n          isFirst = false;\n          writer.write("  "); \n        } else {\n          writer.write("| "); \n        }\n        writer.write(getCaseInsensitiveRegex(ASCIITLD));\n        writer.write(NL);\n      }\n      writer.write("\t) \".\"?   // Accept trailing root (empty) domain");\n      writer.write(NL);\n      writer.write(NL);\n    } finally {\n      writer.close();\n    }\n  }
1312	public static boolean isParentClassLoader(final ClassLoader parent, final ClassLoader child) {\n    try {\n      ClassLoader cl = child;\n      while (cl != null) {\n        if (cl == parent) {\n          return true;\n        }\n        cl = cl.getParent();\n      }\n      return false;\n    } catch (SecurityException se) {\n      return false;\n    }\n  }
1313	public Query rewrite(Query original) throws IOException {\n    Query query = original;\n    for (Query rewrittenQuery = query.rewrite(reader); rewrittenQuery != query;\n         rewrittenQuery = query.rewrite(reader)) {\n      query = rewrittenQuery;\n    }\n    return query;\n  }
1314	public static synchronized CellFormat getInstance(Locale locale, String format) {\n        Map<String, CellFormat> formatMap = formatCache.get(locale);\n        if (formatMap == null) {\n            formatMap = new WeakHashMap<>();\n            formatCache.put(locale, formatMap);\n        }\n        CellFormat fmt = formatMap.get(format);\n        if (fmt == null) {\n            if (format.equals("General") || format.equals("@"))\n                fmt = createGeneralFormat(locale);\n            else\n                fmt = new CellFormat(locale, format);\n            formatMap.put(format, fmt);\n        }\n        return fmt;\n    }
1315	public static <V> CharArrayMap<V> unmodifiableMap(CharArrayMap<V> map) {\n    if (map == null)\n      throw new NullPointerException("Given map is null");\n    if (map == emptyMap() || map.isEmpty())\n      return emptyMap();\n    if (map instanceof UnmodifiableCharArrayMap)\n      return map;\n    return new UnmodifiableCharArrayMap<>(map);\n  }
1316	public static CellRangeAddress createEnclosingCellRange(CellRangeAddress crA, CellRangeAddress crB) {\n        if( crB == null) {\n            return crA.copy();\n        }\n        \n        int minRow = lt(crB.getFirstRow(),   crA.getFirstRow())   ?crB.getFirstRow()   :crA.getFirstRow();\n        int maxRow = gt(crB.getLastRow(),    crA.getLastRow())    ?crB.getLastRow()    :crA.getLastRow();\n        int minCol = lt(crB.getFirstColumn(),crA.getFirstColumn())?crB.getFirstColumn():crA.getFirstColumn();\n        int maxCol = gt(crB.getLastColumn(), crA.getLastColumn()) ?crB.getLastColumn() :crA.getLastColumn();\n\n        return new CellRangeAddress(minRow, maxRow, minCol, maxCol);\n    }
1317	public int calculateWorkdays(double start, double end, double[] holidays) {\n        int saturdaysPast = this.pastDaysOfWeek(start, end, Calendar.SATURDAY);\n        int sundaysPast = this.pastDaysOfWeek(start, end, Calendar.SUNDAY);\n        int nonWeekendHolidays = this.calculateNonWeekendHolidays(start, end, holidays);\n        return (int) (end - start + 1) - saturdaysPast - sundaysPast - nonWeekendHolidays;\n    }
1318	private void paintDashDotDotBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             ((northBorderType == BorderStyle.DASH_DOT_DOT) ||\n              (northBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n        for (int l=x; l < width;) {\n          l=l+drawDashDotDot(g, l, y, thickness, true, true);\n        }\n\n      }\n\n      if (eastBorder &&\n              ((eastBorderType == BorderStyle.DASH_DOT_DOT) ||\n               (eastBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n\n      	g.setColor(eastColor);\n\n        for (int l=y;l < height;) {\n                    l=l+drawDashDotDot(g,width-1,l,thickness,false,false);\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.DASH_DOT_DOT) ||\n               (southBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(southBorderType);\n\n      	g.setColor(southColor);\n\n        for (int l=x; l < width;) {\n                    l=l+drawDashDotDot(g, l, height-1, thickness, true, false);\n        }\n      }\n\n      if (westBorder &&\n            ((westBorderType == BorderStyle.DASH_DOT_DOT) ||\n             (westBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int l=y;l < height;) {\n                    l=l+drawDashDotDot(g,x,l,thickness,false,true);\n        }\n\n      }\n   }
1319	private void isCellFontBoldMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        boolean b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getBold();\n        boolean b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getBold();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 ? "" : "NOT ")+"BOLD",\n                (b2 ? "" : "NOT ")+"BOLD"\n            );\n        }\n    }
1320	public void removeRelationship(String id) {\n        PackageRelationship rel = relationshipsByID.get(id);\n        if (rel != null) {\n            relationshipsByID.remove(rel.getId());\n            relationshipsByType.values().remove(rel);\n            internalRelationshipsByTargetName.values().remove(rel);\n        }\n    }
1321	public static Quarter parseQuarter(String s) {\n\n                        int i = s.indexOf("Q");\n        if (i == -1) {\n            throw new TimePeriodFormatException("Missing Q.");\n        }\n\n        if (i == s.length() - 1) {\n            throw new TimePeriodFormatException("Q found at end of string.");\n        }\n\n        String qstr = s.substring(i + 1, i + 2);\n        int quarter = Integer.parseInt(qstr);\n        String remaining = s.substring(0, i) + s.substring(i + 2, s.length());\n\n                remaining = remaining.replace('/', ' ');\n        remaining = remaining.replace(',', ' ');\n        remaining = remaining.replace('-', ' ');\n\n                Year year = Year.parseYear(remaining.trim());\n        Quarter result = new Quarter(quarter, year);\n        return result;\n\n    }
1322	public static Document loadXML(Reader is) {\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    DocumentBuilder db = null;\n\n    try {\n      db = dbf.newDocumentBuilder();\n    }\n    catch (Exception se) {\n      throw new RuntimeException("Parser configuration error", se);\n    }\n\n        org.w3c.dom.Document doc = null;\n    try {\n      doc = db.parse(new InputSource(is));\n          }\n    catch (Exception se) {\n      throw new RuntimeException("Error parsing file:" + se, se);\n    }\n\n    return doc;\n  }
1323	public void addRangeCrosshair(Crosshair crosshair) {\n        ParamChecks.nullNotPermitted(crosshair, "crosshair");\n        this.yCrosshairs.add(crosshair);\n        crosshair.addPropertyChangeListener(this);\n        fireOverlayChanged();\n    }
1324	public static RectangleEdge resolveRangeAxisLocation(\n            AxisLocation location, PlotOrientation orientation) {\n\n        ParamChecks.nullNotPermitted(location, "location");\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n\n        RectangleEdge result = null;\n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.TOP_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n\n                if (result == null) {\n            throw new IllegalStateException("resolveRangeAxisLocation()");\n        }\n        return result;\n\n    }
1325	public synchronized void prune(Pruner pruner) throws IOException {\n                    final List<SearcherTracker> trackers = new ArrayList<>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n                              if (pruner.doPrune(ageSec, tracker.searcher)) {\n                searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }
1326	int nextRun() {\n    final int runBase = runEnd(0);\n    assert runBase < to;\n    if (runBase == to - 1) {\n      return 1;\n    }\n    int o = runBase + 2;\n    if (compare(runBase, runBase+1) > 0) {\n            while (o < to && compare(o - 1, o) > 0) {\n        ++o;\n      }\n      reverse(runBase, o);\n    } else {\n            while (o < to && compare(o - 1, o) <= 0) {\n        ++o;\n      }\n    }\n    final int runHi = Math.max(o, Math.min(to, runBase + minRun));\n    binarySort(runBase, runHi, o);\n    return runHi - runBase;\n  }
1327	public static OPCPackage clone(OPCPackage pkg, File file) throws OpenXML4JException, IOException {\n\n        String path = file.getAbsolutePath();\n\n        OPCPackage dest = OPCPackage.create(path);\n        PackageRelationshipCollection rels = pkg.getRelationships();\n        for (PackageRelationship rel : rels) {\n            PackagePart part = pkg.getPart(rel);\n            PackagePart part_tgt;\n            if (rel.getRelationshipType().equals(PackageRelationshipTypes.CORE_PROPERTIES)) {\n                copyProperties(pkg.getPackageProperties(), dest.getPackageProperties());\n                continue;\n            }\n            dest.addRelationship(part.getPartName(), rel.getTargetMode(), rel.getRelationshipType());\n            part_tgt = dest.createPart(part.getPartName(), part.getContentType());\n\n            OutputStream out = part_tgt.getOutputStream();\n            IOUtils.copy(part.getInputStream(), out);\n            out.close();\n\n            if(part.hasRelationships()) {\n                copy(pkg, part, dest, part_tgt);\n            }\n        }\n        dest.close();\n\n                new File(path).deleteOnExit();\n        return OPCPackage.open(path);\n    }
1328	private short genericProcessEvents(HSSFRequest req, InputStream in)\n		throws HSSFUserException {\n		short userCode = 0;\n\n				RecordFactoryInputStream recordStream = new RecordFactoryInputStream(in, false);\n\n				while(true) {\n			Record r = recordStream.nextRecord();\n			if(r == null) {\n				break;\n			}\n			userCode = req.processRecord(r);\n			if (userCode != 0) {\n				break;\n			}\n		}\n\n				return userCode;\n	}
1329	public Map<String, String> readMacros() throws IOException {\n        Map<String, Module> modules = readMacroModules();\n        Map<String, String> moduleSources = new HashMap<>();\n        for (Map.Entry<String, Module> entry : modules.entrySet()) {\n            moduleSources.put(entry.getKey(), entry.getValue().getContent());\n        }\n        return moduleSources;\n    }
1330	public void remove(CategoryPlot subplot) {\n        ParamChecks.nullNotPermitted(subplot, "subplot");\n        int position = -1;\n        int size = this.subplots.size();\n        int i = 0;\n        while (position == -1 && i < size) {\n            if (this.subplots.get(i) == subplot) {\n                position = i;\n            }\n            i++;\n        }\n        if (position != -1) {\n            this.subplots.remove(position);\n            subplot.setParent(null);\n            subplot.removeChangeListener(this);\n            CategoryAxis domain = getDomainAxis();\n            if (domain != null) {\n                domain.configure();\n            }\n            fireChangeEvent();\n        }\n    }
1331	private static boolean isValidRangeOperand(ParseNode a) {\n        Ptg tkn = a.getToken();\n                if (tkn instanceof OperandPtg) {\n                        return true;\n        }\n\n                if (tkn instanceof AbstractFunctionPtg) {\n            AbstractFunctionPtg afp = (AbstractFunctionPtg) tkn;\n            byte returnClass = afp.getDefaultOperandClass();\n            return Ptg.CLASS_REF == returnClass;\n        }\n        if (tkn instanceof ValueOperatorPtg) {\n            return false;\n        }\n        if (tkn instanceof OperationPtg) {\n            return true;\n        }\n\n                if (tkn instanceof ParenthesisPtg) {\n                        return isValidRangeOperand(a.getChildren()[0]);\n        }\n\n                if (tkn == ErrPtg.REF_INVALID) {\n            return true;\n        }\n\n                return false;\n    }
1332	protected static List<ValueEval> getValidationValuesForConstraint(DataValidationContext context) {\n        final DataValidationConstraint val = context.getValidation().getValidationConstraint();\n        if (val.getValidationType() != ValidationType.LIST) return null;\n        \n        String formula = val.getFormula1();\n        \n        final List<ValueEval> values = new ArrayList<>();\n        \n        if (val.getExplicitListValues() != null && val.getExplicitListValues().length > 0) {\n                        for (String s : val.getExplicitListValues()) {\n                if (s != null) values.add(new StringEval(s));             }\n        } else if (formula != null) {\n                                    ValueEval eval = context.getEvaluator().getWorkbookEvaluator().evaluateList(formula, context.getTarget(), context.getRegion());\n                                    if (eval instanceof TwoDEval) {\n                TwoDEval twod = (TwoDEval) eval;\n                for (int i=0; i < twod.getHeight(); i++) {\n                    final ValueEval cellValue = twod.getValue(i,  0);\n                    values.add(cellValue);\n                }\n            }\n        }\n        return Collections.unmodifiableList(values);\n    }
1333	public static String searchReplace(String inputString,\n                                       String searchString,\n                                       String replaceString) {\n\n        int i = inputString.indexOf(searchString);\n        if (i == -1) {\n            return inputString;\n        }\n\n        String r = "";\n        r += inputString.substring(0, i) + replaceString;\n        if (i + searchString.length() < inputString.length()) {\n            r += searchReplace(inputString.substring(i + searchString.length()),\n                    searchString, replaceString);\n        }\n\n        return r;\n    }
1334	public static void checkHitCollector(Random random, Query query, String defaultFieldName,\n                                       IndexSearcher searcher, int[] results)\n    throws IOException {\n\n    QueryUtils.check(random,query,searcher);\n    \n    Set<Integer> correct = new TreeSet<>();\n    for (int i = 0; i < results.length; i++) {\n      correct.add(Integer.valueOf(results[i]));\n    }\n    final Set<Integer> actual = new TreeSet<>();\n    final Collector c = new SetCollector(actual);\n\n    searcher.search(query, c);\n    Assert.assertEquals("Simple: " + query.toString(defaultFieldName), \n                        correct, actual);\n\n    for (int i = -1; i < 2; i++) {\n      actual.clear();\n      IndexSearcher s = QueryUtils.wrapUnderlyingReader\n        (random, searcher, i);\n      s.search(query, c);\n      Assert.assertEquals("Wrap Reader " + i + ": " +\n                          query.toString(defaultFieldName),\n                          correct, actual);\n    }\n  }
1335	public void delete(int start, int end, boolean notify) {\n        if (end < start) {\n            throw new IllegalArgumentException("Requires start <= end.");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        updateMinMaxYByIteration();\n        if (this.data.isEmpty()) {\n            this.timePeriodClass = null;\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }
1336	boolean next() {\n    if (scriptLimit >= limit)\n      return false;\n\n    scriptCode = UScript.COMMON;\n    scriptStart = scriptLimit;\n\n    while (index < limit) {\n      final int ch = UTF16.charAt(text, start, limit, index - start);\n      final int sc = getScript(ch);\n\n      \n      if (isSameScript(scriptCode, sc)\n          || UCharacter.getType(ch) == ECharacterCategory.NON_SPACING_MARK) {\n        index += UTF16.getCharCount(ch);\n\n        \n        if (scriptCode <= UScript.INHERITED && sc > UScript.INHERITED) {\n          scriptCode = sc;\n        }\n\n      } else {\n        break;\n      }\n    }\n\n    scriptLimit = index;\n    return true;\n  }
1337	private void createChart() {\n        CTPlotArea plotArea = getCTPlotArea();\n\n        plotArea.addNewLayout();\n        chart.addNewPlotVisOnly().setVal(true);\n\n        CTPrintSettings printSettings = chartSpace.addNewPrintSettings();\n        printSettings.addNewHeaderFooter();\n\n        CTPageMargins pageMargins = printSettings.addNewPageMargins();\n        pageMargins.setB(0.75);\n        pageMargins.setL(0.70);\n        pageMargins.setR(0.70);\n        pageMargins.setT(0.75);\n        pageMargins.setHeader(0.30);\n        pageMargins.setFooter(0.30);\n        printSettings.addNewPageSetup();\n    }
1338	public void removeAgedItems(boolean notify) {\n                        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed) {\n                updateMinMaxYByIteration();\n                if (notify) {\n                    fireSeriesChanged();\n                }\n            }\n        }\n    }
1339	protected void processCommands() {\n		if(commandDefinitions == null) {\n			throw new IllegalStateException("You must supply the command definitions before calling processCommands!");\n		}\n\n						ArrayList<Command> commandList = new ArrayList<>();\n		for(CommandDefinition cdef : commandDefinitions) {\n			int type = cdef.getType();\n			int offset = cdef.getOffset();\n\n						if(type == 10) {\n				name = cdef.getName();\n				continue;\n			} else if(type == 18) {\n				continue;\n			}\n\n\n						Command command;\n			if(type == 11 || type == 21) {\n				command = new BlockOffsetCommand(cdef);\n			} else {\n				command = new Command(cdef);\n			}\n\n									switch(type) {\n			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n			case 11: case 21:\n			case 12: case 16: case 17: case 18: case 28: case 29:\n								break;\n			default:\n								if(offset >= 19) {\n					offset -= 19;\n				}\n			}\n\n						if(offset >= contents.length) {\n				logger.log(POILogger.WARN,\n						"Command offset " + offset + " past end of data at " + contents.length\n				);\n				continue;\n			}\n\n			try {\n								switch(type) {\n								case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n					int val = contents[offset] & (1<<type);\n					command.value = Boolean.valueOf(val > 0);\n					break;\n				case 8:\n					command.value = Byte.valueOf(contents[offset]);\n					break;\n				case 9:\n					command.value = Double.valueOf(\n							LittleEndian.getDouble(contents, offset)\n					);\n					break;\n				case 12:\n															\n										if(contents.length < 8) {\n						command.value = "";\n						break;\n					}\n\n										int startsAt = 8;\n					int endsAt = startsAt;\n					for(int j=startsAt; j<contents.length-1 && endsAt == startsAt; j++) {\n						if(contents[j] == 0 && contents[j+1] == 0) {\n							endsAt = j;\n						}\n					}\n					if(endsAt == startsAt) {\n						endsAt = contents.length;\n					}\n\n					int strLen = endsAt - startsAt;\n					command.value = new String(contents, startsAt, strLen, header.getChunkCharset().name());\n					break;\n				case 25:\n					command.value = Short.valueOf(\n						LittleEndian.getShort(contents, offset)\n					);\n					break;\n				case 26:\n					command.value = Integer.valueOf(\n							LittleEndian.getInt(contents, offset)\n					);\n					break;\n\n								case 11: case 21:\n					if(offset < contents.length - 3) {\n						int bOffset = (int)LittleEndian.getUInt(contents, offset);\n						BlockOffsetCommand bcmd = (BlockOffsetCommand)command;\n						bcmd.setOffset(bOffset);\n					}\n					break;\n\n				default:\n					logger.log(POILogger.INFO,\n							"Command of type " + type + " not processed!");\n				}\n			}\n			catch (Exception e) {\n				logger.log(POILogger.ERROR, "Unexpected error processing command, ignoring and continuing. Command: " +\n						command, e);\n			}\n\n						commandList.add(command);\n		}\n\n				this.commands = commandList.toArray(\n							new Command[commandList.size()] );\n\n					}
1340	Query makeDisjoint(Rectangle bbox) {\n\n        \n            Query qMinY = this.makeNumericRangeQuery(field_minY, bbox.getMaxY(), null, false, false);\n    Query qMaxY = this.makeNumericRangeQuery(field_maxY, null, bbox.getMinY(), false, false);\n    Query yConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qMinY, qMaxY);\n\n        Query xConditions;\n\n        if (!bbox.getCrossesDateLine()) {\n\n                  Query qMinX = this.makeNumericRangeQuery(field_minX, bbox.getMaxX(), null, false, false);\n      if (bbox.getMinX() == -180.0 && ctx.isGeo()) {        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(qMinX, BooleanClause.Occur.MUST);\n        bq.add(makeNumberTermQuery(field_maxX, 180.0), BooleanClause.Occur.MUST_NOT);\n        qMinX = bq.build();\n      }\n      Query qMaxX = this.makeNumericRangeQuery(field_maxX, null, bbox.getMinX(), false, false);\n\n      if (bbox.getMaxX() == 180.0 && ctx.isGeo()) {        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(qMaxX, BooleanClause.Occur.MUST);\n        bq.add(makeNumberTermQuery(field_minX, -180.0), BooleanClause.Occur.MUST_NOT);\n        qMaxX = bq.build();\n      }\n      Query qMinMax = this.makeQuery(BooleanClause.Occur.SHOULD, qMinX, qMaxX);\n      Query qNonXDL = this.makeXDL(false, qMinMax);\n\n      if (!ctx.isGeo()) {\n        xConditions = qNonXDL;\n      } else {\n        \n                                                        Query qMinXLeft = this.makeNumericRangeQuery(field_minX, bbox.getMaxX(), null, false, false);\n        Query qMaxXRight = this.makeNumericRangeQuery(field_maxX, null, bbox.getMinX(), false, false);\n        Query qLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qMinXLeft, qMaxXRight);\n        Query qXDL = this.makeXDL(true, qLeftRight);\n\n                xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);\n      }\n          } else {\n\n                              Query qMinXLeft = this.makeNumericRangeQuery(field_minX, 180.0, null, false, false);\n      Query qMaxXLeft = this.makeNumericRangeQuery(field_maxX, null, bbox.getMinX(), false, false);\n      Query qMinXRight = this.makeNumericRangeQuery(field_minX, bbox.getMaxX(), null, false, false);\n      Query qMaxXRight = this.makeNumericRangeQuery(field_maxX, null, -180.0, false, false);\n      Query qLeft = this.makeQuery(BooleanClause.Occur.SHOULD, qMinXLeft, qMaxXLeft);\n      Query qRight = this.makeQuery(BooleanClause.Occur.SHOULD, qMinXRight, qMaxXRight);\n      Query qLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qLeft, qRight);\n\n      \n      xConditions = this.makeXDL(false, qLeftRight);\n    }\n\n        return this.makeQuery(BooleanClause.Occur.SHOULD, xConditions, yConditions);\n  }
1341	private void drawAdditionalItemLabel(Graphics2D g2,\n            PlotOrientation orientation, XYDataset dataset, int series,\n            int item, double x, double y) {\n\n        if (this.additionalItemLabelGenerator == null) {\n            return;\n        }\n\n        Font labelFont = getItemLabelFont(series, item);\n        Paint paint = getItemLabelPaint(series, item);\n        g2.setFont(labelFont);\n        g2.setPaint(paint);\n        String label = this.additionalItemLabelGenerator.generateLabel(dataset,\n                series, item);\n\n        ItemLabelPosition position = getNegativeItemLabelPosition(series, item);\n        Point2D anchorPoint = calculateLabelAnchorPoint(\n                position.getItemLabelAnchor(), x, y, orientation);\n        TextUtilities.drawRotatedString(label, g2,\n                (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                position.getTextAnchor(), position.getAngle(),\n                position.getRotationAnchor());\n    }
1342	protected Set<BytesRef> decodeContexts(BytesRef scratch, ByteArrayDataInput tmpInput) {\n    tmpInput.reset(scratch.bytes, scratch.offset, scratch.length);\n    tmpInput.skipBytes(scratch.length - 2);     short ctxSetSize = tmpInput.readShort();\n    scratch.length -= 2;\n    final Set<BytesRef> contextSet = new HashSet<>();\n    for (short i = 0; i < ctxSetSize; i++) {\n      tmpInput.setPosition(scratch.offset + scratch.length - 2);\n      short curContextLength = tmpInput.readShort();\n      scratch.length -= 2;\n      tmpInput.setPosition(scratch.offset + scratch.length - curContextLength);\n      BytesRef contextSpare = new BytesRef(curContextLength);\n      tmpInput.readBytes(contextSpare.bytes, 0, curContextLength);\n      contextSpare.length = curContextLength;\n      contextSet.add(contextSpare);\n      scratch.length -= curContextLength;\n    }\n    return contextSet;\n  }
1343	public PackagePart createPart(PackagePartName partName, String contentType,\n			ByteArrayOutputStream content) {\n		PackagePart addedPart = this.createPart(partName, contentType);\n		if (addedPart == null) {\n			return null;\n		}\n				if (content != null) {\n			try {\n				OutputStream partOutput = addedPart.getOutputStream();\n				if (partOutput == null) {\n					return null;\n				}\n\n				partOutput.write(content.toByteArray(), 0, content.size());\n				partOutput.close();\n\n			} catch (IOException ioe) {\n				return null;\n			}\n		} else {\n			return null;\n		}\n		return addedPart;\n	}
1344	public String getText() {\n        StringBuffer text = new StringBuffer();\n        \n                CodepageRecord codepage = null;\n        \n                while (ris.hasNextRecord()) {\n            int sid = ris.getNextSid();\n            ris.nextRecord();\n\n            switch (sid) {\n                case  FILE_PASS_RECORD_SID:\n                    throw new EncryptedDocumentException("Encryption not supported for Old Excel files");\n\n                case OldSheetRecord.sid:\n                    OldSheetRecord shr = new OldSheetRecord(ris);\n                    shr.setCodePage(codepage);\n                    text.append("Sheet: ");\n                    text.append(shr.getSheetname());\n                    text.append('\n');\n                    break;\n            \n                case OldLabelRecord.biff2_sid:\n                case OldLabelRecord.biff345_sid:\n                    OldLabelRecord lr = new OldLabelRecord(ris);\n                    lr.setCodePage(codepage);\n                    text.append(lr.getValue());\n                    text.append('\n');\n                    break;\n                case OldStringRecord.biff2_sid:\n                case OldStringRecord.biff345_sid:\n                    OldStringRecord sr = new OldStringRecord(ris);\n                    sr.setCodePage(codepage);\n                    text.append(sr.getString());\n                    text.append('\n');\n                    break;\n                    \n                case NumberRecord.sid:\n                    NumberRecord nr = new NumberRecord(ris);\n                    handleNumericCell(text, nr.getValue());\n                    break;\n                case OldFormulaRecord.biff2_sid:\n                case OldFormulaRecord.biff3_sid:\n                case OldFormulaRecord.biff4_sid:\n                                        if (biffVersion == 5) {\n                        FormulaRecord fr = new FormulaRecord(ris);\n                        if (fr.getCachedResultType() == CellType.NUMERIC.getCode()) {\n                            handleNumericCell(text, fr.getValue());\n                        }\n                    } else {\n                        OldFormulaRecord fr = new OldFormulaRecord(ris);\n                        if (fr.getCachedResultType() == CellType.NUMERIC.getCode()) {\n                            handleNumericCell(text, fr.getValue());\n                        }\n                    }\n                    break;\n                case RKRecord.sid:\n                    RKRecord rr = new RKRecord(ris);\n                    handleNumericCell(text, rr.getRKNumber());\n                    break;\n                    \n                case CodepageRecord.sid:\n                    codepage = new CodepageRecord(ris);\n                    break;\n                    \n                default:\n                    ris.readFully(IOUtils.safelyAllocate(ris.remaining(), MAX_RECORD_LENGTH));\n            }\n        }\n\n        close();\n        ris = null;\n\n        return text.toString();\n    }
1345	public void zoomInDomain(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n                                                boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomDomainAxes(this.zoomInFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }
1346	public static byte[] encode(InetAddress value) {\n    byte[] address = value.getAddress();\n    if (address.length == 4) {\n      byte[] mapped = new byte[16];\n      System.arraycopy(IPV4_PREFIX, 0, mapped, 0, IPV4_PREFIX.length);\n      System.arraycopy(address, 0, mapped, IPV4_PREFIX.length, address.length);\n      address = mapped;\n    } else if (address.length != 16) {\n            throw new UnsupportedOperationException("Only IPv4 and IPv6 addresses are supported");\n    }\n    return address;\n  }
1347	protected static HSLFTextRun appendText(List<HSLFTextParagraph> paragraphs, String text, boolean newParagraph) {\n        text = toInternalString(text);\n\n                assert(!paragraphs.isEmpty() && !paragraphs.get(0).getTextRuns().isEmpty());\n\n        HSLFTextParagraph htp = paragraphs.get(paragraphs.size() - 1);\n        HSLFTextRun htr = htp.getTextRuns().get(htp.getTextRuns().size() - 1);\n\n        boolean addParagraph = newParagraph;\n        for (String rawText : text.split("(?<=\r)")) {\n                        boolean lastRunEmpty = (htr.getLength() == 0);\n            boolean lastParaEmpty = lastRunEmpty && (htp.getTextRuns().size() == 1);\n\n            if (addParagraph && !lastParaEmpty) {\n                TextPropCollection tpc = htp.getParagraphStyle();\n                HSLFTextParagraph prevHtp = htp;\n                htp = new HSLFTextParagraph(htp._headerAtom, htp._byteAtom, htp._charAtom, paragraphs);\n                htp.getParagraphStyle().copy(tpc);\n                htp.setParentShape(prevHtp.getParentShape());\n                htp.setShapeId(prevHtp.getShapeId());\n                htp.supplySheet(prevHtp.getSheet());\n                paragraphs.add(htp);\n            }\n            addParagraph = true;\n\n            if (!lastRunEmpty) {\n                TextPropCollection tpc = htr.getCharacterStyle();\n                htr = new HSLFTextRun(htp);\n                htr.getCharacterStyle().copy(tpc);\n                htp.addTextRun(htr);\n            }\n            htr.setText(rawText);\n        }\n\n        storeText(paragraphs);\n\n        return htr;\n    }
1348	public static CustomGeometry convertCustomGeometry(XMLStreamReader staxReader) {\n        try {\n            JAXBContext jaxbContext = JAXBContext.newInstance(BINDING_PACKAGE);\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            JAXBElement<CTCustomGeometry2D> el = unmarshaller.unmarshal(staxReader, CTCustomGeometry2D.class);\n            return new CustomGeometry(el.getValue());\n        } catch (JAXBException e) {\n            LOG.log(POILogger.ERROR, "Unable to parse single custom geometry", e);\n            return null;\n        }\n    }
1349	private int[] joinMap(int[] a, int[] b) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n        int[] result = new int[a.length + b.length];\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n    }
1350	protected final void recurseClearCachedFormulaResults() {\n		FormulaCellCacheEntry[] formulaCells = getConsumingCells();\n\n		for (int i = 0; i < formulaCells.length; i++) {\n			FormulaCellCacheEntry fc = formulaCells[i];\n			fc.clearFormulaEntry();\n			fc.recurseClearCachedFormulaResults();\n		}\n	}
1351	private BigDecimal parseLargePair(NumberBuffer buffer) {\n    BigDecimal first = parseMediumNumber(buffer);\n    BigDecimal second = parseLargeKanjiNumeral(buffer);\n\n    if (first == null && second == null) {\n      return null;\n    }\n\n    if (second == null) {\n                  return first;\n    }\n\n    if (first == null) {\n                  return second;\n    }\n\n    return first.multiply(second);\n  }
1352	public void add(TaskSeries series) {\n        ParamChecks.nullNotPermitted(series, "series");\n        this.data.add(series);\n        series.addChangeListener(this);\n\n                Iterator iterator = series.getTasks().iterator();\n        while (iterator.hasNext()) {\n            Task task = (Task) iterator.next();\n            String key = task.getDescription();\n            int index = this.keys.indexOf(key);\n            if (index < 0) {\n                this.keys.add(key);\n            }\n        }\n        fireDatasetChanged();\n    }
1353	public static void main(String[] args) {\n                                                                                                                                                ToCSV converter;\n        boolean converted = true;\n        long startTime = System.currentTimeMillis();\n        try {\n            converter = new ToCSV();\n            if(args.length == 2) {\n                                                converter.convertExcelToCSV(args[0], args[1]);\n            }\n            else if(args.length == 3){\n                                                converter.convertExcelToCSV(args[0], args[1], args[2]);\n            }\n            else if(args.length == 4) {\n                                                converter.convertExcelToCSV(args[0], args[1],\n                                            args[2], Integer.parseInt(args[3]));\n            }\n            else {\n                                                System.out.println("Usage: java ToCSV [Source File/Folder] " +\n                    "[Destination Folder] [Separator] [Formatting Convention]\n" +\n                    "\tSource File/Folder\tThis argument should contain the name of and\n" +\n                    "\t\t\t\tpath to either a single Excel workbook or a\n" +\n                    "\t\t\t\tfolder containing one or more Excel workbooks.\n" +\n                    "\tDestination Folder\tThe name of and path to the folder that the\n" +\n                    "\t\t\t\tCSV files should be written out into. The\n" +\n                    "\t\t\t\tfolder must exist before running the ToCSV\n" +\n                    "\t\t\t\tcode as it will not check for or create it.\n" +\n                    "\tSeparator\t\tOptional. The character or characters that\n" +\n                    "\t\t\t\tshould be used to separate fields in the CSV\n" +\n                    "\t\t\t\trecord. If no value is passed then the comma\n" +\n                    "\t\t\t\twill be assumed.\n" +\n                    "\tFormatting Convention\tOptional. This argument can take one of two\n" +\n                    "\t\t\t\tvalues. Passing 0 (zero) will result in a CSV\n" +\n                    "\t\t\t\tfile that obeys Excel's formatting conventions\n" +\n                    "\t\t\t\twhilst passing 1 (one) will result in a file\n" +\n                    "\t\t\t\tthat obeys UNIX formatting conventions. If no\n" +\n                    "\t\t\t\tvalue is passed, then the CSV file produced\n" +\n                    "\t\t\t\twill obey Excel's formatting conventions.");\n                converted = false;\n            }\n        }\n                                                        catch(Exception ex) {\n            System.out.println("Caught an: " + ex.getClass().getName());\n            System.out.println("Message: " + ex.getMessage());\n            System.out.println("Stacktrace follows:.....");\n            ex.printStackTrace(System.out);\n            converted = false;\n        }\n        \n        if (converted) {\n            System.out.println("Conversion took " + \n                  (int)((System.currentTimeMillis() - startTime)/1000) + " seconds");\n        }\n    }
1354	public CellRangeAddress8Bit removeArrayFormula(int rowIndex, int columnIndex) {\n		for (ArrayRecord ar : _arrayRecords) {\n			if (ar.isInRange(rowIndex, columnIndex)) {\n				_arrayRecords.remove(ar);\n				return ar.getRange();\n			}\n		}\n		String ref = new CellReference(rowIndex, columnIndex, false, false).formatAsString();\n		throw new IllegalArgumentException("Specified cell " + ref\n				+ " is not part of an array formula.");\n	}
1355	private static int anyOfRightLength(Automaton.Builder builder, String x, int n) {\n    int s = builder.createState();\n    if (x.length() == n) {\n      builder.setAccept(s, true);\n    } else {\n      builder.addTransition(s, anyOfRightLength(builder, x, n + 1), '0', '9');\n    }\n    return s;\n  }
1356	public static Week parseWeek(String s) {\n\n        Week result = null;\n        if (s != null) {\n\n                        s = s.trim();\n\n            int i = Week.findSeparator(s);\n            if (i != -1) {\n                String s1 = s.substring(0, i).trim();\n                String s2 = s.substring(i + 1, s.length()).trim();\n\n                Year y = Week.evaluateAsYear(s1);\n                int w;\n                if (y != null) {\n                    w = Week.stringToWeek(s2);\n                    if (w == -1) {\n                        throw new TimePeriodFormatException(\n                                "Can't evaluate the week.");\n                    }\n                    result = new Week(w, y);\n                }\n                else {\n                    y = Week.evaluateAsYear(s2);\n                    if (y != null) {\n                        w = Week.stringToWeek(s1);\n                        if (w == -1) {\n                            throw new TimePeriodFormatException(\n                                    "Can't evaluate the week.");\n                        }\n                        result = new Week(w, y);\n                    }\n                    else {\n                        throw new TimePeriodFormatException(\n                                "Can't evaluate the year.");\n                    }\n                }\n\n            }\n            else {\n                throw new TimePeriodFormatException(\n                        "Could not find separator.");\n            }\n\n        }\n        return result;\n\n    }
1357	synchronized boolean visit() throws IOException {\n    if (exc != null) {\n            return true;\n    }\n\n    if (current == null) {\n      if (iter.hasNext() == false) {\n        c.close();\n        return true;\n      }\n\n      Map.Entry<String,FileMetaData> next = iter.next();\n      FileMetaData metaData = next.getValue();\n      String fileName = next.getKey();\n      long len = c.in.readVLong();\n      if (len != metaData.length) {\n        throw new IllegalStateException("file " + fileName + ": meta data says length=" + metaData.length + " but c.in says " + len);\n      }\n      current = new CopyOneFile(c.in, dest, fileName, metaData, copyBuffer);\n    }\n\n    if (current.visit()) {\n            copiedFiles.put(current.name, current.tmpName);\n      totBytesCopied += current.getBytesCopied();\n      assert totBytesCopied <= totBytes: "totBytesCopied=" + totBytesCopied + " totBytes=" + totBytes;\n      current = null;\n      return false;\n    }\n\n    return false;\n  }
1358	public static PostingsEnum getTermDocsEnum(IndexReader r, String field, BytesRef term, int flags) throws IOException {\n    assert field != null;\n    assert term != null;\n    final Terms terms = getTerms(r, field);\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (termsEnum.seekExact(term)) {\n        return termsEnum.postings(null, flags);\n      }\n    }\n    return null;\n  }
1359	private int doNext() throws IOException {\n    while (freq < minShouldMatch) {\n      assert freq > 0;\n      if (freq + tailSize >= minShouldMatch) {\n                        advanceTail();\n      } else {\n                pushBackLeads();\n        setDocAndFreq();\n      }\n    }\n\n    return doc;\n  }
1360	private void paintNormalBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n\n      if (northBorder &&\n             ((northBorderType == BorderStyle.THIN) ||\n              (northBorderType == BorderStyle.MEDIUM) ||\n              (northBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x,y+k,width,y+k);\n        }\n      }\n\n      if (eastBorder &&\n             ((eastBorderType == BorderStyle.THIN) ||\n              (eastBorderType == BorderStyle.MEDIUM) ||\n              (eastBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(width-k,y,width-k,height);\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.THIN) ||\n               (southBorderType == BorderStyle.MEDIUM) ||\n               (southBorderType == BorderStyle.THICK)\n              )\n         ) {\n\n        int thickness = getThickness(southBorderType);\n\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x,height - k,width,height - k);\n        }\n      }\n\n      if (westBorder &&\n             ((westBorderType == BorderStyle.THIN) ||\n              (westBorderType == BorderStyle.MEDIUM) ||\n              (westBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x+k,y,x+k,height);\n        }\n      }\n   }
1361	public static String fileNameFromGeneration(String base, String ext, long gen) {\n    if (gen == -1) {\n      return null;\n    } else if (gen == 0) {\n      return segmentFileName(base, "", ext);\n    } else {\n      assert gen > 0;\n                        StringBuilder res = new StringBuilder(base.length() + 6 + ext.length())\n          .append(base).append('_').append(Long.toString(gen, Character.MAX_RADIX));\n      if (ext.length() > 0) {\n        res.append('.').append(ext);\n      }\n      return res.toString();\n    }\n  }
1362	private void paintDoubleBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             northBorderType == BorderStyle.DOUBLE) {\n\n      	g.setColor(northColor);\n\n        int leftx=x;\n        int rightx=width;\n\n                                        if (westBorder)\n           leftx = x+3;\n\n        if (eastBorder)\n           rightx = width-3;\n\n           g.drawLine(x,y,width,y);\n           g.drawLine(leftx,y+2,rightx,y+2);\n      }\n\n      if (eastBorder &&\n              eastBorderType == BorderStyle.DOUBLE\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; \n      	g.setColor(eastColor);\n\n        int topy=y;\n        int bottomy=height;\n\n        if (northBorder)\n          topy=y+3;\n\n        if (southBorder)\n            bottomy=height-3;\n\n        g.drawLine(width-1,y,width-1,height);\n        g.drawLine(width-3,topy,width-3,bottomy);\n      }\n\n      if (southBorder &&\n              southBorderType == BorderStyle.DOUBLE\n         ) {\n\n      	g.setColor(southColor);\n\n        int leftx=y;\n        int rightx=width;\n\n        if (westBorder)\n           leftx=x+3;\n\n        if (eastBorder)\n           rightx=width-3;\n\n\n        g.drawLine(x,height - 1,width,height - 1);\n        g.drawLine(leftx,height - 3,rightx,height - 3);\n      }\n\n      if (westBorder &&\n            westBorderType == BorderStyle.DOUBLE\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        int topy=y;\n        int bottomy=height-3;\n\n        if (northBorder)\n           topy=y+2;\n\n        if (southBorder)\n           bottomy=height-3;\n\n        g.drawLine(x,y,x,height);\n        g.drawLine(x+2,topy,x+2,bottomy);\n      }\n   }
1363	public static int convertColStringToIndex(String ref) {\n        int retval=0;\n        char[] refs = ref.toUpperCase(Locale.ROOT).toCharArray();\n        for (int k=0; k<refs.length; k++) {\n            char thechar = refs[k];\n            if (thechar == ABSOLUTE_REFERENCE_MARKER) {\n                if (k != 0) {\n                    throw new IllegalArgumentException("Bad col ref format '" + ref + "'");\n                }\n                continue;\n            }\n\n                        retval = (retval * 26) + (thechar - 'A' + 1);\n        }\n        return retval-1;\n    }
1364	static SerializableObject readObject(final PlanetModel planetModel, final InputStream inputStream, final Class<?> clazz) throws IOException {\n    try {\n            final Constructor<?> c = clazz.getDeclaredConstructor(PlanetModel.class, InputStream.class);\n            final Object object = c.newInstance(planetModel, inputStream);\n            if (!(object instanceof SerializableObject)) {\n        throw new IOException("Object "+clazz.getName()+" does not implement SerializableObject");\n      }\n      return (SerializableObject)object;\n    } catch (InstantiationException e) {\n      throw new IOException("Instantiation exception for class "+clazz.getName()+": "+e.getMessage(), e);\n    } catch (IllegalAccessException e) {\n      throw new IOException("Illegal access creating class "+clazz.getName()+": "+e.getMessage(), e);\n    } catch (NoSuchMethodException e) {\n      throw new IOException("No such method exception for class "+clazz.getName()+": "+e.getMessage(), e);\n    } catch (InvocationTargetException e) {\n      throw new IOException("Exception instantiating class "+clazz.getName()+": "+e.getMessage(), e);\n    }\n\n  }
1365	public GeoPoint bisection(final GeoPoint pt1, final GeoPoint pt2) {\n    final double A0 = (pt1.x + pt2.x) * 0.5;\n    final double B0 = (pt1.y + pt2.y) * 0.5;\n    final double C0 = (pt1.z + pt2.z) * 0.5;\n      \n    final double denom = inverseAbSquared * A0 * A0 +\n      inverseAbSquared * B0 * B0 +\n      inverseCSquared * C0 * C0;\n          \n    if(denom < Vector.MINIMUM_RESOLUTION) {\n            return null;\n    }\n      \n    final double t = Math.sqrt(1.0 / denom);\n      \n    return new GeoPoint(t * A0, t * B0, t * C0);\n  }
1366	public BigDecimal parseLargeKanjiNumeral(NumberBuffer buffer) {\n    int i = buffer.position();\n\n    if (i >= buffer.length()) {\n      return null;\n    }\n\n    char c = buffer.charAt(i);\n    int power = exponents[c];\n\n    if (power > 3) {\n      buffer.advance();\n      return BigDecimal.TEN.pow(power);\n    }\n\n    return null;\n  }
1367	public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery("JoinUtil.createJoinQuery with no segments");\n    } else if (numSegments == 1) {\n            ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery("JoinUtil.createJoinQuery: no join values");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException("OrdinalMap is required, because there is more than 1 segment");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, "Score mode %s isn't supported.", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }
1368	public void loadPatterns(InputSource source) throws IOException {\n    PatternParser pp = new PatternParser(this);\n    ivalues = new TernaryTree();\n\n    pp.parse(source);\n\n            trimToSize();\n    vspace.trimToSize();\n    classmap.trimToSize();\n\n        ivalues = null;\n  }
1369	public void createChartPrintJob() {\n        PrinterJob job = PrinterJob.getPrinterJob();\n        PageFormat pf = job.defaultPage();\n        PageFormat pf2 = job.pageDialog(pf);\n        if (pf2 != pf) {\n            job.setPrintable(this, pf2);\n            if (job.printDialog()) {\n                try {\n                    job.print();\n                }\n                catch (PrinterException e) {\n                    JOptionPane.showMessageDialog(this, e);\n                }\n            }\n        }\n    }
1370	protected void drawGridBands(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, List ticks) {\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            drawGridBandsHorizontal(g2, plotArea, dataArea, true, ticks);\n        } else if (RectangleEdge.isLeftOrRight(edge)) {\n            drawGridBandsVertical(g2, plotArea, dataArea, true, ticks);\n        }\n        g2.setClip(savedClip);\n    }
1371	@SuppressWarnings("deprecation")\n    private void buildRunsInOrderFromXml(XmlObject object) {\n        XmlCursor c = object.newCursor();\n        c.selectPath("child::*");\n        while (c.toNextSelection()) {\n            XmlObject o = c.getObject();\n            if (o instanceof CTR) {\n                XWPFRun r = new XWPFRun((CTR) o, this);\n                runs.add(r);\n                iruns.add(r);\n            }\n            if (o instanceof CTHyperlink) {\n                CTHyperlink link = (CTHyperlink)o;\n                for (CTR r : link.getRArray()) {\n                    XWPFHyperlinkRun hr = new XWPFHyperlinkRun(link, r, this);\n                    runs.add(hr);\n                    iruns.add(hr);\n                }\n            }\n            if (o instanceof CTSimpleField) {\n                CTSimpleField field = (CTSimpleField)o;\n                for (CTR r : field.getRArray()) {\n                    XWPFFieldRun fr = new XWPFFieldRun(field, r, this);\n                    runs.add(fr);\n                    iruns.add(fr);\n                }\n            }\n            if (o instanceof CTSdtBlock) {\n                XWPFSDT cc = new XWPFSDT((CTSdtBlock) o, part);\n                iruns.add(cc);\n            }\n            if (o instanceof CTSdtRun) {\n                XWPFSDT cc = new XWPFSDT((CTSdtRun) o, part);\n                iruns.add(cc);\n            }\n            if (o instanceof CTRunTrackChange) {\n                for (CTR r : ((CTRunTrackChange) o).getRArray()) {\n                    XWPFRun cr = new XWPFRun(r, this);\n                    runs.add(cr);\n                    iruns.add(cr);\n                }\n            }\n            if (o instanceof CTSmartTagRun) {\n                                                buildRunsInOrderFromXml(o);\n            }\n            if (o instanceof CTRunTrackChange) {\n                                for (CTRunTrackChange change : ((CTRunTrackChange) o).getInsArray()) {\n                    buildRunsInOrderFromXml(change);\n                }\n            }\n        }\n        c.dispose();\n    }
1372	protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        Line2D line;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        } else {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }
1373	public Point translateJava2DToScreen(Point2D java2DPoint) {\n        Insets insets = getInsets();\n        int x = (int) (java2DPoint.getX() * this.scaleX + insets.left);\n        int y = (int) (java2DPoint.getY() * this.scaleY + insets.top);\n        return new Point(x, y);\n    }
1374	public static void createShapeTree(EscherContainerRecord container, EscherAggregate agg, HSSFShapeContainer out, DirectoryNode root) {\n        if (container.getRecordId() == EscherContainerRecord.SPGR_CONTAINER) {\n            ObjRecord obj = null;\n            EscherClientDataRecord clientData = ((EscherContainerRecord) container.getChild(0)).getChildById(EscherClientDataRecord.RECORD_ID);\n            if (null != clientData) {\n                obj = (ObjRecord) agg.getShapeToObjMapping().get(clientData);\n            }\n            HSSFShapeGroup group = new HSSFShapeGroup(container, obj);\n            List<EscherContainerRecord> children = container.getChildContainers();\n                        for (int i = 0; i < children.size(); i++) {\n                EscherContainerRecord spContainer = children.get(i);\n                if (i != 0) {\n                    createShapeTree(spContainer, agg, group, root);\n                }\n            }\n            out.addShape(group);\n        } else if (container.getRecordId() == EscherContainerRecord.SP_CONTAINER) {\n            Map<EscherRecord, Record> shapeToObj = agg.getShapeToObjMapping();\n            ObjRecord objRecord = null;\n            TextObjectRecord txtRecord = null;\n\n            for (EscherRecord record : container) {\n                switch (record.getRecordId()) {\n                    case EscherClientDataRecord.RECORD_ID:\n                        objRecord = (ObjRecord) shapeToObj.get(record);\n                        break;\n                    case EscherTextboxRecord.RECORD_ID:\n                        txtRecord = (TextObjectRecord) shapeToObj.get(record);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (objRecord == null) {\n                throw new RecordFormatException("EscherClientDataRecord can't be found.");\n            }\n            if (isEmbeddedObject(objRecord)) {\n                HSSFObjectData objectData = new HSSFObjectData(container, objRecord, root);\n                out.addShape(objectData);\n                return;\n            }\n            CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord) objRecord.getSubRecords().get(0);\n            final HSSFShape shape;\n            switch (cmo.getObjectType()) {\n                case CommonObjectDataSubRecord.OBJECT_TYPE_PICTURE:\n                    shape = new HSSFPicture(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_RECTANGLE:\n                    shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_LINE:\n                    shape = new HSSFSimpleShape(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_COMBO_BOX:\n                    shape = new HSSFCombobox(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING:\n                    EscherOptRecord optRecord = container.getChildById(EscherOptRecord.RECORD_ID);\n                    if(optRecord == null) {\n                    	shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                    } else {\n                        EscherProperty property = optRecord.lookup(EscherProperties.GEOMETRY__VERTICES);\n                        if (null != property) {\n                            shape = new HSSFPolygon(container, objRecord, txtRecord);\n                        } else {\n                            shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                        }\n                    }\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_TEXT:\n                    shape = new HSSFTextbox(container, objRecord, txtRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_COMMENT:\n                    shape = new HSSFComment(container, objRecord, txtRecord, agg.getNoteRecordByObj(objRecord));\n                    break;\n                default:\n                    shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n            }\n            out.addShape(shape);\n        }\n    }
1375	public static final void writeAsPDF(Drawable drawable, \n            int w, int h, File file) {\n        if (!ExportUtils.isOrsonPDFAvailable()) {\n            throw new IllegalStateException(\n                    "OrsonPDF is not present on the classpath.");\n        }\n        ParamChecks.nullNotPermitted(drawable, "drawable");\n        ParamChecks.nullNotPermitted(file, "file");\n        try {\n            Class<?> pdfDocClass = Class.forName("com.orsonpdf.PDFDocument");\n            Object pdfDoc = pdfDocClass.newInstance();\n            Method m = pdfDocClass.getMethod("createPage", Rectangle2D.class);\n            Rectangle2D rect = new Rectangle(w, h);\n            Object page = m.invoke(pdfDoc, rect);\n            Method m2 = page.getClass().getMethod("getGraphics2D");\n            Graphics2D g2 = (Graphics2D) m2.invoke(page);\n            Rectangle2D drawArea = new Rectangle2D.Double(0, 0, w, h);\n            drawable.draw(g2, drawArea);\n            Method m3 = pdfDocClass.getMethod("writeToFile", File.class);\n            m3.invoke(pdfDoc, file);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(ex);\n        } catch (InstantiationException ex) {\n            throw new RuntimeException(ex);\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(ex);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            throw new RuntimeException(ex);\n        }\n    }
1376	private void updateHeaderFooterText(String[] parts) {\n		String _left = parts[0];\n		String _center = parts[1];\n		String _right = parts[2];\n		\n		if (_center.length() < 1 && _left.length() < 1 && _right.length() < 1) {\n			setHeaderFooterText("");\n			return;\n		}\n		StringBuilder sb = new StringBuilder(64);\n		sb.append("&C");\n		sb.append(_center);\n		sb.append("&L");\n		sb.append(_left);\n		sb.append("&R");\n		sb.append(_right);\n		String text = sb.toString();\n		setHeaderFooterText(text);\n	}
1377	private void unhookOldEnvironments(WorkbookEvaluator[] evaluators) {\n        Set<CollaboratingWorkbooksEnvironment> oldEnvs = new HashSet<>();\n        for(int i=0; i<evaluators.length; i++) {\n            oldEnvs.add(evaluators[i].getEnvironment());\n        }\n        CollaboratingWorkbooksEnvironment[] oldCWEs = new CollaboratingWorkbooksEnvironment[oldEnvs.size()];\n        oldEnvs.toArray(oldCWEs);\n        for (int i = 0; i < oldCWEs.length; i++) {\n            oldCWEs[i].unhook();\n        }\n    }
1378	public static Templates getTemplates(InputStream xslIs)\n      throws ParserConfigurationException, SAXException, IOException, TransformerConfigurationException {\n    dbf.setNamespaceAware(true);\n    DocumentBuilder builder = dbf.newDocumentBuilder();\n    org.w3c.dom.Document xslDoc = builder.parse(xslIs);\n    DOMSource ds = new DOMSource(xslDoc);\n    return tFactory.newTemplates(ds);\n  }
1379	protected void delete(int start, int end) {\n        for (int i = start; i <= end; i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }
1380	private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n        FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n                        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n                                        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n                    leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n                              leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new BitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }
1381	private int calculateNewLastCellPlusOne(int lastcell) {\n        int cellIx = lastcell - 1;\n        HSSFCell r = retrieveCell(cellIx);\n\n        while (r == null) {\n            if (cellIx < 0) {\n                return 0;\n            }\n            r = retrieveCell(--cellIx);\n        }\n        return cellIx+1;\n    }
1382	private CTTextParagraphProperties getDefaultMasterStyle(){\n        CTPlaceholder ph = _shape.getPlaceholderDetails().getCTPlaceholder(false);\n        String defaultStyleSelector;  \n        switch(ph == null ? -1 : ph.getType().intValue()) {\n            case STPlaceholderType.INT_TITLE:\n            case STPlaceholderType.INT_CTR_TITLE:\n                defaultStyleSelector = "titleStyle";\n                break;\n            case -1:             case STPlaceholderType.INT_FTR:\n            case STPlaceholderType.INT_SLD_NUM:\n            case STPlaceholderType.INT_DT:\n                defaultStyleSelector = "otherStyle";\n                break;\n            default:\n                defaultStyleSelector = "bodyStyle";\n                break;\n        }\n        int level = getIndentLevel();\n\n                final String nsPML = "http://schemas.openxmlformats.org/presentationml/2006/main";\n        XSLFSheet masterSheet = _shape.getSheet();\n        for (XSLFSheet m = masterSheet; m != null; m = (XSLFSheet)m.getMasterSheet()) {\n            masterSheet = m;\n            XmlObject xo = masterSheet.getXmlObject();\n            XmlCursor cur = xo.newCursor();\n            try {\n                cur.push();\n                if ((cur.toChild(nsPML, "txStyles") && cur.toChild(nsPML, defaultStyleSelector)) ||\n            		(cur.pop() && cur.toChild(nsPML, "notesStyle"))) {\n                    while (level >= 0) {\n                        cur.push();\n                    	if (cur.toChild(XSLFRelation.NS_DRAWINGML, "lvl" +(level+1)+ "pPr")) {\n                    		return (CTTextParagraphProperties)cur.getObject();\n                    	}\n                    	cur.pop();\n                    	level--;\n                    }\n                }\n            } finally {\n            	cur.dispose();\n            }\n        }\n        \n        return null;\n    }
1383	public DirectoryEntry createDirectory(final String name)\n        throws IOException\n    {\n        DirectoryProperty property = new DirectoryProperty(name);\n\n        DirectoryNode rval = new DirectoryNode(property, _nfilesystem, this);\n       _nfilesystem.addDirectory(property);\n\n        (( DirectoryProperty ) getProperty()).addChild(property);\n        _entries.add(rval);\n        _byname.put(name, rval);\n        return rval;\n    }
1384	public void add(SeriesDataset[] data) {\n\n        for (int i = 0; i < data.length; i++) {\n            fastAdd(data[i]);\n        }\n        DatasetChangeEvent event = new DatasetChangeEvent(this, this);\n        notifyListeners(event);\n\n    }
1385	public int serialize( int offset, byte[] data ) {\n        LOG.log( DEBUG, "Serializing Workbook with offsets" );\n\n        int pos = 0;\n\n        SSTRecord lSST = null;\n        int sstPos = 0;\n        boolean wroteBoundSheets = false;\n        for ( Record record : records.getRecords() ) {\n            int len = 0;\n            if (record instanceof SSTRecord) {\n                lSST = (SSTRecord)record;\n                sstPos = pos;\n            }\n            if (record.getSid() == ExtSSTRecord.sid && lSST != null) {\n                record = lSST.createExtSSTRecord(sstPos + offset);\n            }\n            if (record instanceof BoundSheetRecord) {\n                 if(!wroteBoundSheets) {\n                    for (BoundSheetRecord bsr : boundsheets) {\n                        len += bsr.serialize(pos+offset+len, data);\n                    }\n                    wroteBoundSheets = true;\n                 }\n            } else {\n               len = record.serialize( pos + offset, data );\n            }\n            pos += len;\n        }\n        \n        LOG.log( DEBUG, "Exiting serialize workbook" );\n        return pos;\n    }
1386	private void openWorkbook(File file) throws FileNotFoundException,\n                                           IOException {\n        System.out.println("Opening workbook [" + file.getName() + "]");\n        try (FileInputStream fis = new FileInputStream(file)) {\n\n                                                            this.workbook = WorkbookFactory.create(fis);\n            this.evaluator = this.workbook.getCreationHelper().createFormulaEvaluator();\n            this.formatter = new DataFormatter(true);\n        }\n    }
1387	public void preWrite() {\n        List<Property> pList = new ArrayList<>();\n                int i=0;\n        for (Property p : _properties) {\n                        if (p == null) continue;\n            p.setIndex(i++);\n            pList.add(p);\n        }\n\n                for (Property p : pList) p.preWrite();\n    }
1388	public void multiLevelBulletedListInCell(HSSFWorkbook workbook,\n                                             ArrayList<MultiLevelListItem> multiLevelListItems,\n                                             HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n                        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n                for(MultiLevelListItem multiLevelListItem : multiLevelListItems) {\n                                    buffer.append(InCellLists.BULLET_CHARACTER);\n            buffer.append(" ");\n            buffer.append(multiLevelListItem.getItemText());\n            buffer.append("\n");\n                                    ArrayList<String> lowerLevelItems = multiLevelListItem.getLowerLevelItems();\n            if(!(lowerLevelItems == null) && !(lowerLevelItems.isEmpty())) {\n                for(String item : lowerLevelItems) {\n                    buffer.append(InCellLists.TAB);\n                    buffer.append(InCellLists.BULLET_CHARACTER);\n                    buffer.append(" ");\n                    buffer.append(item);\n                    buffer.append("\n");\n                }\n            }\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
1389	protected void read(POIXMLFactory factory, Map<PackagePart, POIXMLDocumentPart> context) throws OpenXML4JException {\n        PackagePart pp = getPackagePart();\n                POIXMLDocumentPart otherChild = context.put(pp, this);\n        if (otherChild != null && otherChild != this) {\n            throw new POIXMLException("Unique PackagePart-POIXMLDocumentPart relation broken!");\n        }\n\n        if (!pp.hasRelationships()) return;\n\n        PackageRelationshipCollection rels = packagePart.getRelationships();\n        List<POIXMLDocumentPart> readLater = new ArrayList<>();\n\n                for (PackageRelationship rel : rels) {\n            if (rel.getTargetMode() == TargetMode.INTERNAL) {\n                URI uri = rel.getTargetURI();\n\n                                PackagePartName relName;\n                if (uri.getRawFragment() != null) {\n                    relName = PackagingURIHelper.createPartName(uri.getPath());\n                } else {\n                    relName = PackagingURIHelper.createPartName(uri);\n                }\n\n                final PackagePart p = packagePart.getPackage().getPart(relName);\n                if (p == null) {\n                    logger.log(POILogger.ERROR, "Skipped invalid entry " + rel.getTargetURI());\n                    continue;\n                }\n\n                POIXMLDocumentPart childPart = context.get(p);\n                if (childPart == null) {\n                    childPart = factory.createDocumentPart(this, p);\n                                                            if (this instanceof XDDFChart && childPart instanceof XSSFWorkbook) {\n                        ((XDDFChart) this).setWorkbook((XSSFWorkbook) childPart);\n                    }\n                    childPart.parent = this;\n                                        context.put(p, childPart);\n                    readLater.add(childPart);\n                }\n\n                addRelation(rel, childPart);\n            }\n        }\n\n        for (POIXMLDocumentPart childPart : readLater) {\n            childPart.read(factory, context);\n        }\n    }
1390	public void copyBytes(long src, long dest, int len) {\n        assert src < dest;\n\n                \n    "  cycle: chunk="" len="\n\n    long end = src + len;\n\n    int blockIndex = (int) (end >> blockBits);\n    int downTo = (int) (end & blockMask);\n    if (downTo == 0) {\n      blockIndex--;\n      downTo = blockSize;\n    }\n    byte[] block = blocks.get(blockIndex);\n\n    while (len > 0) {\n            if (len <= downTo) {\n                writeBytes(dest, block, downTo-len, len);\n        break;\n      } else {\n                len -= downTo;\n        writeBytes(dest + len, block, 0, downTo);\n        blockIndex--;\n        block = blocks.get(blockIndex);\n        downTo = blockSize;\n      }\n    }\n  }
1391	default InputStream readObjectData() throws IOException {\n        final String progId = getProgId();\n        if (progId == null) {\n            throw new IllegalStateException(\n                "Ole object hasn't been initialized or provided in the source xml. " +\n                "use updateObjectData() first or check the corresponding slideXXX.xml");\n        }\n\n        final Application app = Application.lookup(progId);\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream(50000);\n        try (final InputStream is = FileMagic.prepareToCheckMagic(readObjectDataRaw())) {\n            final FileMagic fm = FileMagic.valueOf(is);\n            if (fm == FileMagic.OLE2) {\n                try (final POIFSFileSystem poifs = new POIFSFileSystem(is)) {\n                    String[] names = {\n                        (app == null) ? null : app.getMetaData().getOleEntry(),\n                                                "Package",\n                        "Contents",\n                        "CONTENTS",\n                        "CONTENTSV30",\n                    };\n                    final DirectoryNode root = poifs.getRoot();\n                    String entryName = null;\n                    for (String n : names) {\n                        if (root.hasEntry(n)) {\n                            entryName = n;\n                            break;\n                        }\n                    }\n                    if (entryName == null) {\n                        poifs.writeFilesystem(bos);\n                    } else {\n                        try (final InputStream is2 = poifs.createDocumentInputStream(entryName)) {\n                            IOUtils.copy(is2, bos);\n                        }\n                    }\n                }\n            } else {\n                IOUtils.copy(is, bos);\n            }\n        }\n\n        return new ByteArrayInputStream(bos.toByteArray());\n    }
1392	public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    long startMS = System.currentTimeMillis();\n\n    List<Future<Partition>> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n        TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (true) {\n        Partition part = readPartition(is);\n        if (part.count == 0) {\n          if (partitionsInRAM != null) {\n            partitionsInRAM.release();\n          }\n          assert part.exhausted;\n          break;\n        }\n\n        Callable<Partition> job = new SortPartitionTask(trackingDir, part);\n\n        segments.add(exec.submit(job));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += part.count;\n        levelCounts[0]++;\n\n                int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n\n        if (part.exhausted) {\n          break;\n        }\n      }\n      \n            \n            while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, "sort", IOContext.DEFAULT)) {\n                    CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = getPartition(segments.get(0)).fileName;\n      }\n\n            assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTimeMS = System.currentTimeMillis() - startMS;\n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }
1393	protected static double restrictValueToDataArea(double value,\n                                                    XYPlot plot,\n                                                    Rectangle2D dataArea) {\n        double min = 0;\n        double max = 0;\n        if (plot.getOrientation() == PlotOrientation.VERTICAL) {\n            min = dataArea.getMinY();\n            max = dataArea.getMaxY();\n        }\n        else if (plot.getOrientation() ==  PlotOrientation.HORIZONTAL) {\n            min = dataArea.getMinX();\n            max = dataArea.getMaxX();\n        }\n        if (value < min) {\n            value = min;\n        }\n        else if (value > max) {\n            value = max;\n        }\n        return value;\n    }
1394	public long deleteAll() throws IOException {\n    ensureOpen();\n        boolean success = false;\n    \n    "point in time semantics"\n    try {\n      synchronized (fullFlushLock) { \n        docWriter.lockAndAbortAll(this);\n        processEvents(false, true);\n        synchronized (this) {\n          try {\n                        abortMerges();\n                        stopMerges = false;\n            adjustPendingNumDocs(-segmentInfos.totalMaxDoc());\n                        segmentInfos.clear();\n                        deleter.checkpoint(segmentInfos, false);\n\n            \n                        readerPool.dropAll(false);\n                        changeCount.incrementAndGet();\n            segmentInfos.changed();\n            globalFieldNumberMap.clear();\n            success = true;\n            long seqNo = docWriter.deleteQueue.getNextSequenceNumber();\n            docWriter.setLastSeqNo(seqNo);\n            return seqNo;\n          } finally {\n            docWriter.unlockAllAfterAbortAll(this);\n            if (!success) {\n              if (infoStream.isEnabled("IW")) {\n                infoStream.message("IW", "hit exception during deleteAll");\n              }\n            }\n          }\n        }\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, "deleteAll");\n\n            return -1;\n    }\n  }
1395	protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n        try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n                  \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (enableGraphQueries && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n                  \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n                return analyzeTerm(field, stream);\n      } else if (isGraph) {\n                if (quoted) {\n          return analyzeGraphPhrase(stream, field, phraseSlop);\n        } else {\n          return analyzeGraphBoolean(field, stream, operator);\n        }\n      } else if (quoted && positionCount > 1) {\n                if (hasSynonyms) {\n                    return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n                    return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n                if (positionCount == 1) {\n                    return analyzeBoolean(field, stream);\n        } else {\n                    return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException("Error analyzing query text", e);\n    }\n  }
1396	public static URI getZipURIFromOPCName(String opcItemName) {\n        if (opcItemName == null) {\n            throw new IllegalArgumentException("opcItemName");\n        }\n\n        String retVal = opcItemName;\n        while (retVal.startsWith(FORWARD_SLASH)) {\n            retVal = retVal.substring(1);\n        }\n        try {\n            return new URI(retVal);\n        } catch (URISyntaxException e) {\n            return null;\n        }\n    }
1397	public double draw(Graphics2D g2, double cursor,\n                       Rectangle2D plotArea, Rectangle2D dataArea,\n                       Rectangle2D reservedArea, RectangleEdge edge) {\n\n        Rectangle2D colorBarArea = null;\n\n        double thickness = calculateBarThickness(dataArea, edge);\n        if (this.colorBarThickness > 0) {\n            thickness = this.colorBarThickness;          }\n\n        double length;\n        if (RectangleEdge.isLeftOrRight(edge)) {\n            length = dataArea.getHeight();\n        }\n        else {\n            length = dataArea.getWidth();\n        }\n\n        if (this.colorBarLength > 0) {\n            length = this.colorBarLength;\n        }\n\n        if (edge == RectangleEdge.BOTTOM) {\n            colorBarArea = new Rectangle2D.Double(dataArea.getX(),\n                    plotArea.getMaxY() + this.outerGap, length, thickness);\n        }\n        else if (edge == RectangleEdge.TOP) {\n            colorBarArea = new Rectangle2D.Double(dataArea.getX(),\n                    reservedArea.getMinY() + this.outerGap, length, thickness);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            colorBarArea = new Rectangle2D.Double(plotArea.getX() - thickness\n                    - this.outerGap, dataArea.getMinY(), thickness, length);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            colorBarArea = new Rectangle2D.Double(plotArea.getMaxX()\n                    + this.outerGap, dataArea.getMinY(), thickness, length);\n        }\n\n                this.axis.refreshTicks(g2, new AxisState(), colorBarArea, edge);\n\n        drawColorBar(g2, colorBarArea, edge);\n\n        AxisState state = null;\n        assert colorBarArea != null;         if (edge == RectangleEdge.TOP) {\n            cursor = colorBarArea.getMinY();\n            state = this.axis.draw(g2, cursor, reservedArea, colorBarArea,\n                    RectangleEdge.TOP, null);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            cursor = colorBarArea.getMaxY();\n            state = this.axis.draw(g2, cursor, reservedArea, colorBarArea,\n                    RectangleEdge.BOTTOM, null);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            cursor = colorBarArea.getMinX();\n            state = this.axis.draw(g2, cursor, reservedArea, colorBarArea,\n                    RectangleEdge.LEFT, null);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            cursor = colorBarArea.getMaxX();\n            state = this.axis.draw(g2, cursor, reservedArea, colorBarArea,\n                    RectangleEdge.RIGHT, null);\n        }\n        assert state != null;         return state.getCursor();\n\n    }
1398	public static IntsRef toUTF32(CharSequence s, IntsRefBuilder scratch) {\n    int charIdx = 0;\n    int intIdx = 0;\n    final int charLimit = s.length();\n    while(charIdx < charLimit) {\n      scratch.grow(intIdx+1);\n      final int utf32 = Character.codePointAt(s, charIdx);\n      scratch.setIntAt(intIdx, utf32);\n      charIdx += Character.charCount(utf32);\n      intIdx++;\n    }\n    scratch.setLength(intIdx);\n    return scratch.get();\n  }
1399	public void dumpPictures(byte[] data, int padding) throws IOException {\n        int pos = 0;\n        while (pos < data.length) {\n            byte[] header = new byte[PICT_HEADER_SIZE];\n\n            System.arraycopy(data, pos, header, 0, header.length);\n            int size = LittleEndian.getInt(header, 4) - 17;\n            byte[] pictdata = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n            System.arraycopy(data, pos + PICT_HEADER_SIZE, pictdata, 0, pictdata.length);\n            pos += PICT_HEADER_SIZE + size;\n\n            padding++;\n            write(out, "<picture size=\""+size+"\" type=\""+getPictureType(header)+"\">" + CR, padding);\n            padding++;\n            write(out, "<header>" + CR, padding);\n            dump(out, header, 0, header.length, padding, true);\n            write(out, "</header>" + CR, padding);\n            write(out, "<imgdata>" + CR, padding);\n            dump(out, pictdata, 0, Math.min(pictdata.length, 100), padding, true);\n            write(out, "</imgdata>" + CR, padding);\n            padding--;\n            write(out, "</picture>" + CR, padding);\n            padding--;\n\n        }\n    }
1400	public static AreaReference[] generateContiguous(SpreadsheetVersion version, String reference) {\n        if (null == version) {\n            version = DEFAULT_SPREADSHEET_VERSION;         }\n        List<AreaReference> refs = new ArrayList<>();\n        StringTokenizer st = new StringTokenizer(reference, ",");\n        while(st.hasMoreTokens()) {\n            refs.add(\n                    new AreaReference(st.nextToken(), version)\n            );\n        }\n        return refs.toArray(new AreaReference[refs.size()]);\n    }
1401	public void drawRangeMarker(Graphics2D g2,\n                                ContourPlot plot,\n                                ValueAxis rangeAxis,\n                                Marker marker,\n                                Rectangle2D dataArea) {\n\n        if (marker instanceof ValueMarker) {\n            ValueMarker vm = (ValueMarker) marker;\n            double value = vm.getValue();\n            Range range = rangeAxis.getRange();\n            if (!range.contains(value)) {\n                return;\n            }\n\n            double y = rangeAxis.valueToJava2D(value, dataArea,\n                    RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), y,\n                    dataArea.getMaxX(), y);\n            Paint paint = marker.getOutlinePaint();\n            Stroke stroke = marker.getOutlineStroke();\n            g2.setPaint(paint != null ? paint : Plot.DEFAULT_OUTLINE_PAINT);\n            g2.setStroke(stroke != null ? stroke : Plot.DEFAULT_OUTLINE_STROKE);\n            g2.draw(line);\n        }\n\n    }
1402	public void setRangeValues(InetAddress min, InetAddress max) {\n    final byte[] bytes;\n    if (fieldsData == null) {\n      bytes = new byte[BYTES*2];\n      fieldsData = new BytesRef(bytes);\n    } else {\n      bytes = ((BytesRef)fieldsData).bytes;\n    }\n    encode(min, max, bytes);\n  }
1403	public XSSFFontFormatting createFontFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTFont font;\n        if(!dxf.isSetFont()) {\n            font = dxf.addNewFont();\n        } else {\n            font = dxf.getFont();\n        }\n\n        return new XSSFFontFormatting(font, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
1404	private void step5() {\n    if (RV == null) return  ;\n\n    if (suffix(RV,"e")) {\n      if (suffixPreceded(RV,"e","gu")) {\n        CT = removeSuffix(CT,"e") ;\n        CT = removeSuffix(CT,"u") ;\n        return ;\n      }\n\n      if (suffixPreceded(RV,"e","ci")) {\n        CT = removeSuffix(CT,"e") ;\n        CT = removeSuffix(CT,"i") ;\n        return ;\n      }\n\n      CT = removeSuffix(CT,"e") ; return ;\n    }\n  }
1405	public void releaseCopyState(CopyState copyState) throws IOException {\n        assert copyState.infos != null;\n    writer.decRefDeleter(copyState.infos);\n    int count = copyingCount.decrementAndGet();\n    assert count >= 0;\n  }
1406	public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount, boolean iteratorFirst) {\n                if (password == null) {\n            password = Decryptor.DEFAULT_PASSWORD;\n        }\n        \n        MessageDigest hashAlg = getMessageDigest(hashAlgorithm);\n        \n        hashAlg.update(salt);\n        byte[] hash = hashAlg.digest(StringUtil.getToUnicodeLE(password));\n        byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];\n\n        byte[] first = (iteratorFirst ? iterator : hash);\n        byte[] second = (iteratorFirst ? hash : iterator);\n        \n        try {\n            for (int i = 0; i < spinCount; i++) {\n                LittleEndian.putInt(iterator, 0, i);\n                hashAlg.reset();\n                hashAlg.update(first);\n                hashAlg.update(second);\n                hashAlg.digest(hash, 0, hash.length);             }\n        } catch (DigestException e) {\n            throw new EncryptedDocumentException("error in password hashing");\n        }\n        \n        return hash;\n    }
1407	public CharSequence[] decompose(CharSequence cmd) {\n    int parts = 0;\n    \n    for (int i = 0; 0 <= i && i < cmd.length();) {\n      int next = dashEven(cmd, i);\n      if (i == next) {\n        parts++;\n        i = next + 2;\n      } else {\n        parts++;\n        i = next;\n      }\n    }\n    \n    CharSequence part[] = new CharSequence[parts];\n    int x = 0;\n    \n    for (int i = 0; 0 <= i && i < cmd.length();) {\n      int next = dashEven(cmd, i);\n      if (i == next) {\n        part[x++] = cmd.subSequence(i, i + 2);\n        i = next + 2;\n      } else {\n        part[x++] = (next < 0) ? cmd.subSequence(i, cmd.length()) : cmd.subSequence(i, next);\n        i = next;\n      }\n    }\n    return part;\n  }
1408	public synchronized void setRequireDimCount(String dimName, boolean v) {\n    DimConfig ft = fieldTypes.get(dimName);\n    if (ft == null) {\n      ft = new DimConfig();\n      fieldTypes.put(dimName, ft);\n    }\n    ft.requireDimCount = v;\n  }
1409	public GeoPoint[] findArcDistancePoints(final PlanetModel planetModel, final double arcDistanceValue, final GeoPoint startPoint, final Membership... bounds) {\n    if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n      throw new IllegalStateException("Can't find arc distance using plane that doesn't go through origin");\n    }\n    if (!evaluateIsZero(startPoint)) {\n      throw new IllegalArgumentException("Start point is not on plane");\n    }\n    \n            \n                        \n        final double azimuthMagnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    final double cosPlaneAltitude = this.z;\n    final double sinPlaneAltitude = azimuthMagnitude;\n    final double cosPlaneAzimuth = this.x / azimuthMagnitude;\n    final double sinPlaneAzimuth = this.y / azimuthMagnitude;\n    \n    assert Math.abs(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude - 1.0) < MINIMUM_RESOLUTION : "Improper sin/cos of altitude: "+(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude);\n    assert Math.abs(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth - 1.0) < MINIMUM_RESOLUTION : "Improper sin/cos of azimuth: "+(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth);\n\n                            \n        final double x0 = startPoint.x;\n    final double y0 = startPoint.y;\n    final double z0 = startPoint.z;\n    \n    final double x1 = x0 * cosPlaneAzimuth + y0 * sinPlaneAzimuth;\n    final double y1 = -x0 * sinPlaneAzimuth + y0 * cosPlaneAzimuth;\n    final double z1 = z0;\n    \n        final double x2 = x1 * cosPlaneAltitude - z1 * sinPlaneAltitude;\n    final double y2 = y1;\n    final double z2 = +x1 * sinPlaneAltitude + z1 * cosPlaneAltitude;\n    \n    assert Math.abs(z2) < MINIMUM_RESOLUTION : "Rotation should have put startpoint on x-y plane, instead has value "+z2;\n    \n            final double startAngle = Math.atan2(y2, x2);\n    \n        final double point1Angle = startAngle + arcDistanceValue;\n    final double point2Angle = startAngle - arcDistanceValue;\n        final double point1x2 = Math.cos(point1Angle);\n    final double point1y2 = Math.sin(point1Angle);\n    final double point1z2 = 0.0;\n    \n    final double point2x2 = Math.cos(point2Angle);\n    final double point2y2 = Math.sin(point2Angle);\n    final double point2z2 = 0.0;\n    \n            final double point1x1 = point1x2 * cosPlaneAltitude + point1z2 * sinPlaneAltitude;\n    final double point1y1 = point1y2;\n    final double point1z1 = -point1x2 * sinPlaneAltitude + point1z2 * cosPlaneAltitude;\n    \n    final double point2x1 = point2x2 * cosPlaneAltitude + point2z2 * sinPlaneAltitude;\n    final double point2y1 = point2y2;\n    final double point2z1 = -point2x2 * sinPlaneAltitude + point2z2 * cosPlaneAltitude;\n\n        final double point1x0 = point1x1 * cosPlaneAzimuth - point1y1 * sinPlaneAzimuth;\n    final double point1y0 = point1x1 * sinPlaneAzimuth + point1y1 * cosPlaneAzimuth;\n    final double point1z0 = point1z1;\n\n    final double point2x0 = point2x1 * cosPlaneAzimuth - point2y1 * sinPlaneAzimuth;\n    final double point2y0 = point2x1 * sinPlaneAzimuth + point2y1 * cosPlaneAzimuth;\n    final double point2z0 = point2z1;\n\n    final GeoPoint point1 = planetModel.createSurfacePoint(point1x0, point1y0, point1z0);\n    final GeoPoint point2 = planetModel.createSurfacePoint(point2x0, point2y0, point2z0);\n    \n        boolean isPoint1Inside = meetsAllBounds(point1, bounds);\n    boolean isPoint2Inside = meetsAllBounds(point2, bounds);\n    \n    if (isPoint1Inside) {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point1, point2};\n      } else {\n        return new GeoPoint[]{point1};\n      }\n    } else {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point2};\n      } else {\n        return new GeoPoint[0];\n      }\n    }\n  }
1410	public static TimeSeriesCollection createMovingAverage(\n            TimeSeriesCollection source, String suffix, int periodCount,\n            int skip) {\n\n        ParamChecks.nullNotPermitted(source, "source");\n        if (periodCount < 1) {\n            throw new IllegalArgumentException("periodCount must be greater "\n                    + "than or equal to 1.");\n        }\n\n        TimeSeriesCollection result = new TimeSeriesCollection();\n        for (int i = 0; i < source.getSeriesCount(); i++) {\n            TimeSeries sourceSeries = source.getSeries(i);\n            TimeSeries maSeries = createMovingAverage(sourceSeries,\n                    sourceSeries.getKey() + suffix, periodCount, skip);\n            result.addSeries(maSeries);\n        }\n        return result;\n\n    }
1411	private void setExternalDependencyXmlProperties() {\n    for (String module : internalCompileScopeDependencies.keySet()) {       StringBuilder compileScopeBuilder = new StringBuilder();\n      StringBuilder testScopeBuilder = new StringBuilder();\n      SortedSet<ExternalDependency> extDeps = allExternalDependencies.get(module);\n      if (null != extDeps) {\n        for (ExternalDependency dep : extDeps) {\n          StringBuilder builder = dep.isTestDependency ? testScopeBuilder : compileScopeBuilder;\n          appendDependencyXml(builder, dep.groupId, dep.artifactId, "    ", null, \n                              dep.isTestDependency, dep.isOptional, dep.classifier, null);\n                                        if ( ! dep.isTestDependency && modulesWithSeparateCompileAndTestPOMs.contains(module)) {\n            appendDependencyXml(testScopeBuilder, dep.groupId, dep.artifactId, "    ", null,\n                                true, dep.isOptional, dep.classifier, null);\n          }\n        }\n      }\n      if (compileScopeBuilder.length() > 0) {\n        compileScopeBuilder.setLength(compileScopeBuilder.length() - 1);       }\n      if (testScopeBuilder.length() > 0) {\n        testScopeBuilder.setLength(testScopeBuilder.length() - 1);       }\n      allProperties.setProperty(module + ".external.dependencies", compileScopeBuilder.toString());\n      allProperties.setProperty(module + ".external.test.dependencies", testScopeBuilder.toString());\n    }\n  }
1412	protected float[] calculateAnchorPoint(ValueTick tick, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        float[] result = new float[2];\n        if (edge == RectangleEdge.TOP) {\n            result[0] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n            result[1] = (float) (cursor - insets.getBottom() - 2.0);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result[0] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n            result[1] = (float) (cursor + insets.getTop() + 2.0);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            result[0] = (float) (cursor - insets.getLeft() - 2.0);\n            result[1] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result[0] = (float) (cursor + insets.getRight() + 2.0);\n            result[1] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n        }\n        return result;\n    }
1413	private static int findSeparator(String s) {\n\n        int result = s.indexOf('-');\n        if (result == -1) {\n            result = s.indexOf(',');\n        }\n        if (result == -1) {\n            result = s.indexOf(' ');\n        }\n        if (result == -1) {\n            result = s.indexOf('.');\n        }\n        return result;\n    }
1414	private boolean collectConflicts(IvyNodeElement root, IvyNodeElement parent, String moduleName) {\n    boolean conflicts = false;\n    for (IvyNodeElement child : parent.getDependencies()) {\n      String coordinate = "/" + child.getOrganization() + "/" + child.getName();\n      Dependency dependency = directDependencies.get(coordinate);\n      if (null != dependency) {         String indirectVersion = child.getRevision();\n        if (isConflict(coordinate, dependency.directVersion, indirectVersion)) {\n          conflicts = true;\n          Set<String> moduleNames = dependency.conflictLocations.get(root);\n          if (null == moduleNames) {\n            moduleNames = new HashSet<>();\n            dependency.conflictLocations.put(root, moduleNames);\n          }\n          moduleNames.add(moduleName);\n        }\n        conflicts |= collectConflicts(root, child, moduleName);\n      }\n    }\n    return conflicts;\n  }
1415	protected void drawItemPass0(Graphics2D x_graphics,\n                                 Rectangle2D x_dataArea,\n                                 PlotRenderingInfo x_info,\n                                 XYPlot x_plot,\n                                 ValueAxis x_domainAxis,\n                                 ValueAxis x_rangeAxis,\n                                 XYDataset x_dataset,\n                                 int x_series,\n                                 int x_item,\n                                 CrosshairState x_crosshairState) {\n\n        if (!((0 == x_series) && (0 == x_item))) {\n            return;\n        }\n\n        boolean b_impliedZeroSubtrahend = (1 == x_dataset.getSeriesCount());\n\n                if (isEitherSeriesDegenerate(x_dataset, b_impliedZeroSubtrahend)) {\n            return;\n        }\n\n                if (!b_impliedZeroSubtrahend && areSeriesDisjoint(x_dataset)) {\n            return;\n        }\n\n                LinkedList l_minuendXs    = new LinkedList();\n        LinkedList l_minuendYs    = new LinkedList();\n        LinkedList l_subtrahendXs = new LinkedList();\n        LinkedList l_subtrahendYs = new LinkedList();\n        LinkedList l_polygonXs    = new LinkedList();\n        LinkedList l_polygonYs    = new LinkedList();\n\n                int l_minuendItem      = 0;\n        int l_minuendItemCount = x_dataset.getItemCount(0);\n        Double l_minuendCurX   = null;\n        Double l_minuendNextX  = null;\n        Double l_minuendCurY   = null;\n        Double l_minuendNextY  = null;\n        double l_minuendMaxY   = Double.NEGATIVE_INFINITY;\n        double l_minuendMinY   = Double.POSITIVE_INFINITY;\n\n        int l_subtrahendItem      = 0;\n        int l_subtrahendItemCount = 0;         Double l_subtrahendCurX   = null;\n        Double l_subtrahendNextX  = null;\n        Double l_subtrahendCurY   = null;\n        Double l_subtrahendNextY  = null;\n        double l_subtrahendMaxY   = Double.NEGATIVE_INFINITY;\n        double l_subtrahendMinY   = Double.POSITIVE_INFINITY;\n\n                if (b_impliedZeroSubtrahend) {\n            l_subtrahendItem      = 0;\n            l_subtrahendItemCount = 2;\n            l_subtrahendCurX      = new Double(x_dataset.getXValue(0, 0));\n            l_subtrahendNextX     = new Double(x_dataset.getXValue(0,\n                    (l_minuendItemCount - 1)));\n            l_subtrahendCurY      = new Double(0.0);\n            l_subtrahendNextY     = new Double(0.0);\n            l_subtrahendMaxY      = 0.0;\n            l_subtrahendMinY      = 0.0;\n\n            l_subtrahendXs.add(l_subtrahendCurX);\n            l_subtrahendYs.add(l_subtrahendCurY);\n        }\n        else {\n            l_subtrahendItemCount = x_dataset.getItemCount(1);\n        }\n\n        boolean b_minuendDone           = false;\n        boolean b_minuendAdvanced       = true;\n        boolean b_minuendAtIntersect    = false;\n        boolean b_minuendFastForward    = false;\n        boolean b_subtrahendDone        = false;\n        boolean b_subtrahendAdvanced    = true;\n        boolean b_subtrahendAtIntersect = false;\n        boolean b_subtrahendFastForward = false;\n        boolean b_colinear              = false;\n\n        boolean b_positive;\n\n                double l_x1 = 0.0, l_y1 = 0.0;         double l_x2 = 0.0, l_y2 = 0.0;         double l_x3 = 0.0, l_y3 = 0.0;         double l_x4 = 0.0, l_y4 = 0.0; \n                boolean b_fastForwardDone = false;\n        while (!b_fastForwardDone) {\n                        l_x1 = x_dataset.getXValue(0, l_minuendItem);\n            l_y1 = x_dataset.getYValue(0, l_minuendItem);\n            l_x2 = x_dataset.getXValue(0, l_minuendItem + 1);\n            l_y2 = x_dataset.getYValue(0, l_minuendItem + 1);\n\n            l_minuendCurX  = new Double(l_x1);\n            l_minuendCurY  = new Double(l_y1);\n            l_minuendNextX = new Double(l_x2);\n            l_minuendNextY = new Double(l_y2);\n\n            if (b_impliedZeroSubtrahend) {\n                l_x3 = l_subtrahendCurX.doubleValue();\n                l_y3 = l_subtrahendCurY.doubleValue();\n                l_x4 = l_subtrahendNextX.doubleValue();\n                l_y4 = l_subtrahendNextY.doubleValue();\n            }\n            else {\n                l_x3 = x_dataset.getXValue(1, l_subtrahendItem);\n                l_y3 = x_dataset.getYValue(1, l_subtrahendItem);\n                l_x4 = x_dataset.getXValue(1, l_subtrahendItem + 1);\n                l_y4 = x_dataset.getYValue(1, l_subtrahendItem + 1);\n\n                l_subtrahendCurX  = new Double(l_x3);\n                l_subtrahendCurY  = new Double(l_y3);\n                l_subtrahendNextX = new Double(l_x4);\n                l_subtrahendNextY = new Double(l_y4);\n            }\n\n            if (l_x2 <= l_x3) {\n                                l_minuendItem++;\n                b_minuendFastForward = true;\n                continue;\n            }\n\n            if (l_x4 <= l_x1) {\n                                l_subtrahendItem++;\n                b_subtrahendFastForward = true;\n                continue;\n            }\n\n                        if ((l_x3 < l_x1) && (l_x1 < l_x4)) {\n                                double l_slope   = (l_y4 - l_y3) / (l_x4 - l_x3);\n                l_subtrahendCurX = l_minuendCurX;\n                l_subtrahendCurY = new Double((l_slope * l_x1)\n                        + (l_y3 - (l_slope * l_x3)));\n\n                l_subtrahendXs.add(l_subtrahendCurX);\n                l_subtrahendYs.add(l_subtrahendCurY);\n            }\n\n            if ((l_x1 < l_x3) && (l_x3 < l_x2)) {\n                                double l_slope = (l_y2 - l_y1) / (l_x2 - l_x1);\n                l_minuendCurX  = l_subtrahendCurX;\n                l_minuendCurY  = new Double((l_slope * l_x3)\n                        + (l_y1 - (l_slope * l_x1)));\n\n                l_minuendXs.add(l_minuendCurX);\n                l_minuendYs.add(l_minuendCurY);\n            }\n\n            l_minuendMaxY    = l_minuendCurY.doubleValue();\n            l_minuendMinY    = l_minuendCurY.doubleValue();\n            l_subtrahendMaxY = l_subtrahendCurY.doubleValue();\n            l_subtrahendMinY = l_subtrahendCurY.doubleValue();\n\n            b_fastForwardDone = true;\n        }\n\n                while (!b_minuendDone && !b_subtrahendDone) {\n            if (!b_minuendDone && !b_minuendFastForward && b_minuendAdvanced) {\n                l_x1 = x_dataset.getXValue(0, l_minuendItem);\n                l_y1 = x_dataset.getYValue(0, l_minuendItem);\n                l_minuendCurX = new Double(l_x1);\n                l_minuendCurY = new Double(l_y1);\n\n                if (!b_minuendAtIntersect) {\n                    l_minuendXs.add(l_minuendCurX);\n                    l_minuendYs.add(l_minuendCurY);\n                }\n\n                l_minuendMaxY = Math.max(l_minuendMaxY, l_y1);\n                l_minuendMinY = Math.min(l_minuendMinY, l_y1);\n\n                l_x2 = x_dataset.getXValue(0, l_minuendItem + 1);\n                l_y2 = x_dataset.getYValue(0, l_minuendItem + 1);\n                l_minuendNextX = new Double(l_x2);\n                l_minuendNextY = new Double(l_y2);\n            }\n\n                        if (!b_impliedZeroSubtrahend && !b_subtrahendDone\n                    && !b_subtrahendFastForward && b_subtrahendAdvanced) {\n                l_x3 = x_dataset.getXValue(1, l_subtrahendItem);\n                l_y3 = x_dataset.getYValue(1, l_subtrahendItem);\n                l_subtrahendCurX = new Double(l_x3);\n                l_subtrahendCurY = new Double(l_y3);\n\n                if (!b_subtrahendAtIntersect) {\n                    l_subtrahendXs.add(l_subtrahendCurX);\n                    l_subtrahendYs.add(l_subtrahendCurY);\n                }\n\n                l_subtrahendMaxY = Math.max(l_subtrahendMaxY, l_y3);\n                l_subtrahendMinY = Math.min(l_subtrahendMinY, l_y3);\n\n                l_x4 = x_dataset.getXValue(1, l_subtrahendItem + 1);\n                l_y4 = x_dataset.getYValue(1, l_subtrahendItem + 1);\n                l_subtrahendNextX = new Double(l_x4);\n                l_subtrahendNextY = new Double(l_y4);\n            }\n\n                        b_minuendFastForward    = false;\n            b_subtrahendFastForward = false;\n\n            Double l_intersectX = null;\n            Double l_intersectY = null;\n            boolean b_intersect = false;\n\n            b_minuendAtIntersect    = false;\n            b_subtrahendAtIntersect = false;\n\n                        if ((l_x2 == l_x4) && (l_y2 == l_y4)) {\n                                if ((l_x1 == l_x3) && (l_y1 == l_y3)) {\n                    b_colinear = true;\n                }\n                else {\n                                                            l_intersectX = new Double(l_x2);\n                    l_intersectY = new Double(l_y2);\n\n                    b_intersect             = true;\n                    b_minuendAtIntersect    = true;\n                    b_subtrahendAtIntersect = true;\n                 }\n            }\n            else {\n                                double l_denominator = ((l_y4 - l_y3) * (l_x2 - l_x1))\n                        - ((l_x4 - l_x3) * (l_y2 - l_y1));\n\n                                double l_deltaY = l_y1 - l_y3;\n                double l_deltaX = l_x1 - l_x3;\n\n                                double l_numeratorA = ((l_x4 - l_x3) * l_deltaY)\n                        - ((l_y4 - l_y3) * l_deltaX);\n                double l_numeratorB = ((l_x2 - l_x1) * l_deltaY)\n                        - ((l_y2 - l_y1) * l_deltaX);\n\n                                if ((0 == l_numeratorA) && (0 == l_numeratorB)\n                        && (0 == l_denominator)) {\n                    b_colinear = true;\n                }\n                else {\n                                        if (b_colinear) {\n                                                l_minuendXs.clear();\n                        l_minuendYs.clear();\n                        l_subtrahendXs.clear();\n                        l_subtrahendYs.clear();\n                        l_polygonXs.clear();\n                        l_polygonYs.clear();\n\n                        b_colinear = false;\n\n                                                boolean b_useMinuend = ((l_x3 <= l_x1)\n                                && (l_x1 <= l_x4));\n                        l_polygonXs.add(b_useMinuend ? l_minuendCurX\n                                : l_subtrahendCurX);\n                        l_polygonYs.add(b_useMinuend ? l_minuendCurY\n                                : l_subtrahendCurY);\n                    }\n                }\n\n                                double l_slopeA = l_numeratorA / l_denominator;\n                double l_slopeB = l_numeratorB / l_denominator;\n\n                                boolean b_vertical = (l_x1 == l_x2) && (l_x3 == l_x4) && (l_x2 == l_x4);\n\n                                if (((0 < l_slopeA) && (l_slopeA <= 1) && (0 < l_slopeB)\n                        && (l_slopeB <= 1))|| b_vertical) {\n\n                                        double l_xi;\n                    double l_yi;\n                    if(b_vertical){\n                        b_colinear = false;\n                        l_xi = l_x2;\n                        l_yi = l_x4;\n                    }\n                    else{\n                        l_xi = l_x1 + (l_slopeA * (l_x2 - l_x1));\n                        l_yi = l_y1 + (l_slopeA * (l_y2 - l_y1));\n                    }\n\n                    l_intersectX            = new Double(l_xi);\n                    l_intersectY            = new Double(l_yi);\n                    b_intersect             = true;\n                    b_minuendAtIntersect    = ((l_xi == l_x2)\n                            && (l_yi == l_y2));\n                    b_subtrahendAtIntersect = ((l_xi == l_x4)\n                            && (l_yi == l_y4));\n\n                                        l_minuendCurX    = l_intersectX;\n                    l_minuendCurY    = l_intersectY;\n                    l_subtrahendCurX = l_intersectX;\n                    l_subtrahendCurY = l_intersectY;\n                }\n            }\n\n            if (b_intersect) {\n                                                l_polygonXs.addAll(l_minuendXs);\n                l_polygonYs.addAll(l_minuendYs);\n\n                                l_polygonXs.add(l_intersectX);\n                l_polygonYs.add(l_intersectY);\n\n                                Collections.reverse(l_subtrahendXs);\n                Collections.reverse(l_subtrahendYs);\n                l_polygonXs.addAll(l_subtrahendXs);\n                l_polygonYs.addAll(l_subtrahendYs);\n\n                                b_positive = (l_subtrahendMaxY <= l_minuendMaxY)\n                        && (l_subtrahendMinY <= l_minuendMinY);\n                createPolygon(x_graphics, x_dataArea, x_plot, x_domainAxis,\n                        x_rangeAxis, b_positive, l_polygonXs, l_polygonYs);\n\n                                l_minuendXs.clear();\n                l_minuendYs.clear();\n                l_subtrahendXs.clear();\n                l_subtrahendYs.clear();\n                l_polygonXs.clear();\n                l_polygonYs.clear();\n\n                                double l_y       = l_intersectY.doubleValue();\n                l_minuendMaxY    = l_y;\n                l_subtrahendMaxY = l_y;\n                l_minuendMinY    = l_y;\n                l_subtrahendMinY = l_y;\n\n                                l_polygonXs.add(l_intersectX);\n                l_polygonYs.add(l_intersectY);\n            }\n\n                        if (l_x2 <= l_x4) {\n                l_minuendItem++;\n                b_minuendAdvanced = true;\n            }\n            else {\n                b_minuendAdvanced = false;\n            }\n\n                        if (l_x4 <= l_x2) {\n                l_subtrahendItem++;\n                b_subtrahendAdvanced = true;\n            }\n            else {\n                b_subtrahendAdvanced = false;\n            }\n\n            b_minuendDone    = (l_minuendItem == (l_minuendItemCount - 1));\n            b_subtrahendDone = (l_subtrahendItem == (l_subtrahendItemCount\n                    - 1));\n        }\n\n                if (b_minuendDone && (l_x3 < l_x2) && (l_x2 < l_x4)) {\n                        double l_slope    = (l_y4 - l_y3) / (l_x4 - l_x3);\n            l_subtrahendNextX = l_minuendNextX;\n            l_subtrahendNextY = new Double((l_slope * l_x2)\n                    + (l_y3 - (l_slope * l_x3)));\n        }\n\n        if (b_subtrahendDone && (l_x1 < l_x4) && (l_x4 < l_x2)) {\n                        double l_slope = (l_y2 - l_y1) / (l_x2 - l_x1);\n            l_minuendNextX = l_subtrahendNextX;\n            l_minuendNextY = new Double((l_slope * l_x4)\n                    + (l_y1 - (l_slope * l_x1)));\n        }\n\n                        l_minuendMaxY    = Math.max(l_minuendMaxY,\n                l_minuendNextY.doubleValue());\n        l_subtrahendMaxY = Math.max(l_subtrahendMaxY,\n                l_subtrahendNextY.doubleValue());\n        l_minuendMinY    = Math.min(l_minuendMinY,\n                l_minuendNextY.doubleValue());\n        l_subtrahendMinY = Math.min(l_subtrahendMinY,\n                l_subtrahendNextY.doubleValue());\n\n                l_minuendXs.add(l_minuendNextX);\n        l_minuendYs.add(l_minuendNextY);\n        l_subtrahendXs.add(l_subtrahendNextX);\n        l_subtrahendYs.add(l_subtrahendNextY);\n\n                        l_polygonXs.addAll(l_minuendXs);\n        l_polygonYs.addAll(l_minuendYs);\n\n                Collections.reverse(l_subtrahendXs);\n        Collections.reverse(l_subtrahendYs);\n        l_polygonXs.addAll(l_subtrahendXs);\n        l_polygonYs.addAll(l_subtrahendYs);\n\n                b_positive = (l_subtrahendMaxY <= l_minuendMaxY)\n                && (l_subtrahendMinY <= l_minuendMinY);\n        createPolygon(x_graphics, x_dataArea, x_plot, x_domainAxis,\n                x_rangeAxis, b_positive, l_polygonXs, l_polygonYs);\n    }
1416	public PackageRelationship getRelationship(int index) {\n        if (index < 0 || index > relationshipsByID.values().size())\n            throw new IllegalArgumentException("index");\n\n        int i = 0;\n        for (PackageRelationship rel : relationshipsByID.values()) {\n            if (index == i++)\n                return rel;\n        }\n\n        return null;\n    }
1417	protected double[] calculateBarL0L1(double value) {\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n        double barLow = Math.min(this.base, value);\n        double barHigh = Math.max(this.base, value);\n        if (barHigh < lclip) {              return null;\n        }\n        if (barLow > uclip) {               return null;\n        }\n        barLow = Math.max(barLow, lclip);\n        barHigh = Math.min(barHigh, uclip);\n        return new double[] {barLow, barHigh};\n    }
1418	public boolean flushAndRefresh() throws IOException {\n    message("top: now flushAndRefresh");\n    Set<String> completedMergeFiles;\n    synchronized(finishedMergedFiles) {\n      completedMergeFiles = Collections.unmodifiableSet(new HashSet<>(finishedMergedFiles));\n    }\n    mgr.maybeRefreshBlocking();\n    boolean result = setCurrentInfos(completedMergeFiles);\n    if (result) {\n      message("top: opened NRT reader version=" + curInfos.getVersion());\n      finishedMergedFiles.removeAll(completedMergeFiles);\n      message("flushAndRefresh: version=" + curInfos.getVersion() + " completedMergeFiles=" + completedMergeFiles + " finishedMergedFiles=" + finishedMergedFiles);\n    } else {\n      message("top: no changes in flushAndRefresh; still version=" + curInfos.getVersion());\n    }\n    return result;\n  }
1419	public static void checkNoMatchExplanations(Query q, String defaultFieldName,\n                                              IndexSearcher searcher, int[] results)\n    throws IOException {\n\n    String d = q.toString(defaultFieldName);\n    Set<Integer> ignore = new TreeSet<>();\n    for (int i = 0; i < results.length; i++) {\n      ignore.add(Integer.valueOf(results[i]));\n    }\n    \n    int maxDoc = searcher.getIndexReader().maxDoc();\n    for (int doc = 0; doc < maxDoc; doc++) {\n      if (ignore.contains(Integer.valueOf(doc))) continue;\n\n      Explanation exp = searcher.explain(q, doc);\n      Assert.assertNotNull("Explanation of [["+d+"]] for #"+doc+" is null",\n                             exp);\n      Assert.assertFalse("Explanation of [["+d+"]] for #"+doc+\n                         " doesn't indicate non-match: " + exp.toString(),\n                         exp.isMatch());\n    }\n    \n  }
1420	private void paintDashedBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             ((northBorderType == BorderStyle.DASHED) ||\n              (northBorderType == BorderStyle.HAIR))\n         ) {\n        int thickness = getThickness(northBorderType);\n\n        int dashlength = 1;\n\n        if (northBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+5) {\n             g.drawLine(xc,y+k,xc+dashlength,y+k);\n           }\n        }\n      }\n\n      if (eastBorder &&\n              ((eastBorderType == BorderStyle.DASHED) ||\n               (eastBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; \n\n        int dashlength = 1;\n\n        if (eastBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+5) {\n                g.drawLine(width-k,yc,width-k,yc+dashlength);\n           }\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.DASHED) ||\n               (southBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(southBorderType);\n        thickness++;\n\n        int dashlength = 1;\n\n        if (southBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+5) {\n             g.drawLine(xc,height-k,xc+dashlength,height-k);\n           }\n        }\n      }\n\n      if (westBorder &&\n            ((westBorderType == BorderStyle.DASHED) ||\n             (westBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n        int dashlength = 1;\n\n        if (westBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+5) {\n                g.drawLine(x+k,yc,x+k,yc+dashlength);\n           }\n        }\n      }\n   }
1421	public void attemptTickLabelFontSelection() {\n\n        FontChooserPanel panel = new FontChooserPanel(this.tickLabelFont);\n        int result = JOptionPane.showConfirmDialog(this, panel,\n            localizationResources.getString("Font_Selection"),\n            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);\n\n        if (result == JOptionPane.OK_OPTION) {\n            this.tickLabelFont = panel.getSelectedFont();\n            this.tickLabelFontField.setText(\n                this.tickLabelFont.getFontName() + " "\n                + this.tickLabelFont.getSize()\n            );\n        }\n\n    }
1422	final ByteBuffer[] map(String resourceDescription, FileChannel fc, long offset, long length) throws IOException {\n    if ((length >>> chunkSizePower) >= Integer.MAX_VALUE)\n      throw new IllegalArgumentException("RandomAccessFile too big for chunk size: " + resourceDescription);\n    \n    final long chunkSize = 1L << chunkSizePower;\n    \n        final int nrBuffers = (int) (length >>> chunkSizePower) + 1;\n    \n    ByteBuffer buffers[] = new ByteBuffer[nrBuffers];\n    \n    long bufferStart = 0L;\n    for (int bufNr = 0; bufNr < nrBuffers; bufNr++) { \n      int bufSize = (int) ( (length > (bufferStart + chunkSize))\n          ? chunkSize\n              : (length - bufferStart)\n          );\n      MappedByteBuffer buffer;\n      try {\n        buffer = fc.map(MapMode.READ_ONLY, offset + bufferStart, bufSize);\n      } catch (IOException ioe) {\n        throw convertMapFailedIOException(ioe, resourceDescription, bufSize);\n      }\n      if (preload) {\n        buffer.load();\n      }\n      buffers[bufNr] = buffer;\n      bufferStart += bufSize;\n    }\n    \n    return buffers;\n  }
1423	private static FillPatternType getFillPattern(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        FillPatternType pattern;\n        if (value instanceof FillPatternType) {\n            pattern = (FillPatternType) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map uses Short values for "\n                        + name + ". Should use FillPatternType enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            pattern = FillPatternType.forInt(code);\n        }\n        else if (value == null) {\n            pattern = FillPatternType.NO_FILL;\n        }\n        else {\n            throw new RuntimeException("Unexpected fill pattern style class. Must be FillPatternType or Short (deprecated).");\n        }\n        return pattern;\n    }
1424	protected void createAndAddEntity(double cursor, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        if (plotState == null || plotState.getOwner() == null) {\n            return;          }\n        Rectangle2D hotspot = null;\n        if (edge.equals(RectangleEdge.TOP)) {\n            hotspot = new Rectangle2D.Double(dataArea.getX(),\n                    state.getCursor(), dataArea.getWidth(),\n                    cursor - state.getCursor());\n        }\n        else if (edge.equals(RectangleEdge.BOTTOM)) {\n            hotspot = new Rectangle2D.Double(dataArea.getX(), cursor,\n                    dataArea.getWidth(), state.getCursor() - cursor);\n        }\n        else if (edge.equals(RectangleEdge.LEFT)) {\n            hotspot = new Rectangle2D.Double(state.getCursor(),\n                    dataArea.getY(), cursor - state.getCursor(),\n                    dataArea.getHeight());\n        }\n        else if (edge.equals(RectangleEdge.RIGHT)) {\n            hotspot = new Rectangle2D.Double(cursor, dataArea.getY(),\n                    state.getCursor() - cursor, dataArea.getHeight());\n        }\n        EntityCollection e = plotState.getOwner().getEntityCollection();\n        if (e != null) {\n            e.add(new AxisEntity(hotspot, this));\n        }\n    }
1425	public CellFormatResult apply(JLabel label, Cell c) {\n        switch (ultimateType(c)) {\n            case BLANK:\n                return apply(label, "");\n            case BOOLEAN:\n                return apply(label, c.getBooleanCellValue());\n            case NUMERIC:\n                Double value = c.getNumericCellValue();\n                if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                    if (DateUtil.isValidExcelDate(value)) {\n                        return apply(label, c.getDateCellValue(), value);\n                    } else {\n                        return apply(label, INVALID_VALUE_FOR_FORMAT);\n                    }\n                } else {\n                    return apply(label, value);\n                }\n            case STRING:\n                return apply(label, c.getStringCellValue());\n            default:\n                return apply(label, "?");\n            }\n    }
1426	public void insert(String key, char val) {\n        int len = key.length() + 1;     if (freenode + len > eq.length) {\n      redimNodeArrays(eq.length + BLOCK_SIZE);\n    }\n    char strkey[] = new char[len--];\n    key.getChars(0, len, strkey, 0);\n    strkey[len] = 0;\n    root = insert(root, strkey, 0, val);\n  }
1427	public static String getZipItemNameFromOPCName(String opcItemName) {\n        if (opcItemName == null) {\n            throw new IllegalArgumentException("opcItemName cannot be null");\n        }\n\n        String retVal = opcItemName;\n        while (retVal.startsWith(FORWARD_SLASH)) {\n            retVal = retVal.substring(1);\n        }\n        return retVal;\n    }
1428	public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException("fraction should be >= 0 and <= 1");\n    }\n    \n        if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      query = addMinShouldMatchToBoolean((BooleanQuery) query, fraction);\n    }\n    return query;\n  }
1429	public BigInteger addNum(BigInteger abstractNumID) {\n        CTNum ctNum = this.ctNumbering.addNewNum();\n        ctNum.addNewAbstractNumId();\n        ctNum.getAbstractNumId().setVal(abstractNumID);\n        ctNum.setNumId(BigInteger.valueOf(nums.size() + 1));\n        XWPFNum num = new XWPFNum(ctNum, this);\n        nums.add(num);\n        return ctNum.getNumId();\n    }
1430	public static IntsRef toUTF16(CharSequence s, IntsRefBuilder scratch) {\n    final int charLimit = s.length();\n    scratch.setLength(charLimit);\n    scratch.grow(charLimit);\n    for (int idx = 0; idx < charLimit; idx++) {\n      scratch.setIntAt(idx, (int) s.charAt(idx));\n    }\n    return scratch.get();\n  }
1431	public void traverse(CellHandler handler) {\n        int firstRow = range.getFirstRow();\n        int lastRow = range.getLastRow();\n        int firstColumn = range.getFirstColumn();\n        int lastColumn = range.getLastColumn();\n        final int width = lastColumn - firstColumn + 1;\n        SimpleCellWalkContext ctx = new SimpleCellWalkContext();\n        Row currentRow = null;\n        Cell currentCell = null;\n\n        for (ctx.rowNumber = firstRow; ctx.rowNumber <= lastRow; ++ctx.rowNumber) {\n            currentRow = sheet.getRow(ctx.rowNumber);\n            if (currentRow == null) {\n                continue;\n            }\n            for (ctx.colNumber = firstColumn; ctx.colNumber <= lastColumn; ++ctx.colNumber) {\n                currentCell = currentRow.getCell(ctx.colNumber);\n\n                if (currentCell == null) {\n                    continue;\n                }\n                if (isEmpty(currentCell) && !traverseEmptyCells) {\n                    continue;\n                }\n\n                ctx.ordinalNumber =\n                        (ctx.rowNumber - firstRow) * width +\n                                (ctx.colNumber - firstColumn + 1);\n\n                handler.onCell(currentCell, ctx);\n            }\n        }\n    }
1432	private void syncWithDataSource() throws IOException {\n                        _mini_store.syncWithDataSource();\n        \n                POIFSStream propStream = new POIFSStream(this, _header.getPropertyStart());\n        _property_table.preWrite();\n        _property_table.write(propStream);\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream(\n                _header.getBigBlockSize().getBigBlockSize()\n        );\n        _header.writeData(baos);\n        getBlockAt(-1).put(baos.toByteArray());\n\n       \n              for(BATBlock bat : _bat_blocks) {\n          ByteBuffer block = getBlockAt(bat.getOurBlockIndex());\n          bat.writeData(block);\n       }\n              for(BATBlock bat : _xbat_blocks) {\n           ByteBuffer block = getBlockAt(bat.getOurBlockIndex());\n           bat.writeData(block);\n        }\n    }
1433	static Automaton reverse(Automaton a, Set<Integer> initialStates) {\n\n    if (Operations.isEmpty(a)) {\n      return new Automaton();\n    }\n\n    int numStates = a.getNumStates();\n\n        Automaton.Builder builder = new Automaton.Builder();\n\n        builder.createState();\n\n    for(int s=0;s<numStates;s++) {\n      builder.createState();\n    }\n\n        builder.setAccept(1, true);\n\n    Transition t = new Transition();\n    for (int s=0;s<numStates;s++) {\n      int numTransitions = a.getNumTransitions(s);\n      a.initTransition(s, t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        builder.addTransition(t.dest+1, s+1, t.min, t.max);\n      }\n    }\n\n    Automaton result = builder.finish();\n\n    int s = 0;\n    BitSet acceptStates = a.getAcceptStates();\n    while (s < numStates && (s = acceptStates.nextSetBit(s)) != -1) {\n      result.addEpsilon(0, s+1);\n      if (initialStates != null) {\n        initialStates.add(s+1);\n      }\n      s++;\n    }\n\n    result.finishState();\n\n    return result;\n  }
1434	public final T pop() {\n    if (size > 0) {\n      T result = heap[1];             heap[1] = heap[size];           heap[size] = null;              size--;\n      downHeap(1);                    return result;\n    } else {\n      return null;\n    }\n  }
1435	public void sortByKeys(SortOrder order) {\n        final int size = this.keys.size();\n        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];\n\n        for (int i = 0; i < size; i++) {\n            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i),\n                    (Number) this.values.get(i));\n        }\n\n        Comparator comparator = new KeyedValueComparator(\n                KeyedValueComparatorType.BY_KEY, order);\n        Arrays.sort(data, comparator);\n        clear();\n\n        for (int i = 0; i < data.length; i++) {\n            final DefaultKeyedValue value = data[i];\n            addValue(value.getKey(), value.getValue());\n        }\n    }
1436	public void clear(long startIndex, long endIndex) {\n    assert startIndex >= 0 && startIndex < numBits : "startIndex=" + startIndex + ", numBits=" + numBits;\n    assert endIndex >= 0 && endIndex <= numBits : "endIndex=" + endIndex + ", numBits=" + numBits;\n    if (endIndex <= startIndex) {\n      return;\n    }\n\n    int startWord = (int) (startIndex >> 6);\n    int endWord = (int) ((endIndex-1) >> 6);\n\n    long startmask = -1L << startIndex;\n    long endmask = -1L >>> -endIndex;  \n        startmask = ~startmask;\n    endmask = ~endmask;\n\n    if (startWord == endWord) {\n      bits[startWord] &= (startmask | endmask);\n      return;\n    }\n\n    bits[startWord] &= startmask;\n    Arrays.fill(bits, startWord+1, endWord, 0L);\n    bits[endWord] &= endmask;\n  }
1437	protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        Size2D s = arrangeFN(container, g2, constraint);\n        if (constraint.getHeightRange().contains(s.height)) {\n            return s;\n        }\n        else {\n            RectangleConstraint c = constraint.toFixedHeight(\n                    constraint.getHeightRange().constrain(s.getHeight()));\n            return arrangeFF(container, g2, c);\n        }\n    }
1438	private CTTwoCellAnchor createTwoCellAnchor(XSSFClientAnchor anchor) {\n        CTTwoCellAnchor ctAnchor = drawing.addNewTwoCellAnchor();\n        ctAnchor.setFrom(anchor.getFrom());\n        ctAnchor.setTo(anchor.getTo());\n        ctAnchor.addNewClientData();\n        anchor.setTo(ctAnchor.getTo());\n        anchor.setFrom(ctAnchor.getFrom());\n        STEditAs.Enum aditAs;\n        switch(anchor.getAnchorType()) {\n            case DONT_MOVE_AND_RESIZE: aditAs = STEditAs.ABSOLUTE; break;\n            case MOVE_AND_RESIZE: aditAs = STEditAs.TWO_CELL; break;\n            case MOVE_DONT_RESIZE: aditAs = STEditAs.ONE_CELL; break;\n            default: aditAs = STEditAs.ONE_CELL;\n        }\n        ctAnchor.setEditAs(aditAs);\n        return ctAnchor;\n    }
1439	public int addOlePackage(POIFSFileSystem poiData, String label, String fileName, String command)\n    throws IOException {\n    	DirectoryNode root = poiData.getRoot();\n    	Map<String,ClassID> olemap = getOleMap();\n    	for (Map.Entry<String,ClassID> entry : olemap.entrySet()) {\n    		if (root.hasEntry(entry.getKey())) {\n    			root.setStorageClsid(entry.getValue());\n    			break;\n    		}\n    	}\n\n    	ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    	poiData.writeFilesystem(bos);\n        return addOlePackage(bos.toByteArray(), label, fileName, command);\n    }
1440	public static Range iterateZBounds(XYZDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getZValue(series, item);\n                if (!Double.isNaN(value)) {\n                    minimum = Math.min(minimum, value);\n                    maximum = Math.max(maximum, value);\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }
1441	public static void buildAxDataSource(CTAxDataSource ctAxDataSource, ChartDataSource<?> dataSource) {\n        if (dataSource.isNumeric()) {\n            if (dataSource.isReference()) {\n                buildNumRef(ctAxDataSource.addNewNumRef(), dataSource);\n            } else {\n                buildNumLit(ctAxDataSource.addNewNumLit(), dataSource);\n            }\n        } else {\n            if (dataSource.isReference()) {\n                buildStrRef(ctAxDataSource.addNewStrRef(), dataSource);\n            } else {\n                buildStrLit(ctAxDataSource.addNewStrLit(), dataSource);\n            }\n        }\n    }
1442	protected void drawLeftLabel(Graphics2D g2, PiePlotState state,\n                                 PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMinX();\n        double targetX = anchorX - record.getGap();\n        double targetY = record.getAllocatedY();\n\n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta)\n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta)\n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta)\n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta)\n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            PieLabelLinkStyle style = getLabelLinkStyle();\n            if (style.equals(PieLabelLinkStyle.STANDARD)) {\n                g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n                g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n                g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n            }\n            else if (style.equals(PieLabelLinkStyle.QUAD_CURVE)) {\n                QuadCurve2D q = new QuadCurve2D.Float();\n                q.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY);\n                g2.draw(q);\n                g2.draw(new Line2D.Double(elbowX, elbowY, linkX, linkY));\n            }\n            else if (style.equals(PieLabelLinkStyle.CUBIC_CURVE)) {\n                CubicCurve2D c = new CubicCurve2D .Float();\n                c.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY,\n                        linkX, linkY);\n                g2.draw(c);\n            }\n        }\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);\n\n    }
1443	public static CellRangeAddress valueOf(String ref) {\n        int sep = ref.indexOf(":");\n        CellReference a;\n        CellReference b;\n        if (sep == -1) {\n            a = new CellReference(ref);\n            b = a;\n        } else {\n            a = new CellReference(ref.substring(0, sep));\n            b = new CellReference(ref.substring(sep + 1));\n        }\n        return new CellRangeAddress(a.getRow(), b.getRow(), a.getCol(), b.getCol());\n    }
1444	public int getFontIndex(FontRecord font) {\n        for(int i=0; i<=numfonts; i++) {\n            FontRecord thisFont =\n                ( FontRecord ) records.get((records.getFontpos() - (numfonts - 1)) + i);\n            if(thisFont == font) {\n                                return (i > 3) ? i+1 : i;\n            }\n        }\n        throw new IllegalArgumentException("Could not find that font!");\n    }
1445	protected Query analyzeMultiBoolean(String field, TokenStream stream, BooleanClause.Occur operator) throws IOException {\n    BooleanQuery.Builder q = newBooleanQuery();\n    List<Term> currentQuery = new ArrayList<>();\n    \n    TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n    PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n    \n    stream.reset();\n    while (stream.incrementToken()) {\n      if (posIncrAtt.getPositionIncrement() != 0) {\n        add(q, currentQuery, operator);\n        currentQuery.clear();\n      }\n      currentQuery.add(new Term(field, termAtt.getBytesRef()));\n    }\n    add(q, currentQuery, operator);\n    \n    return q.build();\n  }
1446	private void pushCurrentDoc() {\n    for(int i=0;i<numSubsOnDoc;i++) {\n      docIDQueue.add(subsOnDoc[i]);\n    }\n    numSubsOnDoc = 0;\n  }
1447	public static void assertEquals(File expected, File actual) {\n		assertNotNull(expected);\n		assertNotNull(actual);\n\n		assertTrue("File does not exist [" + expected.getAbsolutePath()\n				+ "]", expected.exists());\n		assertTrue("File does not exist [" + actual.getAbsolutePath()\n				+ "]", actual.exists());\n\n		assertTrue("Expected file not readable", expected.canRead());\n		assertTrue("Actual file not readable", actual.canRead());\n\n		try {\n			TreeMap<String, ByteArrayOutputStream> file1 = decompress(expected);\n			TreeMap<String, ByteArrayOutputStream> file2 = decompress(actual);\n			equals(file1, file2);\n		} catch (IOException e) {\n			throw new AssertionFailedError(e.toString());\n		}\n	}
1448	public static double calculateQ1(List values) {\n        ParamChecks.nullNotPermitted(values, "values");\n\n        double result = Double.NaN;\n        int count = values.size();\n        if (count > 0) {\n            if (count % 2 == 1) {\n                if (count > 1) {\n                    result = Statistics.calculateMedian(values, 0, count / 2);\n                }\n                else {\n                    result = Statistics.calculateMedian(values, 0, 0);\n                }\n            }\n            else {\n                result = Statistics.calculateMedian(values, 0, count / 2 - 1);\n            }\n\n        }\n        return result;\n    }
1449	private int getSizeOfInitialSheetRecords(int bofRecordIndex) {\n\n        int result = 0;\n                for (int j = bofRecordIndex + 1; j < _records.size(); j++) {\n            RecordBase tmpRec = _records.get(j);\n            if (tmpRec instanceof RowRecordsAggregate) {\n                break;\n            }\n            result += tmpRec.getRecordSize();\n        }\n        if (_isUncalced) {\n            result += UncalcedRecord.getStaticRecordSize();\n        }\n        return result;\n    }
1450	public static synchronized FontDetails getFontDetails(Font font) {\n						if (fontMetricsProps == null) {\n		    try {\n		        fontMetricsProps = loadMetrics();\n		    } catch (IOException e) {\n		        throw new RuntimeException("Could not load font metrics", e);\n		    }\n		}\n\n				String fontName = font.getName();\n\n								String fontStyle = "";\n		if (font.isPlain()) {\n			fontStyle += "plain";\n		}\n		if (font.isBold()) {\n			fontStyle += "bold";\n		}\n		if (font.isItalic()) {\n			fontStyle += "italic";\n		}\n\n						String fontHeight = FontDetails.buildFontHeightProperty(fontName);\n		String styleHeight = FontDetails.buildFontHeightProperty(fontName + "." + fontStyle);\n		\n		if (fontMetricsProps.get(fontHeight) == null\n			&& fontMetricsProps.get(styleHeight) != null) {\n						fontName += "." + fontStyle;\n		}\n\n				FontDetails fontDetails = fontDetailsMap.get(fontName);\n		if (fontDetails == null) {\n			fontDetails = FontDetails.create(fontName, fontMetricsProps);\n			fontDetailsMap.put(fontName, fontDetails);\n		}\n        return fontDetails;\n	}
1451	public void split(IndexReader in, Directory[] outputs, boolean seq) throws IOException {\n    if (outputs == null || outputs.length < 2) {\n      throw new IOException("Invalid number of outputs.");\n    }\n    if (in == null || in.numDocs() < 2) {\n      throw new IOException("Not enough documents for splitting");\n    }\n    int numParts = outputs.length;\n                FakeDeleteIndexReader input = new FakeDeleteIndexReader(in);\n    int maxDoc = input.maxDoc();\n    int partLen = maxDoc / numParts;\n    for (int i = 0; i < numParts; i++) {\n      input.undeleteAll();\n      if (seq) {         int lo = partLen * i;\n        int hi = lo + partLen;\n                for (int j = 0; j < lo; j++) {\n          input.deleteDocument(j);\n        }\n                        if (i < numParts - 1) {\n          for (int j = hi; j < maxDoc; j++) {\n            input.deleteDocument(j);\n          }\n        }\n      } else {\n                for (int j = 0; j < maxDoc; j++) {\n          if ((j + numParts - i) % numParts != 0) {\n            input.deleteDocument(j);\n          }\n        }\n      }\n      IndexWriter w = new IndexWriter(outputs[i], new IndexWriterConfig(null)\n          .setOpenMode(OpenMode.CREATE));\n      System.err.println("Writing part " + (i + 1) + " ...");\n            final List<? extends FakeDeleteLeafIndexReader> sr = input.getSequentialSubReaders();\n      w.addIndexes(sr.toArray(new CodecReader[sr.size()]));       w.close();\n    }\n    System.err.println("Done.");\n  }
1452	public synchronized IndexCommit snapshot() throws IOException {\n    if (!initCalled) {\n      throw new IllegalStateException("this instance is not being used by IndexWriter; be sure to use the instance returned from writer.getConfig().getIndexDeletionPolicy()");\n    }\n    if (lastCommit == null) {\n            throw new IllegalStateException("No index commit to snapshot");\n    }\n\n    incRef(lastCommit);\n\n    return lastCommit;\n  }
1453	protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }
1454	@Beta\n    private XSSFPivotTable createPivotTable() {\n        XSSFWorkbook wb = getWorkbook();\n        List<XSSFPivotTable> pivotTables = wb.getPivotTables();\n        int tableId = getWorkbook().getPivotTables().size()+1;\n                XSSFPivotTable pivotTable = (XSSFPivotTable) createRelationship(XSSFRelation.PIVOT_TABLE,\n                XSSFFactory.getInstance(), tableId);\n        pivotTable.setParentSheet(this);\n        pivotTables.add(pivotTable);\n        XSSFWorkbook workbook = getWorkbook();\n\n                XSSFPivotCacheDefinition pivotCacheDefinition = (XSSFPivotCacheDefinition) workbook.\n                createRelationship(XSSFRelation.PIVOT_CACHE_DEFINITION, XSSFFactory.getInstance(), tableId);\n        String rId = workbook.getRelationId(pivotCacheDefinition);\n                PackagePart pivotPackagePart = pivotTable.getPackagePart();\n        pivotPackagePart.addRelationship(pivotCacheDefinition.getPackagePart().getPartName(),\n                TargetMode.INTERNAL, XSSFRelation.PIVOT_CACHE_DEFINITION.getRelation());\n\n        pivotTable.setPivotCacheDefinition(pivotCacheDefinition);\n\n                pivotTable.setPivotCache(new XSSFPivotCache(workbook.addPivotCache(rId)));\n\n                XSSFPivotCacheRecords pivotCacheRecords = (XSSFPivotCacheRecords) pivotCacheDefinition.\n                createRelationship(XSSFRelation.PIVOT_CACHE_RECORDS, XSSFFactory.getInstance(), tableId);\n\n                pivotTable.getPivotCacheDefinition().getCTPivotCacheDefinition().setId(pivotCacheDefinition.getRelationId(pivotCacheRecords));\n\n        wb.setPivotTables(pivotTables);\n\n        return pivotTable;\n    }
1455	private int mergeMiddle(MergePolicy.OneMerge merge, MergePolicy mergePolicy) throws IOException {\n    merge.checkAborted();\n\n    Directory mergeDirectory = config.getMergeScheduler().wrapForMerge(merge, directory);\n    List<SegmentCommitInfo> sourceSegments = merge.segments;\n    \n    IOContext context = new IOContext(merge.getStoreMergeInfo());\n\n    final TrackingDirectoryWrapper dirWrapper = new TrackingDirectoryWrapper(mergeDirectory);\n\n    if (infoStream.isEnabled("IW")) {\n      infoStream.message("IW", "merging " + segString(merge.segments));\n    }\n\n    merge.readers = new ArrayList<>(sourceSegments.size());\n\n            boolean success = false;\n    try {\n      int segUpto = 0;\n      while(segUpto < sourceSegments.size()) {\n\n        final SegmentCommitInfo info = sourceSegments.get(segUpto);\n\n                        final ReadersAndUpdates rld = readerPool.get(info, true);\n        rld.setIsMerging();\n\n        SegmentReader reader = rld.getReaderForMerge(context);\n        int delCount = reader.numDeletedDocs();\n\n        if (infoStream.isEnabled("IW")) {\n          infoStream.message("IW", "seg=" + segString(info) + " reader=" + reader);\n        }\n\n        merge.readers.add(reader);\n        assert delCount <= info.info.maxDoc(): "delCount=" + delCount + " info.maxDoc=" + info.info.maxDoc() + " rld.pendingDeleteCount=" + rld.getPendingDeleteCount() + " info.getDelCount()=" + info.getDelCount();\n        segUpto++;\n      }\n\n            List<CodecReader> mergeReaders = new ArrayList<>();\n      for (SegmentReader reader : merge.readers) {\n        CodecReader wrappedReader = merge.wrapForMerge(reader);\n        validateMergeReader(wrappedReader);\n        mergeReaders.add(wrappedReader);\n      }\n      final SegmentMerger merger = new SegmentMerger(mergeReaders,\n                                                     merge.info.info, infoStream, dirWrapper,\n                                                     globalFieldNumberMap, \n                                                     context);\n\n      merge.checkAborted();\n\n      merge.mergeStartNS = System.nanoTime();\n\n            if (merger.shouldMerge()) {\n        merger.merge();\n      }\n\n      MergeState mergeState = merger.mergeState;\n      assert mergeState.segmentInfo == merge.info.info;\n      merge.info.info.setFiles(new HashSet<>(dirWrapper.getCreatedFiles()));\n\n      if (infoStream.isEnabled("IW")) {\n        if (merger.shouldMerge()) {\n          String pauseInfo = merge.getMergeProgress().getPauseTimes().entrySet()\n            .stream()\n            .filter((e) -> e.getValue() > 0)\n            .map((e) -> String.format(Locale.ROOT, "%.1f sec %s", \n                e.getValue() / 1000000000., \n                e.getKey().name().toLowerCase(Locale.ROOT)))\n            .collect(Collectors.joining(", "));\n          if (!pauseInfo.isEmpty()) {\n            pauseInfo = " (" + pauseInfo + ")";\n          }\n\n          long t1 = System.nanoTime();\n          double sec = (t1-merge.mergeStartNS)/1000000000.;\n          double segmentMB = (merge.info.sizeInBytes()/1024./1024.);\n          infoStream.message("IW", "merge codec=" + codec + " maxDoc=" + merge.info.info.maxDoc() + "; merged segment has " +\n                             (mergeState.mergeFieldInfos.hasVectors() ? "vectors" : "no vectors") + "; " +\n                             (mergeState.mergeFieldInfos.hasNorms() ? "norms" : "no norms") + "; " + \n                             (mergeState.mergeFieldInfos.hasDocValues() ? "docValues" : "no docValues") + "; " + \n                             (mergeState.mergeFieldInfos.hasProx() ? "prox" : "no prox") + "; " + \n                             (mergeState.mergeFieldInfos.hasProx() ? "freqs" : "no freqs") + "; " +\n                             (mergeState.mergeFieldInfos.hasPointValues() ? "points" : "no points") + "; " +\n                             String.format(Locale.ROOT,\n                                           "%.1f sec%s to merge segment [%.2f MB, %.2f MB/sec]",\n                                           sec,\n                                           pauseInfo,\n                                           segmentMB,\n                                           segmentMB / sec));\n        } else {\n          infoStream.message("IW", "skip merging fully deleted segments");\n        }\n      }\n\n      if (merger.shouldMerge() == false) {\n                assert merge.info.info.maxDoc() == 0;\n        commitMerge(merge, mergeState);\n        return 0;\n      }\n\n      assert merge.info.info.maxDoc() > 0;\n\n                        boolean useCompoundFile;\n      synchronized (this) {         useCompoundFile = mergePolicy.useCompoundFile(segmentInfos, merge.info, this);\n      }\n\n      if (useCompoundFile) {\n        success = false;\n\n        Collection<String> filesToRemove = merge.info.files();\n        TrackingDirectoryWrapper trackingCFSDir = new TrackingDirectoryWrapper(mergeDirectory);\n        try {\n          createCompoundFile(infoStream, trackingCFSDir, merge.info.info, context);\n          success = true;\n        } catch (Throwable t) {\n          synchronized(this) {\n            if (merge.isAborted()) {\n                                                        if (infoStream.isEnabled("IW")) {\n                infoStream.message("IW", "hit merge abort exception creating compound file during merge");\n              }\n              return 0;\n            } else {\n              handleMergeException(t, merge);\n            }\n          }\n        } finally {\n          if (success == false) {\n            if (infoStream.isEnabled("IW")) {\n              infoStream.message("IW", "hit exception creating compound file during merge");\n            }\n                        deleteNewFiles(merge.info.files());\n          }\n        }\n\n                                success = false;\n\n        synchronized(this) {\n\n                              deleteNewFiles(filesToRemove);\n\n          if (merge.isAborted()) {\n            if (infoStream.isEnabled("IW")) {\n              infoStream.message("IW", "abort merge after building CFS");\n            }\n                        deleteNewFiles(merge.info.files());\n            return 0;\n          }\n        }\n\n        merge.info.info.setUseCompoundFile(true);\n      } else {\n                                success = false;\n      }\n\n                              boolean success2 = false;\n      try {\n        codec.segmentInfoFormat().write(directory, merge.info.info, context);\n        success2 = true;\n      } finally {\n        if (!success2) {\n                    deleteNewFiles(merge.info.files());\n        }\n      }\n\n                  \n      if (infoStream.isEnabled("IW")) {\n        infoStream.message("IW", String.format(Locale.ROOT, "merged segment size=%.3f MB vs estimate=%.3f MB", merge.info.sizeInBytes()/1024./1024., merge.estimatedMergeBytes/1024/1024.));\n      }\n\n      final IndexReaderWarmer mergedSegmentWarmer = config.getMergedSegmentWarmer();\n      if (poolReaders && mergedSegmentWarmer != null) {\n        final ReadersAndUpdates rld = readerPool.get(merge.info, true);\n        final SegmentReader sr = rld.getReader(IOContext.READ);\n        try {\n          mergedSegmentWarmer.warm(sr);\n        } finally {\n          synchronized(this) {\n            rld.release(sr);\n            readerPool.release(rld);\n          }\n        }\n      }\n\n      if (!commitMerge(merge, mergeState)) {\n                        return 0;\n      }\n\n      success = true;\n\n    } finally {\n                  if (success == false) {\n        closeMergeReaders(merge, true);\n      }\n    }\n\n    return merge.info.info.maxDoc();\n  }
1456	public final String getBestFragments(\n    TokenStream tokenStream,\n    String text,\n    int maxNumFragments,\n    String separator)\n    throws IOException, InvalidTokenOffsetsException\n  {\n    String sections[] =  getBestFragments(tokenStream,text, maxNumFragments);\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < sections.length; i++)\n    {\n      if (i > 0)\n      {\n        result.append(separator);\n      }\n      result.append(sections[i]);\n    }\n    return result.toString();\n  }
1457	private void setDocAndFreq() {\n    assert head.size() > 0;\n\n            lead = head.pop();\n    lead.next = null;\n    freq = 1;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }
1458	private int findLastRow(int lastrow) {\n        if (lastrow < 1) {\n            return 0;\n        }\n        int rownum = lastrow - 1;\n        HSSFRow r = getRow(rownum);\n\n        while (r == null && rownum > 0) {\n            r = getRow(--rownum);\n        }\n        if (r == null) {\n            return 0;\n        }\n        return rownum;\n    }
1459	public static Second parseSecond(String s) {\n        Second result = null;\n        s = s.trim();\n        String daystr = s.substring(0, Math.min(10, s.length()));\n        Day day = Day.parseDay(daystr);\n        if (day != null) {\n            String hmsstr = s.substring(Math.min(daystr.length() + 1,\n                    s.length()), s.length());\n            hmsstr = hmsstr.trim();\n\n            int l = hmsstr.length();\n            String hourstr = hmsstr.substring(0, Math.min(2, l));\n            String minstr = hmsstr.substring(Math.min(3, l), Math.min(5, l));\n            String secstr = hmsstr.substring(Math.min(6, l), Math.min(8, l));\n            int hour = Integer.parseInt(hourstr);\n\n            if ((hour >= 0) && (hour <= 23)) {\n\n                int minute = Integer.parseInt(minstr);\n                if ((minute >= 0) && (minute <= 59)) {\n\n                    Minute m = new Minute(minute, new Hour(hour, day));\n                    int second = Integer.parseInt(secstr);\n                    if ((second >= 0) && (second <= 59)) {\n                        result = new Second(second, m);\n                    }\n                }\n            }\n        }\n        return result;\n    }
1460	default boolean hasDirectoryEntry() {\n        try (final InputStream is = FileMagic.prepareToCheckMagic(getInputStream())) {\n            FileMagic fm = FileMagic.valueOf(is);\n            return fm == FileMagic.OLE2;\n        } catch (IOException e) {\n            POILogger LOG = POILogFactory.getLogger(ObjectData.class);\n            LOG.log(POILogger.WARN, "Can't determine filemagic of ole stream", e);\n            return false;\n        }\n    }
1461	public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {\n    if (valSrcExpls.length == 1) {\n      return customExplain(doc, subQueryExpl, valSrcExpls[0]);\n    }\n    if (valSrcExpls.length == 0) {\n      return subQueryExpl;\n    }\n    float valSrcScore = 1;\n    for (Explanation valSrcExpl : valSrcExpls) {\n      valSrcScore *= valSrcExpl.getValue();\n    }\n    \n    List<Explanation> subs = new ArrayList<>();\n    subs.add(subQueryExpl);\n    for (Explanation valSrcExpl : valSrcExpls) {\n      subs.add(valSrcExpl);\n    }\n    return Explanation.match(valSrcScore * subQueryExpl.getValue(), "custom score: product of:", subs);\n  }
1462	private char normalizeIterationMark(char c) throws IOException {\n\n        if (bufferPosition < iterationMarkSpanEndPosition) {\n      return normalize(sourceCharacter(bufferPosition, iterationMarksSpanSize), c);\n    }\n\n        if (bufferPosition == iterationMarkSpanEndPosition) {\n                  iterationMarkSpanEndPosition++;\n      return c;\n    }\n\n        iterationMarksSpanSize = nextIterationMarkSpanSize();\n    iterationMarkSpanEndPosition = bufferPosition + iterationMarksSpanSize;\n    return normalize(sourceCharacter(bufferPosition, iterationMarksSpanSize), c);\n  }
1463	public void addObservations(double[] values) {\n        for (int i = 0; i < values.length; i++) {\n            addObservation(values[i], false);\n        }\n        notifyListeners(new DatasetChangeEvent(this, this));\n    }
1464	public int getRowCellBlockSize(int startRow, int endRow) {\n		int result = 0;\n		for(int rowIx=startRow; rowIx<=endRow && rowIx<records.length; rowIx++) {\n			result += getRowSerializedSize(records[rowIx]);\n		}\n		return result;\n	}
1465	protected static int getSoundReference(HSLFShape shape){\n        int soundRef = -1;\n                InteractiveInfoAtom info = shape.getClientDataRecord(RecordTypes.InteractiveInfo.typeID);\n        if (info != null && info.getAction() == InteractiveInfoAtom.ACTION_MEDIA) {\n            soundRef = info.getSoundRef();\n        }\n        return soundRef;\n    }
1466	private void appendDefaultType(Element root, Entry<String, String> entry) {\n        Element defaultType = root.getOwnerDocument().createElementNS(TYPES_NAMESPACE_URI, DEFAULT_TAG_NAME);\n        defaultType.setAttribute(EXTENSION_ATTRIBUTE_NAME, entry.getKey());\n        defaultType.setAttribute(CONTENT_TYPE_ATTRIBUTE_NAME, entry.getValue());\n        root.appendChild(defaultType);\n    }
1467	private double calculateBarThickness(Rectangle2D plotArea,\n            RectangleEdge edge) {\n        double result;\n        if (RectangleEdge.isLeftOrRight(edge)) {\n            result = plotArea.getWidth() * this.colorBarThicknessPercent;\n        }\n        else {\n            result = plotArea.getHeight() * this.colorBarThicknessPercent;\n        }\n        return result;\n    }
1468	public static void main(final String args[]) {\n        if (args.length == 0) {\n            System.err.println("Must specify at least one file to view");\n            System.exit(1);\n        }\n        boolean printNames = (args.length > 1);\n\n        for (String arg : args) {\n            viewFile(arg, printNames);\n        }\n    }
1469	public boolean validateProtectionPassword(String password) {\n        BigInteger sid = safeGetDocumentProtection().getCryptAlgorithmSid();\n        byte hash[] = safeGetDocumentProtection().getHash();\n        byte salt[] = safeGetDocumentProtection().getSalt();\n        BigInteger spinCount = safeGetDocumentProtection().getCryptSpinCount();\n\n        if (sid == null || hash == null || salt == null || spinCount == null) return false;\n\n        HashAlgorithm hashAlgo;\n        switch (sid.intValue()) {\n            case 1:\n                hashAlgo = HashAlgorithm.md2;\n                break;\n            case 2:\n                hashAlgo = HashAlgorithm.md4;\n                break;\n            case 3:\n                hashAlgo = HashAlgorithm.md5;\n                break;\n            case 4:\n                hashAlgo = HashAlgorithm.sha1;\n                break;\n            case 12:\n                hashAlgo = HashAlgorithm.sha256;\n                break;\n            case 13:\n                hashAlgo = HashAlgorithm.sha384;\n                break;\n            case 14:\n                hashAlgo = HashAlgorithm.sha512;\n                break;\n            default:\n                return false;\n        }\n\n        String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n                                byte hash2[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount.intValue(), false);\n\n        return Arrays.equals(hash, hash2);\n    }
1470	private void strip( StringBuilder buffer )\n    {\n      boolean doMore = true;\n      while ( doMore && buffer.length() > 3 ) {\n        if ( ( buffer.length() + substCount > 5 ) &&\n          buffer.substring( buffer.length() - 2, buffer.length() ).equals( "nd" ) )\n        {\n          buffer.delete( buffer.length() - 2, buffer.length() );\n        }\n        else if ( ( buffer.length() + substCount > 4 ) &&\n          buffer.substring( buffer.length() - 2, buffer.length() ).equals( "em" ) ) {\n            buffer.delete( buffer.length() - 2, buffer.length() );\n        }\n        else if ( ( buffer.length() + substCount > 4 ) &&\n          buffer.substring( buffer.length() - 2, buffer.length() ).equals( "er" ) ) {\n            buffer.delete( buffer.length() - 2, buffer.length() );\n        }\n        else if ( buffer.charAt( buffer.length() - 1 ) == 'e' ) {\n          buffer.deleteCharAt( buffer.length() - 1 );\n        }\n        else if ( buffer.charAt( buffer.length() - 1 ) == 's' ) {\n          buffer.deleteCharAt( buffer.length() - 1 );\n        }\n        else if ( buffer.charAt( buffer.length() - 1 ) == 'n' ) {\n          buffer.deleteCharAt( buffer.length() - 1 );\n        }\n                else if ( buffer.charAt( buffer.length() - 1 ) == 't' ) {\n          buffer.deleteCharAt( buffer.length() - 1 );\n        }\n        else {\n          doMore = false;\n        }\n      }\n    }
1471	public void clearCoreCacheKey(Object coreKey) {\n    lock.lock();\n    try {\n      final LeafCache leafCache = cache.remove(coreKey);\n      if (leafCache != null) {\n        ramBytesUsed -= HASHTABLE_RAM_BYTES_PER_ENTRY;\n        final int numEntries = leafCache.cache.size();\n        if (numEntries > 0) {\n          onDocIdSetEviction(coreKey, numEntries, leafCache.ramBytesUsed);\n        } else {\n          assert numEntries == 0;\n          assert leafCache.ramBytesUsed == 0;\n        }\n      }\n    } finally {\n      lock.unlock();\n    }\n  }
1472	public Weight createWeight(Query query, boolean needsScores, float boost) throws IOException {\n    final QueryCache queryCache = this.queryCache;\n    Weight weight = query.createWeight(this, needsScores, boost);\n    if (needsScores == false && queryCache != null) {\n      weight = queryCache.doCache(weight, queryCachingPolicy);\n    }\n    return weight;\n  }
1473	public static URI relativizeURI(URI sourceURI, URI targetURI, boolean msCompatible) {\n		StringBuilder retVal = new StringBuilder();\n		String[] segmentsSource = sourceURI.getPath().split("/", -1);\n		String[] segmentsTarget = targetURI.getPath().split("/", -1);\n\n				if (segmentsSource.length == 0) {\n			throw new IllegalArgumentException(\n					"Can't relativize an empty source URI !");\n		}\n\n				if (segmentsTarget.length == 0) {\n			throw new IllegalArgumentException(\n					"Can't relativize an empty target URI !");\n		}\n\n						if(sourceURI.toString().equals("/")) {\n            String path = targetURI.getPath();\n            if(msCompatible && path.length() > 0 && path.charAt(0) == '/') {\n                try {\n                    targetURI = new URI(path.substring(1));\n                } catch (Exception e) {\n                    _logger.log(POILogger.WARN, e);\n                    return null;\n                }\n            }\n			return targetURI;\n		}\n\n\n								int segmentsTheSame = 0;\n		for (int i = 0; i < segmentsSource.length && i < segmentsTarget.length; i++) {\n			if (segmentsSource[i].equals(segmentsTarget[i])) {\n								segmentsTheSame++;\n			} else {\n				break;\n			}\n		}\n\n				if ((segmentsTheSame == 0 || segmentsTheSame == 1) &&\n				segmentsSource[0].isEmpty() && segmentsTarget[0].isEmpty()) {\n			for (int i = 0; i < segmentsSource.length - 2; i++) {\n				retVal.append("../");\n			}\n			for (int i = 0; i < segmentsTarget.length; i++) {\n				if (segmentsTarget[i].isEmpty())\n					continue;\n				retVal.append(segmentsTarget[i]);\n				if (i != segmentsTarget.length - 1)\n					retVal.append("/");\n			}\n\n			try {\n				return new URI(retVal.toString());\n			} catch (Exception e) {\n				_logger.log(POILogger.WARN, e);\n				return null;\n			}\n		}\n\n				if (segmentsTheSame == segmentsSource.length\n				&& segmentsTheSame == segmentsTarget.length) {\n            if(sourceURI.equals(targetURI)){\n                                                                                retVal.append(segmentsSource[segmentsSource.length - 1]);\n            } else {\n                retVal.append("");\n            }\n\n		} else {\n			\n												if (segmentsTheSame == 1) {\n				retVal.append("/");\n			} else {\n				for (int j = segmentsTheSame; j < segmentsSource.length - 1; j++) {\n					retVal.append("../");\n				}\n			}\n\n						for (int j = segmentsTheSame; j < segmentsTarget.length; j++) {\n				if (retVal.length() > 0\n						&& retVal.charAt(retVal.length() - 1) != '/') {\n					retVal.append("/");\n				}\n				retVal.append(segmentsTarget[j]);\n			}\n		}\n\n                String fragment = targetURI.getRawFragment();\n        if (fragment != null) {\n            retVal.append("#").append(fragment);\n        }\n\n		try {\n			return new URI(retVal.toString());\n		} catch (Exception e) {\n			_logger.log(POILogger.WARN, e);\n			return null;\n		}\n	}
1474	private static int getColumnForString(AreaEval db,String name)\n            throws EvaluationException {\n        int resultColumn = -1;\n        final int width = db.getWidth();\n        for(int column = 0; column < width; ++column) {\n            ValueEval columnNameValueEval = resolveReference(db, 0, column);\n            if(columnNameValueEval instanceof BlankEval) {\n                continue;\n            }\n            if(columnNameValueEval instanceof ErrorEval) {\n                continue;\n            }\n            String columnName = OperandResolver.coerceValueToString(columnNameValueEval);\n            if(name.equals(columnName)) {\n                resultColumn = column;\n                break;\n            }\n        }\n        return resultColumn;\n    }
1475	public int normalize(char s[], int len) {\n\n    for (int i = 0; i < len; i++) {\n      switch (s[i]) {\n      case FARSI_YEH:\n      case YEH_BARREE:\n        s[i] = YEH;\n        break;\n      case KEHEH:\n        s[i] = KAF;\n        break;\n      case HEH_YEH:\n      case HEH_GOAL:\n        s[i] = HEH;\n        break;\n      case HAMZA_ABOVE:         len = delete(s, i, len);\n        i--;\n        break;\n      default:\n        break;\n      }\n    }\n\n    return len;\n  }
1476	private void drawHorizontalAxisTrace(Graphics2D g2, int x) {\n\n        Rectangle2D dataArea = getScreenDataArea();\n\n        g2.setXORMode(Color.orange);\n        if (((int) dataArea.getMinX() < x) && (x < (int) dataArea.getMaxX())) {\n\n            if (this.verticalTraceLine != null) {\n                g2.draw(this.verticalTraceLine);\n                this.verticalTraceLine.setLine(x, (int) dataArea.getMinY(), x,\n                        (int) dataArea.getMaxY());\n            }\n            else {\n                this.verticalTraceLine = new Line2D.Float(x,\n                        (int) dataArea.getMinY(), x, (int) dataArea.getMaxY());\n            }\n            g2.draw(this.verticalTraceLine);\n        }\n\n                g2.setPaintMode();\n    }
1477	@Beta\n    public void addDataColumn(int columnIndex, boolean isDataField) {\n        checkColumnIndex(columnIndex);\n\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n\n        pivotField.setDataField(isDataField);\n        pivotField.setShowAll(false);\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n    }
1478	public XWPFFooter createFooter(Enum type, XWPFParagraph[] pars) {\n        XWPFFooter footer = getFooter(type);\n\n        if (footer == null) {\n            FtrDocument ftrDoc = FtrDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.FOOTER;\n            int i = getRelationIndex(relation);\n\n            XWPFFooter wrapper = (XWPFFooter) doc.createRelationship(relation,\n                    XWPFFactory.getInstance(), i);\n            wrapper.setXWPFDocument(doc);\n\n            CTHdrFtr ftr = buildFtr(type, wrapper, pars);\n            wrapper.setHeaderFooter(ftr);\n            ftrDoc.setFtr(ftr);\n            assignFooter(wrapper, type);\n            footer = wrapper;\n        }\n\n        return footer;\n    }
1479	public void setValue(Number value, Comparable rowKey,\n                         Comparable columnKey) {\n\n        DefaultKeyedValues row;\n        int rowIndex = getRowIndex(rowKey);\n\n        if (rowIndex >= 0) {\n            row = (DefaultKeyedValues) this.rows.get(rowIndex);\n        }\n        else {\n            row = new DefaultKeyedValues();\n            if (this.sortRowKeys) {\n                rowIndex = -rowIndex - 1;\n                this.rowKeys.add(rowIndex, rowKey);\n                this.rows.add(rowIndex, row);\n            }\n            else {\n                this.rowKeys.add(rowKey);\n                this.rows.add(row);\n            }\n        }\n        row.setValue(columnKey, value);\n\n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n    }
1480	private void updateRawContents() throws IOException {\n        if (initialised) {\n                        \n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    \n                        for(TextPropCollection tpc : paragraphStyles) {\n                tpc.writeOut(baos);\n            }\n    \n                        for(TextPropCollection tpc : charStyles) {\n                tpc.writeOut(baos);\n            }\n    \n            rawContents = baos.toByteArray();\n        }\n        \n                int newSize = rawContents.length + reserved.length;\n        LittleEndian.putInt(_header,4,newSize);\n    }
1481	public void copy(Automaton other) {\n\n        int stateOffset = getNumStates();\n    states = ArrayUtil.grow(states, nextState + other.nextState);\n    System.arraycopy(other.states, 0, states, nextState, other.nextState);\n    for(int i=0;i<other.nextState;i += 2) {\n      if (states[nextState+i] != -1) {\n        states[nextState+i] += nextTransition;\n      }\n    }\n    nextState += other.nextState;\n    int otherNumStates = other.getNumStates();\n    BitSet otherAcceptStates = other.getAcceptStates();\n    int state = 0;\n    while (state < otherNumStates && (state = otherAcceptStates.nextSetBit(state)) != -1) {\n      setAccept(stateOffset + state, true);\n      state++;\n    }\n\n        transitions = ArrayUtil.grow(transitions, nextTransition + other.nextTransition);\n    System.arraycopy(other.transitions, 0, transitions, nextTransition, other.nextTransition);\n    for(int i=0;i<other.nextTransition;i += 3) {\n      transitions[nextTransition+i] += stateOffset;\n    }\n    nextTransition += other.nextTransition;\n\n    if (other.deterministic == false) {\n      deterministic = false;\n    }\n  }
1482	public static OPCPackage create(File file) {\n		if (file == null || (file.exists() && file.isDirectory())) {\n			throw new IllegalArgumentException("file");\n		}\n\n		if (file.exists()) {\n			throw new InvalidOperationException(\n					"This package (or file) already exists : use the open() method or delete the file.");\n		}\n\n				OPCPackage pkg = new ZipPackage();\n		pkg.originalPackagePath = file.getAbsolutePath();\n\n		configurePackage(pkg);\n		return pkg;\n	}
1483	protected void adjustInwards() {\n        int lower = 0;\n        int upper = this.labels.size() - 1;\n        while (upper > lower) {\n            if (lower < upper - 1) {\n                PieLabelRecord r0 = getPieLabelRecord(lower);\n                PieLabelRecord r1 = getPieLabelRecord(lower + 1);\n                if (r1.getLowerY() < r0.getUpperY()) {\n                    double adjust = r0.getUpperY() - r1.getLowerY()\n                                    + this.minGap;\n                    r1.setAllocatedY(r1.getAllocatedY() + adjust);\n                }\n            }\n            PieLabelRecord r2 = getPieLabelRecord(upper - 1);\n            PieLabelRecord r3 = getPieLabelRecord(upper);\n            if (r2.getUpperY() > r3.getLowerY()) {\n                double adjust = (r2.getUpperY() - r3.getLowerY()) + this.minGap;\n                r3.setAllocatedY(r3.getAllocatedY() + adjust);\n            }\n            lower++;\n            upper--;\n        }\n    }
1484	protected Size2D arrangeNN(Graphics2D g2) {\n        Rectangle2D contentSize = new Rectangle2D.Double();\n        if (this.line != null) {\n            contentSize.setRect(this.line.getBounds2D());\n        }\n        if (this.shape != null) {\n            contentSize = contentSize.createUnion(this.shape.getBounds2D());\n        }\n        return new Size2D(contentSize.getWidth(), contentSize.getHeight());\n    }
1485	private int recursiveNodeCalculator(TSTNode currentNode, boolean checkData,\n          int numNodes2) {\n    if (currentNode == null) {\n      return numNodes2;\n    }\n    int numNodes = recursiveNodeCalculator(\n            currentNode.relatives[TSTNode.LOKID], checkData, numNodes2);\n    numNodes = recursiveNodeCalculator(currentNode.relatives[TSTNode.EQKID],\n            checkData, numNodes);\n    numNodes = recursiveNodeCalculator(currentNode.relatives[TSTNode.HIKID],\n            checkData, numNodes);\n    if (checkData) {\n      if (currentNode.data != null) {\n        numNodes++;\n      }\n    } else {\n      numNodes++;\n    }\n    return numNodes;\n  }
1486	public int adjustForInsert(int listIndex, int length) {\n        int size = _textPieces.size();\n\n        TextPiece tp = _textPieces.get(listIndex);\n\n                tp.setEnd(tp.getEnd() + length);\n\n                for (int x = listIndex + 1; x < size; x++) {\n            tp = _textPieces.get(x);\n            tp.setStart(tp.getStart() + length);\n            tp.setEnd(tp.getEnd() + length);\n        }\n\n                return length;\n    }
1487	public static DVConstraint createDateConstraint(int comparisonOperator, String expr1, String expr2, String dateFormat) {\n		if (expr1 == null) {\n			throw new IllegalArgumentException("expr1 must be supplied");\n		}\n		OperatorType.validateSecondArg(comparisonOperator, expr2);\n		SimpleDateFormat df = null;\n		if (dateFormat != null) {\n		    df = new SimpleDateFormat(dateFormat, LocaleUtil.getUserLocale());\n		    df.setTimeZone(LocaleUtil.getUserTimeZone());\n		}\n		\n				String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertDate(expr1, df) : null;\n				String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertDate(expr2, df) : null;\n		return new DVConstraint(ValidationType.DATE, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
1488	public static JFreeChart createXYStepChart(String title, String xAxisLabel,\n            String yAxisLabel, XYDataset dataset, PlotOrientation orientation,\n            boolean legend, boolean tooltips, boolean urls) {\n\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        DateAxis xAxis = new DateAxis(xAxisLabel);\n        NumberAxis yAxis = new NumberAxis(yAxisLabel);\n        yAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());\n\n        XYToolTipGenerator toolTipGenerator = null;\n        if (tooltips) {\n            toolTipGenerator = new StandardXYToolTipGenerator();\n        }\n\n        XYURLGenerator urlGenerator = null;\n        if (urls) {\n            urlGenerator = new StandardXYURLGenerator();\n        }\n        XYItemRenderer renderer = new XYStepRenderer(toolTipGenerator,\n                urlGenerator);\n\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, null);\n        plot.setRenderer(renderer);\n        plot.setOrientation(orientation);\n        plot.setDomainCrosshairVisible(false);\n        plot.setRangeCrosshairVisible(false);\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\n                plot, legend);\n        currentTheme.apply(chart);\n        return chart;\n\n    }
1489	public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n            return avg;\n    }\n    int m = 0;         for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : "Fishy: no \"good\" queries!";\n        avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                     avg.pReleventSum *= avg.maxGoodPoints;     \n    return avg;\n  }
1490	public int aggregateDrawingRecords(DrawingManager2 drawingManager, boolean createIfMissing) {\n        int loc = findFirstRecordLocBySid(DrawingRecord.sid);\n        boolean noDrawingRecordsFound = (loc == -1);\n        if (noDrawingRecordsFound) {\n            if(!createIfMissing) {\n                                return -1;\n            }\n\n            EscherAggregate aggregate = new EscherAggregate(true);\n            loc = findFirstRecordLocBySid(EscherAggregate.sid);\n            if (loc == -1) {\n                loc = findFirstRecordLocBySid( WindowTwoRecord.sid );\n            } else {\n                getRecords().remove(loc);\n            }\n            getRecords().add( loc, aggregate );\n            return loc;\n        }\n        List<RecordBase> records = getRecords();\n\n        EscherAggregate.createAggregate(records, loc);\n\n        return loc;\n    }
1491	private double fixToRange(double x, double minX, double maxX) {\n        if (minX > maxX) {\n            throw new IllegalArgumentException("Requires 'minX' <= 'maxX'.");\n        }\n        if (x < minX) {\n            return minX;\n        }\n        else if (x > maxX) {\n            return maxX;\n        }\n        else {\n            return x;\n        }\n    }
1492	private void compareNumberOfSheets(Locator loc1, Locator loc2) {\n        int num1 = loc1.workbook.getNumberOfSheets();\n        int num2 = loc2.workbook.getNumberOfSheets();\n        if (num1 != num2) {\n            String str = String.format(Locale.ROOT, "%s\nworkbook1 [%d] != workbook2 [%d]",\n                "Number of Sheets do not match ::",\n                num1, num2\n            );\n\n            listOfDifferences.add(str);\n            \n        }\n    }
1493	public static void main(final String[] args)\n            throws UnsupportedEncodingException, IOException {\n        String originalFileName = null;\n        String copyFileName = null;\n\n        \n        if (args.length == 1) {\n            originalFileName = args[0];\n            File f = TempFile.createTempFile("CopyOfPOIFileSystem-", ".ole2");\n            f.deleteOnExit();\n            copyFileName = f.getAbsolutePath();\n        } else if (args.length == 2) {\n            originalFileName = args[0];\n            copyFileName = args[1];\n        } else {\n            System.err.println("Usage: " + CopyCompare.class.getName() +\n                    "originPOIFS [copyPOIFS]");\n            System.exit(1);\n        }\n\n        \n        final POIFSReader r = new POIFSReader();\n        final CopyFile cf = new CopyFile(copyFileName);\n        r.registerListener(cf);\n        r.setNotifyEmptyDirectories(true);\n\n        r.read(new File(originalFileName));\n\n        \n        cf.close();\n\n        \n        try (POIFSFileSystem opfs = new POIFSFileSystem(new File(originalFileName));\n             POIFSFileSystem cpfs = new POIFSFileSystem(new File(copyFileName))) {\n            final DirectoryEntry oRoot = opfs.getRoot();\n            final DirectoryEntry cRoot = cpfs.getRoot();\n            System.out.println(EntryUtils.areDirectoriesIdentical(oRoot, cRoot) ? "Equal" : "Not equal");\n        }\n    }
1494	protected void drawHorizontalItem(Graphics2D g2,\n                                      CategoryItemRendererState state,\n                                      Rectangle2D dataArea,\n                                      CategoryPlot plot,\n                                      CategoryAxis domainAxis,\n                                      ValueAxis rangeAxis,\n                                      StatisticalCategoryDataset dataset,\n                                      int visibleRow,\n                                      int row,\n                                      int column) {\n\n                double rectY = calculateBarW0(plot, PlotOrientation.HORIZONTAL, \n                dataArea, domainAxis, state, visibleRow, column);\n\n                Number meanValue = dataset.getMeanValue(row, column);\n        if (meanValue == null) {\n            return;\n        }\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {              if (value >= uclip) {\n                return;             }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) {             if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else {             if (value <= lclip) {\n                return;             }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n                yAxisLocation);\n        double rectX = Math.min(transY2, transY1);\n\n        double rectHeight = state.getBarWidth();\n        double rectWidth = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n                rectHeight);\n        Paint itemPaint = getItemPaint(row, column);\n        GradientPaintTransformer t = getGradientPaintTransformer();\n        if (t != null && itemPaint instanceof GradientPaint) {\n            itemPaint = t.transform((GradientPaint) itemPaint, bar);\n        }\n        g2.setPaint(itemPaint);\n        g2.fill(bar);\n\n                if (isDrawBarOutline()\n                && state.getBarWidth() > BAR_OUTLINE_WIDTH_THRESHOLD) {\n            Stroke stroke = getItemOutlineStroke(row, column);\n            Paint paint = getItemOutlinePaint(row, column);\n            if (stroke != null && paint != null) {\n                g2.setStroke(stroke);\n                g2.setPaint(paint);\n                g2.draw(bar);\n            }\n        }\n\n                Number n = dataset.getStdDevValue(row, column);\n        if (n != null) {\n            double valueDelta = n.doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);\n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));\n            }\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            Line2D line;\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d,\n                                     highVal, rectY + rectHeight / 2.0d);\n            g2.draw(line);\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25,\n                                     highVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25,\n                                     lowVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n        }\n\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n                    (value < 0.0));\n        }\n\n                EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }
1495	protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\n                LengthConstraintType.FIXED, 0.0, null,\n                LengthConstraintType.NONE);\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2, c1);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\n                new Range(0.0, width), LengthConstraintType.RANGE,\n                0.0, null, LengthConstraintType.NONE);\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, c2);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        if (this.rightBlock != null) {\n            double maxW = Math.max(width - w[2], 0.0);\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(Math.min(w[2], maxW), maxW),\n                    LengthConstraintType.RANGE, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.rightBlock.arrange(g2, c3);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.centerBlock.arrange(g2, c4);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        return arrange(container, g2, new RectangleConstraint(width, height));\n    }
1496	public void resize(double scaleX, double scaleY){\n        XSSFClientAnchor anchor = getClientAnchor();\n        XSSFClientAnchor pref = getPreferredSize(scaleX,scaleY);\n        if (anchor == null || pref == null) {\n            logger.log(POILogger.WARN, "picture is not anchored via client anchor - ignoring resize call");\n            return;\n        }\n\n        int row2 = anchor.getRow1() + (pref.getRow2() - pref.getRow1());\n        int col2 = anchor.getCol1() + (pref.getCol2() - pref.getCol1());\n\n        anchor.setCol2(col2);\n                anchor.setDx2(pref.getDx2());\n\n        anchor.setRow2(row2);\n                anchor.setDy2(pref.getDy2());\n    }
1497	protected static CTGroupShape prototype() {\n        if (prototype == null) {\n            CTGroupShape shape = CTGroupShape.Factory.newInstance();\n\n            CTGroupShapeNonVisual nv = shape.addNewNvGrpSpPr();\n            CTNonVisualDrawingProps nvpr = nv.addNewCNvPr();\n            nvpr.setId(0);\n            nvpr.setName("Group 0");\n            nv.addNewCNvGrpSpPr();\n            CTGroupShapeProperties sp = shape.addNewGrpSpPr();\n            CTGroupTransform2D t2d = sp.addNewXfrm();\n            CTPositiveSize2D p1 = t2d.addNewExt();\n            p1.setCx(0);\n            p1.setCy(0);\n            CTPoint2D p2 = t2d.addNewOff();\n            p2.setX(0);\n            p2.setY(0);\n            CTPositiveSize2D p3 = t2d.addNewChExt();\n            p3.setCx(0);\n            p3.setCy(0);\n            CTPoint2D p4 = t2d.addNewChOff();\n            p4.setX(0);\n            p4.setY(0);\n\n            prototype = shape;\n        }\n        return prototype;\n    }
1498	public void insertValue(int position, Comparable key, Number value) {\n        if (position < 0 || position > getItemCount()) {\n            throw new IllegalArgumentException("'position' out of bounds.");\n        }\n        ParamChecks.nullNotPermitted(key, "key");\n        int pos = getIndex(key);\n        if (pos == position) {\n            this.keys.set(pos, key);\n            this.values.set(pos, value);\n        }\n        else {\n            if (pos >= 0) {\n                this.keys.remove(pos);\n                this.values.remove(pos);\n            }\n\n            this.keys.add(position, key);\n            this.values.add(position, value);\n            rebuildIndex();\n        }\n    }
1499	public int normalize(char s[], int len) {\n\n    for (int i = 0; i < len; i++) {\n      switch (s[i]) {\n                case '\u0981':\n          len = delete(s, i, len);\n          i--;\n          break;\n\n                case '\u09C0':\n          s[i] = '\u09BF';\n          break;\n\n                case '\u09C2':\n          s[i] = '\u09C1';\n          break;\n\n                case '\u0995':\n          if(i + 2 < len && s[i+1] == '\u09CD' && s[i+2] == '\u09BF') {\n            if (i == 0) {\n              s[i] = '\u0996';\n              len = delete(s, i + 2, len);\n              len = delete(s, i + 1, len);\n            } else {\n              s[i+1] = '\u0996';\n              len = delete(s, i + 2, len);\n            }\n          }\n          break;\n\n                case '\u0999':\n          s[i] = '\u0982';\n          break;\n\n                case '\u09AF':\n          if(i - 2 == 0 && s[i-1] == '\u09CD') {\n            s[i - 1] = '\u09C7';\n\n            if(i + 1 < len && s[i+1] == '\u09BE') {\n              len = delete(s, i+1, len);\n            }\n            len = delete(s, i, len);\n            i --;\n          } else if(i - 1 >= 0 && s[i-1] == '\u09CD' ){\n            len = delete(s, i, len);\n            len = delete(s, i-1, len);\n            i -=2;\n          }\n          break;\n\n                case '\u09AC':\n          if((i >= 1 && s[i-1] != '\u09CD') || i == 0)\n            break;\n          if(i - 2 == 0) {\n            len = delete(s, i, len);\n            len = delete(s, i - 1, len);\n            i -= 2;\n          } else if(i - 5 >= 0 && s[i - 3] == '\u09CD') {\n            len = delete(s, i, len);\n            len = delete(s, i-1, len);\n            i -=2;\n          } else if(i - 2 >= 0){\n            s[i - 1] = s[i - 2];\n            len = delete(s, i, len);\n            i --;\n          }\n          break;\n\n                case '\u0983':\n          if(i == len -1) {\n            if(len <= 3) {\n              s[i] = '\u09B9';\n            } else {\n              len = delete(s, i, len);\n            }\n          } else {\n            s[i] = s[i+1];\n          }\n          break;\n\n                case '\u09B6':\n        case '\u09B7':\n          s[i] = '\u09B8';\n          break;\n\n                case '\u09A3':\n          s[i] = '\u09A8';\n          break;\n\n                case '\u09DC':\n        case '\u09DD':\n          s[i] = '\u09B0';\n          break;\n\n        case '\u09CE':\n          s[i] = '\u09A4';\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return len;\n  }
1500	public XSSFShapeGroup createGroup(XSSFChildAnchor anchor) {\n        CTGroupShape ctShape = ctGroup.addNewGrpSp();\n        ctShape.set(prototype());\n\n        XSSFShapeGroup shape = new XSSFShapeGroup(getDrawing(), ctShape);\n        shape.parent = this;\n        shape.anchor = anchor;\n\n        \n        CTGroupTransform2D xfrm = shape.getCTGroupShape().getGrpSpPr().getXfrm();\n        CTTransform2D t2 = anchor.getCTTransform2D();\n        xfrm.setOff(t2.getOff());\n        xfrm.setExt(t2.getExt());\n                xfrm.setChExt(t2.getExt());\n        xfrm.setFlipH(t2.getFlipH());\n        xfrm.setFlipV(t2.getFlipV());\n\n        return shape;\n    }
1501	private double transStart(double value, Rectangle2D area,\n                              RectangleEdge edge,\n                              double length1, double length2) {\n        double min = 0.0;\n        double max = 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min = area.getX();\n            max = area.getX() + area.getWidth() * length1 / (length1 + length2);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            min = area.getMaxY();\n            max = area.getMaxY() - area.getHeight() * length1\n                  / (length1 + length2);\n        }\n        if (isInverted()) {\n            return max - ((value - this.displayStart)\n                / (this.fixedRange.getUpperBound() - this.displayStart))\n                * (max - min);\n        }\n        else {\n            return min + ((value - this.displayStart)\n                / (this.fixedRange.getUpperBound() - this.displayStart))\n                * (max - min);\n        }\n\n    }
1502	public POIFSFileSystem getSummaryEntries(DirectoryNode root, String encryptedStream)\n    throws IOException, GeneralSecurityException {\n        DocumentNode es = (DocumentNode) root.getEntry(encryptedStream);\n        DocumentInputStream dis = root.createDocumentInputStream(es);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        IOUtils.copy(dis, bos);\n        dis.close();\n        CryptoAPIDocumentInputStream sbis = new CryptoAPIDocumentInputStream(this, bos.toByteArray());\n        LittleEndianInputStream leis = new LittleEndianInputStream(sbis);\n        POIFSFileSystem fsOut = null;\n        try {\n            int streamDescriptorArrayOffset = (int) leis.readUInt();\n             leis.readUInt();\n            long skipN = streamDescriptorArrayOffset - 8L;\n            if (sbis.skip(skipN) < skipN) {\n                throw new EOFException("buffer underrun");\n            }\n            sbis.setBlock(0);\n            int encryptedStreamDescriptorCount = (int) leis.readUInt();\n            StreamDescriptorEntry entries[] = new StreamDescriptorEntry[encryptedStreamDescriptorCount];\n            for (int i = 0; i < encryptedStreamDescriptorCount; i++) {\n                StreamDescriptorEntry entry = new StreamDescriptorEntry();\n                entries[i] = entry;\n                entry.streamOffset = (int) leis.readUInt();\n                entry.streamSize = (int) leis.readUInt();\n                entry.block = leis.readUShort();\n                int nameSize = leis.readUByte();\n                entry.flags = leis.readUByte();\n                                entry.reserved2 = leis.readInt();\n                entry.streamName = StringUtil.readUnicodeLE(leis, nameSize);\n                leis.readShort();\n                assert(entry.streamName.length() == nameSize);\n            }\n\n            fsOut = new POIFSFileSystem();             for (StreamDescriptorEntry entry : entries) {\n                sbis.seek(entry.streamOffset);\n                sbis.setBlock(entry.block);\n                InputStream is = new BoundedInputStream(sbis, entry.streamSize);\n                fsOut.createDocument(is, entry.streamName);\n                is.close();\n            }\n        } catch (Exception e) {\n            IOUtils.closeQuietly(fsOut);\n            if (e instanceof GeneralSecurityException) {\n                throw (GeneralSecurityException)e;\n            } else if (e instanceof IOException) {\n                throw (IOException)e;\n            } else {\n                throw new IOException("summary entries can't be read", e);\n            }\n        } finally {\n            IOUtils.closeQuietly(leis);\n            IOUtils.closeQuietly(sbis);\n        }\n        return fsOut;\n    }
1503	public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        ParamChecks.nullNotPermitted(item, "item");\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = "You are trying to add data where the time "\n                    + "period class is " + periodClass.getName()\n                    + ", but the TimeSeries is expecting an instance of "\n                    + this.timePeriodClass.getName() + ".";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n                                    boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                updateMinMaxYByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = maxIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n                        if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);                                                                            fireSeriesChanged();\n        return overwritten;\n\n    }
1504	private void parseObject(String path) throws ParseException {\n    scan('{');\n    boolean first = true;\n    while (true) {\n      char ch = peek();\n      if (ch == '}') {\n        break;\n      } else if (first == false) {\n        if (ch == ',') {\n                    upto++;\n          ch = peek();\n          if (ch == '}') {\n            break;\n          }\n        } else {\n          throw newParseException("expected , but got " + ch);\n        }\n      }\n\n      first = false;\n\n      int uptoStart = upto;\n      String key = parseString();\n\n      if (path.equals("crs.properties") && key.equals("href")) {\n        upto = uptoStart;\n        throw newParseException("cannot handle linked crs");\n      }\n\n      scan(':');\n\n      Object o;\n\n      ch = peek();\n\n      uptoStart = upto;\n\n      if (ch == '[') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + "." + key;\n        }\n        o = parseArray(newPath);\n      } else if (ch == '{') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + "." + key;\n        }\n        parseObject(newPath);\n        o = null;\n      } else if (ch == '"') {\n        o = parseString();\n      } else if (ch == 't') {\n        scan("true");\n        o = Boolean.TRUE;\n      } else if (ch == 'f') {\n        scan("false");\n        o = Boolean.FALSE;\n      } else if (ch == 'n') {\n        scan("null");\n        o = null;\n      } else if (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9')) {\n        o = parseNumber();\n      } else if (ch == '}') {\n        break;\n      } else {\n        throw newParseException("expected array, object, string or literal value, but got: " + ch);\n      }\n\n      if (path.equals("crs.properties") && key.equals("name")) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException("crs.properties.name should be a string, but saw: " + o);\n        }\n        String crs = (String) o;\n        if (crs.startsWith("urn:ogc:def:crs:OGC") == false || crs.endsWith(":CRS84") == false) {\n          upto = uptoStart;\n          throw newParseException("crs must be CRS84 from OGC, but saw: " + o);\n        }\n      }\n\n      if (key.equals("type") && path.startsWith("crs") == false) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException("type should be a string, but got: " + o);\n        }\n        String type = (String) o;\n        if (type.equals("Polygon") && isValidGeometryPath(path)) {\n          polyType = "Polygon";\n        } else if (type.equals("MultiPolygon") && isValidGeometryPath(path)) {\n          polyType = "MultiPolygon";\n        } else if ((type.equals("FeatureCollection") || type.equals("Feature")) && (path.equals("features.[]") || path.equals(""))) {\n          // OK, we recurse\n        } else {\n          upto = uptoStart;\n          throw newParseException("can only handle type FeatureCollection (if it has a single polygon geometry), Feature, Polygon or MutiPolygon, but got " + type);\n        }\n      } else if (key.equals("coordinates") && isValidGeometryPath(path)) {\n        if (o instanceof List == false) {\n          upto = uptoStart;\n          throw newParseException("coordinates should be an array, but got: " + o.getClass());\n        }\n        if (coordinates != null) {\n          upto = uptoStart;\n          throw newParseException("only one Polygon or MultiPolygon is supported");\n        }\n        coordinates = (List<Object>) o;\n      }\n    }\n\n    scan('}');\n  }
1505	void add() throws IOException {\n                int termID = bytesHash.add(termAtt.getBytesRef());\n      \n    \n    if (termID >= 0) {      bytesHash.byteStart(termID);\n            if (numPostingInt + intPool.intUpto > IntBlockPool.INT_BLOCK_SIZE) {\n        intPool.nextBuffer();\n      }\n\n      if (ByteBlockPool.BYTE_BLOCK_SIZE - bytePool.byteUpto < numPostingInt*ByteBlockPool.FIRST_LEVEL_SIZE) {\n        bytePool.nextBuffer();\n      }\n\n      intUptos = intPool.buffer;\n      intUptoStart = intPool.intUpto;\n      intPool.intUpto += streamCount;\n\n      postingsArray.intStarts[termID] = intUptoStart + intPool.intOffset;\n\n      for(int i=0;i<streamCount;i++) {\n        final int upto = bytePool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n        intUptos[intUptoStart+i] = upto + bytePool.byteOffset;\n      }\n      postingsArray.byteStarts[termID] = intUptos[intUptoStart];\n\n      newTerm(termID);\n\n    } else {\n      termID = (-termID)-1;\n      int intStart = postingsArray.intStarts[termID];\n      intUptos = intPool.buffers[intStart >> IntBlockPool.INT_BLOCK_SHIFT];\n      intUptoStart = intStart & IntBlockPool.INT_BLOCK_MASK;\n      addTerm(termID);\n    }\n\n    if (doNextCall) {\n      nextPerField.add(postingsArray.textStarts[termID]);\n    }\n  }
1506	public static int bytesDifference(BytesRef left, BytesRef right) {\n    int len = left.length < right.length ? left.length : right.length;\n    final byte[] bytesLeft = left.bytes;\n    final int offLeft = left.offset;\n    byte[] bytesRight = right.bytes;\n    final int offRight = right.offset;\n    for (int i = 0; i < len; i++)\n      if (bytesLeft[i+offLeft] != bytesRight[i+offRight])\n        return i;\n    return len;\n  }
1507	public void getNextTransition(Transition t) {\n        assert (t.transitionUpto+3 - states[2*t.source]) <= 3*states[2*t.source+1];\n\n        assert transitionSorted(t);\n\n    t.dest = transitions[t.transitionUpto++];\n    t.min = transitions[t.transitionUpto++];\n    t.max = transitions[t.transitionUpto++];\n  }
1508	public StylesTable getStylesTable() throws IOException, InvalidFormatException {\n        ArrayList<PackagePart> parts = pkg.getPartsByContentType(XSSFRelation.STYLES.getContentType());\n        if (parts.size() == 0) return null;\n\n                StylesTable styles = new StylesTable(parts.get(0));\n        parts = pkg.getPartsByContentType(XSSFRelation.THEME.getContentType());\n        if (parts.size() != 0) {\n            styles.setTheme(new ThemesTable(parts.get(0)));\n        }\n        return styles;\n    }
1509	public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IOException {\n                        for (String workbookName : WORKBOOK_DIR_ENTRY_NAMES) {\n            if (poifsDir.hasEntry(workbookName)) {\n                if (getPreferEventExtractor()) {\n                    return new EventBasedExcelExtractor(poifsDir);\n                }\n                return new ExcelExtractor(poifsDir);\n            }\n        }\n        if (poifsDir.hasEntry(OLD_WORKBOOK_DIR_ENTRY_NAME)) {\n            throw new OldExcelFormatException("Old Excel Spreadsheet format (1-95) "\n                    + "found. Please call OldExcelExtractor directly for basic text extraction");\n        }\n        \n                Class<?> cls = getScratchpadClass();\n        try {\n            Method m = cls.getDeclaredMethod("createExtractor", DirectoryNode.class);\n            POITextExtractor ext = (POITextExtractor)m.invoke(null, poifsDir);\n            if (ext != null) return ext;\n        } catch (IllegalArgumentException iae) {\n            throw iae;\n        } catch (Exception e) {\n            throw new IllegalArgumentException("Error creating Scratchpad Extractor", e);\n        }\n\n        throw new IllegalArgumentException("No supported documents found in the OLE2 stream");\n    }
1510	private void collectValues(ValueEval operand, DoubleList temp) throws EvaluationException {\n        if (operand instanceof ThreeDEval) {\n            ThreeDEval ae = (ThreeDEval) operand;\n            for (int sIx=ae.getFirstSheetIndex(); sIx <= ae.getLastSheetIndex(); sIx++) {\n                int width = ae.getWidth();\n                int height = ae.getHeight();\n                for (int rrIx=0; rrIx<height; rrIx++) {\n                    for (int rcIx=0; rcIx<width; rcIx++) {\n                        ValueEval ve = ae.getValue(sIx, rrIx, rcIx);\n                        if(!isSubtotalCounted() && ae.isSubTotal(rrIx, rcIx)) continue;\n                        collectValue(ve, true, temp);\n                    }\n                }\n            }\n            return;\n        }\n		if (operand instanceof TwoDEval) {\n			TwoDEval ae = (TwoDEval) operand;\n			int width = ae.getWidth();\n			int height = ae.getHeight();\n			for (int rrIx=0; rrIx<height; rrIx++) {\n				for (int rcIx=0; rcIx<width; rcIx++) {\n					ValueEval ve = ae.getValue(rrIx, rcIx);\n                    if(!isSubtotalCounted() && ae.isSubTotal(rrIx, rcIx)) continue;\n                    collectValue(ve, true, temp);\n				}\n			}\n			return;\n		}\n		if (operand instanceof RefEval) {\n			RefEval re = (RefEval) operand;\n			for (int sIx = re.getFirstSheetIndex(); sIx <= re.getLastSheetIndex(); sIx++) {\n			    collectValue(re.getInnerValueEval(sIx), true, temp);\n			}\n			return;\n		}\n		collectValue(operand, false, temp);\n	}
1511	private boolean isStemmable( String term )\n    {\n      for ( int c = 0; c < term.length(); c++ ) {\n        if ( !Character.isLetter( term.charAt( c ) ) )\n          return false;\n      }\n      return true;\n    }
1512	public final AttributeSource cloneAttributes() {\n    final AttributeSource clone = new AttributeSource(this.factory);\n    \n    if (hasAttributes()) {\n            for (State state = getCurrentState(); state != null; state = state.next) {\n        clone.attributeImpls.put(state.attribute.getClass(), state.attribute.clone());\n      }\n      \n            for (Entry<Class<? extends Attribute>, AttributeImpl> entry : this.attributes.entrySet()) {\n        clone.attributes.put(entry.getKey(), clone.attributeImpls.get(entry.getValue().getClass()));\n      }\n    }\n    \n    return clone;\n  }
1513	public static CFRule12Record create(HSSFSheet sheet, ExtendedColor color) {\n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_DATA_BAR, \n                                              ComparisonOperator.NO_COMPARISON);\n        DataBarFormatting dbf = r.createDataBarFormatting();\n        dbf.setColor(color);\n        dbf.setPercentMin((byte)0);\n        dbf.setPercentMax((byte)100);\n        \n        DataBarThreshold min = new DataBarThreshold();\n        min.setType(RangeType.MIN.id);\n        dbf.setThresholdMin(min);\n        \n        DataBarThreshold max = new DataBarThreshold();\n        max.setType(RangeType.MAX.id);\n        dbf.setThresholdMax(max);\n        \n        return r;\n    }
1514	public void addSeriesLabel(int series, String label) {\n        Integer key = new Integer(series);\n        List labelList = (List) this.seriesLabelLists.get(key);\n        if (labelList == null) {\n            labelList = new java.util.ArrayList();\n            this.seriesLabelLists.put(key, labelList);\n        }\n        labelList.add(label);\n    }
1515	public static Rectangle fromPointDistance(final double centerLat, final double centerLon, final double radiusMeters) {\n    checkLatitude(centerLat);\n    checkLongitude(centerLon);\n    final double radLat = toRadians(centerLat);\n    final double radLon = toRadians(centerLon);\n        double radDistance = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;\n    double minLat = radLat - radDistance;\n    double maxLat = radLat + radDistance;\n    double minLon;\n    double maxLon;\n\n    if (minLat > MIN_LAT_RADIANS && maxLat < MAX_LAT_RADIANS) {\n      double deltaLon = asin(sloppySin(radDistance) / cos(radLat));\n      minLon = radLon - deltaLon;\n      if (minLon < MIN_LON_RADIANS) {\n        minLon += 2d * PI;\n      }\n      maxLon = radLon + deltaLon;\n      if (maxLon > MAX_LON_RADIANS) {\n        maxLon -= 2d * PI;\n      }\n    } else {\n            minLat = max(minLat, MIN_LAT_RADIANS);\n      maxLat = min(maxLat, MAX_LAT_RADIANS);\n      minLon = MIN_LON_RADIANS;\n      maxLon = MAX_LON_RADIANS;\n    }\n\n    return new Rectangle(toDegrees(minLat), toDegrees(maxLat), toDegrees(minLon), toDegrees(maxLon));\n  }
1516	static void evaluateRules(Workbook wb, String sheetName) {\n        final WorkbookEvaluatorProvider wbEvalProv = (WorkbookEvaluatorProvider) wb.getCreationHelper().createFormulaEvaluator();\n        final ConditionalFormattingEvaluator cfEval = new ConditionalFormattingEvaluator(wb, wbEvalProv);\n                cfEval.clearAllCachedValues();\n        \n        final Sheet sheet = wb.getSheet(sheetName);\n        for (Row r : sheet) {\n            for (Cell c : r) {\n                final List<EvaluationConditionalFormatRule> rules = cfEval.getConditionalFormattingForCell(c);\n                                if (rules == null || rules.isEmpty()) continue;\n                final CellReference ref = ConditionalFormattingEvaluator.getRef(c);\n                if (rules.isEmpty()) continue;\n\n                System.out.println("\n"\n                  + ref.formatAsString()\n                  + " has conditional formatting.");\n\n                for (EvaluationConditionalFormatRule rule : rules) {\n                    ConditionalFormattingRule cf = rule.getRule();\n\n                    StringBuilder b = new StringBuilder();\n                    b.append("\tRule ")\n                     .append(rule.getFormattingIndex())\n                     .append(": ");\n                    \n                                        if (cf.getColorScaleFormatting() != null) {\n                        b.append("\n\t\tcolor scale (caller must calculate bucket)");\n                    }\n                                        if (cf.getDataBarFormatting() != null) {\n                        b.append("\n\t\tdata bar (caller must calculate bucket)");\n                    }\n                                        if (cf.getMultiStateFormatting() != null) {\n                        b.append("\n\t\ticon set (caller must calculate icon bucket)");\n                    }\n                                        if (cf.getPatternFormatting() != null) {\n                        final PatternFormatting fill = cf.getPatternFormatting();\n                        b.append("\n\t\tfill pattern ")\n                         .append(fill.getFillPattern())\n                         .append(" color index ")\n                         .append(fill.getFillBackgroundColor());\n                    }\n                                        if (cf.getFontFormatting() != null) {\n                        final FontFormatting ff = cf.getFontFormatting();\n                        b.append("\n\t\tfont format ")\n                         .append("color index ")\n                         .append(ff.getFontColorIndex());\n                        if (ff.isBold()) b.append(" bold");\n                        if (ff.isItalic()) b.append(" italic");\n                        if (ff.isStruckout()) b.append(" strikeout");\n                        b.append(" underline index ")\n                         .append(ff.getUnderlineType());\n                    }\n                    \n                    System.out.println(b);\n                }\n            }\n        }\n    }
1517	private void isCellFontFamilyMatches(Locator loc1, Locator loc2) {\n                if (!(loc1.cell instanceof XSSFCell)) return;\n        String family1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getFontName();\n        String family2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getFontName();\n        if (!family1.equals(family2)) {\n            addMessage(loc1, loc2, "Cell Font Family does not Match ::", family1, family2);\n        }\n    }
1518	public void confirmSignature() throws XMLSignatureException, MarshalException {\n        final Document document = DocumentHelper.createDocument();\n        final DOMSignContext xmlSignContext = createXMLSignContext(document);\n\n                final DOMSignedInfo signedInfo = preSign(xmlSignContext);\n\n                final String signatureValue = signDigest(xmlSignContext, signedInfo);\n\n                postSign(xmlSignContext, signatureValue);\n    }
1519	public static PointValues.Relation relate(\n      double minLat, double maxLat, double minLon, double maxLon,\n      double lat, double lon, double distanceSortKey, double axisLat) {\n\n    if (minLon > maxLon) {\n      throw new IllegalArgumentException("Box crosses the dateline");\n    }\n\n    if ((lon < minLon || lon > maxLon) && (axisLat + Rectangle.AXISLAT_ERROR < minLat || axisLat - Rectangle.AXISLAT_ERROR > maxLat)) {\n            if (SloppyMath.haversinSortKey(lat, lon, minLat, minLon) > distanceSortKey &&\n          SloppyMath.haversinSortKey(lat, lon, minLat, maxLon) > distanceSortKey &&\n          SloppyMath.haversinSortKey(lat, lon, maxLat, minLon) > distanceSortKey &&\n          SloppyMath.haversinSortKey(lat, lon, maxLat, maxLon) > distanceSortKey) {\n                return Relation.CELL_OUTSIDE_QUERY;\n      }\n    }\n\n    if (within90LonDegrees(lon, minLon, maxLon) &&\n        SloppyMath.haversinSortKey(lat, lon, minLat, minLon) <= distanceSortKey &&\n        SloppyMath.haversinSortKey(lat, lon, minLat, maxLon) <= distanceSortKey &&\n        SloppyMath.haversinSortKey(lat, lon, maxLat, minLon) <= distanceSortKey &&\n        SloppyMath.haversinSortKey(lat, lon, maxLat, maxLon) <= distanceSortKey) {\n            return Relation.CELL_INSIDE_QUERY;\n    }\n\n    return Relation.CELL_CROSSES_QUERY;\n  }
1520	private boolean advanceRpts(PhrasePositions pp) throws IOException {\n    if (pp.rptGroup < 0) {\n      return true;     }\n    PhrasePositions[] rg = rptGroups[pp.rptGroup];\n    FixedBitSet bits = new FixedBitSet(rg.length);     int k0 = pp.rptInd;\n    int k;\n    while((k=collide(pp)) >= 0) {\n      pp = lesser(pp, rg[k]);       if (!advancePP(pp)) {\n        return false;       }\n      if (k != k0) {         bits = FixedBitSet.ensureCapacity(bits, k);\n        bits.set(k);       }\n    }\n            int n = 0;\n        int numBits = bits.length();     while (bits.cardinality() > 0) {\n      PhrasePositions pp2 = pq.pop();\n      rptStack[n++] = pp2;\n      if (pp2.rptGroup >= 0 \n          && pp2.rptInd < numBits            && bits.get(pp2.rptInd)) {\n        bits.clear(pp2.rptInd);\n      }\n    }\n        for (int i=n-1; i>=0; i--) {\n      pq.add(rptStack[i]);\n    }\n    return true;\n  }
1521	public UnitNRShape toShape(Calendar cal) {\n        final int calPrecField = getCalPrecisionField(cal);    try {\n      int[] valStack = new int[maxLevels];      int len = 0;\n      if (calPrecField >= Calendar.YEAR) {        int year = cal.get(Calendar.YEAR);\n        int yearAdj = cal.get(Calendar.ERA) == 0 ? AD_YEAR_BASE - (year - 1) : AD_YEAR_BASE + year;\n\n        valStack[len++] = yearAdj / 1000_000;\n        yearAdj -= valStack[len-1] * 1000_000;\n        valStack[len++] = yearAdj / 1000;\n        yearAdj -= valStack[len-1] * 1000;\n        valStack[len++] = yearAdj;\n        for (int level = YEAR_LEVEL +1; level < FIELD_BY_LEVEL.length; level++) {\n          int field = FIELD_BY_LEVEL[level];\n          if (field > calPrecField)\n            break;\n          valStack[len++] = cal.get(field) - cal.getActualMinimum(field);\n        }\n      }\n\n      return toShape(valStack, len);\n    } finally {\n      clearFieldsAfter(cal, calPrecField);    }\n  }
1522	private int getBodyElementSpecificPos(int pos, List<? extends IBodyElement> list) {\n                if (list.size() == 0) {\n            return -1;\n        }\n\n        if (pos >= 0 && pos < bodyElements.size()) {\n                        IBodyElement needle = bodyElements.get(pos);\n            if (needle.getElementType() != list.get(0).getElementType()) {\n                                return -1;\n            }\n\n                        int startPos = Math.min(pos, list.size() - 1);\n            for (int i = startPos; i >= 0; i--) {\n                if (list.get(i) == needle) {\n                    return i;\n                }\n            }\n        }\n\n                return -1;\n    }
1523	protected static CharArraySet loadStopwordSet(Path stopwords) throws IOException {\n    Reader reader = null;\n    try {\n      reader = Files.newBufferedReader(stopwords, StandardCharsets.UTF_8);\n      return WordlistLoader.getWordSet(reader);\n    } finally {\n      IOUtils.close(reader);\n    }\n  }
1524	public XYDataItem addOrUpdate(XYDataItem item) {\n        ParamChecks.nullNotPermitted(item, "item");\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n                XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n                        boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = maxIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n                                                            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\n                this.data.add(-index - 1, item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n                        if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }
1525	public static CharArraySet getSnowballWordSet(Reader reader, CharArraySet result)\n      throws IOException {\n    BufferedReader br = null;\n    try {\n      br = getBufferedReader(reader);\n      String line = null;\n      while ((line = br.readLine()) != null) {\n        int comment = line.indexOf('|');\n        if (comment >= 0) line = line.substring(0, comment);\n        String words[] = line.split("\\s+");\n        for (int i = 0; i < words.length; i++)\n          if (words[i].length() > 0) result.add(words[i]);\n      }\n    } finally {\n      IOUtils.close(br);\n    }\n    return result;\n  }
1526	protected Query newPrefixQuery(String text) {\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    for (Map.Entry<String,Float> entry : weights.entrySet()) {\n      final String fieldName = entry.getKey();\n      final BytesRef term = getAnalyzer().normalize(fieldName, text);\n      Query q = new PrefixQuery(new Term(fieldName, term));\n      float boost = entry.getValue();\n      if (boost != 1f) {\n        q = new BoostQuery(q, boost);\n      }\n      bq.add(q, BooleanClause.Occur.SHOULD);\n    }\n    return simplify(bq.build());\n  }
1527	public void writeOut(OutputStream out) throws IOException {\n		\n				ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		for (Record r : _children) r.writeOut(baos);\n		byte[] data = baos.toByteArray();\n\n				_escherRecord.setData(data);\n	}
1528	protected List<CharSequence[]> loadFieldValues(String[] fields,\n                                                 DocIdSetIterator docIter, int cacheCharsThreshold)\n      throws IOException {\n    List<CharSequence[]> docListOfFields =\n        new ArrayList<>(cacheCharsThreshold == 0 ? 1 : (int) Math.min(64, docIter.cost()));\n\n    LimitedStoredFieldVisitor visitor = newLimitedStoredFieldsVisitor(fields);\n    int sumChars = 0;\n    do {\n      int docId = docIter.nextDoc();\n      if (docId == DocIdSetIterator.NO_MORE_DOCS) {\n        break;\n      }\n      visitor.init();\n      searcher.doc(docId, visitor);\n      CharSequence[] valuesByField = visitor.getValuesByField();\n      docListOfFields.add(valuesByField);\n      for (CharSequence val : valuesByField) {\n        sumChars += (val == null ? 0 : val.length());\n      }\n    } while (sumChars <= cacheCharsThreshold && cacheCharsThreshold != 0);\n    return docListOfFields;\n  }
1529	public static String saveChartAsPNG(JFreeChart chart, int width, int height,\n            ChartRenderingInfo info, HttpSession session) throws IOException {\n\n        ParamChecks.nullNotPermitted(chart, "chart");\n        ServletUtilities.createTempDir();\n        String prefix = ServletUtilities.tempFilePrefix;\n        if (session == null) {\n            prefix = ServletUtilities.tempOneTimeFilePrefix;\n        }\n        File tempFile = File.createTempFile(prefix, ".png",\n                new File(System.getProperty("java.io.tmpdir")));\n        ChartUtilities.saveChartAsPNG(tempFile, chart, width, height, info);\n        if (session != null) {\n            ServletUtilities.registerChartForDeletion(tempFile, session);\n        }\n        return tempFile.getName();\n\n    }
1530	protected void init() {\n    skipBuffer = new RAMOutputStream[numberOfSkipLevels];\n    for (int i = 0; i < numberOfSkipLevels; i++) {\n      skipBuffer[i] = new RAMOutputStream();\n    }\n  }
1531	public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\n\n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n        if (this.dataset != null) {\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        }\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n\n    }
1532	private void makePaintIndex() {\n        if (this.plot == null) {\n            return;\n        }\n        WaferMapDataset data = this.plot.getDataset();\n        Number dataMin = data.getMinValue();\n        Number dataMax = data.getMaxValue();\n        Set uniqueValues = data.getUniqueValues();\n        if (uniqueValues.size() <= this.paintLimit) {\n            int count = 0;             for (Iterator i = uniqueValues.iterator(); i.hasNext();) {\n                this.paintIndex.put(i.next(), new Integer(count++));\n            }\n        }\n        else {\n                                    switch (this.paintIndexMethod) {\n                case POSITION_INDEX:\n                    makePositionIndex(uniqueValues);\n                    break;\n                case VALUE_INDEX:\n                    makeValueIndex(dataMax, dataMin, uniqueValues);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }
1533	public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());\n    if (iterations == 0) {\n            return 1;\n    } else if ((iterations - 1) * byteValueCount() >= valueCount) {\n            return (int) Math.ceil((double) valueCount / byteValueCount());\n    } else {\n      return iterations;\n    }\n  }
1534	public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n        FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }
1535	public synchronized long deleteDocuments(String id) throws IOException {\n    assert buffer.getFilePointer() == 0;\n    buffer.writeByte(OP_DELETE_DOCUMENTS);\n    buffer.writeString(id);\n    return flushBuffer();\n  }
1536	public static SidedPlane constructNormalizedPerpendicularSidedPlane(final Vector insidePoint,\n    final Vector normalVector, final Vector point1, final Vector point2) {\n    final Vector pointsVector = new Vector(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z);\n    final Vector newNormalVector = new Vector(normalVector, pointsVector);\n    try {\n            return new SidedPlane(insidePoint, newNormalVector, -newNormalVector.dotProduct(point1));\n    } catch (IllegalArgumentException e) {\n      return null;\n    }\n  }
1537	public static Cell translateUnicodeValues(Cell cell) {\n\n        String s = cell.getRichStringCellValue().getString();\n        boolean foundUnicode = false;\n        String lowerCaseStr = s.toLowerCase(Locale.ROOT);\n\n        for (UnicodeMapping entry : unicodeMappings) {\n            String key = entry.entityName;\n            if (lowerCaseStr.contains(key)) {\n                s = s.replaceAll(key, entry.resolvedValue);\n                foundUnicode = true;\n            }\n        }\n        if (foundUnicode) {\n            cell.setCellValue(cell.getRow().getSheet().getWorkbook().getCreationHelper()\n                    .createRichTextString(s));\n        }\n        return cell;\n    }
1538	public int buildTextPropList(int containsField, byte[] data, int dataOffset) {\n		int bytesPassed = 0;\n\n						for(TextProp tp : getPotentialProperties()) {\n			\n						if((containsField & tp.getMask()) != 0) {\n                if(dataOffset+bytesPassed >= data.length) {\n                                                            maskSpecial |= tp.getMask();\n                    return bytesPassed;\n                }\n\n								TextProp prop = tp.clone();\n				int val = 0;\n				if (prop instanceof HSLFTabStopPropCollection) {\n                    ((HSLFTabStopPropCollection)prop).parseProperty(data, dataOffset+bytesPassed);\n                } else if (prop.getSize() == 2) {\n					val = LittleEndian.getShort(data,dataOffset+bytesPassed);\n				} else if(prop.getSize() == 4) {\n					val = LittleEndian.getInt(data,dataOffset+bytesPassed);\n				} else if (prop.getSize() == 0) {\n                                        maskSpecial |= tp.getMask();\n                    continue;\n                }\n				\n				if (prop instanceof BitMaskTextProp) {\n				    ((BitMaskTextProp)prop).setValueWithMask(val, containsField);\n				} else if (!(prop instanceof HSLFTabStopPropCollection)) {\n				    prop.setValue(val);\n				}\n				bytesPassed += prop.getSize();\n				addProp(prop);\n			}\n		}\n\n				return bytesPassed;\n	}
1539	private void updateFormula(XSSFCell cell, String oldName, String newName) {\n        CTCellFormula f = cell.getCTCell().getF();\n        if (f != null) {\n            String formula = f.getStringValue();\n            if (formula != null && formula.length() > 0) {\n                int sheetIndex = _wb.getSheetIndex(cell.getSheet());\n                Ptg[] ptgs = FormulaParser.parse(formula, _fpwb, FormulaType.CELL, sheetIndex, cell.getRowIndex());\n                for (Ptg ptg : ptgs) {\n                    updatePtg(ptg, oldName, newName);\n                }\n                String updatedFormula = FormulaRenderer.toFormulaString(_fpwb, ptgs);\n                if (!formula.equals(updatedFormula)) f.setStringValue(updatedFormula);\n            }\n        }\n    }
1540	protected String getCellFormula(XSSFEvaluationWorkbook fpb) {\n        CellType cellType = getCellType();\n        if(cellType != CellType.FORMULA) {\n            throw typeMismatch(CellType.FORMULA, cellType, false);\n        }\n\n        CTCellFormula f = _cell.getF();\n        if (isPartOfArrayFormulaGroup()) {\n            \n            if (f == null || f.getStringValue().isEmpty()) {\n                XSSFCell cell = getSheet().getFirstCellInArrayFormula(this);\n                return cell.getCellFormula(fpb);\n            }\n        }\n        if (f.getT() == STCellFormulaType.SHARED) {\n            return convertSharedFormula((int)f.getSi(), fpb == null ? XSSFEvaluationWorkbook.create(getSheet().getWorkbook()) : fpb);\n        }\n        return f.getStringValue();\n    }
1541	static void preserveSpaces(XmlString xs) {\n        String text = xs.getStringValue();\n        if (text != null && (text.startsWith(" ") || text.endsWith(" "))) {\n            XmlCursor c = xs.newCursor();\n            c.toNextToken();\n            c.insertAttributeWithValue(new QName("http://www.w3.org/XML/1998/namespace", "space"), "preserve");\n            c.dispose();\n        }\n    }
1542	private String getModuleName(File ivyXmlFile) {\n    String path = ivyXmlFile.getAbsolutePath();\n    Matcher matcher = PROPERTY_PREFIX_FROM_IVY_XML_FILE_PATTERN.matcher(path);\n    if ( ! matcher.find()) {\n      throw new BuildException("Can't get module name from ivy.xml path: " + path);\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(matcher.group(1));\n    if (null != matcher.group(2)) {       builder.append("-analyzers");\n    } else if (null != matcher.group(3)) {       builder.append("-example");\n    } else if (null != matcher.group(4)) {       builder.append("-server");\n    }\n    builder.append('-');\n    builder.append(matcher.group(5));\n    return builder.toString().replace("solr-solr-", "solr-");\n  }
1543	public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n            Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    crashed = true;\n    unSyncedFiles = new HashSet<>();\n  }
1544	private Range calculateXDataRange(float[][] data) {\n\n        Range result = null;\n\n        if (data != null) {\n            float lowest = Float.POSITIVE_INFINITY;\n            float highest = Float.NEGATIVE_INFINITY;\n            for (int i = 0; i < data[0].length; i++) {\n                float v = data[0][i];\n                if (v < lowest) {\n                    lowest = v;\n                }\n                if (v > highest) {\n                    highest = v;\n                }\n            }\n            if (lowest <= highest) {\n                result = new Range(lowest, highest);\n            }\n        }\n\n        return result;\n\n    }
1545	void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    for (final String fileName: files) {\n                                          if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled("IFD")) {\n          infoStream.message("IFD", "will delete new file \"" + fileName + "\"");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n  }
1546	public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n                  \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n                in.readVInt();\n\n                if (version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n                        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n                        in.setPosition(arc.nextArc);\n      }\n    }\n        in.readByte();\n    return readLabel(in);\n  }
1547	protected List<PropertyValue> writeProperties(OutputStream out) throws IOException {\n        List<PropertyValue> variableLengthProperties = new ArrayList<>();\n        for (Entry<MAPIProperty, PropertyValue> entry : properties.entrySet()) {\n            MAPIProperty property = entry.getKey();\n            PropertyValue value = entry.getValue();\n            if (value == null) {\n                continue;\n            }\n            if (property.id < 0) {\n                continue;\n            }\n                          	                    long tag = Long.parseLong(getFileName(property, value.getActualType()), 16);\n            LittleEndian.putUInt(tag, out);\n            LittleEndian.putUInt(value.getFlags(), out); \n            MAPIType type = getTypeMapping(value.getActualType());\n            if (type.isFixedLength()) {\n                                writeFixedLengthValueHeader(out, property, type, value);\n            } else {\n                                writeVariableLengthValueHeader(out, property, type, value);\n                variableLengthProperties.add(value);\n            }\n        }\n        return variableLengthProperties;\n    }
1548	protected Query getBooleanQuery(List<BooleanClause> clauses) throws ParseException {\n    if (clauses.size()==0) {\n      return null;     }\n    BooleanQuery.Builder query = newBooleanQuery();\n    for(final BooleanClause clause: clauses) {\n      query.add(clause);\n    }\n    return query.build();\n  }
1549	public static String createSafeSheetName(final String nameProposal, char replaceChar) {\n        if (nameProposal == null) {\n            return "null";\n        }\n        if (nameProposal.length() < 1) {\n            return "empty";\n        }\n        final int length = Math.min(31, nameProposal.length());\n        final String shortenname = nameProposal.substring(0, length);\n        final StringBuilder result = new StringBuilder(shortenname);\n        for (int i=0; i<length; i++) {\n            char ch = result.charAt(i);\n            switch (ch) {\n                case '\u0000':\n                case '\u0003':\n                case ':':\n                case '/':\n                case '\\':\n                case '?':\n                case '*':\n                case ']':\n                case '[':\n                    result.setCharAt(i, replaceChar);\n                    break;\n                case '\'':\n                    if (i==0 || i==length-1) {\n                        result.setCharAt(i, replaceChar);\n                    }\n                    break;\n                default:\n                                }\n        }\n        return result.toString();\n    }
1550	private RuntimeException expected(String s) {\n        String msg;\n\n        if (look == '=' && _formulaString.substring(0, _pointer-1).trim().length() < 1) {\n            msg = "The specified formula '" + _formulaString\n                + "' starts with an equals sign which is not allowed.";\n        } else {\n            msg = new StringBuilder("Parse error near char ")\n                .append(_pointer-1)                 .append(" '")\n                .appendCodePoint(look)\n                .append("'")\n                .append(" in specified formula '")\n                .append(_formulaString)\n                .append("'. Expected ")\n                .append(s)\n                .toString();\n        }\n        return new FormulaParseException(msg);\n    }
1551	public Date calculateWorkdays(double start, int workdays, double[] holidays) {\n		Date startDate = DateUtil.getJavaDate(start);\n		int direction = workdays < 0 ? -1 : 1;\n		Calendar endDate = LocaleUtil.getLocaleCalendar();\n		endDate.setTime(startDate);\n		double excelEndDate = DateUtil.getExcelDate(endDate.getTime());\n		while (workdays != 0) {\n			endDate.add(Calendar.DAY_OF_YEAR, direction);\n			excelEndDate += direction;\n			if (endDate.get(Calendar.DAY_OF_WEEK) != Calendar.SATURDAY\n					&& endDate.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY\n					&& !isHoliday(excelEndDate,	holidays)) {\n				workdays -= direction;\n			}\n		}\n		return endDate.getTime();\n	}
1552	void setText(char text[], int length) {\n    this.text = text;\n    this.length = this.endBounds = length;\n    current = startBounds = end = 0;\n    skipPossessive = hasFinalPossessive = false;\n    setBounds();\n  }
1553	private void addTermFrequencies(Reader r, Map<String, Map<String, Int>> perFieldTermFrequencies, String fieldName)\n      throws IOException {\n    if (analyzer == null) {\n      throw new UnsupportedOperationException("To use MoreLikeThis without " +\n          "term vectors, you must provide an Analyzer");\n    }\n    Map<String, Int> termFreqMap = perFieldTermFrequencies.get(fieldName);\n    if (termFreqMap == null) {\n      termFreqMap = new HashMap<>();\n      perFieldTermFrequencies.put(fieldName, termFreqMap);\n    }\n    try (TokenStream ts = analyzer.tokenStream(fieldName, r)) {\n      int tokenCount = 0;\n            CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n      ts.reset();\n      while (ts.incrementToken()) {\n        String word = termAtt.toString();\n        tokenCount++;\n        if (tokenCount > maxNumTokensParsed) {\n          break;\n        }\n        if (isNoiseWord(word)) {\n          continue;\n        }\n\n                Int cnt = termFreqMap.get(word);\n        if (cnt == null) {\n          termFreqMap.put(word, new Int());\n        } else {\n          cnt.x++;\n        }\n      }\n      ts.end();\n    }\n  }
1554	public String[] retrieveInterestingTerms(Reader r, String fieldName) throws IOException {\n    ArrayList<Object> al = new ArrayList<>(maxQueryTerms);\n    PriorityQueue<ScoreTerm> pq = retrieveTerms(r, fieldName);\n    ScoreTerm scoreTerm;\n    int lim = maxQueryTerms;         while (((scoreTerm = pq.pop()) != null) && lim-- > 0) {\n      al.add(scoreTerm.word);     }\n    String[] res = new String[al.size()];\n    return al.toArray(res);\n  }
1555	public static Color HSL2RGB(double h, double s, double l, double alpha) {\n                        s = Math.max(0, Math.min(100, s));\n        l = Math.max(0, Math.min(100, l));\n\n        if (alpha <0.0f || alpha > 1.0f) {\n            String message = "Color parameter outside of expected range - Alpha: " + alpha;\n            throw new IllegalArgumentException( message );\n        }\n\n        \n        h = h % 360.0f;\n        h /= 360f;\n        s /= 100f;\n        l /= 100f;\n\n        double q = (l < 0.5d)\n            ? l * (1d + s)\n            : (l + s) - (s * l);\n\n        double p = 2d * l - q;\n\n        double r = Math.max(0, HUE2RGB(p, q, h + (1.0d / 3.0d)));\n        double g = Math.max(0, HUE2RGB(p, q, h));\n        double b = Math.max(0, HUE2RGB(p, q, h - (1.0d / 3.0d)));\n\n        r = Math.min(r, 1.0d);\n        g = Math.min(g, 1.0d);\n        b = Math.min(b, 1.0d);\n\n        return new Color((float)r, (float)g, (float)b, (float)alpha);\n    }
1556	private boolean isNoiseWord(String term) {\n    int len = term.length();\n    if (minWordLen > 0 && len < minWordLen) {\n      return true;\n    }\n    if (maxWordLen > 0 && len > maxWordLen) {\n      return true;\n    }\n    return stopWords != null && stopWords.contains(term);\n  }
1557	public void addChild(final Property property)\n        throws IOException\n    {\n        String name = property.getName();\n\n        if (_children_names.contains(name))\n        {\n            throw new IOException("Duplicate name \"" + name + "\"");\n        }\n        _children_names.add(name);\n        _children.add(property);\n    }
1558	private SheetIdentifier parseSheetRange(String bookname, NameIdentifier sheet1Name) {\n        GetChar();\n        SheetIdentifier sheet2 = parseSheetName();\n        if (sheet2 != null) {\n           return new SheetRangeIdentifier(bookname, sheet1Name, sheet2.getSheetIdentifier());\n        }\n        return null;\n    }
1559	protected int minFrequencyToCache(Query query) {\n    if (isCostly(query)) {\n      return 2;\n    } else {\n            int minFrequency = 5;\n      if (query instanceof BooleanQuery\n          || query instanceof DisjunctionMaxQuery) {\n                                                minFrequency--;\n      }\n      return minFrequency;\n    }\n  }
1560	protected static CharArraySet loadStopwordSet(final boolean ignoreCase,\n      final Class<? extends Analyzer> aClass, final String resource,\n      final String comment) throws IOException {\n    Reader reader = null;\n    try {\n      reader = IOUtils.getDecodingReader(aClass.getResourceAsStream(resource), StandardCharsets.UTF_8);\n      return WordlistLoader.getWordSet(reader, comment, new CharArraySet(16, ignoreCase));\n    } finally {\n      IOUtils.close(reader);\n    }\n    \n  }
1561	protected void fillBackground(Graphics2D g2, Rectangle2D area,\n            PlotOrientation orientation) {\n        ParamChecks.nullNotPermitted(orientation, "orientation");\n        if (this.backgroundPaint == null) {\n            return;\n        }\n        Paint p = this.backgroundPaint;\n        if (p instanceof GradientPaint) {\n            GradientPaint gp = (GradientPaint) p;\n            if (orientation == PlotOrientation.VERTICAL) {\n                p = new GradientPaint((float) area.getCenterX(),\n                        (float) area.getMaxY(), gp.getColor1(),\n                        (float) area.getCenterX(), (float) area.getMinY(),\n                        gp.getColor2());\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                p = new GradientPaint((float) area.getMinX(),\n                        (float) area.getCenterY(), gp.getColor1(),\n                        (float) area.getMaxX(), (float) area.getCenterY(),\n                        gp.getColor2());\n            }\n        }\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                this.backgroundAlpha));\n        g2.setPaint(p);\n        g2.fill(area);\n        g2.setComposite(originalComposite);\n    }
1562	private ContextMenu createContextMenu() {\n        final ContextMenu menu = new ContextMenu();\n       \n        Menu export = new Menu("Export As");\n        \n        MenuItem pngItem = new MenuItem("PNG...");\n        pngItem.setOnAction((ActionEvent e) -> { handleExportToPNG(); });        \n        export.getItems().add(pngItem);\n        \n        MenuItem jpegItem = new MenuItem("JPEG...");\n        jpegItem.setOnAction((ActionEvent e) -> { handleExportToJPEG(); });        \n        export.getItems().add(jpegItem);\n        \n        if (ExportUtils.isOrsonPDFAvailable()) {\n            MenuItem pdfItem = new MenuItem("PDF...");\n            pdfItem.setOnAction((ActionEvent e) -> {\n                handleExportToPDF();\n            });\n            export.getItems().add(pdfItem);\n        }\n        if (ExportUtils.isJFreeSVGAvailable()) {\n            MenuItem svgItem = new MenuItem("SVG...");\n            svgItem.setOnAction((ActionEvent e) -> {\n                handleExportToSVG();\n            });\n            export.getItems().add(svgItem);        \n        }\n        menu.getItems().add(export);\n        return menu;\n    }
1563	protected Size2D arrangeRN(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        RectangleConstraint c1 = constraint.toUnconstrainedWidth();\n        Size2D size1 = arrange(container, g2, c1);\n\n        if (constraint.getWidthRange().contains(size1.getWidth())) {\n            return size1;\n        }\n        else {\n            double w = constraint.getWidthRange().constrain(size1.getWidth());\n            RectangleConstraint c2 = constraint.toFixedWidth(w);\n            return arrange(container, g2, c2);\n        }\n    }
1564	public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (numBits < bits.numBits) {\n      return bits;\n    } else {\n                  int numWords = bits2words(numBits);\n      long[] arr = bits.getBits();\n      if (numWords >= arr.length) {\n        arr = ArrayUtil.grow(arr, numWords + 1);\n      }\n      return new FixedBitSet(arr, arr.length << 6);\n    }\n  }
1565	public XWPFNumbering createNumbering() {\n        if (numbering == null) {\n            NumberingDocument numberingDoc = NumberingDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.NUMBERING;\n            int i = getRelationIndex(relation);\n\n            XWPFNumbering wrapper = (XWPFNumbering) createRelationship(relation, XWPFFactory.getInstance(), i);\n            wrapper.setNumbering(numberingDoc.addNewNumbering());\n            numbering = wrapper;\n        }\n\n        return numbering;\n    }
1566	public void drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state) {\n\n        Plot p = getPlot();\n        if (p == null) {\n            return;\n        }\n        CategoryPlot plot = (CategoryPlot) p;\n        double il = getTickMarkInsideLength();\n        double ol = getTickMarkOutsideLength();\n        Line2D line = new Line2D.Double();\n        List categories = plot.getCategoriesForAxis(this);\n        g2.setPaint(getTickMarkPaint());\n        g2.setStroke(getTickMarkStroke());\n        Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        if (edge.equals(RectangleEdge.TOP)) {\n            Iterator iterator = categories.iterator();\n            while (iterator.hasNext()) {\n                Comparable key = (Comparable) iterator.next();\n                double x = getCategoryMiddle(key, categories, dataArea, edge);\n                line.setLine(x, cursor, x, cursor + il);\n                g2.draw(line);\n                line.setLine(x, cursor, x, cursor - ol);\n                g2.draw(line);\n            }\n            state.cursorUp(ol);\n        } else if (edge.equals(RectangleEdge.BOTTOM)) {\n            Iterator iterator = categories.iterator();\n            while (iterator.hasNext()) {\n                Comparable key = (Comparable) iterator.next();\n                double x = getCategoryMiddle(key, categories, dataArea, edge);\n                line.setLine(x, cursor, x, cursor - il);\n                g2.draw(line);\n                line.setLine(x, cursor, x, cursor + ol);\n                g2.draw(line);\n            }\n            state.cursorDown(ol);\n        } else if (edge.equals(RectangleEdge.LEFT)) {\n            Iterator iterator = categories.iterator();\n            while (iterator.hasNext()) {\n                Comparable key = (Comparable) iterator.next();\n                double y = getCategoryMiddle(key, categories, dataArea, edge);\n                line.setLine(cursor, y, cursor + il, y);\n                g2.draw(line);\n                line.setLine(cursor, y, cursor - ol, y);\n                g2.draw(line);\n            }\n            state.cursorLeft(ol);\n        } else if (edge.equals(RectangleEdge.RIGHT)) {\n            Iterator iterator = categories.iterator();\n            while (iterator.hasNext()) {\n                Comparable key = (Comparable) iterator.next();\n                double y = getCategoryMiddle(key, categories, dataArea, edge);\n                line.setLine(cursor, y, cursor - il, y);\n                g2.draw(line);\n                line.setLine(cursor, y, cursor + ol, y);\n                g2.draw(line);\n            }\n            state.cursorRight(ol);\n        }\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }
1567	private void processGlyphs(Graphics2D graphics, DrawFontManager dfm, List<AttributedStringData> attList, final int beginIndex, TextRun run, String runText) {\n                List<FontGroupRange> ttrList = FontGroup.getFontGroupRanges(runText);\n        int rangeBegin = 0;\n        for (FontGroupRange ttr : ttrList) {\n            FontInfo fiRun = run.getFontInfo(ttr.getFontGroup());\n            if (fiRun == null) {\n                                fiRun = run.getFontInfo(FontGroup.LATIN);\n            }\n            FontInfo fiMapped = dfm.getMappedFont(graphics, fiRun);\n            FontInfo fiFallback = dfm.getFallbackFont(graphics, fiRun);\n            assert(fiFallback != null);\n            if (fiMapped == null) {\n                fiMapped = dfm.getMappedFont(graphics, new DrawFontInfo(paragraph.getDefaultFontFamily()));\n            }\n            if (fiMapped == null) {\n                fiMapped = fiFallback;\n            }\n\n            Font fontMapped = dfm.createAWTFont(graphics, fiMapped, 10, run.isBold(), run.isItalic());\n            Font fontFallback = dfm.createAWTFont(graphics, fiFallback, 10, run.isBold(), run.isItalic());\n\n                        final int rangeLen = ttr.getLength();\n            int partEnd = rangeBegin;\n            while (partEnd<rangeBegin+rangeLen) {\n                                int partBegin = partEnd;\n                partEnd = nextPart(fontMapped, runText, partBegin, rangeBegin+rangeLen, true);\n\n                                                                \n                if (partBegin < partEnd) {\n                                        attList.add(new AttributedStringData(TextAttribute.FAMILY, fontMapped.getFontName(Locale.ROOT), beginIndex+partBegin, beginIndex+partEnd));\n                    if (LOG.check(POILogger.DEBUG)) {\n                        LOG.log(POILogger.DEBUG, "mapped: ",fontMapped.getFontName(Locale.ROOT)," ",(beginIndex+partBegin)," ",(beginIndex+partEnd)," - ",runText.substring(beginIndex+partBegin, beginIndex+partEnd));\n                    }\n                }\n\n                                partBegin = partEnd;\n                partEnd = nextPart(fontMapped, runText, partBegin, rangeBegin+rangeLen, false);\n                \n                if (partBegin < partEnd) {\n                                        attList.add(new AttributedStringData(TextAttribute.FAMILY, fontFallback.getFontName(Locale.ROOT), beginIndex+partBegin, beginIndex+partEnd));\n                    if (LOG.check(POILogger.DEBUG)) {\n                        LOG.log(POILogger.DEBUG, "fallback: ",fontFallback.getFontName(Locale.ROOT)," ",(beginIndex+partBegin)," ",(beginIndex+partEnd)," - ",runText.substring(beginIndex+partBegin, beginIndex+partEnd));\n                    }\n                }\n            }\n            \n            rangeBegin += rangeLen;\n        }\n    }
1568	public static Rectangle2D rectangleByRadius(Rectangle2D rect,\n            double radiusW, double radiusH) {\n        ParamChecks.nullNotPermitted(rect, "rect");\n        double x = rect.getCenterX();\n        double y = rect.getCenterY();\n        double w = rect.getWidth() * radiusW;\n        double h = rect.getHeight() * radiusH;\n        return new Rectangle2D.Double(x - w / 2.0, y - h / 2.0, w, h);\n    }
1569	public Map<String, String[]> highlightFields(String[] fields, Query query, TopDocs topDocs, int[] maxPassages)\n      throws IOException {\n    final ScoreDoc scoreDocs[] = topDocs.scoreDocs;\n    int docids[] = new int[scoreDocs.length];\n    for (int i = 0; i < docids.length; i++) {\n      docids[i] = scoreDocs[i].doc;\n    }\n\n    return highlightFields(fields, query, docids, maxPassages);\n  }
1570	public Date rollDate(Date base, TimeZone zone) {\n                                        Calendar calendar = Calendar.getInstance(zone);\n        calendar.setTime(base);\n        calendar.add(this.rollUnitType.getCalendarField(), this.rollCount);\n        return calendar.getTime();\n    }
1571	public static CharArraySet unmodifiableSet(CharArraySet set) {\n    if (set == null)\n      throw new NullPointerException("Given set is null");\n    if (set == EMPTY_SET)\n      return EMPTY_SET;\n    if (set.map instanceof CharArrayMap.UnmodifiableCharArrayMap)\n      return set;\n    return new CharArraySet(CharArrayMap.unmodifiableMap(set.map));\n  }
1572	public static CellRangeAddress[][] buildMergedRangesMap( Sheet sheet ) {\n        CellRangeAddress[][] mergedRanges = new CellRangeAddress[1][];\n        for ( final CellRangeAddress cellRangeAddress : sheet.getMergedRegions() ) {\n            final int requiredHeight = cellRangeAddress.getLastRow() + 1;\n            if ( mergedRanges.length < requiredHeight ) {\n                CellRangeAddress[][] newArray = new CellRangeAddress[requiredHeight][];\n                System.arraycopy( mergedRanges, 0, newArray, 0,\n                        mergedRanges.length );\n                mergedRanges = newArray;\n            }\n\n            for ( int r = cellRangeAddress.getFirstRow(); r <= cellRangeAddress\n                    .getLastRow(); r++ ) {\n                final int requiredWidth = cellRangeAddress.getLastColumn() + 1;\n\n                CellRangeAddress[] rowMerged = mergedRanges[r];\n                if ( rowMerged == null ) {\n                    rowMerged = new CellRangeAddress[requiredWidth];\n                    mergedRanges[r] = rowMerged;\n                } else {\n                    final int rowMergedLength = rowMerged.length;\n                    if ( rowMergedLength < requiredWidth )\n                    {\n                        final CellRangeAddress[] newRow = new CellRangeAddress[requiredWidth];\n                        System.arraycopy( rowMerged, 0, newRow, 0,\n                                rowMergedLength );\n\n                        mergedRanges[r] = newRow;\n                        rowMerged = newRow;\n                    }\n                }\n\n                Arrays.fill( rowMerged, cellRangeAddress.getFirstColumn(),\n                        cellRangeAddress.getLastColumn() + 1, cellRangeAddress );\n            }\n        }\n        return mergedRanges;\n    }
1573	public void clearIndex() throws IOException {\n    synchronized (modifyCurrentIndexLock) {\n      ensureOpen();\n      final Directory dir = this.spellIndex;\n      final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(null)\n          .setOpenMode(OpenMode.CREATE));\n      writer.close();\n      swapSearcher(dir);\n    }\n  }
1574	public void add(double space, RectangleEdge edge) {\n        ParamChecks.nullNotPermitted(edge, "edge");\n        if (edge == RectangleEdge.TOP) {\n            this.top += space;\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            this.bottom += space;\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            this.left += space;\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            this.right += space;\n        }\n        else {\n            throw new IllegalStateException("Unrecognised 'edge' argument.");\n        }\n    }
1575	public int addConditionalFormatting(CellRangeAddress[] regions, HSSFConditionalFormattingRule[] cfRules) {\n        if (regions == null) {\n            throw new IllegalArgumentException("regions must not be null");\n        }\n        for(CellRangeAddress range : regions) range.validate(SpreadsheetVersion.EXCEL97);\n\n        if (cfRules == null) {\n            throw new IllegalArgumentException("cfRules must not be null");\n        }\n        if (cfRules.length == 0) {\n            throw new IllegalArgumentException("cfRules must not be empty");\n        }\n        if (cfRules.length > 3) {\n            throw new IllegalArgumentException("Number of rules must not exceed 3");\n        }\n\n        CFRuleBase[] rules = new CFRuleBase[cfRules.length];\n        for (int i = 0; i != cfRules.length; i++) {\n            rules[i] = cfRules[i].getCfRuleRecord();\n        }\n        CFRecordsAggregate cfra = new CFRecordsAggregate(regions, rules);\n        return _conditionalFormattingTable.add(cfra);\n    }
1576	protected Size2D arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        Size2D s = arrangeNF(container, g2, constraint);\n        if (constraint.getWidthRange().contains(s.width)) {\n            return s;\n        }\n        else {\n            RectangleConstraint c = constraint.toFixedWidth(\n                constraint.getWidthRange().constrain(s.getWidth())\n            );\n            return arrangeFF(container, g2, c);\n        }\n    }
1577	protected String tableTitle (String longestOp) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(Format.format(OP,longestOp));\n    sb.append(ROUND);\n    sb.append(getRunData().getConfig().getColsNamesForValsByRound());\n    for (int i = 0; i < COLS.length; i++) {\n      sb.append(COLS[i]);\n    }\n    return sb.toString(); \n  }
1578	private static VerticalAlignment getVerticalAlignment(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        VerticalAlignment align;\n        if (value instanceof VerticalAlignment) {\n            align = (VerticalAlignment) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map used a Short value for "\n                        + name + ". Should use VerticalAlignment enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            align = VerticalAlignment.forInt(code);\n        }\n        else if (value == null) {\n            align = VerticalAlignment.BOTTOM;\n        }\n        else {\n            throw new RuntimeException("Unexpected vertical alignment style class. Must be VerticalAlignment or Short (deprecated).");\n        }\n        return align;\n    }
1579	public static TNEFAttribute create(InputStream inp) throws IOException {\n      int id   = LittleEndian.readUShort(inp);\n      int type = LittleEndian.readUShort(inp);\n      \n            if(id == TNEFProperty.ID_MAPIPROPERTIES.id ||\n            id == TNEFProperty.ID_ATTACHMENT.id) {\n         return new TNEFMAPIAttribute(id, type, inp);\n      }\n      if(type == TNEFProperty.TYPE_STRING ||\n           type == TNEFProperty.TYPE_TEXT) {\n         return new TNEFStringAttribute(id, type, inp);\n      }\n      if(type == TNEFProperty.TYPE_DATE) {\n         return new TNEFDateAttribute(id, type, inp);\n      }\n      return new TNEFAttribute(id, type, inp); \n   }
1580	static boolean positionsOrdered(Spans spans1, Spans spans2) {\n    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();\n    int start1 = spans1.startPosition();\n    int start2 = spans2.startPosition();\n    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);\n  }
1581	public double drawParagraphs(Graphics2D graphics, double x, double y) {\n        DrawFactory fact = DrawFactory.getInstance(graphics);\n\n        double y0 = y;\n        Iterator<? extends TextParagraph<?,?,? extends TextRun>> paragraphs = getShape().iterator();\n        \n        boolean isFirstLine = true;\n        for (int autoNbrIdx=0; paragraphs.hasNext(); autoNbrIdx++){\n            TextParagraph<?,?,? extends TextRun> p = paragraphs.next();\n            DrawTextParagraph dp = fact.getDrawable(p);\n            BulletStyle bs = p.getBulletStyle();\n            if (bs == null || bs.getAutoNumberingScheme() == null) {\n                autoNbrIdx = -1;\n            } else {\n                Integer startAt = bs.getAutoNumberingStartAt();\n                if (startAt == null) startAt = 1;\n                                if (startAt > autoNbrIdx) autoNbrIdx = startAt;\n            }\n            dp.setAutoNumberingIdx(autoNbrIdx);\n            dp.breakText(graphics);\n\n            if (isFirstLine) {\n                y += dp.getFirstLineLeading();\n            } else {\n                                Double spaceBefore = p.getSpaceBefore();\n                if (spaceBefore == null) spaceBefore = 0d;\n                if(spaceBefore > 0) {\n                                                            y += spaceBefore*0.01*dp.getFirstLineHeight();\n                } else {\n                                        y += -spaceBefore;\n                }\n            }\n            isFirstLine = false;\n            \n            dp.setPosition(x, y);\n            dp.draw(graphics);\n            y += dp.getY();\n\n            if (paragraphs.hasNext()) {\n                Double spaceAfter = p.getSpaceAfter();\n                if (spaceAfter == null) spaceAfter = 0d;\n                if(spaceAfter > 0) {\n                                                            y += spaceAfter*0.01*dp.getLastLineHeight();\n                } else {\n                                        y += -spaceAfter;\n                }\n            }\n        }\n        return y - y0;\n    }
1582	private int getMaxTopNSearcherQueueSize(int topN, int numDocs, double liveDocsRatio, boolean filterEnabled) {\n    long maxQueueSize = topN * maxAnalyzedPathsPerOutput;\n        assert liveDocsRatio <= 1.0d;\n    maxQueueSize = (long) (maxQueueSize / liveDocsRatio);\n    if (filterEnabled) {\n      maxQueueSize = maxQueueSize + (numDocs/2);\n    }\n    return (int) Math.min(MAX_TOP_N_QUEUE_SIZE, maxQueueSize);\n  }
1583	private String parseAsSpecialQuantifier(){\n        if ( look != '[') {\n            return null;\n        }\n        GetChar();\n        if( look != '#') {\n            return null;\n        }\n        GetChar();\n        String name = parseAsName();\n        if ( name.equals("This")) {\n            name = name + ' ' + parseAsName();\n        }\n        Match(']');\n        return name;\n    }
1584	protected void drawTask(Graphics2D g2,\n                            CategoryItemRendererState state,\n                            Rectangle2D dataArea,\n                            CategoryPlot plot,\n                            CategoryAxis domainAxis,\n                            ValueAxis rangeAxis,\n                            GanttCategoryDataset dataset,\n                            int row,\n                            int column) {\n\n        PlotOrientation orientation = plot.getOrientation();\n        RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge();\n\n                Number value0 = dataset.getEndValue(row, column);\n        if (value0 == null) {\n            return;\n        }\n        double java2dValue0 = rangeAxis.valueToJava2D(value0.doubleValue(),\n                dataArea, rangeAxisLocation);\n\n                Number value1 = dataset.getStartValue(row, column);\n        if (value1 == null) {\n            return;\n        }\n        double java2dValue1 = rangeAxis.valueToJava2D(value1.doubleValue(),\n                dataArea, rangeAxisLocation);\n\n        if (java2dValue1 < java2dValue0) {\n            double temp = java2dValue1;\n            java2dValue1 = java2dValue0;\n            java2dValue0 = temp;\n            value1 = value0;\n        }\n\n        double rectStart = calculateBarW0(plot, orientation, dataArea,\n                domainAxis, state, row, column);\n        double rectBreadth = state.getBarWidth();\n        double rectLength = Math.abs(java2dValue1 - java2dValue0);\n\n        Rectangle2D bar = null;\n        RectangleEdge barBase = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            bar = new Rectangle2D.Double(java2dValue0, rectStart, rectLength,\n                    rectBreadth);\n            barBase = RectangleEdge.LEFT;\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            bar = new Rectangle2D.Double(rectStart, java2dValue1, rectBreadth,\n                    rectLength);\n            barBase = RectangleEdge.BOTTOM;\n        }\n\n        Rectangle2D completeBar = null;\n        Rectangle2D incompleteBar = null;\n        Number percent = dataset.getPercentComplete(row, column);\n        double start = getStartPercent();\n        double end = getEndPercent();\n        if (percent != null) {\n            double p = percent.doubleValue();\n            if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {\n                completeBar = new Rectangle2D.Double(java2dValue0,\n                        rectStart + start * rectBreadth, rectLength * p,\n                        rectBreadth * (end - start));\n                incompleteBar = new Rectangle2D.Double(java2dValue0\n                        + rectLength * p, rectStart + start * rectBreadth,\n                        rectLength * (1 - p), rectBreadth * (end - start));\n            }\n            else if (plot.getOrientation() == PlotOrientation.VERTICAL) {\n                completeBar = new Rectangle2D.Double(rectStart + start\n                        * rectBreadth, java2dValue1 + rectLength * (1 - p),\n                        rectBreadth * (end - start), rectLength * p);\n                incompleteBar = new Rectangle2D.Double(rectStart + start\n                        * rectBreadth, java2dValue1, rectBreadth * (end\n                        - start), rectLength * (1 - p));\n            }\n\n        }\n\n        if (getShadowsVisible()) {\n            getBarPainter().paintBarShadow(g2, this, row, column, bar,\n                    barBase, true);\n        }\n        getBarPainter().paintBar(g2, this, row, column, bar, barBase);\n\n        if (completeBar != null) {\n            g2.setPaint(getCompletePaint());\n            g2.fill(completeBar);\n        }\n        if (incompleteBar != null) {\n            g2.setPaint(getIncompletePaint());\n            g2.fill(incompleteBar);\n        }\n\n                if (isDrawBarOutline()\n                && state.getBarWidth() > BAR_OUTLINE_WIDTH_THRESHOLD) {\n            Stroke stroke = getItemOutlineStroke(row, column);\n            Paint paint = getItemOutlinePaint(row, column);\n            if (stroke != null && paint != null) {\n                g2.setStroke(stroke);\n                g2.setPaint(paint);\n                g2.draw(bar);\n            }\n        }\n\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n                    false);\n        }\n\n                int datasetIndex = plot.indexOf(dataset);\n        Comparable columnKey = dataset.getColumnKey(column);\n        Comparable rowKey = dataset.getRowKey(row);\n        double xx = domainAxis.getCategorySeriesMiddle(columnKey, rowKey,\n                dataset, getItemMargin(), dataArea, plot.getDomainAxisEdge());\n        updateCrosshairValues(state.getCrosshairState(),\n                dataset.getRowKey(row), dataset.getColumnKey(column),\n                value1.doubleValue(), datasetIndex, xx, java2dValue1,\n                orientation);\n\n                EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }
1585	public static byte[] checkIndexHeaderID(DataInput in, byte[] expectedID) throws IOException {\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, expectedID)) {\n      throw new CorruptIndexException("file mismatch, expected id=" + StringHelper.idToString(expectedID) \n                                                         + ", got=" + StringHelper.idToString(id), in);\n    }\n    return id;\n  }
1586	public int addByPoolOffset(int offset) {\n    assert bytesStart != null : "Bytesstart is null - not initialized";\n        int code = offset;\n    int hashPos = offset & hashMask;\n    int e = ids[hashPos];\n    if (e != -1 && bytesStart[e] != offset) {\n                  do {\n        code++;\n        hashPos = code & hashMask;\n        e = ids[hashPos];\n      } while (e != -1 && bytesStart[e] != offset);\n    }\n    if (e == -1) {\n            if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : "count: " + count + " len: "\n            + bytesStart.length;\n      }\n      e = count++;\n      bytesStart[e] = offset;\n      assert ids[hashPos] == -1;\n      ids[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, false);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }
1587	public long getTime(Date date) {\n        long result = date.getTime();\n        if (this.adjustForDaylightSaving) {\n            this.workingCalendar.setTime(date);\n            this.workingCalendarNoDST.set(\n                    this.workingCalendar.get(Calendar.YEAR),\n                    this.workingCalendar.get(Calendar.MONTH),\n                    this.workingCalendar.get(Calendar.DATE),\n                    this.workingCalendar.get(Calendar.HOUR_OF_DAY),\n                    this.workingCalendar.get(Calendar.MINUTE),\n                    this.workingCalendar.get(Calendar.SECOND));\n            this.workingCalendarNoDST.set(Calendar.MILLISECOND,\n                    this.workingCalendar.get(Calendar.MILLISECOND));\n            Date revisedDate = this.workingCalendarNoDST.getTime();\n            result = revisedDate.getTime();\n        }\n\n        return result;\n    }
1588	public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException("no segments* file found in " + dir + ": files: " + Arrays.toString(files));\n    }\n    try {\n                  sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, "ERROR: could not read any segments file in directory");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n        Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n                oldSegs = "pre-3.1";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n        IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, "ERROR: could not open segments file in directory");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n       input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, "ERROR: could not read segment file version in directory");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = " userData=" + sis.getUserData();\n    } else {\n      userDataString = "";\n    }\n\n    String versionString = "";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = "versions=[" + oldSegs + " .. " + newest + "]";\n      } else {\n        versionString = "version=" + oldSegs;\n      }\n    } else if (newest != null) {       versionString = oldest.equals(newest) ? ( "version=" + oldest ) : ("versions=[" + oldest + " .. " + newest + "]");\n    }\n\n    msg(infoStream, "Segments file=" + segmentsFileName + " numSegments=" + numSegments\n        + " " + versionString + " id=" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print("\nChecking only these segments:");\n        for (String s : onlySegments) {\n          infoStream.print(" " + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, ":");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, "  " + (1+i) + " of " + numSegments + ": name=" + info.info.name + " maxDoc=" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException("illegal number of documents: maxDoc=" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, "    version=" + (version == null ? "3.0" : version));\n        msg(infoStream, "    id=" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, "    codec=" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, "    compound=" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, "    numFiles=" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, "    sort=" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException("index sort changed from " + previousIndexSort + " to " + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, "    size (MB)=" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, "    diagnostics = " + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, "    no deletions");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, "    has deletions [delGen=" + info.getDelGen() + "]");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print("    test: open reader.........");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print("    test: check integrity.....");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException("SegmentReader.maxDoc() " + reader.maxDoc() + " != SegmentInfo.maxDoc " + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException("delete count mismatch: info=" + (info.info.maxDoc() - info.getDelCount()) + " vs reader=" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException("too many deleted docs: maxDoc()=" + reader.maxDoc() + " vs del count=" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException("delete count mismatch: info=" + info.getDelCount() + " vs reader=" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException("delete count mismatch: info=" + info.getDelCount() + " vs reader=" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n                    segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n                    segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n                    segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n                    segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n                    segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n                    segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n                    segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n                    segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n                    segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n                              if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException("Live docs test failed");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException("Field Info test failed");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException("Field Norm test failed");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException("Term Index test failed");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException("Stored Field test failed");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException("Term Vector test failed");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException("DocValues test failed");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException("Points test failed");\n          }\n        }\n\n        msg(infoStream, "");\n        \n        if (verbose) {\n          msg(infoStream, "detailed segment RAM usage: ");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, "FAILED");\n        String comment;\n        comment = "exorciseIndex() would remove reference to this segment";\n        msg(infoStream, "    WARNING: " + comment + "; full exception:");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, "");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n            result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, "WARNING: " + result.numBadSegments + " broken segments (containing " + result.totLoseDocCount + " documents) detected");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, "ERROR: Next segment name counter " + sis.counter + " is not greater than max segment name " + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, "No problems were detected with this index.\n");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, "Took %.3f sec total.", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }
1589	protected List refreshAngleTicks() {\n        List ticks = new ArrayList();\n        for (double currentTickVal = 0.0; currentTickVal < 360.0;\n                currentTickVal += this.angleTickUnit.getSize()) {\n\n            TextAnchor ta = calculateTextAnchor(currentTickVal);\n            NumberTick tick = new NumberTick(new Double(currentTickVal),\n                this.angleTickUnit.valueToString(currentTickVal),\n                ta, TextAnchor.CENTER, 0.0);\n            ticks.add(tick);\n        }\n        return ticks;\n    }
1590	public List<CharsRef> uniqueStems(char word[], int length) {\n    List<CharsRef> stems = stem(word, length);\n    if (stems.size() < 2) {\n      return stems;\n    }\n    CharArraySet terms = new CharArraySet(8, dictionary.ignoreCase);\n    List<CharsRef> deduped = new ArrayList<>();\n    for (CharsRef s : stems) {\n      if (!terms.contains(s)) {\n        deduped.add(s);\n        terms.add(s);\n      }\n    }\n    return deduped;\n  }
1591	public static int compareArray(char[] larray, int lstartIndex, char[] rarray,\n      int rstartIndex) {\n\n    if (larray == null) {\n      if (rarray == null || rstartIndex >= rarray.length)\n        return 0;\n      else\n        return -1;\n    } else {\n            if (rarray == null) {\n        if (lstartIndex >= larray.length)\n          return 0;\n        else\n          return 1;\n      }\n    }\n\n    int li = lstartIndex, ri = rstartIndex;\n    while (li < larray.length && ri < rarray.length && larray[li] == rarray[ri]) {\n      li++;\n      ri++;\n    }\n    if (li == larray.length) {\n      if (ri == rarray.length) {\n                return 0;\n      } else {\n                return -1;\n      }\n    } else {\n            if (ri == rarray.length) {\n                return 1;\n      } else {\n                if (larray[li] > rarray[ri])\n          return 1;\n        else\n          return -1;\n      }\n    }\n  }
1592	protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double maxW = 0.0;\n        double maxH = 0.0;\n        List blocks = container.getBlocks();\n        Iterator iterator = blocks.iterator();\n        while (iterator.hasNext()) {\n            Block b = (Block) iterator.next();\n            if (b != null) {\n                Size2D s = b.arrange(g2, RectangleConstraint.NONE);\n                maxW = Math.max(maxW, s.width);\n                maxH = Math.max(maxH, s.height);\n            }\n        }\n        double width = this.columns * maxW;\n        double height = this.rows * maxH;\n        RectangleConstraint c = new RectangleConstraint(width, height);\n        return arrangeFF(container, g2, c);\n    }
1593	public void setObject(Object object, Comparable rowKey,\n            Comparable columnKey) {\n        ParamChecks.nullNotPermitted(rowKey, "rowKey");\n        ParamChecks.nullNotPermitted(columnKey, "columnKey");\n        KeyedObjects row;\n        int rowIndex = this.rowKeys.indexOf(rowKey);\n        if (rowIndex >= 0) {\n            row = (KeyedObjects) this.rows.get(rowIndex);\n        }\n        else {\n            this.rowKeys.add(rowKey);\n            row = new KeyedObjects();\n            this.rows.add(row);\n        }\n        row.setObject(columnKey, object);\n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n    }
1594	protected void cacheProperties() {\n        if (origSize == null || checksum == null) {\n            byte data[] = getData();\n            checksum = IOUtils.calculateChecksum(data);\n            \n            PictureType pt = getType();\n            if (pt == null) {\n                origSize = new Dimension(1,1);\n                return;\n            }\n            \n            switch (pt) {\n            case EMF:\n                origSize = new ImageHeaderEMF(data, 0).getSize();\n                break;\n            case WMF:\n                                                origSize = new ImageHeaderWMF(data, 0).getSize();\n                break;\n            case PICT:\n                origSize = new ImageHeaderPICT(data, 0).getSize();\n                break;\n            default:\n                origSize = new ImageHeaderBitmap(data, 0).getSize();\n                break;\n            }\n        }\n    }
1595	public static double getCorrelation(Number[] data1, Number[] data2) {\n        ParamChecks.nullNotPermitted(data1, "data1");\n        ParamChecks.nullNotPermitted(data2, "data2");\n        if (data1.length != data2.length) {\n            throw new IllegalArgumentException(\n                "'data1' and 'data2' arrays must have same length."\n            );\n        }\n        int n = data1.length;\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n        double sumXY = 0.0;\n        for (int i = 0; i < n; i++) {\n            double x = 0.0;\n            if (data1[i] != null) {\n                x = data1[i].doubleValue();\n            }\n            double y = 0.0;\n            if (data2[i] != null) {\n                y = data2[i].doubleValue();\n            }\n            sumX = sumX + x;\n            sumY = sumY + y;\n            sumXY = sumXY + (x * y);\n            sumX2 = sumX2 + (x * x);\n            sumY2 = sumY2 + (y * y);\n        }\n        return (n * sumXY - sumX * sumY) / Math.pow((n * sumX2 - sumX * sumX)\n                * (n * sumY2 - sumY * sumY), 0.5);\n    }
1596	public void setBorderBottom(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetBottom();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
1597	protected double trimToContentWidth(double fixedWidth) {\n        double result = this.margin.trimWidth(fixedWidth);\n        result = this.frame.getInsets().trimWidth(result);\n        result = this.padding.trimWidth(result);\n        return Math.max(result, 0.0);\n    }
1598	public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : "A reader with deletions must have at least one leave";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n                final LeafReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }
1599	private static Double computeAngle(final GeoPoint point,\n    final double sinLatitude,\n    final double cosLatitude,\n    final double sinLongitude,\n    final double cosLongitude) {\n                                                              \n    final double x1 = point.x * cosLongitude + point.y * sinLongitude;\n    final double y1 = - point.x * sinLongitude + point.y * cosLongitude;\n    final double z1 = point.z;\n      \n        final double y2 = y1;\n    final double z2 = - x1 * sinLatitude + z1 * cosLatitude;\n    \n            if (Math.sqrt(y2*y2 + z2*z2) < Vector.MINIMUM_RESOLUTION) {\n      return null;\n    }\n    \n    return Math.atan2(z2, y2);\n  }
1600	public static final VariableContext[] parse(String variable) {\n    char[] text = variable.toCharArray();\n    List<VariableContext> contexts = new ArrayList<>();\n    int i = addMember(text, 0, contexts);     while (i < text.length) {\n      if (text[i] == '[') {\n        if (text[++i] == '\'') {\n          i = addStringIndex(text, i, contexts);\n        } else {\n          i = addIntIndex(text, i, contexts);\n        }\n        ++i;       } else {         i = addMember(text, i + 1, contexts);\n      }\n    }\n    return contexts.toArray(new VariableContext[contexts.size()]);\n  }
1601	public final void clear() {\n    for (int i = 0; i <= size; i++) {\n      heap[i] = null;\n    }\n    size = 0;\n  }
1602	public Cell merge(Cell m, Cell e) {\n    Cell n = new Cell();\n    \n    if (m.skip != e.skip) {\n      return null;\n    }\n    \n    if (m.cmd >= 0) {\n      if (e.cmd >= 0) {\n        if (m.cmd == e.cmd) {\n          n.cmd = m.cmd;\n        } else {\n          return null;\n        }\n      } else {\n        n.cmd = m.cmd;\n      }\n    } else {\n      n.cmd = e.cmd;\n    }\n    if (m.ref >= 0) {\n      if (e.ref >= 0) {\n        if (m.ref == e.ref) {\n          if (m.skip == e.skip) {\n            n.ref = m.ref;\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      } else {\n        n.ref = m.ref;\n      }\n    } else {\n      n.ref = e.ref;\n    }\n    n.cnt = m.cnt + e.cnt;\n    n.skip = m.skip;\n    return n;\n  }
1603	private boolean needToPreserve(char[] input, int inputLength) {\n    if(inputLength != outputPos) {\n      return true;\n    }\n    for(int i = 0; i < inputLength; i++) {\n      if(input[i] != output[i]) {\n        return true;\n      }\n    }\n    return false;\n  }
1604	public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n        for (final LeafReaderContext ctx : context.leaves()) {\n            final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n                    perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }
1605	private ClientAnchorDetail fitImageToColumns(Sheet sheet, int colNumber,\n            double reqImageWidthMM, int resizeBehaviour) {\n\n        double colWidthMM;\n        double colCoordinatesPerMM;\n        int pictureWidthCoordinates;\n        ClientAnchorDetail colClientAnchorDetail = null;\n\n                colWidthMM = ConvertImageUnits.widthUnits2Millimetres(\n                (short)sheet.getColumnWidth(colNumber));\n\n                                                if(colWidthMM < reqImageWidthMM) {\n\n                        if((resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                                                sheet.setColumnWidth(colNumber,\n                        ConvertImageUnits.millimetres2WidthUnits(reqImageWidthMM));\n                                                                                if(sheet instanceof HSSFSheet) {\n                    colWidthMM = reqImageWidthMM;\n                    colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                        colWidthMM;\n                    pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n\n                }\n                else {\n                    pictureWidthCoordinates = (int)reqImageWidthMM * AddDimensionedImage.EMU_PER_MM;\n                }\n                colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                        colNumber, pictureWidthCoordinates);\n            }\n                                                else if ((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                     (resizeBehaviour == AddDimensionedImage.EXPAND_ROW)) {\n                colClientAnchorDetail = this.calculateColumnLocation(sheet,\n                        colNumber, reqImageWidthMM);\n            }\n        }\n                else {\n            if(sheet instanceof HSSFSheet) {\n                                colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                                pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n            }\n            else {\n                pictureWidthCoordinates = (int)reqImageWidthMM *\n                        AddDimensionedImage.EMU_PER_MM;\n            }\n            colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                    colNumber, pictureWidthCoordinates);\n        }\n        return(colClientAnchorDetail);\n    }
1606	private void drawStringInRect(Graphics2D g2, Rectangle2D bounds, Font font,\n                                  String text) {\n\n        g2.setFont(font);\n        FontMetrics fm = g2.getFontMetrics(font);\n        Rectangle2D r = TextUtilities.getTextBounds(text, g2, fm);\n        double x = bounds.getX();\n        if (r.getWidth() < bounds.getWidth()) {\n            x = x + (bounds.getWidth() - r.getWidth()) / 2;\n        }\n        LineMetrics metrics = font.getLineMetrics(\n            text, g2.getFontRenderContext()\n        );\n        g2.drawString(\n            text, (float) x, (float) (bounds.getMaxY()\n                - this.bottomInnerGap - metrics.getDescent())\n        );\n    }
1607	public static int[] findLiveItems(XYDataset dataset, int series,\n            double xLow, double xHigh) {\n                                int i0 = findLiveItemsLowerBound(dataset, series, xLow, xHigh);\n        int i1 = findLiveItemsUpperBound(dataset, series, xLow, xHigh);\n        if (i0 > i1) {\n            i0 = i1;\n        }\n        return new int[] {i0, i1};\n    }
1608	public State complete() {\n    if (this.stateRegistry == null) throw new IllegalStateException();\n    \n    if (root.hasChildren()) replaceOrRegister(root);\n    \n    stateRegistry = null;\n    return root;\n  }
1609	Query makeWithin(Rectangle bbox) {\n\n        \n            Query qMinY = this.makeNumericRangeQuery(field_minY, bbox.getMinY(), null, true, false);\n    Query qMaxY = this.makeNumericRangeQuery(field_maxY, null, bbox.getMaxY(), false, true);\n    Query yConditions = this.makeQuery(BooleanClause.Occur.MUST, qMinY, qMaxY);\n\n        Query xConditions;\n\n    if (ctx.isGeo() && bbox.getMinX() == -180.0 && bbox.getMaxX() == 180.0) {\n            return yConditions;\n\n    } else if (!bbox.getCrossesDateLine()) {\n      \n            Query qMinX = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);\n      Query qMaxX = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);\n      Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);\n\n      double edge = 0;      if (bbox.getMinX() == -180.0)\n        edge = 180;\n      else if (bbox.getMaxX() == 180.0)\n        edge = -180;\n      if (edge != 0 && ctx.isGeo()) {\n        Query edgeQ = makeQuery(BooleanClause.Occur.MUST,\n            makeNumberTermQuery(field_minX, edge), makeNumberTermQuery(field_maxX, edge));\n        qMinMax = makeQuery(BooleanClause.Occur.SHOULD, qMinMax, edgeQ);\n      }\n\n      xConditions = this.makeXDL(false, qMinMax);\n\n          } else {\n\n      \n                  Query qMinXLeft = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);\n      Query qMaxXLeft = this.makeNumericRangeQuery(field_maxX, null, 180.0, false, true);\n      Query qLeft = this.makeQuery(BooleanClause.Occur.MUST, qMinXLeft, qMaxXLeft);\n\n                  Query qMinXRight = this.makeNumericRangeQuery(field_minX, -180.0, null, true, false);\n      Query qMaxXRight = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);\n      Query qRight = this.makeQuery(BooleanClause.Occur.MUST, qMinXRight, qMaxXRight);\n\n                  Query qLeftRight = this.makeQuery(BooleanClause.Occur.SHOULD, qLeft, qRight);\n      Query qNonXDL = this.makeXDL(false, qLeftRight);\n\n                                    Query qXDLLeft = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);\n      Query qXDLRight = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);\n      Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight);\n      Query qXDL = this.makeXDL(true, qXDLLeftRight);\n\n            xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);\n    }\n\n        return this.makeQuery(BooleanClause.Occur.MUST, xConditions, yConditions);\n  }
1610	protected void addItemEntity(EntityCollection entities,\n            CategoryDataset dataset, int row, int column, Shape hotspot) {\n        ParamChecks.nullNotPermitted(hotspot, "hotspot");\n        if (!getItemCreateEntity(row, column)) {\n            return;\n        }\n        String tip = null;\n        CategoryToolTipGenerator tipster = getToolTipGenerator(row, column);\n        if (tipster != null) {\n            tip = tipster.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getItemURLGenerator(row, column);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(hotspot, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }
1611	private void initCharacterRuns() {\n		if (!_charRangeFound) {\n			int[] point = findRange(_characters, _start, _end);\n			_charStart = point[0];\n			_charEnd = point[1];\n			_charRangeFound = true;\n		}\n	}
1612	public static double npv(double r, double[] cfs) {\n        double npv = 0;\n        double r1 = r + 1;\n        double trate = r1;\n        for (int i=0, iSize=cfs.length; i<iSize; i++) {\n            npv += cfs[i] / trate;\n            trate *= r1;\n        }\n        return npv;\n    }
1613	public Reader freeze(boolean trim) {\n    if (frozen) {\n      throw new IllegalStateException("already frozen");\n    }\n    if (didSkipBytes) {\n      throw new IllegalStateException("cannot freeze when copy(BytesRef, BytesRef) was used");\n    }\n    if (trim && upto < blockSize) {\n      final byte[] newBlock = new byte[upto];\n      System.arraycopy(currentBlock, 0, newBlock, 0, upto);\n      currentBlock = newBlock;\n    }\n    if (currentBlock == null) {\n      currentBlock = EMPTY_BYTES;\n    }\n    addBlock(currentBlock);\n    frozen = true;\n    currentBlock = null;\n    return new PagedBytes.Reader(this);\n  }
1614	@SuppressWarnings("unused")\n    public void mergeCells(int firstRow, int lastRow, int firstCol, int lastCol) {\n\n    	if(firstRow > lastRow) {\n    		throw new IllegalArgumentException(\n    			"Cannot merge, first row > last row : "\n    			+ firstRow + " > " + lastRow\n    		);\n    	}\n\n    	if(firstCol > lastCol) {\n    		throw new IllegalArgumentException(\n    			"Cannot merge, first column > last column : "\n    			+ firstCol + " > " + lastCol\n    		);\n    	}\n\n    	int rowSpan = (lastRow - firstRow) + 1;\n    	boolean mergeRowRequired = rowSpan > 1;\n\n    	int colSpan = (lastCol - firstCol) + 1;\n    	boolean mergeColumnRequired = colSpan > 1;\n\n    	for(int i = firstRow; i <= lastRow; i++) {\n\n    		XSLFTableRow row = _rows.get(i);\n\n    		for(int colPos = firstCol; colPos <= lastCol; colPos++) {\n\n    			XSLFTableCell cell = row.getCells().get(colPos);\n\n    			if(mergeRowRequired) {\n	    			if(i == firstRow) {\n	    				cell.setRowSpan(rowSpan);\n	    			} else {\n	    				cell.setVMerge();\n	    			}\n    			}\n    			if(mergeColumnRequired) {\n    				if(colPos == firstCol) {\n    					cell.setGridSpan(colSpan);\n    				} else {\n    					cell.setHMerge();\n    				}\n    			}\n    		}\n    	}\n    }
1615	public Row merge(Row master, Row existing) {\n    Iterator<Character> i = master.cells.keySet().iterator();\n    Row n = new Row();\n    for (; i.hasNext();) {\n      Character ch = i.next();\n            Cell a = master.cells.get(ch);\n      Cell b = existing.cells.get(ch);\n      \n      Cell s = (b == null) ? new Cell(a) : merge(a, b);\n      if (s == null) {\n        return null;\n      }\n      n.cells.put(ch, s);\n    }\n    i = existing.cells.keySet().iterator();\n    for (; i.hasNext();) {\n      Character ch = i.next();\n      if (master.at(ch) != null) {\n        continue;\n      }\n      n.cells.put(ch, existing.at(ch));\n    }\n    return n;\n  }
1616	protected long decode(BytesRef scratch, ByteArrayDataInput tmpInput) {\n    tmpInput.reset(scratch.bytes, scratch.offset, scratch.length);\n    tmpInput.skipBytes(scratch.length - 8);     scratch.length -= Long.BYTES;     return tmpInput.readLong();\n  }
1617	public void moveCursor(double units, RectangleEdge edge) {\n        if (edge == RectangleEdge.TOP) {\n            cursorUp(units);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            cursorDown(units);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            cursorLeft(units);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            cursorRight(units);\n        }\n    }
1618	protected BytesRef decodePayload(BytesRef scratch, ByteArrayDataInput tmpInput) {\n    tmpInput.reset(scratch.bytes, scratch.offset, scratch.length);\n    tmpInput.skipBytes(scratch.length - 2);     short payloadLength = tmpInput.readShort();     assert payloadLength >= 0: payloadLength;\n    tmpInput.setPosition(scratch.offset + scratch.length - 2 - payloadLength);     BytesRef payloadScratch = new BytesRef(payloadLength); \n    tmpInput.readBytes(payloadScratch.bytes, 0, payloadLength);     payloadScratch.length = payloadLength;\n    scratch.length -= 2;     scratch.length -= payloadLength;     return payloadScratch;\n  }
1619	protected void drawGridBandsVertical(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, boolean firstGridBandIsDark, \n            List ticks) {\n\n        boolean currentGridBandIsDark = firstGridBandIsDark;\n        double xx = dataArea.getX();\n        double yy1, yy2;\n\n                double outlineStrokeWidth = 1.0;\n        Stroke outlineStroke = getPlot().getOutlineStroke();\n        if (outlineStroke != null && outlineStroke instanceof BasicStroke) {\n            outlineStrokeWidth = ((BasicStroke) outlineStroke).getLineWidth();\n        }\n\n        Iterator iterator = ticks.iterator();\n        ValueTick tick;\n        Rectangle2D band;\n        while (iterator.hasNext()) {\n            tick = (ValueTick) iterator.next();\n            yy1 = valueToJava2D(tick.getValue() + 0.5d, dataArea,\n                    RectangleEdge.LEFT);\n            yy2 = valueToJava2D(tick.getValue() - 0.5d, dataArea,\n                    RectangleEdge.LEFT);\n            if (currentGridBandIsDark) {\n                g2.setPaint(this.gridBandPaint);\n            }\n            else {\n                g2.setPaint(this.gridBandAlternatePaint);\n            }\n            band = new Rectangle2D.Double(xx + outlineStrokeWidth, \n                    Math.min(yy1, yy2), dataArea.getMaxX() - xx \n                    - outlineStrokeWidth, Math.abs(yy2 - yy1));\n            g2.fill(band);\n            currentGridBandIsDark = !currentGridBandIsDark;\n        }\n    }
1620	private int calcSize() throws WritingNotSupportedException, IOException {\n        sectionBytes.reset();\n        write(sectionBytes);\n        padSectionBytes();\n        return sectionBytes.size();\n    }
1621	private static PrintSetupRecord createPrintSetup() {\n        PrintSetupRecord retval = new PrintSetupRecord();\n\n        retval.setPaperSize(( short ) 1);\n        retval.setScale(( short ) 100);\n        retval.setPageStart(( short ) 1);\n        retval.setFitWidth(( short ) 1);\n        retval.setFitHeight(( short ) 1);\n        retval.setOptions(( short ) 2);\n        retval.setHResolution(( short ) 300);\n        retval.setVResolution(( short ) 300);\n        retval.setHeaderMargin( 0.5);\n        retval.setFooterMargin( 0.5);\n        retval.setCopies(( short ) 1);\n        return retval;\n    }
1622	public IndexableField getField(FieldInfo fieldInfo) {  \n\n    fieldNames.add(fieldInfo.name);\n    List<LazyField> values = fields.get(fieldInfo.number);\n    if (null == values) {\n      values = new ArrayList<>();\n      fields.put(fieldInfo.number, values);\n    } \n\n    LazyField value = new LazyField(fieldInfo.name, fieldInfo.number);\n    values.add(value);\n\n    synchronized (this) {\n                              doc = null;\n    }\n    return value;\n  }
1623	public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    \n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n        Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException("number of groups differs across shards; you must pass same top groups to all shards' second-pass collector");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({"unchecked","rawtypes"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n            float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n                final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException("group values differ across shards; you must pass same top groups to all shards' second-pass collector");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException("group values differ across shards; you must pass same top groups to all shards' second-pass collector");\n        }\n\n        "      doc="\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n            final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException("can't handle ScoreMergeMode " + scoreMergeMode);\n      }\n        \n            mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }
1624	public AxisSpace reserveSpace(Graphics2D g2, Plot plot,\n                                  Rectangle2D plotArea,\n                                  Rectangle2D dataArea, RectangleEdge edge,\n                                  AxisSpace space) {\n\n        AxisSpace result = this.axis.reserveSpace(g2, plot, plotArea, edge,\n                space);\n        double thickness = calculateBarThickness(dataArea, edge);\n        result.add(thickness + 2 * this.outerGap, edge);\n        return result;\n\n    }
1625	private static void hexDumpAligned(Writer w, byte[] data, int dumpLen, int globalOffset,\n			boolean zeroAlignEachRecord) {\n		int baseDataOffset = 0;\n\n				int globalStart = globalOffset + baseDataOffset;\n		int globalEnd = globalOffset + baseDataOffset + dumpLen;\n		int startDelta = globalStart % DUMP_LINE_LEN;\n		int endDelta = globalEnd % DUMP_LINE_LEN;\n		if (zeroAlignEachRecord) {\n			endDelta -= startDelta;\n			if (endDelta < 0) {\n				endDelta += DUMP_LINE_LEN;\n			}\n			startDelta = 0;\n		}\n		int startLineAddr;\n		int endLineAddr;\n		if (zeroAlignEachRecord) {\n			endLineAddr = globalEnd - endDelta - (globalStart - startDelta);\n			startLineAddr = 0;\n		} else {\n			startLineAddr = globalStart - startDelta;\n			endLineAddr = globalEnd - endDelta;\n		}\n\n		int lineDataOffset = baseDataOffset - startDelta;\n		int lineAddr = startLineAddr;\n\n				if (startLineAddr == endLineAddr) {\n			hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, endDelta);\n			return;\n		}\n		hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, DUMP_LINE_LEN);\n\n				while (true) {\n			lineAddr += DUMP_LINE_LEN;\n			lineDataOffset += DUMP_LINE_LEN;\n			if (lineAddr >= endLineAddr) {\n				break;\n			}\n			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, DUMP_LINE_LEN);\n		}\n\n\n				if (endDelta != 0) {\n			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, endDelta);\n		}\n	}
1626	protected synchronized void closeResources() throws IOException {\n    if (initializedReaderManager) {\n      readerManager.close();\n      readerManager = null;\n      initializedReaderManager = false;\n    }\n    if (cache != null) {\n      cache.close();\n    }\n  }
1627	public void add(String dim, Query subQuery) {\n    assert drillDownDims.size() == dimQueries.size();\n    if (drillDownDims.containsKey(dim) == false) {\n      drillDownDims.put(dim, drillDownDims.size());\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      dimQueries.add(builder);\n    }\n    final int index = drillDownDims.get(dim);\n    dimQueries.get(index).add(subQuery, Occur.SHOULD);\n  }
1628	private SortedSet<String> getIANARootZoneDatabase() throws IOException {\n    final SortedSet<String> TLDs = new TreeSet<>();\n    final URLConnection connection = tldFileURL.openConnection();\n    connection.setUseCaches(false);\n    connection.addRequestProperty("Cache-Control", "no-cache");\n    connection.connect();\n    tldFileLastModified = connection.getLastModified();\n    BufferedReader reader = new BufferedReader\n      (new InputStreamReader(connection.getInputStream(), StandardCharsets.US_ASCII));\n    try {\n      String line;\n      while (null != (line = reader.readLine())) {\n        Matcher matcher = TLD_PATTERN_1.matcher(line);\n        if (matcher.matches()) {\n          TLDs.add(matcher.group(1).toLowerCase(Locale.ROOT));\n        } else {\n          matcher = TLD_PATTERN_2.matcher(line);\n          if (matcher.matches()) {\n            TLDs.add(matcher.group(1).toLowerCase(Locale.ROOT));\n          }\n        }\n      }\n    } finally {\n      reader.close();\n    }\n    return TLDs;\n  }
1629	public static byte getType(int ch) {\n    switch (Character.getType(ch)) {\n      case Character.UPPERCASE_LETTER: return UPPER;\n      case Character.LOWERCASE_LETTER: return LOWER;\n\n      case Character.TITLECASE_LETTER:\n      case Character.MODIFIER_LETTER:\n      case Character.OTHER_LETTER:\n      case Character.NON_SPACING_MARK:\n      case Character.ENCLOSING_MARK:        case Character.COMBINING_SPACING_MARK:\n        return ALPHA; \n\n      case Character.DECIMAL_DIGIT_NUMBER:\n      case Character.LETTER_NUMBER:\n      case Character.OTHER_NUMBER:\n        return DIGIT;\n\n                                    \n      case Character.SURROGATE:          return ALPHA|DIGIT;  \n\n                                                                  \n      default: return SUBWORD_DELIM;\n    }\n  }
1630	public void add(Number mean, Number standardDeviation,\n                    Comparable rowKey, Comparable columnKey) {\n        MeanAndStandardDeviation item = new MeanAndStandardDeviation(\n                mean, standardDeviation);\n        this.data.addObject(item, rowKey, columnKey);\n\n        double m = Double.NaN;\n        double sd = Double.NaN;\n        if (mean != null) {\n            m = mean.doubleValue();\n        }\n        if (standardDeviation != null) {\n            sd = standardDeviation.doubleValue();\n        }\n\n                int r = this.data.getColumnIndex(columnKey);\n        int c = this.data.getRowIndex(rowKey);\n        if ((r == this.maximumRangeValueRow && c\n                == this.maximumRangeValueColumn) || (r\n                == this.maximumRangeValueIncStdDevRow && c\n                == this.maximumRangeValueIncStdDevColumn) || (r\n                == this.minimumRangeValueRow && c\n                == this.minimumRangeValueColumn) || (r\n                == this.minimumRangeValueIncStdDevRow && c\n                == this.minimumRangeValueIncStdDevColumn)) {\n\n                        updateBounds();\n        }\n        else {\n            if (!Double.isNaN(m)) {\n                if (Double.isNaN(this.maximumRangeValue)\n                        || m > this.maximumRangeValue) {\n                    this.maximumRangeValue = m;\n                    this.maximumRangeValueRow = r;\n                    this.maximumRangeValueColumn = c;\n                }\n            }\n\n            if (!Double.isNaN(m + sd)) {\n                if (Double.isNaN(this.maximumRangeValueIncStdDev)\n                        || (m + sd) > this.maximumRangeValueIncStdDev) {\n                    this.maximumRangeValueIncStdDev = m + sd;\n                    this.maximumRangeValueIncStdDevRow = r;\n                    this.maximumRangeValueIncStdDevColumn = c;\n                }\n            }\n\n            if (!Double.isNaN(m)) {\n                if (Double.isNaN(this.minimumRangeValue)\n                        || m < this.minimumRangeValue) {\n                    this.minimumRangeValue = m;\n                    this.minimumRangeValueRow = r;\n                    this.minimumRangeValueColumn = c;\n                }\n            }\n\n            if (!Double.isNaN(m - sd)) {\n                if (Double.isNaN(this.minimumRangeValueIncStdDev)\n                        || (m - sd) < this.minimumRangeValueIncStdDev) {\n                    this.minimumRangeValueIncStdDev = m - sd;\n                    this.minimumRangeValueIncStdDevRow = r;\n                    this.minimumRangeValueIncStdDevColumn = c;\n                }\n            }\n        }\n        fireDatasetChanged();\n    }
1631	public void addFootnoteReference(XWPFAbstractFootnoteEndnote footnote) {\n        XWPFRun run = createRun();\n        CTR ctRun = run.getCTR();\n        ctRun.addNewRPr().addNewRStyle().setVal("FootnoteReference");\n        if (footnote instanceof XWPFEndnote) {\n            ctRun.addNewEndnoteReference().setId(footnote.getId());\n        } else {\n            ctRun.addNewFootnoteReference().setId(footnote.getId());\n        }\n    }
1632	private void handleExportToSVG() {\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle("Export to SVG");\n        fileChooser.setSelectedExtensionFilter(new FileChooser.ExtensionFilter(\n                "Scalable Vector Graphics (SVG)", "svg"));\n        File file = fileChooser.showSaveDialog(this.getScene().getWindow());\n        if (file != null) {\n            ExportUtils.writeAsSVG(this.chart, (int) getWidth(), \n                    (int) getHeight(), file);\n        }\n    }
1633	protected void drawSecondaryPass(Graphics2D g2, XYPlot plot, \n            XYDataset dataset, int pass, int series, int item,\n            ValueAxis domainAxis, Rectangle2D dataArea, ValueAxis rangeAxis,\n            CrosshairState crosshairState, EntityCollection entities) {\n\n        Shape entityArea = null;\n\n                double x1 = dataset.getXValue(series, item);\n        double y1 = dataset.getYValue(series, item);\n        if (Double.isNaN(y1) || Double.isNaN(x1)) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation);\n        double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation);\n\n        if (getItemShapeVisible(series, item)) {\n            Shape shape = getItemShape(series, item);\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                shape = ShapeUtilities.createTranslatedShape(shape, transY1,\n                        transX1);\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                shape = ShapeUtilities.createTranslatedShape(shape, transX1,\n                        transY1);\n            }\n            entityArea = shape;\n            if (shape.intersects(dataArea)) {\n                if (getItemShapeFilled(series, item)) {\n                    if (this.useFillPaint) {\n                        g2.setPaint(getItemFillPaint(series, item));\n                    }\n                    else {\n                        g2.setPaint(getItemPaint(series, item));\n                    }\n                    g2.fill(shape);\n                }\n                if (this.drawOutlines) {\n                    if (getUseOutlinePaint()) {\n                        g2.setPaint(getItemOutlinePaint(series, item));\n                    }\n                    else {\n                        g2.setPaint(getItemPaint(series, item));\n                    }\n                    g2.setStroke(getItemOutlineStroke(series, item));\n                    g2.draw(shape);\n                }\n            }\n        }\n\n        double xx = transX1;\n        double yy = transY1;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            xx = transY1;\n            yy = transX1;\n        }\n\n                if (isItemLabelVisible(series, item)) {\n            drawItemLabel(g2, orientation, dataset, series, item, xx, yy,\n                    (y1 < 0.0));\n        }\n\n        int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);\n        int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);\n        updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,\n                rangeAxisIndex, transX1, transY1, orientation);\n\n                        if (entities != null && isPointInRect(dataArea, xx, yy)) {\n            addEntity(entities, entityArea, dataset, series, item, xx, yy);\n        }\n    }
1634	public static long calculateChecksum(InputStream stream) throws IOException {\n        Checksum sum = new CRC32();\n\n        byte[] buf = new byte[4096];\n        int count;\n        while ((count = stream.read(buf)) != -1) {\n            if (count > 0) {\n                sum.update(buf, 0, count);\n            }\n        }\n        return sum.getValue();\n    }
1635	private static void copyProperties(PackageProperties src, PackageProperties tgt) {\n        tgt.setCategoryProperty(src.getCategoryProperty());\n        tgt.setContentStatusProperty(src.getContentStatusProperty());\n        tgt.setContentTypeProperty(src.getContentTypeProperty());\n        tgt.setCreatorProperty(src.getCreatorProperty());\n        tgt.setDescriptionProperty(src.getDescriptionProperty());\n        tgt.setIdentifierProperty(src.getIdentifierProperty());\n        tgt.setKeywordsProperty(src.getKeywordsProperty());\n        tgt.setLanguageProperty(src.getLanguageProperty());\n        tgt.setRevisionProperty(src.getRevisionProperty());\n        tgt.setSubjectProperty(src.getSubjectProperty());\n        tgt.setTitleProperty(src.getTitleProperty());\n        tgt.setVersionProperty(src.getVersionProperty());\n    }
1636	private void compareNumberOfRowsInSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n\n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n            \n            int num1 = loc1.sheet.getPhysicalNumberOfRows();\n            int num2 = loc2.sheet.getPhysicalNumberOfRows();\n\n            if (num1 != num2) {\n                String str = String.format(Locale.ROOT, "%s\nworkbook1 -> %s [%d] != workbook2 -> %s [%d]",\n                    "Number Of Rows does not Match ::",\n                    loc1.sheet.getSheetName(), num1,\n                    loc2.sheet.getSheetName(), num2\n                );\n                listOfDifferences.add(str);\n            }\n        }\n\n    }
1637	protected void drawChipGrid(Graphics2D g2, Rectangle2D plotArea) {\n\n        Shape savedClip = g2.getClip();\n        g2.setClip(getWaferEdge(plotArea));\n        Rectangle2D chip = new Rectangle2D.Double();\n        int xchips = 35;\n        int ychips = 20;\n        double space = 1d;\n        if (this.dataset != null) {\n            xchips = this.dataset.getMaxChipX() + 2;\n            ychips = this.dataset.getMaxChipY() + 2;\n            space = this.dataset.getChipSpace();\n        }\n        double startX = plotArea.getX();\n        double startY = plotArea.getY();\n        double chipWidth = 1d;\n        double chipHeight = 1d;\n        if (plotArea.getWidth() != plotArea.getHeight()) {\n            double major, minor;\n            if (plotArea.getWidth() > plotArea.getHeight()) {\n                major = plotArea.getWidth();\n                minor = plotArea.getHeight();\n            }\n            else {\n                major = plotArea.getHeight();\n                minor = plotArea.getWidth();\n            }\n                        if (plotArea.getWidth() == minor) {                 startY += (major - minor) / 2;\n                chipWidth = (plotArea.getWidth() - (space * xchips - 1))\n                    / xchips;\n                chipHeight = (plotArea.getWidth() - (space * ychips - 1))\n                    / ychips;\n            }\n            else {                 startX += (major - minor) / 2;\n                chipWidth = (plotArea.getHeight() - (space * xchips - 1))\n                    / xchips;\n                chipHeight = (plotArea.getHeight() - (space * ychips - 1))\n                    / ychips;\n            }\n        }\n\n        for (int x = 1; x <= xchips; x++) {\n            double upperLeftX = (startX - chipWidth) + (chipWidth * x)\n                + (space * (x - 1));\n            for (int y = 1; y <= ychips; y++) {\n                double upperLeftY = (startY - chipHeight) + (chipHeight * y)\n                    + (space * (y - 1));\n                chip.setFrame(upperLeftX, upperLeftY, chipWidth, chipHeight);\n                g2.setColor(Color.white);\n                if (this.dataset.getChipValue(x - 1, ychips - y - 1) != null) {\n                    g2.setPaint(\n                        this.renderer.getChipColor(\n                            this.dataset.getChipValue(x - 1, ychips - y - 1)\n                        )\n                    );\n                }\n                g2.fill(chip);\n                g2.setColor(Color.lightGray);\n                g2.draw(chip);\n            }\n        }\n        g2.setClip(savedClip);\n    }
1638	public XWPFTable createTable() {\n        XWPFTable table = new XWPFTable(ctDocument.getBody().addNewTbl(), this);\n        bodyElements.add(table);\n        tables.add(table);\n        return table;\n    }
1639	protected int isGeoAreaShapeInsideShape(final GeoShape geoshape)  {\n    boolean foundOutside = false;\n    boolean foundInside = false;\n    for (GeoPoint p : getEdgePoints()) {\n      if (geoshape.isWithin(p)) {\n        foundInside = true;\n      } else {\n        foundOutside = true;\n      }\n      if (foundInside && foundOutside) {\n        return SOME_INSIDE;\n      }\n    }\n    if (!foundInside && !foundOutside)\n      return NONE_INSIDE;\n    if (foundInside && !foundOutside)\n      return ALL_INSIDE;\n    if (foundOutside && !foundInside)\n      return NONE_INSIDE;\n    return SOME_INSIDE;\n  }
1640	public static boolean hasExactSharedBorder(CellRangeAddress crA, CellRangeAddress crB) {\n        int oFirstRow = crB.getFirstRow();\n        int oLastRow  = crB.getLastRow();\n        int oFirstCol = crB.getFirstColumn();\n        int oLastCol  = crB.getLastColumn();\n\n        if (crA.getFirstRow() > 0 && crA.getFirstRow()-1 == oLastRow || \n                oFirstRow > 0 && oFirstRow-1 == crA.getLastRow()) {\n                                    return crA.getFirstColumn() == oFirstCol && crA.getLastColumn() == oLastCol;\n        }\n\n        if (crA.getFirstColumn()>0 && crA.getFirstColumn() - 1 == oLastCol ||\n                oFirstCol>0 && crA.getLastColumn() == oFirstCol -1) {\n                                    return crA.getFirstRow() == oFirstRow && crA.getLastRow() == oLastRow;\n        }\n        return false;\n    }
1641	protected static Map<Short, Constructor<? extends EscherRecord>> recordsToMap(Class<?>[] recClasses) {\n        Map<Short, Constructor<? extends EscherRecord>> result = new HashMap<>();\n        final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n\n        for (Class<?> recClass : recClasses) {\n            @SuppressWarnings("unchecked")\n            Class<? extends EscherRecord> recCls = (Class<? extends EscherRecord>) recClass;\n            short sid;\n            try {\n                sid = recCls.getField("RECORD_ID").getShort(null);\n            } catch (IllegalArgumentException e) {\n                throw new RuntimeException(e);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(e);\n            } catch (NoSuchFieldException e) {\n                throw new RuntimeException(e);\n            }\n            Constructor<? extends EscherRecord> constructor;\n            try {\n                constructor = recCls.getConstructor(EMPTY_CLASS_ARRAY);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(e);\n            }\n            result.put(Short.valueOf(sid), constructor);\n        }\n        return result;\n    }
1642	private static void checkFunction(Method method) {\n        final MethodType type;\n    try {\n      type = MethodHandles.publicLookup().unreflect(method).type();\n    } catch (IllegalAccessException iae) {\n      throw new IllegalArgumentException(method + " is not accessible (declaring class or method not public).");\n    }\n        if (!Modifier.isStatic(method.getModifiers())) {\n      throw new IllegalArgumentException(method + " is not static.");\n    }\n    for (int arg = 0, arity = type.parameterCount(); arg < arity; arg++) {\n      if (type.parameterType(arg) != double.class) {\n        throw new IllegalArgumentException(method + " must take only double parameters.");\n      }\n    }\n    if (type.returnType() != double.class) {\n      throw new IllegalArgumentException(method + " does not return a double.");\n    }\n  }
1643	public static long shallowSizeOf(Object obj) {\n    if (obj == null) return 0;\n    final Class<?> clz = obj.getClass();\n    if (clz.isArray()) {\n      return shallowSizeOfArray(obj);\n    } else {\n      return shallowSizeOfInstance(clz);\n    }\n  }
1644	private Ptg columnCopyRefPtg(RefPtgBase rptg) {\n        final int refColumn = rptg.getColumn();\n        if (rptg.isColRelative()) {\n                        final int destColumnIndex = _firstMovedIndex + _amountToMove;\n            if (destColumnIndex < 0 || _version.getLastColumnIndex() < destColumnIndex) {\n                return createDeletedRef(rptg);\n            }\n\n                        final int newColumnIndex = refColumn + _amountToMove;\n            if(newColumnIndex < 0 || _version.getLastColumnIndex() < newColumnIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            rptg.setColumn(newColumnIndex);\n            return rptg;\n        }\n        return null;\n    }
1645	@Beta\n    public void addColLabel(int columnIndex, String valueFormat) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        final int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_COL);\n        pivotField.setShowAll(false);\n        if (valueFormat != null && !valueFormat.trim().isEmpty()) {\n            DataFormat df = parentSheet.getWorkbook().createDataFormat();\n            pivotField.setNumFmtId(df.getFormat(valueFormat));\n        }\n        for (int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTColFields colFields;\n        if(pivotTableDefinition.getColFields() != null) {\n            colFields = pivotTableDefinition.getColFields();\n        } else {\n            colFields = pivotTableDefinition.addNewColFields();\n        }\n\n        colFields.addNewField().setX(columnIndex);\n        colFields.setCount(colFields.sizeOfFieldArray());\n    }
1646	private void concatenate(WordDelimiterConcatenation concatenation) {\n    if (concatenation.isEmpty()) {\n      concatenation.type = iterator.type();\n      concatenation.startPart = iterator.current;\n      concatenation.startPos = wordPos;\n    }\n    concatenation.append(savedTermBuffer, iterator.current, iterator.end - iterator.current);\n    concatenation.endPart = iterator.end;\n  }
1647	private boolean checkCondition(int condition, char c1[], int c1off, int c1len, char c2[], int c2off, int c2len) {\n    if (condition != 0) {\n      CharacterRunAutomaton pattern = dictionary.patterns.get(condition);\n      int state = 0;\n      for (int i = c1off; i < c1off + c1len; i++) {\n        state = pattern.step(state, c1[i]);\n        if (state == -1) {\n          return false;\n        }\n      }\n      for (int i = c2off; i < c2off + c2len; i++) {\n        state = pattern.step(state, c2[i]);\n        if (state == -1) {\n          return false;\n        }\n      }\n      return pattern.isAccept(state);\n    }\n    return true;\n  }
1648	public static int[] findItemIndicesForX(XYDataset dataset, int series,\n            double x) {\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        int itemCount = dataset.getItemCount(series);\n        if (itemCount == 0) {\n            return new int[] {-1, -1};\n        }\n        if (itemCount == 1) {\n            if (x == dataset.getXValue(series, 0)) {\n                return new int[] {0, 0};\n            } else {\n                return new int[] {-1, -1};\n            }\n        }\n        if (dataset.getDomainOrder() == DomainOrder.ASCENDING) {\n            int low = 0;\n            int high = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue > x) {\n                return new int[] {-1, -1};\n            }\n            if (lowValue == x) {\n                return new int[] {low, low};\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue < x) {\n                return new int[] {-1, -1};\n            }\n            if (highValue == x) {\n                return new int[] {high, high};\n            }\n            int mid = (low + high) / 2;\n            while (high - low > 1) {\n                double midV = dataset.getXValue(series, mid);\n                if (x == midV) {\n                    return new int[] {mid, mid};\n                }\n                if (midV < x) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n                mid = (low + high) / 2;\n            }\n            return new int[] {low, high};\n        }\n        else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) {\n            int high = 0;\n            int low = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue > x) {\n                return new int[] {-1, -1};\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue < x) {\n                return new int[] {-1, -1};\n            }\n            int mid = (low + high) / 2;\n            while (high - low > 1) {\n                double midV = dataset.getXValue(series, mid);\n                if (x == midV) {\n                    return new int[] {mid, mid};\n                }\n                if (midV < x) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n                mid = (low + high) / 2;\n            }\n            return new int[] {low, high};\n        }\n        else {\n                                                double prev = dataset.getXValue(series, 0);\n            if (x == prev) {\n                return new int[] {0, 0};             }\n            for (int i = 1; i < itemCount; i++) {\n                double next = dataset.getXValue(series, i);\n                if (x == next) {\n                    return new int[] {i, i};                 }\n                if ((x > prev && x < next) || (x < prev && x > next)) {\n                    return new int[] {i - 1, i};                 }\n            }\n            return new int[] {-1, -1};         }\n    }
1649	public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n                final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n        if (filteredPointList == null) {\n      return null;\n    }\n                final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n                  final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n            final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n                                return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n          }\n    throw new IllegalArgumentException("cannot find a point that is inside the polygon "+filteredPointList);\n  }
1650	public void add(BoxAndWhiskerItem item, Comparable rowKey,\n            Comparable columnKey) {\n\n        this.data.addObject(item, rowKey, columnKey);\n\n                int r = this.data.getRowIndex(rowKey);\n        int c = this.data.getColumnIndex(columnKey);\n        if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn\n                == c) || (this.minimumRangeValueRow == r\n                && this.minimumRangeValueColumn == c))  {\n            updateBounds();\n        }\n        else {\n\n            double minval = Double.NaN;\n            if (item.getMinOutlier() != null) {\n                minval = item.getMinOutlier().doubleValue();\n            }\n            double maxval = Double.NaN;\n            if (item.getMaxOutlier() != null) {\n                maxval = item.getMaxOutlier().doubleValue();\n            }\n\n            if (Double.isNaN(this.maximumRangeValue)) {\n                this.maximumRangeValue = maxval;\n                this.maximumRangeValueRow = r;\n                this.maximumRangeValueColumn = c;\n            }\n            else if (maxval > this.maximumRangeValue) {\n                this.maximumRangeValue = maxval;\n                this.maximumRangeValueRow = r;\n                this.maximumRangeValueColumn = c;\n            }\n\n            if (Double.isNaN(this.minimumRangeValue)) {\n                this.minimumRangeValue = minval;\n                this.minimumRangeValueRow = r;\n                this.minimumRangeValueColumn = c;\n            }\n            else if (minval < this.minimumRangeValue) {\n                this.minimumRangeValue = minval;\n                this.minimumRangeValueRow = r;\n                this.minimumRangeValueColumn = c;\n            }\n        }\n\n        fireDatasetChanged();\n\n    }
1651	private static String getFormulaFromTextExpression(String textExpr) {\n		if (textExpr == null) {\n			return null;\n		}\n		if (textExpr.length() < 1) {\n			throw new IllegalArgumentException("Empty string is not a valid formula/value expression");\n		}\n		if (textExpr.charAt(0) == '=') {\n			return textExpr.substring(1);\n		}\n		return null;\n	}
1652	public void nextRecord() throws RecordFormatException {\n		if (_nextSid == INVALID_SID_VALUE) {\n			throw new IllegalStateException("EOF - next record not available");\n		}\n		if (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {\n			throw new IllegalStateException("Cannot call nextRecord() without checking hasNextRecord() first");\n		}\n		_currentSid = _nextSid;\n		_currentDataOffset = 0;\n		_currentDataLength = _bhi.readDataSize();\n		if (_currentDataLength > MAX_RECORD_DATA_SIZE) {\n			throw new RecordFormatException("The content of an excel record cannot exceed "\n					+ MAX_RECORD_DATA_SIZE + " bytes");\n		}\n	}
1653	static void expiry(Sheet sheet) {\n        CellStyle style = sheet.getWorkbook().createCellStyle();\n        style.setDataFormat((short)BuiltinFormats.getBuiltinFormat("d-mmm"));\n\n        sheet.createRow(0).createCell(0).setCellValue("Date");\n        sheet.createRow(1).createCell(0).setCellFormula("TODAY()+29");\n        sheet.createRow(2).createCell(0).setCellFormula("A2+1");\n        sheet.createRow(3).createCell(0).setCellFormula("A3+1");\n\n        for(int rownum = 1; rownum <= 3; rownum++) {\n            sheet.getRow(rownum).getCell(0).setCellStyle(style);\n        }\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("AND(A2-TODAY()>=0,A2-TODAY()<=30)");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontStyle(false, true);\n        font.setFontColorIndex(IndexedColors.BLUE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A4")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(0).createCell(1).setCellValue("Dates within the next 30 days are highlighted");\n    }
1654	public String toString(Calendar cal) {\n    final int calPrecField = getCalPrecisionField(cal);    if (calPrecField == -1)\n      return "*";\n    try {\n      StringBuilder builder = new StringBuilder("yyyy-MM-dd'T'HH:mm:ss.SSS".length());      int year = cal.get(Calendar.YEAR);       if (cal.get(Calendar.ERA) == 0) {         year -= 1;         if (year > 0) {\n          builder.append('-');\n        }\n      } else if (year > 9999) {\n        builder.append('+');\n      }\n      appendPadded(builder, year, (short) 4);\n      if (calPrecField >= Calendar.MONTH) {\n        builder.append('-');\n        appendPadded(builder, cal.get(Calendar.MONTH) + 1, (short) 2);       }\n      if (calPrecField >= Calendar.DAY_OF_MONTH) {\n        builder.append('-');\n        appendPadded(builder, cal.get(Calendar.DAY_OF_MONTH), (short) 2);\n      }\n      if (calPrecField >= Calendar.HOUR_OF_DAY) {\n        builder.append('T');\n        appendPadded(builder, cal.get(Calendar.HOUR_OF_DAY), (short) 2);\n      }\n      if (calPrecField >= Calendar.MINUTE) {\n        builder.append(':');\n        appendPadded(builder, cal.get(Calendar.MINUTE), (short) 2);\n      }\n      if (calPrecField >= Calendar.SECOND) {\n        builder.append(':');\n        appendPadded(builder, cal.get(Calendar.SECOND), (short) 2);\n      }\n      if (calPrecField >= Calendar.MILLISECOND && cal.get(Calendar.MILLISECOND) > 0) {         builder.append('.');\n        appendPadded(builder,  cal.get(Calendar.MILLISECOND), (short) 3);\n      }\n\n      return builder.toString();\n    } finally {\n      clearFieldsAfter(cal, calPrecField);    }\n  }
1655	public XWPFTableRow createRow() {\n        int sizeCol = ctTbl.sizeOfTrArray() > 0 ? ctTbl.getTrArray(0)\n                .sizeOfTcArray() : 0;\n        XWPFTableRow tabRow = new XWPFTableRow(ctTbl.addNewTr(), this);\n        addColumn(tabRow, sizeCol);\n        tableRows.add(tabRow);\n        return tabRow;\n    }
1656	@Beta\n    public void addColumnLabel(DataConsolidateFunction function, int columnIndex, String valueFieldName, String valueFormat) {\n        checkColumnIndex(columnIndex);\n\n        addDataColumn(columnIndex, true);\n        addDataField(function, columnIndex, valueFieldName, valueFormat);\n\n                if (pivotTableDefinition.getDataFields().getCount() == 2) {\n            CTColFields colFields;\n            if(pivotTableDefinition.getColFields() != null) {\n                colFields = pivotTableDefinition.getColFields();\n            } else {\n                colFields = pivotTableDefinition.addNewColFields();\n            }\n            colFields.addNewField().setX(-2);\n            colFields.setCount(colFields.sizeOfFieldArray());\n        }\n    }
1657	public CellFormatResult apply(Object value) {\n        boolean applies = applies(value);\n        String text;\n        Color textColor;\n        if (applies) {\n            text = format.format(value);\n            textColor = color;\n        } else {\n            text = format.simpleFormat(value);\n            textColor = null;\n        }\n        return new CellFormatResult(applies, text, textColor);\n    }
1658	public void setRangeZoomable(boolean flag) {\n        if (flag) {\n            Plot plot = this.chart.getPlot();\n            if (plot instanceof Zoomable) {\n                Zoomable z = (Zoomable) plot;\n                this.rangeZoomable = flag && (z.isRangeZoomable());\n            }\n        }\n        else {\n            this.rangeZoomable = false;\n        }\n    }
1659	protected Size2D arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        List blocks = container.getBlocks();\n\n        double height = constraint.getHeight();\n        if (height <= 0.0) {\n            height = Double.POSITIVE_INFINITY;\n        }\n\n        double x = 0.0;\n        double y = 0.0;\n        double maxWidth = 0.0;\n        List itemsInColumn = new ArrayList();\n        for (int i = 0; i < blocks.size(); i++) {\n            Block block = (Block) blocks.get(i);\n            Size2D size = block.arrange(g2, RectangleConstraint.NONE);\n            if (y + size.height <= height) {\n                itemsInColumn.add(block);\n                block.setBounds(\n                    new Rectangle2D.Double(x, y, size.width, size.height)\n                );\n                y = y + size.height + this.verticalGap;\n                maxWidth = Math.max(maxWidth, size.width);\n            }\n            else {\n                if (itemsInColumn.isEmpty()) {\n                                        block.setBounds(\n                        new Rectangle2D.Double(\n                            x, y, size.width, Math.min(size.height, height - y)\n                        )\n                    );\n                    y = 0.0;\n                    x = x + size.width + this.horizontalGap;\n                }\n                else {\n                                        itemsInColumn.clear();\n                    x = x + maxWidth + this.horizontalGap;\n                    y = 0.0;\n                    maxWidth = size.width;\n                    block.setBounds(\n                        new Rectangle2D.Double(\n                            x, y, size.width, Math.min(size.height, height)\n                        )\n                    );\n                    y = size.height + this.verticalGap;\n                    itemsInColumn.add(block);\n                }\n            }\n        }\n        return new Size2D(x + maxWidth, constraint.getHeight());\n    }
1660	protected static void setCertID\n        (CertIDType certId, SignatureConfig signatureConfig, boolean issuerNameNoReverseOrder, X509Certificate certificate) {\n        X509IssuerSerialType issuerSerial = certId.addNewIssuerSerial();\n        String issuerName;\n        if (issuerNameNoReverseOrder) {\n            \n                                    issuerName = certificate.getIssuerDN().getName().replace(",", ", ");\n        } else {\n            issuerName = certificate.getIssuerX500Principal().toString();\n        }\n        issuerSerial.setX509IssuerName(issuerName);\n        issuerSerial.setX509SerialNumber(certificate.getSerialNumber());\n\n        byte[] encodedCertificate;\n        try {\n            encodedCertificate = certificate.getEncoded();\n        } catch (CertificateEncodingException e) {\n            throw new RuntimeException("certificate encoding error: "\n                    + e.getMessage(), e);\n        }\n        DigestAlgAndValueType certDigest = certId.addNewCertDigest(); \n        setDigestAlgAndValue(certDigest, encodedCertificate, signatureConfig.getXadesDigestAlgo());\n    }
1661	protected void drawTickMarksHorizontal(Graphics2D g2, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        List ticks = new ArrayList();\n        double x0;\n        double y0 = state.getCursor();\n        double insideLength = getTickMarkInsideLength();\n        double outsideLength = getTickMarkOutsideLength();\n        RegularTimePeriod t = createInstance(this.majorTickTimePeriodClass, \n                this.first.getStart(), getTimeZone(), this.locale);\n        long t0 = t.getFirstMillisecond();\n        Line2D inside = null;\n        Line2D outside = null;\n        long firstOnAxis = getFirst().getFirstMillisecond();\n        long lastOnAxis = getLast().getLastMillisecond() + 1;\n        while (t0 <= lastOnAxis) {\n            ticks.add(new NumberTick(Double.valueOf(t0), "", TextAnchor.CENTER,\n                    TextAnchor.CENTER, 0.0));\n            x0 = valueToJava2D(t0, dataArea, edge);\n            if (edge == RectangleEdge.TOP) {\n                inside = new Line2D.Double(x0, y0, x0, y0 + insideLength);\n                outside = new Line2D.Double(x0, y0, x0, y0 - outsideLength);\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                inside = new Line2D.Double(x0, y0, x0, y0 - insideLength);\n                outside = new Line2D.Double(x0, y0, x0, y0 + outsideLength);\n            }\n            if (t0 >= firstOnAxis) {\n                g2.setPaint(getTickMarkPaint());\n                g2.setStroke(getTickMarkStroke());\n                g2.draw(inside);\n                g2.draw(outside);\n            }\n                        if (this.minorTickMarksVisible) {\n                RegularTimePeriod tminor = createInstance(\n                        this.minorTickTimePeriodClass, new Date(t0),\n                        getTimeZone(), this.locale);\n                long tt0 = tminor.getFirstMillisecond();\n                while (tt0 < t.getLastMillisecond()\n                        && tt0 < lastOnAxis) {\n                    double xx0 = valueToJava2D(tt0, dataArea, edge);\n                    if (edge == RectangleEdge.TOP) {\n                        inside = new Line2D.Double(xx0, y0, xx0,\n                                y0 + this.minorTickMarkInsideLength);\n                        outside = new Line2D.Double(xx0, y0, xx0,\n                                y0 - this.minorTickMarkOutsideLength);\n                    }\n                    else if (edge == RectangleEdge.BOTTOM) {\n                        inside = new Line2D.Double(xx0, y0, xx0,\n                                y0 - this.minorTickMarkInsideLength);\n                        outside = new Line2D.Double(xx0, y0, xx0,\n                                y0 + this.minorTickMarkOutsideLength);\n                    }\n                    if (tt0 >= firstOnAxis) {\n                        g2.setPaint(this.minorTickMarkPaint);\n                        g2.setStroke(this.minorTickMarkStroke);\n                        g2.draw(inside);\n                        g2.draw(outside);\n                    }\n                    tminor = tminor.next();\n                    tminor.peg(this.calendar);\n                    tt0 = tminor.getFirstMillisecond();\n                }\n            }\n            t = t.next();\n            t.peg(this.calendar);\n            t0 = t.getFirstMillisecond();\n        }\n        if (edge == RectangleEdge.TOP) {\n            state.cursorUp(Math.max(outsideLength,\n                    this.minorTickMarkOutsideLength));\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            state.cursorDown(Math.max(outsideLength,\n                    this.minorTickMarkOutsideLength));\n        }\n        state.setTicks(ticks);\n    }
1662	private static int atMost(Automaton.Builder builder, String x, int n) {\n    int s = builder.createState();\n    if (x.length() == n) {\n      builder.setAccept(s, true);\n    } else {\n      char c = x.charAt(n);\n      builder.addTransition(s, atMost(builder, x, (char) n + 1), c);\n      if (c > '0') {\n        builder.addTransition(s, anyOfRightLength(builder, x, n + 1), '0', (char) (c - 1));\n      }\n    }\n    return s;\n  }
1663	private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n\n        int paintCount = stream.readInt();\n        this.paintSequence = new Paint[paintCount];\n        for (int i = 0; i < paintCount; i++) {\n            this.paintSequence[i] = SerialUtilities.readPaint(stream);\n        }\n\n        int outlinePaintCount = stream.readInt();\n        this.outlinePaintSequence = new Paint[outlinePaintCount];\n        for (int i = 0; i < outlinePaintCount; i++) {\n            this.outlinePaintSequence[i] = SerialUtilities.readPaint(stream);\n        }\n\n        int strokeCount = stream.readInt();\n        this.strokeSequence = new Stroke[strokeCount];\n        for (int i = 0; i < strokeCount; i++) {\n            this.strokeSequence[i] = SerialUtilities.readStroke(stream);\n        }\n\n        int outlineStrokeCount = stream.readInt();\n        this.outlineStrokeSequence = new Stroke[outlineStrokeCount];\n        for (int i = 0; i < outlineStrokeCount; i++) {\n            this.outlineStrokeSequence[i] = SerialUtilities.readStroke(stream);\n        }\n\n        int shapeCount = stream.readInt();\n        this.shapeSequence = new Shape[shapeCount];\n        for (int i = 0; i < shapeCount; i++) {\n            this.shapeSequence[i] = SerialUtilities.readShape(stream);\n        }\n\n    }
1664	private Expression compileExpression(ClassLoader parent) throws ParseException {\n    final Map<String, Integer> externalsMap = new LinkedHashMap<>();\n    final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n\n    try {\n      generateClass(getAntlrParseTree(), classWriter, externalsMap);\n\n      final Class<? extends Expression> evaluatorClass = new Loader(parent)\n        .define(COMPILED_EXPRESSION_CLASS, classWriter.toByteArray());\n      final Constructor<? extends Expression> constructor = evaluatorClass.getConstructor(String.class, String[].class);\n\n      return constructor.newInstance(sourceText, externalsMap.keySet().toArray(new String[externalsMap.size()]));\n    } catch (RuntimeException re) {\n      if (re.getCause() instanceof ParseException) {\n        throw (ParseException)re.getCause();\n      }\n      throw re;\n    } catch (ReflectiveOperationException exception) {\n      throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + sourceText + ").", exception);\n    }\n  }
1665	private static String translateBuiltInName(byte name)\n	{\n		switch (name)\n		{\n			case NameRecord.BUILTIN_AUTO_ACTIVATE :     return "Auto_Activate";\n			case NameRecord.BUILTIN_AUTO_CLOSE :        return "Auto_Close";\n			case NameRecord.BUILTIN_AUTO_DEACTIVATE :   return "Auto_Deactivate";\n			case NameRecord.BUILTIN_AUTO_OPEN :         return "Auto_Open";\n			case NameRecord.BUILTIN_CONSOLIDATE_AREA :  return "Consolidate_Area";\n			case NameRecord.BUILTIN_CRITERIA :          return "Criteria";\n			case NameRecord.BUILTIN_DATABASE :          return "Database";\n			case NameRecord.BUILTIN_DATA_FORM :         return "Data_Form";\n			case NameRecord.BUILTIN_PRINT_AREA :        return "Print_Area";\n			case NameRecord.BUILTIN_PRINT_TITLE :       return "Print_Titles";\n			case NameRecord.BUILTIN_RECORDER :          return "Recorder";\n			case NameRecord.BUILTIN_SHEET_TITLE :       return "Sheet_Title";\n			case NameRecord.BUILTIN_FILTER_DB  :        return "_FilterDatabase";\n\n		}\n\n		return "Unknown";\n	}
1666	private boolean initFirstTime() throws IOException {\n        checkedRpts = true;\n    placeFirstPositions();\n\n    LinkedHashMap<Term,Integer> rptTerms = repeatingTerms(); \n    hasRpts = !rptTerms.isEmpty();\n\n    if (hasRpts) {\n      rptStack = new PhrasePositions[numPostings];       ArrayList<ArrayList<PhrasePositions>> rgs = gatherRptGroups(rptTerms);\n      sortRptGroups(rgs);\n      if (!advanceRepeatGroups()) {\n        return false;       }\n    }\n    \n    fillQueue();\n    return true;   }
1667	private ArrayList<FixedBitSet> ppTermsBitSets(PhrasePositions[] rpp, HashMap<Term,Integer> tord) {\n    ArrayList<FixedBitSet> bb = new ArrayList<>(rpp.length);\n    for (PhrasePositions pp : rpp) {\n      FixedBitSet b = new FixedBitSet(tord.size());\n      Integer ord;\n      for (Term t: pp.terms) {\n        if ((ord=tord.get(t))!=null) {\n          b.set(ord);\n        }\n      }\n      bb.add(b);\n    }\n    return bb;\n  }
1668	protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }
1669	private String convertSharedFormula(int si, XSSFEvaluationWorkbook fpb){\n        XSSFSheet sheet = getSheet();\n\n        CTCellFormula f = sheet.getSharedFormula(si);\n        if(f == null) {\n            throw new IllegalStateException(\n                    "Master cell of a shared formula with sid="+si+" was not found");\n        }\n\n        String sharedFormula = f.getStringValue();\n                String sharedFormulaRange = f.getRef();\n\n        CellRangeAddress ref = CellRangeAddress.valueOf(sharedFormulaRange);\n\n        int sheetIndex = sheet.getWorkbook().getSheetIndex(sheet);\n        SharedFormula sf = new SharedFormula(SpreadsheetVersion.EXCEL2007);\n\n        Ptg[] ptgs = FormulaParser.parse(sharedFormula, fpb, FormulaType.CELL, sheetIndex, getRowIndex());\n        Ptg[] fmla = sf.convertSharedFormulas(ptgs,\n                getRowIndex() - ref.getFirstRow(), getColumnIndex() - ref.getFirstColumn());\n        return FormulaRenderer.toFormulaString(fpb, fmla);\n    }
1670	protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n                if (getRenderer() == null) {\n            return;\n        }\n\n                if (isRangeGridlinesVisible() || isRangeMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                boolean paintLine;\n                while (iterator.hasNext()) {\n                    paintLine = false;\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if ((tick.getTickType() == TickType.MINOR)\n                            && isRangeMinorGridlinesVisible()) {\n                        gridStroke = getRangeMinorGridlineStroke();\n                        gridPaint = getRangeMinorGridlinePaint();\n                        paintLine = true;\n                    } else if ((tick.getTickType() == TickType.MAJOR)\n                            && isRangeGridlinesVisible()) {\n                        gridStroke = getRangeGridlineStroke();\n                        gridPaint = getRangeGridlinePaint();\n                        paintLine = true;\n                    }\n                    if ((tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) && paintLine) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(),\n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }
1671	@SuppressWarnings("unchecked")\n    public T getShape() {\n        byte metroBytes[] = getMetroBytes();\n        if (metroBytes == null) {\n            return null;\n        }\n        \n                ClassLoader cl = getClass().getClassLoader();\n        try {\n            Class<?> ms = cl.loadClass("org.apache.poi.xslf.usermodel.XSLFMetroShape");\n            Method m = ms.getMethod("parseShape", byte[].class);\n            return (T)m.invoke(null, new Object[]{metroBytes});\n        } catch (Exception e) {\n            LOGGER.log(POILogger.ERROR, "can't process metro blob, check if all dependencies for POI OOXML are in the classpath.", e);\n            return null;\n        }\n    }
1672	public void write(POIFSStream stream) throws IOException {\n       OutputStream os = stream.getOutputStream();\n       for(Property property : _properties) {\n          if(property != null) {\n             property.writeData(os);\n          }\n       }\n       os.close();\n       \n              if(getStartBlock() != stream.getStartBlock()) {\n          setStartBlock(stream.getStartBlock());\n       }\n    }
1673	static byte[] encode(double minLat, double minLon, double maxLat, double maxLon) {\n    byte[] b = new byte[BYTES * 4];\n    encode(minLat, minLon, b, 0);\n    encode(maxLat, maxLon, b, BYTES*2);\n    return b;\n  }
1674	public void addObservation(double value, boolean notify) {\n        boolean placed = false;\n        Iterator iterator = this.bins.iterator();\n        while (iterator.hasNext() && !placed) {\n            SimpleHistogramBin bin = (SimpleHistogramBin) iterator.next();\n            if (bin.accepts(value)) {\n                bin.setItemCount(bin.getItemCount() + 1);\n                placed = true;\n            }\n        }\n        if (!placed) {\n            throw new RuntimeException("No bin.");\n        }\n        if (notify) {\n            notifyListeners(new DatasetChangeEvent(this, this));\n        }\n    }
1675	private void addName(String functionName) {\n        final Name name = _book.createName();\n        name.setFunction(true);\n        name.setNameName(functionName);\n        name.setSheetIndex(_sheetIndex);\n    }
1676	public static POIFSFileSystem verifyAndBuildPOIFS(InputStream istream) throws IOException {\n        InputStream is = FileMagic.prepareToCheckMagic(istream);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        if (fm != FileMagic.OLE2) {\n            throw new IllegalArgumentException("The document is really a "+fm+" file");\n        }\n\n        return new POIFSFileSystem(is);\n    }
1677	public static void main(String[] args) throws IOException {\n        Workbook wb;\n\n        if(args.length > 0 && args[0].equals("-xls")) {\n            wb = new HSSFWorkbook();\n        } else {\n            wb = new XSSFWorkbook();\n        }\n\n        sameCell(wb.createSheet("Same Cell"));\n        multiCell(wb.createSheet("MultiCell"));\n        overlapping(wb.createSheet("Overlapping"));\n        errors(wb.createSheet("Errors"));\n        hideDupplicates(wb.createSheet("Hide Dups"));\n        formatDuplicates(wb.createSheet("Duplicates"));\n        inList(wb.createSheet("In List"));\n        expiry(wb.createSheet("Expiry"));\n        shadeAlt(wb.createSheet("Shade Alt"));\n        shadeBands(wb.createSheet("Shade Bands"));\n        iconSets(wb.createSheet("Icon Sets"));\n        colourScales(wb.createSheet("Colour Scales"));\n        dataBars(wb.createSheet("Data Bars"));\n\n                evaluateRules(wb, "Overlapping");\n        \n                String file = "cf-poi.xls";\n        if(wb instanceof XSSFWorkbook) {\n            file += "x";\n        }\n        FileOutputStream out = new FileOutputStream(file);\n        wb.write(out);\n        out.close();\n        System.out.println("Generated: " + file);\n        wb.close();\n    }
1678	@SuppressWarnings("unchecked")\n  public static <V> CharArrayMap<V> copy(final Map<?,? extends V> map) {\n    if(map == EMPTY_MAP)\n      return emptyMap();\n    if(map instanceof CharArrayMap) {\n      CharArrayMap<V> m = (CharArrayMap<V>) map;\n                  final char[][] keys = new char[m.keys.length][];\n      System.arraycopy(m.keys, 0, keys, 0, keys.length);\n      final V[] values = (V[]) new Object[m.values.length];\n      System.arraycopy(m.values, 0, values, 0, values.length);\n      m = new CharArrayMap<>(m);\n      m.keys = keys;\n      m.values = values;\n      return m;\n    }\n    return new CharArrayMap<>(map, false);\n  }
1679	protected void adjustDownwards(double minY, double height) {\n        for (int i = 0; i < this.labels.size() - 1; i++) {\n            PieLabelRecord record0 = getPieLabelRecord(i);\n            PieLabelRecord record1 = getPieLabelRecord(i + 1);\n            if (record1.getLowerY() < record0.getUpperY()) {\n                record1.setAllocatedY(Math.min(minY + height\n                        - record1.getLabelHeight() / 2.0,\n                        record0.getUpperY() + this.minGap\n                        + record1.getLabelHeight() / 2.0));\n            }\n        }\n    }
1680	public void drawHorizontalItem(Graphics2D g2, \n            CategoryItemRendererState state, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column) {\n\n        BoxAndWhiskerCategoryDataset bawDataset\n                = (BoxAndWhiskerCategoryDataset) dataset;\n\n        double categoryEnd = domainAxis.getCategoryEnd(column,\n                getColumnCount(), dataArea, plot.getDomainAxisEdge());\n        double categoryStart = domainAxis.getCategoryStart(column,\n                getColumnCount(), dataArea, plot.getDomainAxisEdge());\n        double categoryWidth = Math.abs(categoryEnd - categoryStart);\n\n        double yy = categoryStart;\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getHeight() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            double usedWidth = (state.getBarWidth() * seriesCount)\n                               + (seriesGap * (seriesCount - 1));\n                                    double offset = (categoryWidth - usedWidth) / 2;\n            yy = yy + offset + (row * (state.getBarWidth() + seriesGap));\n        }\n        else {\n                                    double offset = (categoryWidth - state.getBarWidth()) / 2;\n            yy = yy + offset;\n        }\n\n        g2.setPaint(getItemPaint(row, column));\n        Stroke s = getItemStroke(row, column);\n        g2.setStroke(s);\n\n        RectangleEdge location = plot.getRangeAxisEdge();\n\n        Number xQ1 = bawDataset.getQ1Value(row, column);\n        Number xQ3 = bawDataset.getQ3Value(row, column);\n        Number xMax = bawDataset.getMaxRegularValue(row, column);\n        Number xMin = bawDataset.getMinRegularValue(row, column);\n\n        Shape box = null;\n        if (xQ1 != null && xQ3 != null && xMax != null && xMin != null) {\n\n            double xxQ1 = rangeAxis.valueToJava2D(xQ1.doubleValue(), dataArea,\n                    location);\n            double xxQ3 = rangeAxis.valueToJava2D(xQ3.doubleValue(), dataArea,\n                    location);\n            double xxMax = rangeAxis.valueToJava2D(xMax.doubleValue(), dataArea,\n                    location);\n            double xxMin = rangeAxis.valueToJava2D(xMin.doubleValue(), dataArea,\n                    location);\n            double yymid = yy + state.getBarWidth() / 2.0;\n            double halfW = (state.getBarWidth() / 2.0) * this.whiskerWidth;\n\n                        box = new Rectangle2D.Double(Math.min(xxQ1, xxQ3), yy,\n                    Math.abs(xxQ1 - xxQ3), state.getBarWidth());\n            if (this.fillBox) {\n                g2.fill(box);\n            }\n\n            Paint outlinePaint = getItemOutlinePaint(row, column);\n            if (this.useOutlinePaintForWhiskers) {\n                g2.setPaint(outlinePaint);\n            }\n                        g2.draw(new Line2D.Double(xxMax, yymid, xxQ3, yymid));\n            g2.draw(new Line2D.Double(xxMax, yymid - halfW, xxMax,\n                    yymid + halfW));\n\n                        g2.draw(new Line2D.Double(xxMin, yymid, xxQ1, yymid));\n            g2.draw(new Line2D.Double(xxMin, yymid - halfW, xxMin,\n                    yy + halfW));\n\n            g2.setStroke(getItemOutlineStroke(row, column));\n            g2.setPaint(outlinePaint);\n            g2.draw(box);\n        }\n\n                g2.setPaint(this.artifactPaint);\n        double aRadius;                         if (this.meanVisible) {\n            Number xMean = bawDataset.getMeanValue(row, column);\n            if (xMean != null) {\n                double xxMean = rangeAxis.valueToJava2D(xMean.doubleValue(),\n                        dataArea, location);\n                aRadius = state.getBarWidth() / 4;\n                                                if ((xxMean > (dataArea.getMinX() - aRadius))\n                        && (xxMean < (dataArea.getMaxX() + aRadius))) {\n                    Ellipse2D.Double avgEllipse = new Ellipse2D.Double(xxMean\n                            - aRadius, yy + aRadius, aRadius * 2, aRadius * 2);\n                    g2.fill(avgEllipse);\n                    g2.draw(avgEllipse);\n                }\n            }\n        }\n\n                if (this.medianVisible) {\n            Number xMedian = bawDataset.getMedianValue(row, column);\n            if (xMedian != null) {\n                double xxMedian = rangeAxis.valueToJava2D(xMedian.doubleValue(),\n                        dataArea, location);\n                g2.draw(new Line2D.Double(xxMedian, yy, xxMedian,\n                        yy + state.getBarWidth()));\n            }\n        }\n\n                if (state.getInfo() != null && box != null) {\n            EntityCollection entities = state.getEntityCollection();\n            if (entities != null) {\n                addItemEntity(entities, dataset, row, column, box);\n            }\n        }\n\n    }
1681	private Point2D calculateLabelPoint(Line2D line, RectangleAnchor anchor,\n            double deltaX, double deltaY) {\n        double x, y;\n        boolean left = (anchor == RectangleAnchor.BOTTOM_LEFT \n                || anchor == RectangleAnchor.LEFT \n                || anchor == RectangleAnchor.TOP_LEFT);\n        boolean right = (anchor == RectangleAnchor.BOTTOM_RIGHT \n                || anchor == RectangleAnchor.RIGHT \n                || anchor == RectangleAnchor.TOP_RIGHT);\n        boolean top = (anchor == RectangleAnchor.TOP_LEFT \n                || anchor == RectangleAnchor.TOP \n                || anchor == RectangleAnchor.TOP_RIGHT);\n        boolean bottom = (anchor == RectangleAnchor.BOTTOM_LEFT\n                || anchor == RectangleAnchor.BOTTOM\n                || anchor == RectangleAnchor.BOTTOM_RIGHT);\n        Rectangle rect = line.getBounds();\n        \n                if (line.getX1() == line.getX2()) {              x = line.getX1();\n            y = (line.getY1() + line.getY2()) / 2.0;\n            if (left) {\n                x = x - deltaX;\n            }\n            if (right) {\n                x = x + deltaX;\n            }\n            if (top) {\n                y = Math.min(line.getY1(), line.getY2()) + deltaY;\n            }\n            if (bottom) {\n                y = Math.max(line.getY1(), line.getY2()) - deltaY;\n            }\n        }\n        else {              x = (line.getX1() + line.getX2()) / 2.0;\n            y = line.getY1();\n            if (left) {\n                x = Math.min(line.getX1(), line.getX2()) + deltaX;\n            }\n            if (right) {\n                x = Math.max(line.getX1(), line.getX2()) - deltaX;\n            }\n            if (top) {\n                y = y - deltaY;\n            }\n            if (bottom) {\n                y = y + deltaY;\n            }\n        }\n        return new Point2D.Double(x, y);\n    }
1682	public FontRecord createNewFont() {\n        FontRecord rec = createFont();\n\n        records.add(records.getFontpos()+1, rec);\n        records.setFontpos( records.getFontpos() + 1 );\n        numfonts++;\n        return rec;\n    }
1683	public static void merge(Directory srcIndexDir, Directory srcTaxoDir, OrdinalMap map, IndexWriter destIndexWriter,\n      DirectoryTaxonomyWriter destTaxoWriter, FacetsConfig srcConfig) throws IOException {\n    \n        destTaxoWriter.addTaxonomy(srcTaxoDir, map);\n    int ordinalMap[] = map.getMap();\n    DirectoryReader reader = DirectoryReader.open(srcIndexDir);\n    try {\n      List<LeafReaderContext> leaves = reader.leaves();\n      int numReaders = leaves.size();\n      CodecReader wrappedLeaves[] = new CodecReader[numReaders];\n      for (int i = 0; i < numReaders; i++) {\n        wrappedLeaves[i] = SlowCodecReaderWrapper.wrap(new OrdinalMappingLeafReader(leaves.get(i).reader(), ordinalMap, srcConfig));\n      }\n      destIndexWriter.addIndexes(wrappedLeaves);\n      \n            destTaxoWriter.commit();\n      destIndexWriter.commit();\n    } finally {\n      reader.close();\n    }\n  }
1684	public void updateCrosshairY(double candidateY, int rangeAxisIndex) {\n        double d = Math.abs(candidateY - this.anchorY);\n        if (d < this.distance) {\n            this.crosshairY = candidateY;\n            this.rangeAxisIndex = rangeAxisIndex;\n            this.distance = d;\n        }\n\n    }
1685	private void setBytesRef(BytesRefBuilder spare, BytesRef result, int index) {\n    if (index < lastElement) {\n      int offset = offsets[index];\n      int length;\n      if (index == lastElement - 1) {\n        length = currentOffset - offset;\n      } else {\n        length = offsets[index + 1] - offset;\n      }\n      pool.setBytesRef(spare, result, offset, length);\n    } else {\n      throw new IndexOutOfBoundsException("index " + index + " must be less than the size: " + lastElement);\n    }\n  }
1686	PackagePart createPart(PackagePartName partName, String contentType,\n			boolean loadRelationships) {\n		throwExceptionIfReadOnly();\n		if (partName == null) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		if (contentType == null || contentType.isEmpty()) {\n			throw new IllegalArgumentException("contentType");\n		}\n\n				if (partList.containsKey(partName)\n				&& !partList.get(partName).isDeleted()) {\n			throw new PartAlreadyExistsException(\n					"A part with the name '" + partName.getName() + "'" +\n					" already exists : Packages shall not contain equivalent part names and package" +\n					" implementers shall neither create nor recognize packages with equivalent part names. [M1.12]");\n		}\n\n		\n\n																if (contentType.equals(ContentTypes.CORE_PROPERTIES_PART)) {\n			if (this.packageProperties != null) {\n				throw new InvalidOperationException(\n						"OPC Compliance error [M4.1]: you try to add more than one core properties relationship in the package !");\n			}\n		}\n\n		\n\n		PackagePart part = this.createPartImpl(partName, contentType,\n				loadRelationships);\n		this.contentTypeManager.addContentType(partName, contentType);\n		this.partList.put(partName, part);\n		this.isDirty = true;\n		return part;\n	}
1687	public static void writeChartAsPNG(OutputStream out, JFreeChart chart,\n            int width, int height, ChartRenderingInfo info,\n            boolean encodeAlpha, int compression) throws IOException {\n\n        ParamChecks.nullNotPermitted(out, "out");\n        ParamChecks.nullNotPermitted(chart, "chart");\n        BufferedImage chartImage = chart.createBufferedImage(width, height,\n                BufferedImage.TYPE_INT_ARGB, info);\n        ChartUtilities.writeBufferedImageAsPNG(out, chartImage, encodeAlpha,\n                compression);\n\n    }
1688	public static Cipher getCipher(Key key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode, String padding) {\n        int keySizeInBytes = key.getEncoded().length;\n        if (padding == null) padding = "NoPadding";\n        \n        try {\n                        if (Cipher.getMaxAllowedKeyLength(cipherAlgorithm.jceId) < keySizeInBytes*8) {\n                throw new EncryptedDocumentException("Export Restrictions in place - please install JCE Unlimited Strength Jurisdiction Policy files");\n            }\n\n            Cipher cipher;\n            if (cipherAlgorithm == CipherAlgorithm.rc4) {\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId);\n            } else if (cipherAlgorithm.needsBouncyCastle) {\n                registerBouncyCastle();\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding, "BC");\n            } else {\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding);\n            }\n            \n            if (vec == null) {\n                cipher.init(cipherMode, key);\n            } else {\n                AlgorithmParameterSpec aps;\n                if (cipherAlgorithm == CipherAlgorithm.rc2) {\n                    aps = new RC2ParameterSpec(key.getEncoded().length*8, vec);\n                } else {\n                    aps = new IvParameterSpec(vec);\n                }\n                cipher.init(cipherMode, key, aps);\n            }\n            return cipher;\n        } catch (GeneralSecurityException e) {\n            throw new EncryptedDocumentException(e);\n        }\n    }
1689	private void handleFlush(DataInput topIn, DataOutput topOut, BufferedOutputStream bos) throws IOException {\n    Thread.currentThread().setName("flush");\n\n    int atLeastMarkerCount = topIn.readVInt();\n\n    int[] replicaTCPPorts;\n    int[] replicaIDs;\n    synchronized (this) {\n      replicaTCPPorts = this.replicaTCPPorts;\n      replicaIDs = this.replicaIDs;\n    }\n\n    message("now flush; " + replicaIDs.length + " replicas");\n\n    if (flushAndRefresh()) {\n      \n      verifyAtLeastMarkerCount(atLeastMarkerCount, null);\n \n                 long version = getCopyStateVersion();\n      message("send flushed version=" + version);\n      topOut.writeLong(version);\n      bos.flush();\n\n            for(int i=0;i<replicaIDs.length;i++) {\n        int replicaID = replicaIDs[i];\n        try (Connection c = new Connection(replicaTCPPorts[i])) {\n          message("send NEW_NRT_POINT to R" + replicaID + " at tcpPort=" + replicaTCPPorts[i]);\n          c.out.writeByte(SimpleReplicaNode.CMD_NEW_NRT_POINT);\n          c.out.writeVLong(version);\n          c.out.writeVLong(primaryGen);\n          c.out.writeInt(tcpPort);\n          c.flush();\n                                      } catch (Throwable t) {\n          message("top: failed to connect R" + replicaID + " for newNRTPoint; skipping: " + t.getMessage());\n        }\n      }\n    } else {\n            topOut.writeLong(-getCopyStateVersion());\n    }\n  }
1690	public XSLFChart createChart(XSLFSlide slide) {\n        int chartIdx = findNextAvailableFileNameIndex(XSLFRelation.CHART, _charts.size() + 1);\n        XSLFChart chart = (XSLFChart) createRelationship(XSLFRelation.CHART, XSLFFactory.getInstance(), chartIdx, true).getDocumentPart();\n        slide.addRelation(null, XSLFRelation.CHART, chart);\n        chart.setChartIndex(chartIdx);\n        _charts.add(chart);\n        return chart;\n    }
1691	private void create(){\n		EscherContainerRecord dgContainer = new EscherContainerRecord();\n		dgContainer.setRecordId( EscherContainerRecord.DG_CONTAINER );\n		dgContainer.setOptions((short)15);\n\n		dg = new EscherDgRecord();\n		dg.setOptions((short)16);\n		dg.setNumShapes(1);\n		dgContainer.addChildRecord(dg);\n\n		EscherContainerRecord spgrContainer = new EscherContainerRecord();\n		spgrContainer.setOptions((short)15);\n		spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);\n\n		EscherContainerRecord spContainer = new EscherContainerRecord();\n		spContainer.setOptions((short)15);\n		spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n\n		EscherSpgrRecord spgr = new EscherSpgrRecord();\n		spgr.setOptions((short)1);\n		spContainer.addChildRecord(spgr);\n\n		EscherSpRecord sp = new EscherSpRecord();\n		sp.setOptions((short)((ShapeType.NOT_PRIMITIVE.nativeId << 4) + 2));\n		sp.setFlags(EscherSpRecord.FLAG_PATRIARCH | EscherSpRecord.FLAG_GROUP);\n		spContainer.addChildRecord(sp);\n		spgrContainer.addChildRecord(spContainer);\n		dgContainer.addChildRecord(spgrContainer);\n\n		spContainer = new EscherContainerRecord();\n		spContainer.setOptions((short)15);\n		spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n		sp = new EscherSpRecord();\n		sp.setOptions((short)((ShapeType.RECT.nativeId << 4) + 2));\n		sp.setFlags(EscherSpRecord.FLAG_BACKGROUND | EscherSpRecord.FLAG_HASSHAPETYPE);\n		spContainer.addChildRecord(sp);\n\n		EscherOptRecord opt = new EscherOptRecord();\n		opt.setRecordId(EscherOptRecord.RECORD_ID);\n		opt.addEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, 134217728));\n		opt.addEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLBACKCOLOR, 134217733));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.FILL__RECTRIGHT, 10064750));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.FILL__RECTBOTTOM, 7778750));\n		opt.addEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, 1179666));\n		opt.addEscherProperty(new EscherBoolProperty(EscherProperties.LINESTYLE__NOLINEDRAWDASH, 524288));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.SHAPE__BLACKANDWHITESETTINGS, 9));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.SHAPE__BACKGROUNDSHAPE, 65537));\n		spContainer.addChildRecord(opt);\n\n		dgContainer.addChildRecord(spContainer);\n		\n		childRecords.add(dgContainer);\n	}
1692	public void addValue(int seriesNumber, int index, float value) {\n        invalidateRangeInfo();\n        if (seriesNumber >= this.valueHistory.length) {\n            throw new IllegalArgumentException(\n                "TimeSeriesDataset.addValue(): series #"\n                + seriesNumber + "unspecified in c'tor"\n            );\n        }\n        if (this.valueHistory[seriesNumber] == null) {\n            this.valueHistory[seriesNumber]\n                = new ValueSequence(this.historyCount);\n            this.seriesCount++;\n        }\n                                    this.valueHistory[seriesNumber].enterData(index, value);\n                fireSeriesChanged();\n    }
1693	private double[][] parsePoints(List<Object> o) throws ParseException {\n    double[] lats = new double[o.size()];\n    double[] lons = new double[o.size()];\n    for(int i=0;i<o.size();i++) {\n      Object point = o.get(i);\n      if (point instanceof List == false) {\n        throw newParseException("elements of coordinates array must [lat, lon] array, but got: " + point);\n      }\n      List<Object> pointList = (List<Object>) point;\n      if (pointList.size() != 2) {\n        throw newParseException("elements of coordinates array must [lat, lon] array, but got wrong element count: " + pointList);\n      }\n      if (pointList.get(0) instanceof Double == false) {\n        throw newParseException("elements of coordinates array must [lat, lon] array, but first element is not a Double: " + pointList.get(0));\n      }\n      if (pointList.get(1) instanceof Double == false) {\n        throw newParseException("elements of coordinates array must [lat, lon] array, but second element is not a Double: " + pointList.get(1));\n      }\n\n            lons[i] = ((Double) pointList.get(0)).doubleValue();\n      lats[i] = ((Double) pointList.get(1)).doubleValue();\n    }\n\n    return new double[][] {lats, lons};\n  }
1694	protected int split(byte[] minPackedValue, byte[] maxPackedValue, int[] parentSplits) {\n                int maxNumSplits = 0;\n    for (int numSplits : parentSplits) {\n      maxNumSplits = Math.max(maxNumSplits, numSplits);\n    }\n    for (int dim = 0; dim < numDims; ++dim) {\n      final int offset = dim * bytesPerDim;\n      if (parentSplits[dim] < maxNumSplits / 2 &&\n          StringHelper.compare(bytesPerDim, minPackedValue, offset, maxPackedValue, offset) != 0) {\n        return dim;\n      }\n    }\n\n        int splitDim = -1;\n    for(int dim=0;dim<numDims;dim++) {\n      NumericUtils.subtract(bytesPerDim, dim, maxPackedValue, minPackedValue, scratchDiff);\n      if (splitDim == -1 || StringHelper.compare(bytesPerDim, scratchDiff, 0, scratch1, 0) > 0) {\n        System.arraycopy(scratchDiff, 0, scratch1, 0, bytesPerDim);\n        splitDim = dim;\n      }\n    }\n\n        return splitDim;\n  }
1695	protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = true;\n\n        NumberTick lastTick = null;\n        float lastY = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n                        boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double yy = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y = (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = -Math.PI / 2.0;\n                }\n                else {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.CENTER_LEFT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle, new Double(currentTickValue),\n                tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastY = y;\n\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = false;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n    }
1696	public void writeData(final OutputStream stream) throws IOException {\n            new IntegerField(_bat_count_offset,      _bat_count, _data);\n      new IntegerField(_property_start_offset, _property_start, _data);\n      new IntegerField(_sbat_start_offset,     _sbat_start, _data);\n      new IntegerField(_sbat_block_count_offset, _sbat_count, _data);\n      new IntegerField(_xbat_start_offset,      _xbat_start, _data);\n      new IntegerField(_xbat_count_offset,      _xbat_count, _data);\n      \n            stream.write(_data, 0, 512);\n      \n            for(int i=POIFSConstants.SMALLER_BIG_BLOCK_SIZE; i<bigBlockSize.getBigBlockSize(); i++) {\n         stream.write(0);\n      }\n   }
1697	private void collectIfPtgs(TokenCollector temp) {\n\n				getChildren()[0].collectPtgs(temp);\n\n				int ifAttrIndex = temp.createPlaceholder();\n\n				getChildren()[1].collectPtgs(temp);\n\n				int skipAfterTrueParamIndex = temp.createPlaceholder();\n		int trueParamSize = temp.sumTokenSizes(ifAttrIndex+1, skipAfterTrueParamIndex);\n\n		AttrPtg attrIf = AttrPtg.createIf(trueParamSize + 4); \n		if (getChildren().length > 2) {\n			\n						getChildren()[2].collectPtgs(temp);\n\n			int skipAfterFalseParamIndex = temp.createPlaceholder();\n\n			int falseParamSize =  temp.sumTokenSizes(skipAfterTrueParamIndex+1, skipAfterFalseParamIndex);\n\n			AttrPtg attrSkipAfterTrue = AttrPtg.createSkip(falseParamSize + 4 + 4 - 1); 			AttrPtg attrSkipAfterFalse = AttrPtg.createSkip(4 - 1); \n			temp.setPlaceholder(ifAttrIndex, attrIf);\n			temp.setPlaceholder(skipAfterTrueParamIndex, attrSkipAfterTrue);\n			temp.setPlaceholder(skipAfterFalseParamIndex, attrSkipAfterFalse);\n		} else {\n						AttrPtg attrSkipAfterTrue = AttrPtg.createSkip(4 - 1); \n			temp.setPlaceholder(ifAttrIndex, attrIf);\n			temp.setPlaceholder(skipAfterTrueParamIndex, attrSkipAfterTrue);\n		}\n		temp.add(_token);\n	}
1698	public static boolean isEndOfRowBlock(int sid) {\n		switch(sid) {\n			case ViewDefinitionRecord.sid:\n							case DrawingRecord.sid:\n			case DrawingSelectionRecord.sid:\n			case ObjRecord.sid:\n			case TextObjectRecord.sid:\n            case ColumnInfoRecord.sid:             case GutsRecord.sid:   			case WindowOneRecord.sid:\n							case WindowTwoRecord.sid:\n				return true;\n\n			case DVALRecord.sid:\n				return true;\n			case EOFRecord.sid:\n								throw new RuntimeException("Found EOFRecord before WindowTwoRecord was encountered");\n		}\n		return PageSettingsBlock.isComponentRecord(sid);\n	}
1699	public void sortByValues(SortOrder order) {\n        final int size = this.keys.size();\n        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];\n        for (int i = 0; i < size; i++) {\n            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i),\n                    (Number) this.values.get(i));\n        }\n\n        Comparator comparator = new KeyedValueComparator(\n                KeyedValueComparatorType.BY_VALUE, order);\n        Arrays.sort(data, comparator);\n\n        clear();\n        for (int i = 0; i < data.length; i++) {\n            final DefaultKeyedValue value = data[i];\n            addValue(value.getKey(), value.getValue());\n        }\n    }
1700	public Automaton convert(Automaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new Automaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n                convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }
1701	public static void checkDocIds(String mes, int[] results, ScoreDoc[] hits) {\n    Assert.assertEquals(mes + " nr of hits", hits.length, results.length);\n    for (int i = 0; i < results.length; i++) {\n      Assert.assertEquals(mes + " doc nrs for hit " + i, results[i], hits[i].doc);\n    }\n  }
1702	public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n            return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n        if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n                return a;\n      }\n    }\n    a = Operations.totalize(a);\n    \n        final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({"rawtypes","unchecked"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n        for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n        for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n        for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n        int k = 2;\n        while (!pending.isEmpty()) {\n            final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n            pending2.clear(x*statesLen + p);\n            for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n            for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n                    for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    \n        int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n        for (int n = 0; n < k; n++) {\n      \n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n                    break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      \n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n                result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;         }\n    }\n\n        for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n                result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    \n    return Operations.removeDeadStates(result);\n  }
1703	private static CellRefParts separateRefParts(String reference) {\n        int plingPos = reference.lastIndexOf(SHEET_NAME_DELIMITER);\n        final String sheetName = parseSheetName(reference, plingPos);\n        String cell = reference.substring(plingPos+1).toUpperCase(Locale.ROOT);\n        Matcher matcher = CELL_REF_PATTERN.matcher(cell);\n        if (!matcher.matches()) {\n            throw new IllegalArgumentException("Invalid CellReference: " + reference);\n        }\n        String col = matcher.group(1);\n        String row = matcher.group(2);\n\n        return new CellRefParts(sheetName, row, col);\n    }
1704	private void setPropertiesFromSheet(InternalSheet sheet) {\n        RowRecord row = sheet.getNextRow();\n\n        while (row != null) {\n            createRowFromRecord(row);\n\n            row = sheet.getNextRow();\n        }\n\n        Iterator<CellValueRecordInterface> iter = sheet.getCellValueIterator();\n        long timestart = System.currentTimeMillis();\n\n        if (log.check( POILogger.DEBUG )) {\n            log.log(DEBUG, "Time at start of cell creating in HSSF sheet = ",\n                    Long.valueOf(timestart));\n        }\n        HSSFRow lastrow = null;\n\n                while (iter.hasNext()) {\n            CellValueRecordInterface cval = iter.next();\n\n            long cellstart = System.currentTimeMillis();\n            HSSFRow hrow = lastrow;\n\n            if (hrow == null || hrow.getRowNum() != cval.getRow()) {\n                hrow = getRow(cval.getRow());\n                lastrow = hrow;\n                if (hrow == null) {\n                    "Unexpected missing row when some rows already present"\n\n                                        RowRecord rowRec = new RowRecord(cval.getRow());\n                    sheet.addRow(rowRec);\n                    hrow = createRowFromRecord(rowRec);\n                }\n            }\n            if (log.check( POILogger.DEBUG )) {\n                if (cval instanceof Record) {\n                log.log( DEBUG, "record id = " + Integer.toHexString( ( (Record) cval ).getSid() ) );\n                } else {\n                    log.log( DEBUG, "record = " + cval );\n                }\n            }\n            hrow.createCellFromRecord( cval );\n            if (log.check( POILogger.DEBUG )) {\n                log.log( DEBUG, "record took ",\n                    Long.valueOf( System.currentTimeMillis() - cellstart ) );\n            }\n\n        }\n        if (log.check( POILogger.DEBUG )) {\n            log.log(DEBUG, "total sheet cell creation took ",\n                Long.valueOf(System.currentTimeMillis() - timestart));\n    }\n    }
1705	private void appendHeaderFooter( String text, StringBuffer out ) {\n        if ( text == null || text.length() == 0 )\n            return;\n\n        text = text.replace( '\r', '\n' );\n        if ( !text.endsWith( "\n" ))\n        {\n            out.append( text );\n            out.append( '\n' );\n            return;\n        }\n        if ( text.endsWith( "\n\n" ))\n        {\n            out.append( text.substring( 0, text.length() - 1 ));\n            return;\n        }\n        out.append( text );\n    }
1706	public ExcelAntEvaluationResult evaluateCell(String cellName, double expectedValue,\n            double precision) {\n\n        ExcelAntEvaluationResult evalResults = null;\n\n        Cell cell = getCell(cellName);\n\n        FormulaEvaluator evaluator = getEvaluator(excelFileName);\n\n\n        CellValue resultOfEval = evaluator.evaluate(cell);\n\n        if (resultOfEval.getErrorValue() == 0) {\n                        double result = resultOfEval.getNumberValue();\n            double delta = Math.abs(result - expectedValue);\n            if (delta > precision) {\n                evalResults = new ExcelAntEvaluationResult(false, false,\n                        resultOfEval.getNumberValue(),\n                        "Results was out of range based on precision " + " of "\n                                + precision + ".  Delta was actually " + delta, delta, cellName);\n            } else {\n                evalResults = new ExcelAntEvaluationResult(false, true,\n                        resultOfEval.getNumberValue(),\n                        "Evaluation passed without error within in range.", delta, cellName);\n            }\n        } else {\n            String errorMeaning = null;\n            try {\n                errorMeaning = FormulaError.forInt(resultOfEval.getErrorValue()).getString();\n            } catch(IllegalArgumentException iae) {\n                errorMeaning =  "unknown error code: " +\n                                Byte.toString(resultOfEval.getErrorValue());\n            }\n\n            evalResults = new ExcelAntEvaluationResult(true, false,\n                    resultOfEval.getNumberValue(),\n                    "Evaluation failed due to an evaluation error of "\n                            + resultOfEval.getErrorValue()\n                            + " which is "\n                            + errorMeaning, 0, cellName);\n        }\n\n        return evalResults;\n    }
1707	private static Edge createTree(Edge edges[], int low, int high) {\n    if (low > high) {\n      return null;\n    }\n        int mid = (low + high) >>> 1;\n    Edge newNode = edges[mid];\n        newNode.left = createTree(edges, low, mid - 1);\n    newNode.right = createTree(edges, mid + 1, high);\n        if (newNode.left != null) {\n      newNode.max = Math.max(newNode.max, newNode.left.max);\n    }\n    if (newNode.right != null) {\n      newNode.max = Math.max(newNode.max, newNode.right.max);\n    }\n    return newNode;\n  }
1708	@Beta\n    private void addDataField(DataConsolidateFunction function, int columnIndex, String valueFieldName, String valueFormat) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        \n        CTDataFields dataFields;\n        if(pivotTableDefinition.getDataFields() != null) {\n            dataFields = pivotTableDefinition.getDataFields();\n        } else {\n            dataFields = pivotTableDefinition.addNewDataFields();\n        }\n        CTDataField dataField = dataFields.addNewDataField();\n        dataField.setSubtotal(STDataConsolidateFunction.Enum.forInt(function.getValue()));\n        Cell cell = getDataSheet().getRow(pivotArea.getFirstCell().getRow())\n                .getCell(pivotArea.getFirstCell().getCol() + columnIndex);\n        cell.setCellType(CellType.STRING);\n        dataField.setName(valueFieldName);\n        dataField.setFld(columnIndex);\n        if (valueFormat != null && !valueFormat.trim().isEmpty()) {\n            DataFormat df = parentSheet.getWorkbook().createDataFormat();\n            dataField.setNumFmtId(df.getFormat(valueFormat));\n        }\n        dataFields.setCount(dataFields.sizeOfDataFieldArray());\n    }
1709	private void findMostRecentCoreRecords() {\n				Map<Integer,Integer> mostRecentByBytes = new HashMap<>();\n		for (Record record : _hslfSlideShow.getRecords()) {\n			if (record instanceof PersistPtrHolder) {\n				PersistPtrHolder pph = (PersistPtrHolder) record;\n\n												int[] ids = pph.getKnownSlideIDs();\n				for (int id : ids) {\n					mostRecentByBytes.remove(id);\n				}\n\n								Map<Integer,Integer> thisSetOfLocations = pph.getSlideLocationsLookup();\n				for (int id : ids) {\n					mostRecentByBytes.put(id, thisSetOfLocations.get(id));\n				}\n			}\n		}\n\n						_mostRecentCoreRecords = new Record[mostRecentByBytes.size()];\n\n						_sheetIdToCoreRecordsLookup = new HashMap<>();\n		Integer[] allIDs = mostRecentByBytes.keySet().toArray(new Integer[0]);\n		Arrays.sort(allIDs);\n		for (int i = 0; i < allIDs.length; i++) {\n			_sheetIdToCoreRecordsLookup.put(allIDs[i], i);\n		}\n\n		Map<Integer,Integer> mostRecentByBytesRev = new HashMap<>(mostRecentByBytes.size());\n		for (Map.Entry<Integer,Integer> me : mostRecentByBytes.entrySet()) {\n		    mostRecentByBytesRev.put(me.getValue(), me.getKey());\n		}\n\n				for (Record record : _hslfSlideShow.getRecords()) {\n			if (!(record instanceof PositionDependentRecord)) {\n                continue;\n            }\n\n			PositionDependentRecord pdr = (PositionDependentRecord) record;\n			int recordAt = pdr.getLastOnDiskOffset();\n\n			Integer thisID = mostRecentByBytesRev.get(recordAt);\n\n			if (thisID == null) {\n                continue;\n            }\n\n						int storeAt = _sheetIdToCoreRecordsLookup.get(thisID);\n\n						if (pdr instanceof PositionDependentRecordContainer) {\n				PositionDependentRecordContainer pdrc = (PositionDependentRecordContainer) record;\n				pdrc.setSheetId(thisID);\n			}\n\n						_mostRecentCoreRecords[storeAt] = record;\n		}\n\n				for (Record record : _mostRecentCoreRecords) {\n						if (record != null) {\n								if (record.getRecordType() == RecordTypes.Document.typeID) {\n					_documentRecord = (Document) record;\n					_fonts = _documentRecord.getEnvironment().getFontCollection();\n				}\n			} \n		}\n	}
1710	protected static String toDebugFriendlyString(byte[] value) {\n        if (value == null) {\n            return "(Null Byte Array)";\n        }\n\n        StringBuffer text = new StringBuffer();\n        text.append("Bytes len=").append(value.length);\n        text.append(" [");\n\n        int limit = Math.min(value.length, 16);\n        if (value.length > 16) {\n            limit = 12;\n        }\n        for (int i = 0; i < limit; i++) {\n            if (i > 0) {\n                text.append(',');\n            }\n            text.append(value[i]);\n        }\n        if (value.length > 16) {\n            text.append(",....");\n        }\n        text.append("]");\n        return text.toString();\n    }
1711	private Query makeXDL(boolean crossedDateLine, Query query) {\n    if (!ctx.isGeo()) {\n      assert !crossedDateLine;\n      return query;\n    }\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(this.makeXDL(crossedDateLine), BooleanClause.Occur.MUST);\n    bq.add(query, BooleanClause.Occur.MUST);\n    return bq.build();\n  }
1712	public synchronized MergePolicy.OneMerge getNextMerge() {\n    if (pendingMerges.size() == 0) {\n      return null;\n    } else {\n            MergePolicy.OneMerge merge = pendingMerges.removeFirst();\n      runningMerges.add(merge);\n      return merge;\n    }\n  }
1713	public int numDeletedDocs(SegmentCommitInfo info) {\n    ensureOpen(false);\n    int delCount = info.getDelCount();\n\n    final ReadersAndUpdates rld = readerPool.get(info, false);\n    if (rld != null) {\n      delCount += rld.getPendingDeleteCount();\n    }\n    return delCount;\n  }
1714	public void writeOut(OutputStream o, boolean isMasterStyle) throws IOException {\n	    if (!isMasterStyle) {\n	        	        	        StyleTextPropAtom.writeLittleEndian(charactersCovered,o);\n	    }\n\n				if (textPropType == TextPropType.paragraph && indentLevel > -1) {\n			StyleTextPropAtom.writeLittleEndian(indentLevel, o);\n		}\n\n				int mask = maskSpecial;\n		for (TextProp textProp : textProps.values()) {\n            mask |= textProp.getWriteMask();\n        }\n		StyleTextPropAtom.writeLittleEndian(mask,o);\n\n				for (TextProp textProp : getTextPropList()) {\n            int val = textProp.getValue();\n            if (textProp instanceof BitMaskTextProp && textProp.getWriteMask() == 0) {\n                                continue;\n            } else if (textProp.getSize() == 2) {\n                StyleTextPropAtom.writeLittleEndian((short)val,o);\n            } else if (textProp.getSize() == 4) {\n                StyleTextPropAtom.writeLittleEndian(val,o);\n            } else if (textProp instanceof HSLFTabStopPropCollection) {\n                ((HSLFTabStopPropCollection)textProp).writeProperty(o);\n            }\n		}\n	}
1715	public void dumpDrawingGroupRecords(boolean fat) {\n        DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );\n        if (r == null) {\n            return;\n        }\n        r.decode();\n        List<EscherRecord> escherRecords = r.getEscherRecords();\n        PrintWriter w = new PrintWriter(new OutputStreamWriter(System.out, Charset.defaultCharset()));\n        for (EscherRecord escherRecord : escherRecords) {\n            if (fat) {\n                System.out.println(escherRecord);\n            } else {\n                escherRecord.display(w, 0);\n            }\n        }\n        w.flush();\n    }
1716	private int findInTable(short knownHashIndex, char[] charArray) {\n    if (charArray == null || charArray.length == 0)\n      return -1;\n\n    char[][] items = wordItem_charArrayTable[wordIndexTable[knownHashIndex]];\n    int start = 0, end = items.length - 1;\n    int mid = (start + end) / 2, cmpResult;\n\n        while (start <= end) {\n      cmpResult = Utility.compareArray(items[mid], 0, charArray, 1);\n\n      if (cmpResult == 0)\n        return mid;      else if (cmpResult < 0)\n        start = mid + 1;\n      else if (cmpResult > 0)\n        end = mid - 1;\n\n      mid = (start + end) / 2;\n    }\n    return -1;\n  }
1717	protected void writeProperties(POIFSFileSystem outFS, List<String> writtenEntries) throws IOException {\n        final EncryptionInfo ei = getEncryptionInfo();\n        final boolean encryptProps = (ei != null && ei.isDocPropsEncrypted());\n        try (POIFSFileSystem tmpFS = new POIFSFileSystem()) {\n            final POIFSFileSystem fs = (encryptProps) ? tmpFS : outFS;\n\n            writePropertySet(SummaryInformation.DEFAULT_STREAM_NAME, getSummaryInformation(), fs, writtenEntries);\n            writePropertySet(DocumentSummaryInformation.DEFAULT_STREAM_NAME, getDocumentSummaryInformation(), fs, writtenEntries);\n\n            if (!encryptProps) {\n                return;\n            }\n\n                        writePropertySet(DocumentSummaryInformation.DEFAULT_STREAM_NAME, newDocumentSummaryInformation(), outFS);\n\n                        if (outFS.getRoot().hasEntry(SummaryInformation.DEFAULT_STREAM_NAME)) {\n                outFS.getRoot().getEntry(SummaryInformation.DEFAULT_STREAM_NAME).delete();\n            }\n            Encryptor encGen = ei.getEncryptor();\n            if (!(encGen instanceof CryptoAPIEncryptor)) {\n                throw new EncryptedDocumentException(\n                    "Using " + ei.getEncryptionMode() + " encryption. Only CryptoAPI encryption supports encrypted property sets!");\n            }\n            CryptoAPIEncryptor enc = (CryptoAPIEncryptor) encGen;\n            try {\n                enc.setSummaryEntries(outFS.getRoot(), getEncryptedPropertyStreamName(), fs);\n            } catch (GeneralSecurityException e) {\n                throw new IOException(e);\n            }\n        }\n    }
1718	public static void main(String[] args) throws IOException\n    {\n                        try (FileInputStream fin = new FileInputStream(args[0])) {\n                        try (POIFSFileSystem poifs = new POIFSFileSystem(fin)) {\n                                try (InputStream din = poifs.createDocumentInputStream("Workbook")) {\n                                        HSSFRequest req = new HSSFRequest();\n                                        req.addListenerForAllRecords(new EventExample());\n                                        HSSFEventFactory factory = new HSSFEventFactory();\n                                        factory.processEvents(req, din);\n                }\n            }\n        }\n        System.out.println("done.");\n    }
1719	public void zoomOutRange(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n                                                boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomRangeAxes(this.zoomOutFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }
1720	boolean hasLeadingTrailingSpaces(String str) {\n        if (str != null && str.length() > 0) {\n            char firstChar = str.charAt(0);\n            char lastChar  = str.charAt(str.length() - 1);\n            return Character.isWhitespace(firstChar) || Character.isWhitespace(lastChar) ;\n        }\n        return false;\n    }
1721	public int fillCounts(int[] counts) {\n        missingCount = 0;\n    leafUpto = 0;\n    rollup(root, counts, false);\n    return missingCount;\n  }
1722	public void setRunType(int type) {\n        getEscherTextboxWrapper();\n        if (_txtbox == null) {\n            return;\n        }\n        List<HSLFTextParagraph> paras = HSLFTextParagraph.findTextParagraphs(_txtbox, getSheet());\n        if (!paras.isEmpty()) {\n            paras.get(0).setRunType(type);\n        }\n    }
1723	public void findChildren(byte[] documentData) {\n				childStreams = new Stream[childPointers.length];\n		for(int i=0; i<childPointers.length; i++) {\n			Pointer ptr = childPointers[i];\n			childStreams[i] = Stream.createStream(ptr, documentData, chunkFactory, pointerFactory);\n\n						if(childStreams[i] instanceof ChunkStream) {\n				ChunkStream child = (ChunkStream)childStreams[i];\n				child.findChunks();\n			}\n\n						if(childStreams[i] instanceof PointerContainingStream) {\n				PointerContainingStream child =\n					(PointerContainingStream)childStreams[i];\n				child.findChildren(documentData);\n			}\n		}\n	}
1724	private List extractColumnKeys(String line) {\n        List keys = new java.util.ArrayList();\n        int fieldIndex = 0;\n        int start = 0;\n        for (int i = 0; i < line.length(); i++) {\n            if (line.charAt(i) == this.fieldDelimiter) {\n                if (fieldIndex > 0) {                                                             String key = line.substring(start, i);\n                    keys.add(removeStringDelimiters(key));\n                }\n                start = i + 1;\n                fieldIndex++;\n            }\n        }\n        String key = line.substring(start, line.length());\n        keys.add(removeStringDelimiters(key));\n        return keys;\n    }
1725	public static BufferedImage createHeatMapImage(HeatMapDataset dataset,\n            PaintScale paintScale) {\n\n        ParamChecks.nullNotPermitted(dataset, "dataset");\n        ParamChecks.nullNotPermitted(paintScale, "paintScale");\n        int xCount = dataset.getXSampleCount();\n        int yCount = dataset.getYSampleCount();\n        BufferedImage image = new BufferedImage(xCount, yCount,\n                BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = image.createGraphics();\n        for (int xIndex = 0; xIndex < xCount; xIndex++) {\n            for (int yIndex = 0; yIndex < yCount; yIndex++) {\n                double z = dataset.getZValue(xIndex, yIndex);\n                Paint p = paintScale.getPaint(z);\n                g2.setPaint(p);\n                g2.fillRect(xIndex, yCount - yIndex - 1, 1, 1);\n            }\n        }\n        return image;\n    }
1726	public void updateCrosshairX(double candidateX, int domainAxisIndex) {\n\n        double d = Math.abs(candidateX - this.anchorX);\n        if (d < this.distance) {\n            this.crosshairX = candidateX;\n            this.domainAxisIndex = domainAxisIndex;\n            this.distance = d;\n        }\n\n    }
1727	private static final CharSequence escapeWhiteChar(CharSequence str,\n      Locale locale) {\n    if (str == null || str.length() == 0)\n      return str;\n\n    CharSequence buffer = str;\n\n    for (int i = 0; i < escapableWhiteChars.length; i++) {\n      buffer = replaceIgnoreCase(buffer, escapableWhiteChars[i].toLowerCase(locale),\n          "\\", locale);\n    }\n    return buffer;\n  }
