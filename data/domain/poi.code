1	public static byte[] peekFirstNBytes(InputStream stream, int limit) throws IOException, EmptyFileException {\n        stream.mark(limit);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(limit);\n        copy(new BoundedInputStream(stream, limit), bos);\n\n        int readBytes = bos.size();\n        if (readBytes == 0) {\n            throw new EmptyFileException();\n        }\n\n        if (readBytes < limit) {\n            bos.write(new byte[limit-readBytes]);\n        }\n        byte peekedBytes[] = bos.toByteArray();\n        if(stream instanceof PushbackInputStream) {\n            PushbackInputStream pin = (PushbackInputStream)stream;\n            pin.unread(peekedBytes, 0, readBytes);\n        } else {\n            stream.reset();\n        }\n\n        return peekedBytes;\n    }
2	private static void putAll(final Map<String, Object> src, Map<String, Object> dest) {\n        for (final String key : src.keySet()) {\n            if (shortValues.contains(key)) {\n                dest.put(key, getShort(src, key));\n            } else if (booleanValues.contains(key)) {\n                dest.put(key, getBoolean(src, key));\n            } else if (borderTypeValues.contains(key)) {\n                dest.put(key, getBorderStyle(src, key));\n            } else if (ALIGNMENT.equals(key)) {\n                dest.put(key, getHorizontalAlignment(src, key));\n            } else if (VERTICAL_ALIGNMENT.equals(key)) {\n                dest.put(key, getVerticalAlignment(src, key));\n            } else if (FILL_PATTERN.equals(key)) {\n                dest.put(key, getFillPattern(src, key));\n            } else {\n                if (log.check(POILogger.INFO)) {\n                    log.log(POILogger.INFO, "Ignoring unrecognized CellUtil format properties key: " + key);\n                }\n            }\n        }\n    }
3	@Internal\n	public void replaceText(String pPlaceHolder, String pValue, int pOffset) {\n		int absPlaceHolderIndex = getStartOffset() + pOffset;\n\n		Range subRange = new Range(absPlaceHolderIndex,\n				(absPlaceHolderIndex + pPlaceHolder.length()), this);\n		subRange.insertBefore(pValue);\n\n				subRange = new Range((absPlaceHolderIndex + pValue.length()), (absPlaceHolderIndex\n				+ pPlaceHolder.length() + pValue.length()), this);\n\n				subRange.delete();\n	}
4	public void bulletedItemInCell(HSSFWorkbook workbook, String listItem, HSSFCell cell) {\n                        HSSFDataFormat format = workbook.createDataFormat();\n        String formatString = InCellLists.BULLET_CHARACTER + " @";\n        int formatIndex = format.getFormat(formatString);\n\n                        HSSFCellStyle bulletStyle = workbook.createCellStyle();\n        bulletStyle.setDataFormat((short)formatIndex);\n\n                cell.setCellValue(new HSSFRichTextString(listItem));\n        cell.setCellStyle(bulletStyle);\n    }
5	protected List<EvaluationConditionalFormatRule> getRules(Sheet sheet) {\n        final String sheetName = sheet.getSheetName();\n        List<EvaluationConditionalFormatRule> rules = formats.get(sheetName);\n        if (rules == null) {\n            if (formats.containsKey(sheetName)) {\n                return Collections.emptyList();\n            }\n            final SheetConditionalFormatting scf = sheet.getSheetConditionalFormatting();\n            final int count = scf.getNumConditionalFormattings();\n            rules = new ArrayList<>(count);\n            formats.put(sheetName, rules);\n            for (int i=0; i < count; i++) {\n                ConditionalFormatting f = scf.getConditionalFormattingAt(i);\n                                final CellRangeAddress[] regions = f.getFormattingRanges();\n                for (int r=0; r < f.getNumberOfRules(); r++) {\n                    ConditionalFormattingRule rule = f.getRule(r);\n                    rules.add(new EvaluationConditionalFormatRule(workbookEvaluator, sheet, f, i, rule, r, regions));\n                }\n            }\n                        Collections.sort(rules);\n        }\n        return Collections.unmodifiableList(rules);\n    }
6	public void addObjectTableEntry(HwmfObjectTableEntry entry) {\n        ListIterator<HwmfObjectTableEntry> oIter = objectTable.listIterator();\n        while (oIter.hasNext()) {\n            HwmfObjectTableEntry tableEntry = oIter.next();\n            if (tableEntry == null) {\n                oIter.set(entry);\n                return;\n            }\n        }\n        objectTable.add(entry);\n    }
7	public PackagePart getPart(PackagePartName partName) {\n		throwExceptionIfWriteOnly();\n\n		if (partName == null) {\n			throw new IllegalArgumentException("partName");\n		}\n\n				if (partList == null) {\n			try {\n				getParts();\n			} catch (InvalidFormatException e) {\n				return null;\n			}\n		}\n\n		return partList.get(partName);\n	}
8	public int countOfAllChildren() {\n        int count = shapes.size();\n        for (Iterator<HSSFShape> iterator = shapes.iterator(); iterator.hasNext(); ) {\n            HSSFShape shape = iterator.next();\n            count += shape.countOfAllChildren();\n        }\n        return count;\n    }
9	private ClientAnchorDetail fitImageToColumns(HSSFSheet sheet, int colNumber,\n            double reqImageWidthMM, int resizeBehaviour) {\n\n        double colWidthMM;\n        double colCoordinatesPerMM;\n        int pictureWidthCoordinates;\n        ClientAnchorDetail colClientAnchorDetail = null;\n\n                colWidthMM = ConvertImageUnits.widthUnits2Millimetres(\n                (short)sheet.getColumnWidth(colNumber));\n\n                                                if(colWidthMM < reqImageWidthMM) {\n\n                        if((resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                                                sheet.setColumnWidth(colNumber,\n                        ConvertImageUnits.millimetres2WidthUnits(reqImageWidthMM));\n                                                                                colWidthMM = reqImageWidthMM;\n                colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n                colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                        colNumber, pictureWidthCoordinates);\n            }\n                                                else if ((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                     (resizeBehaviour == AddDimensionedImage.EXPAND_ROW)) {\n                colClientAnchorDetail = this.calculateColumnLocation(sheet,\n                        colNumber, reqImageWidthMM);\n            }\n        }\n                else {\n                        colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                        pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n            colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                    colNumber, pictureWidthCoordinates);\n        }\n        return(colClientAnchorDetail);\n    }
10	public XWPFFootnote createFootnote() {\n        CTFtnEdn newNote = CTFtnEdn.Factory.newInstance(); \n        newNote.setType(STFtnEdn.NORMAL);\n\n        XWPFFootnote footnote = addFootnote(newNote);\n        footnote.getCTFtnEdn().setId(getIdManager().nextId());\n        return footnote;\n        \n    }
11	private void rowToCSV(Row row) {\n        Cell cell;\n        int lastCellNum;\n        ArrayList<String> csvLine = new ArrayList<>();\n\n                                if(row != null) {\n\n                                                            lastCellNum = row.getLastCellNum();\n            for(int i = 0; i <= lastCellNum; i++) {\n                cell = row.getCell(i);\n                if(cell == null) {\n                    csvLine.add("");\n                }\n                else {\n                    if(cell.getCellType() != CellType.FORMULA) {\n                        csvLine.add(this.formatter.formatCellValue(cell));\n                    }\n                    else {\n                        csvLine.add(this.formatter.formatCellValue(cell, this.evaluator));\n                    }\n                }\n            }\n                                                if(lastCellNum > this.maxRowWidth) {\n                this.maxRowWidth = lastCellNum;\n            }\n        }\n        this.csvData.add(csvLine);\n    }
12	protected PackagePart[] getRelatedByType(String contentType) throws InvalidFormatException {\n        PackageRelationshipCollection partsC =\n            getPackagePart().getRelationshipsByType(contentType);\n\n        PackagePart[] parts = new PackagePart[partsC.size()];\n        int count = 0;\n        for (PackageRelationship rel : partsC) {\n            parts[count] = getPackagePart().getRelatedPart(rel);\n            count++;\n        }\n        return parts;\n    }
13	public String getSignificantDecimalDigitsLastDigitRounded() {\n		long wp = _wholePart + 5; 		StringBuilder sb = new StringBuilder(24);\n		sb.append(wp);\n		sb.setCharAt(sb.length()-1, '0');\n		return sb.toString();\n	}
14	static void errors(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue(84);\n        sheet.createRow(1).createCell(0).setCellValue(0);\n        sheet.createRow(2).createCell(0).setCellFormula("ROUND(A1/A2,0)");\n        sheet.createRow(3).createCell(0).setCellValue(0);\n        sheet.createRow(4).createCell(0).setCellFormula("ROUND(A6/A4,0)");\n        sheet.createRow(5).createCell(0).setCellValue(41);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("ISERROR(A1)");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontColorIndex(IndexedColors.WHITE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(1).setCellValue("<== The error in this cell is hidden. Condition: Formula Is   =ISERROR(C2)   (White Font)");\n        sheet.getRow(4).createCell(1).setCellValue("<== The error in this cell is hidden. Condition: Formula Is   =ISERROR(C2)   (White Font)");\n    }
15	public XWPFHeader createHeader(Enum type, XWPFParagraph[] pars) {\n        XWPFHeader header = getHeader(type);\n\n        if (header == null) {\n            HdrDocument hdrDoc = HdrDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.HEADER;\n            int i = getRelationIndex(relation);\n\n            XWPFHeader wrapper = (XWPFHeader) doc.createRelationship(relation,\n                    XWPFFactory.getInstance(), i);\n            wrapper.setXWPFDocument(doc);\n\n            CTHdrFtr hdr = buildHdr(type, wrapper, pars);\n            wrapper.setHeaderFooter(hdr);\n            hdrDoc.setHdr(hdr);\n            assignHeader(wrapper, type);\n            header = wrapper;\n        }\n\n        return header;\n    }
16	public void addFormatRun(FormatRun r) {\n      if (field_4_format_runs == null) {\n		field_4_format_runs = new ArrayList<>();\n	  }\n\n      int index = findFormatRunAt(r._character);\n      if (index != -1) {\n         field_4_format_runs.remove(index);\n      }\n\n      field_4_format_runs.add(r);\n                  Collections.sort(field_4_format_runs);\n\n            field_2_optionflags = richText.setByte(field_2_optionflags);\n    }
17	public static int countMatches(CharSequence haystack, char needle) {\n        if (haystack == null) return 0;\n        int count = 0;\n        final int length = haystack.length();\n        for (int i = 0; i < length; i++) {\n            if (haystack.charAt(i) == needle) {\n                count++;\n            }\n        }\n        return count;\n    }
18	public boolean removeBodyElement(int pos) {\n        if (pos >= 0 && pos < bodyElements.size()) {\n            BodyElementType type = bodyElements.get(pos).getElementType();\n            if (type == BodyElementType.TABLE) {\n                int tablePos = getTablePos(pos);\n                tables.remove(tablePos);\n                ctDocument.getBody().removeTbl(tablePos);\n            }\n            if (type == BodyElementType.PARAGRAPH) {\n                int paraPos = getParagraphPos(pos);\n                paragraphs.remove(paraPos);\n                ctDocument.getBody().removeP(paraPos);\n            }\n            bodyElements.remove(pos);\n            return true;\n        }\n        return false;\n    }
19	public List<Cell> getMatchingCells(EvaluationConditionalFormatRule rule) {\n        final List<Cell> cells = new ArrayList<>();\n        final Sheet sheet = rule.getSheet();\n        \n        for (CellRangeAddress region : rule.getRegions()) {\n            for (int r = region.getFirstRow(); r <= region.getLastRow(); r++) {\n                final Row row = sheet.getRow(r);\n                if (row == null) {\n                    continue;                 }\n                for (int c = region.getFirstColumn(); c <= region.getLastColumn(); c++) {\n                    final Cell cell = row.getCell(c);\n                    if (cell == null) {\n                        continue;\n                    }\n                    \n                    List<EvaluationConditionalFormatRule> cellRules = getConditionalFormattingForCell(cell);\n                    if (cellRules.contains(rule)) {\n                        cells.add(cell);\n                    }\n                }\n            }\n        }\n        return Collections.unmodifiableList(cells);\n    }
20	private static boolean needsMemFunc(ParseNode root) {\n        Ptg token = root.getToken();\n        if (token instanceof AbstractFunctionPtg) {\n            return true;\n        }\n        if (token instanceof ExternSheetReferenceToken) {             return true;\n        }\n        if (token instanceof NamePtg || token instanceof NameXPtg) {             return true;\n        }\n\n        if (token instanceof OperationPtg || token instanceof ParenthesisPtg) {\n                        for(ParseNode child : root.getChildren()) {\n                if (needsMemFunc(child)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (token instanceof OperandPtg) {\n            return false;\n        }\n        if (token instanceof OperationPtg) {\n            return true;\n        }\n\n        return false;\n    }
21	public void removeItem(int sheetId, String ref){\n                int id = -1;\n        CTCalcCell[] c = chain.getCArray();\n\n        for (int i = 0; i < c.length; i++){\n                        if(c[i].isSetI()) id = c[i].getI();\n\n            if(id == sheetId && c[i].getR().equals(ref)){\n                if(c[i].isSetI() && i < c.length - 1 && !c[i+1].isSetI()) {\n                    c[i+1].setI(id);\n                }\n                chain.removeC(i);\n                break;\n            }\n        }\n    }
22	public static int getEncodedSizeWithoutArrayData(Ptg[] ptgs) {\n		int result = 0;\n		for (Ptg ptg : ptgs) {\n			if (ptg instanceof ArrayPtg) {\n				result += ArrayPtg.PLAIN_TOKEN_SIZE;\n			} else {\n				result += ptg.getSize();\n			}\n		}\n		return result;\n	}
23	public int addPicture(InputStream is, int format) throws IOException {\n        int imageNumber = getAllPictures().size() + 1;\n        XSSFPictureData img = createRelationship(XSSFPictureData.RELATIONS[format], this.xssfFactory, imageNumber, true).getDocumentPart();\n        try (OutputStream out = img.getPackagePart().getOutputStream()) {\n            IOUtils.copy(is, out);\n        }\n        pictures.add(img);\n        return imageNumber - 1;\n    }
24	private static double invokeInternal(Function target, ValueEval[] args, int srcCellRow, int srcCellCol)\n				throws NumericEvalEx {\n		ValueEval evalResult;\n		try {\n			evalResult = target.evaluate(args, srcCellRow, (short)srcCellCol);\n		} catch (NotImplementedException e) {\n			throw new NumericEvalEx("Not implemented:" + e.getMessage());\n		}\n\n		if(evalResult == null) {\n			throw new NumericEvalEx("Result object was null");\n		}\n		if(evalResult instanceof ErrorEval) {\n			ErrorEval ee = (ErrorEval) evalResult;\n			throw new NumericEvalEx(formatErrorMessage(ee));\n		}\n		if(!(evalResult instanceof NumericValueEval)) {\n			throw new NumericEvalEx("Result object type (" + evalResult.getClass().getName()\n					+ ") is invalid.  Expected implementor of ("\n					+ NumericValueEval.class.getName() + ")");\n		}\n\n		NumericValueEval result = (NumericValueEval) evalResult;\n		return result.getNumberValue();\n	}
25	protected final void onSave(Set<PackagePart> alreadySaved) throws IOException {\n                if (this.isCommited) {\n            return;\n        }\n\n                prepareForCommit();\n\n        commit();\n        alreadySaved.add(this.getPackagePart());\n        for (RelationPart rp : relations.values()) {\n            POIXMLDocumentPart p = rp.getDocumentPart();\n            if (!alreadySaved.contains(p.getPackagePart())) {\n                p.onSave(alreadySaved);\n            }\n        }\n    }
26	public static Workbook create(InputStream inp, String password) throws IOException, EncryptedDocumentException {\n        InputStream is = FileMagic.prepareToCheckMagic(inp);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        switch (fm) {\n            case OLE2:\n                POIFSFileSystem fs = new POIFSFileSystem(is);\n                return create(fs, password);\n            case OOXML:\n                return createXSSFWorkbook(is);\n            default:\n                throw new IOException("Your InputStream was neither an OLE2 stream, nor an OOXML stream");\n        }\n    }
27	static I_MatchPredicate createCriteriaPredicate(ValueEval arg, int srcRowIndex, int srcColumnIndex) {\n\n        ValueEval evaluatedCriteriaArg = evaluateCriteriaArg(arg, srcRowIndex, srcColumnIndex);\n\n        if(evaluatedCriteriaArg instanceof NumberEval) {\n            return new NumberMatcher(((NumberEval)evaluatedCriteriaArg).getNumberValue(), CmpOp.OP_NONE);\n        }\n        if(evaluatedCriteriaArg instanceof BoolEval) {\n            return new BooleanMatcher(((BoolEval)evaluatedCriteriaArg).getBooleanValue(), CmpOp.OP_NONE);\n        }\n\n        if(evaluatedCriteriaArg instanceof StringEval) {\n            return createGeneralMatchPredicate((StringEval)evaluatedCriteriaArg);\n        }\n        if(evaluatedCriteriaArg instanceof ErrorEval) {\n            return new ErrorMatcher(((ErrorEval)evaluatedCriteriaArg).getErrorCode(), CmpOp.OP_NONE);\n        }\n        if(evaluatedCriteriaArg == BlankEval.instance) {\n            return null;\n        }\n        throw new RuntimeException("Unexpected type for criteria ("\n                + evaluatedCriteriaArg.getClass().getName() + ")");\n    }
28	public static Dimension getDimensionFromAnchor(Picture picture) {\n        ClientAnchor anchor = picture.getClientAnchor();\n        boolean isHSSF = (anchor instanceof HSSFClientAnchor);\n        Sheet sheet = picture.getSheet();\n\n        double w = 0;\n        int col2 = anchor.getCol1();\n\n                w = sheet.getColumnWidthInPixels(col2++);\n        if (isHSSF) {\n            w *= 1 - anchor.getDx1()/1024d;\n        } else {\n            w -= anchor.getDx1()/(double)EMU_PER_PIXEL;\n        }\n        \n        while(col2 < anchor.getCol2()){\n            w += sheet.getColumnWidthInPixels(col2++);\n        }\n        \n        if (isHSSF) {\n            w += sheet.getColumnWidthInPixels(col2) * anchor.getDx2()/1024d;\n        } else {\n            w += anchor.getDx2()/(double)EMU_PER_PIXEL;\n        }\n\n        double h = 0;\n        int row2 = anchor.getRow1();\n        \n        h = getRowHeightInPixels(sheet,row2++);\n        if (isHSSF) {\n            h *= 1 - anchor.getDy1()/256d;\n        } else {\n            h -= anchor.getDy1()/(double)EMU_PER_PIXEL;\n        }\n\n        while(row2 < anchor.getRow2()){\n            h += getRowHeightInPixels(sheet,row2++);\n        }\n        \n        if (isHSSF) {\n            h += getRowHeightInPixels(sheet,row2) * anchor.getDy2()/256;\n        } else {\n            h += anchor.getDy2()/(double)EMU_PER_PIXEL;\n        }\n\n        w *= EMU_PER_PIXEL;\n        h *= EMU_PER_PIXEL;\n        \n        return new Dimension((int)Math.rint(w), (int)Math.rint(h));\n    }
29	public void applyFont(short fontIndex) {\n        XSSFFont font;\n        if(styles == null) {\n            font = new XSSFFont();\n            font.setFontName("#" + fontIndex);\n        } else {\n            font = styles.getFontAt(fontIndex);\n        }\n        String text = getString();\n        applyFont(0, text.length(), font);\n    }
30	private static String normalizePartName(URI partName, String baseUri) throws XMLSignatureException {\n        String pn = partName.toASCIIString();\n        if (!pn.startsWith(baseUri)) {\n            pn = baseUri + pn;\n        }\n        try {\n            pn = new URI(pn).normalize().getPath().replace('\\', '/');\n            LOG.log(POILogger.DEBUG, "part name: " + pn);\n        } catch (URISyntaxException e) {\n            throw new XMLSignatureException(e);\n        }\n        return pn;\n    }
31	protected ByteBuffer getBlockAt(final int offset) {\n              int byteOffset = offset * POIFSConstants.SMALL_BLOCK_SIZE;\n       int bigBlockNumber = byteOffset / _filesystem.getBigBlockSize();\n       int bigBlockOffset = byteOffset % _filesystem.getBigBlockSize();\n       \n              Iterator<ByteBuffer> it = _mini_stream.getBlockIterator();\n       for(int i=0; i<bigBlockNumber; i++) {\n          it.next();\n       }\n       ByteBuffer dataBlock = it.next();\n       if(dataBlock == null) {\n          throw new IndexOutOfBoundsException("Big block " + bigBlockNumber + " outside stream");\n       }\n\n              dataBlock.position(\n             dataBlock.position() + bigBlockOffset\n       );\n       ByteBuffer miniBuffer = dataBlock.slice();\n       miniBuffer.limit(POIFSConstants.SMALL_BLOCK_SIZE);\n       return miniBuffer;\n    }
32	private List<? extends DataValidation> getValidations(Sheet sheet) {\n        List<? extends DataValidation> dvs = validations.get(sheet.getSheetName());\n        if (dvs == null && !validations.containsKey(sheet.getSheetName())) {\n            dvs = sheet.getDataValidations();\n            validations.put(sheet.getSheetName(), dvs);\n        }\n        return dvs;\n    }
33	public static Area3DPxg parseStructuredReference(String tableText, FormulaParsingWorkbook workbook, int rowIndex) {\n        final int sheetIndex = -1;         Ptg[] arr = FormulaParser.parse(tableText, workbook, FormulaType.CELL, sheetIndex, rowIndex);\n        if (arr.length != 1 || !(arr[0] instanceof Area3DPxg) ) {\n            throw new IllegalStateException("Illegal structured reference");\n        }\n        return (Area3DPxg) arr[0];\n    }
34	public void drawShape(Graphics2D graphics, Shape<?,?> shape, Rectangle2D bounds) {\n        Rectangle2D shapeBounds = shape.getAnchor();\n        if (shapeBounds.isEmpty() || (bounds != null && bounds.isEmpty())) {\n            return;\n        }\n\n        AffineTransform txg = (AffineTransform)graphics.getRenderingHint(Drawable.GROUP_TRANSFORM);\n        AffineTransform tx = new AffineTransform();\n        try {\n            if (bounds != null) {\n                double scaleX = bounds.getWidth()/shapeBounds.getWidth();\n                double scaleY = bounds.getHeight()/shapeBounds.getHeight();\n                tx.translate(bounds.getCenterX(), bounds.getCenterY());\n                tx.scale(scaleX, scaleY);\n                tx.translate(-shapeBounds.getCenterX(), -shapeBounds.getCenterY());\n            }\n            graphics.setRenderingHint(Drawable.GROUP_TRANSFORM, tx);\n            \n            Drawable d = getDrawable(shape);\n            d.applyTransform(graphics);\n            d.draw(graphics);\n        } finally {\n            graphics.setRenderingHint(Drawable.GROUP_TRANSFORM, txg);\n        }\n    }
35	public int getIndexOfFormattingRun(int index) {\n        if(st.sizeOfRArray() == 0) return 0;\n\n        int pos = 0;\n        for(int i = 0; i < st.sizeOfRArray(); i++){\n            CTRElt r = st.getRArray(i);\n            if(i == index) return pos;\n\n            pos += r.getT().length();\n        }\n        return -1;\n    }
36	public void fixFonts(Graphics2D graphics) {\n        if (!JvmBugs.hasLineBreakMeasurerBug()) return;\n        @SuppressWarnings("unchecked")\n        Map<String,String> fontMap = (Map<String,String>)graphics.getRenderingHint(Drawable.FONT_MAP);\n        if (fontMap == null) {\n            fontMap = new HashMap<>();\n            graphics.setRenderingHint(Drawable.FONT_MAP, fontMap);\n        }\n        \n        String fonts[][] = {\n            { "Calibri", "Lucida Sans" },\n            { "Cambria", "Lucida Bright" },\n            { "Times New Roman", "Lucida Bright" },\n            { "serif", "Lucida Bright" }\n        };\n\n        for (String f[] : fonts) {\n            if (!fontMap.containsKey(f[0])) {\n                fontMap.put(f[0], f[1]);\n            }\n        }\n    }
37	private void write(POIFSFileSystem fs) throws IOException {\n                        List<String> excepts = new ArrayList<>(1);\n\n                fs.createDocument(new ByteArrayInputStream(getBytes()), "Workbook");\n\n                writeProperties(fs, excepts);\n        \n        if (preserveNodes) {\n                                                excepts.addAll(Arrays.asList(WORKBOOK_DIR_ENTRY_NAMES));\n\n                                    excepts.addAll(Arrays.asList(\n                DocumentSummaryInformation.DEFAULT_STREAM_NAME,\n                SummaryInformation.DEFAULT_STREAM_NAME,\n                getEncryptedPropertyStreamName()\n            ));\n\n                        EntryUtils.copyNodes(\n                    new FilteringDirectoryNode(getDirectory(), excepts)\n                    , new FilteringDirectoryNode(fs.getRoot(), excepts)\n                    );\n\n                                    fs.getRoot().setStorageClsid(getDirectory().getStorageClsid());\n        }\n    }
38	static HSSFPatriarch createPatriarch(HSSFPatriarch patriarch, HSSFSheet sheet){\n        HSSFPatriarch newPatriarch = new HSSFPatriarch(sheet, new EscherAggregate(true));\n        newPatriarch.afterCreate();\n        for (HSSFShape shape: patriarch.getChildren()){\n            HSSFShape newShape;\n            if (shape instanceof HSSFShapeGroup){\n                newShape = ((HSSFShapeGroup)shape).cloneShape(newPatriarch);\n            } else {\n                newShape = shape.cloneShape();\n            }\n            newPatriarch.onCreate(newShape);\n            newPatriarch.addShape(newShape);\n        }\n        return newPatriarch;\n    }
39	public static CFRule12Record create(HSSFSheet sheet, byte comparisonOperation,\n            String formulaText1, String formulaText2, String formulaTextScale) {\n        Ptg[] formula1 = parseFormula(formulaText1, sheet);\n        Ptg[] formula2 = parseFormula(formulaText2, sheet);\n        Ptg[] formula3 = parseFormula(formulaTextScale, sheet);\n        return new CFRule12Record(CONDITION_TYPE_CELL_VALUE_IS, comparisonOperation, \n                formula1, formula2, formula3);\n    }
40	public void construct(CellValueRecordInterface rec, RecordStream rs, SharedValueManager sfh) {\n		if (rec instanceof FormulaRecord) {\n			FormulaRecord formulaRec = (FormulaRecord)rec;\n						StringRecord cachedText;\n			Class<? extends Record> nextClass = rs.peekNextClass();\n			if (nextClass == StringRecord.class) {\n				cachedText = (StringRecord) rs.getNext();\n			} else {\n				cachedText = null;\n			}\n			insertCell(new FormulaRecordAggregate(formulaRec, cachedText, sfh));\n		} else {\n			insertCell(rec);\n		}\n	}
41	protected boolean processSheet( HSSFWorkbook workbook, int sheetIndex )\n    {\n        String pageMasterName = "sheet-" + sheetIndex;\n\n        Element pageSequence = foDocumentFacade\n                .createPageSequence( pageMasterName );\n        Element flow = foDocumentFacade.addFlowToPageSequence( pageSequence,\n                "xsl-region-body" );\n\n        HSSFSheet sheet = workbook.getSheetAt( sheetIndex );\n        float tableWidthIn = processSheet( workbook, sheet, flow );\n\n        if ( tableWidthIn == 0 )\n            return false;\n\n        createPageMaster( tableWidthIn, pageMasterName );\n        foDocumentFacade.addPageSequence( pageSequence );\n        return true;\n    }
42	public XDDFTextRun appendField(String id, String type, String text) {\n        CTTextField f = _p.addNewFld();\n        f.setId(id);\n        f.setType(type);\n        f.setT(text);\n        CTTextCharacterProperties rPr = f.addNewRPr();\n        rPr.setLang(LocaleUtil.getUserLocale().toLanguageTag());\n        XDDFTextRun run = new XDDFTextRun(f, this);\n        _runs.add(run);\n        return run;\n    }
43	public void dump(Writer outWriter) throws IOException {\n        this.out = outWriter;\n\n        int padding = 0;\n        write(out, "<Presentation>" + CR, padding);\n        padding++;\n        if (pictstream != null){\n            write(out, "<Pictures>" + CR, padding);\n            dumpPictures(pictstream, padding);\n            write(out, "</Pictures>" + CR, padding);\n        }\n                write(out, "<PowerPointDocument>" + CR, padding);\n        padding++;\n        dump(docstream, 0, docstream.length, padding);\n        padding--;\n        write(out, "</PowerPointDocument>" + CR, padding);\n        padding--;\n        write(out, "</Presentation>", padding);\n    }
44	@Internal\n    public XWPFFootnote addFootnote(CTFtnEdn note) {\n        CTFtnEdn newNote = ctFootnotes.addNewFootnote();\n        newNote.set(note);\n        XWPFFootnote xNote = new XWPFFootnote(newNote, this);\n        listFootnote.add(xNote);\n        return xNote;\n    }
45	public final RelationPart addRelation(String relId, POIXMLRelation relationshipType, POIXMLDocumentPart part) {\n        PackageRelationship pr = this.packagePart.findExistingRelation(part.getPackagePart());\n        if (pr == null) {\n            PackagePartName ppn = part.getPackagePart().getPartName();\n            String relType = relationshipType.getRelation();\n            pr = packagePart.addRelationship(ppn, TargetMode.INTERNAL, relType, relId);\n        }\n        addRelation(pr, part);\n        return new RelationPart(pr, part);\n    }
46	public String getText() {\n        DataFormatter formatter;\n        if(locale == null) {\n            formatter = new DataFormatter();\n        } else  {\n            formatter = new DataFormatter(locale);\n        }\n\n        StringBuilder text = new StringBuilder(64);\n        for(Sheet sh : workbook) {\n            XSSFSheet sheet = (XSSFSheet) sh;\n            if(includeSheetNames) {\n                text.append(sheet.getSheetName()).append("\n");\n            }\n\n                        if(includeHeadersFooters) {\n                text.append(\n                        extractHeaderFooter(sheet.getFirstHeader())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getOddHeader())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getEvenHeader())\n                        );\n            }\n\n                        for (Object rawR : sheet) {\n                Row row = (Row)rawR;\n                for(Iterator<Cell> ri = row.cellIterator(); ri.hasNext();) {\n                    Cell cell = ri.next();\n\n                                        if(cell.getCellType() == CellType.FORMULA) {\n                        if (formulasNotResults) {\n                            String contents = cell.getCellFormula();\n                            checkMaxTextSize(text, contents);\n                            text.append(contents);\n                        } else {\n                            if (cell.getCachedFormulaResultType() == CellType.STRING) {\n                                handleStringCell(text, cell);\n                            } else {\n                                handleNonStringCell(text, cell, formatter);\n                            }\n                        }\n                    } else if(cell.getCellType() == CellType.STRING) {\n                        handleStringCell(text, cell);\n                    } else {\n                        handleNonStringCell(text, cell, formatter);\n                    }\n\n                                        Comment comment = cell.getCellComment();\n                    if(includeCellComments && comment != null) {\n                                                                        String commentText = comment.getString().getString().replace('\n', ' ');\n                        checkMaxTextSize(text, commentText);\n                        text.append(" Comment by ").append(comment.getAuthor()).append(": ").append(commentText);\n                    }\n\n                    if(ri.hasNext()) {\n                        text.append("\t");\n                    }\n                }\n                text.append("\n");\n            }\n            \n                        if (includeTextBoxes){\n                XSSFDrawing drawing = sheet.getDrawingPatriarch();\n                if (drawing != null) {\n                    for (XSSFShape shape : drawing.getShapes()){\n                        if (shape instanceof XSSFSimpleShape){\n                            String boxText = ((XSSFSimpleShape)shape).getText();\n                            if (boxText.length() > 0){\n                                text.append(boxText);\n                                text.append('\n');\n                            }\n                        }\n                    }\n                }\n            }\n                        if(includeHeadersFooters) {\n                text.append(\n                        extractHeaderFooter(sheet.getFirstFooter())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getOddFooter())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getEvenFooter())\n                        );\n            }\n        }\n\n        return text.toString();\n    }
47	public Sheet build() {\n        Sheet sheet = (sheetName == null) ? workbook.createSheet() : workbook.createSheet(sheetName);\n        Row currentRow;\n        Cell currentCell;\n\n        for (int rowIndex = 0; rowIndex < cells.length; ++rowIndex) {\n            Object[] rowArray = cells[rowIndex];\n            currentRow = sheet.createRow(rowIndex);\n\n            for (int cellIndex = 0; cellIndex < rowArray.length; ++cellIndex) {\n                Object cellValue = rowArray[cellIndex];\n                if (cellValue != null || shouldCreateEmptyCells) {\n                    currentCell = currentRow.createCell(cellIndex);\n                    setCellValue(currentCell, cellValue);\n                }\n            }\n        }\n        return sheet;\n    }
48	private Ptg adjustPtgDueToMove(Ptg ptg, int currentExternSheetIx, boolean isRowMove) {\n        if(ptg instanceof RefPtg) {\n            if (currentExternSheetIx != _externSheetIndex) {\n                                return null;\n            }\n            RefPtg rptg = (RefPtg)ptg;\n            return isRowMove ? rowMoveRefPtg(rptg) : columnMoveRefPtg(rptg);\n        }\n        if(ptg instanceof Ref3DPtg) {\n            Ref3DPtg rptg = (Ref3DPtg)ptg;\n            if (_externSheetIndex != rptg.getExternSheetIndex()) {\n                                                return null;\n            }\n            return isRowMove ? rowMoveRefPtg(rptg) : columnMoveRefPtg(rptg);\n        }\n        if(ptg instanceof Ref3DPxg) {\n            Ref3DPxg rpxg = (Ref3DPxg)ptg;\n            if (rpxg.getExternalWorkbookNumber() > 0 ||\n                    ! _sheetName.equalsIgnoreCase(rpxg.getSheetName())) {\n                                return null;\n            }\n            return isRowMove ? rowMoveRefPtg(rpxg) : columnMoveRefPtg(rpxg);\n        }\n        if(ptg instanceof Area2DPtgBase) {\n            if (currentExternSheetIx != _externSheetIndex) {\n                                return ptg;\n            }\n            Area2DPtgBase aptg = (Area2DPtgBase) ptg;\n            return isRowMove ? rowMoveAreaPtg(aptg) : columnMoveAreaPtg(aptg);\n        }\n        if(ptg instanceof Area3DPtg) {\n            Area3DPtg aptg = (Area3DPtg)ptg;\n            if (_externSheetIndex != aptg.getExternSheetIndex()) {\n                                                return null;\n            }\n            return isRowMove ? rowMoveAreaPtg(aptg) : columnMoveAreaPtg(aptg);\n        }\n        if(ptg instanceof Area3DPxg) {\n            Area3DPxg apxg = (Area3DPxg)ptg;\n            if (apxg.getExternalWorkbookNumber() > 0 ||\n                    ! _sheetName.equalsIgnoreCase(apxg.getSheetName())) {\n                                return null;\n            }\n            return isRowMove ? rowMoveAreaPtg(apxg) : columnMoveAreaPtg(apxg);\n        }\n        return null;\n    }
49	public boolean equals(Object o)\n    {\n        if (!(o instanceof UnicodeString)) {\n            return false;\n        }\n        UnicodeString other = (UnicodeString) o;\n\n                if (field_1_charCount != other.field_1_charCount\n            || field_2_optionflags != other.field_2_optionflags\n            || !field_3_string.equals(other.field_3_string)) {\n            return false;\n        }\n\n                if (field_4_format_runs == null) {\n                        return (other.field_4_format_runs == null);\n        } else if (other.field_4_format_runs == null) {\n                        return false;\n        }\n\n                int size = field_4_format_runs.size();\n        if (size != other.field_4_format_runs.size()) {\n          return false;\n        }\n\n        for (int i=0;i<size;i++) {\n          FormatRun run1 = field_4_format_runs.get(i);\n          FormatRun run2 = other.field_4_format_runs.get(i);\n\n          if (!run1.equals(run2)) {\n            return false;\n          }\n        }\n\n                if (field_5_ext_rst == null) {\n            return (other.field_5_ext_rst == null);\n        } else if (other.field_5_ext_rst == null) {\n            return false;\n        }\n            \n       return field_5_ext_rst.equals(other.field_5_ext_rst);\n    }
50	public static void dump(final byte [] data, final long offset,\n        final OutputStream stream, final int index, final int length)\n    throws IOException, ArrayIndexOutOfBoundsException, IllegalArgumentException {\n        if (stream == null) {\n            throw new IllegalArgumentException("cannot write to nullstream");\n        }\n\n        OutputStreamWriter osw = new OutputStreamWriter(stream, UTF8);\n        osw.write(dump(data, offset, index, length));\n        osw.flush();\n    }
51	public void processWorkbookEvents(HSSFRequest req, DirectoryNode dir) throws IOException {\n                String name = null;\n        Set<String> entryNames = dir.getEntryNames();\n        for (String potentialName : WORKBOOK_DIR_ENTRY_NAMES) {\n            if (entryNames.contains(potentialName)) {\n                name = potentialName;\n                break;\n            }\n        }\n                if (name == null) {\n            name = WORKBOOK_DIR_ENTRY_NAMES[0];\n        }\n\n        InputStream in = dir.createDocumentInputStream(name);\n        try {\n            processEvents(req, in);\n        } finally {\n            in.close();\n        }\n    }
52	void clearButKeepProperties() {\n        CTTextParagraph thisP = getXmlObject();\n        for (int i=thisP.sizeOfBrArray(); i>0; i--) {\n            thisP.removeBr(i-1);\n        }\n        for (int i=thisP.sizeOfFldArray(); i>0; i--) {\n            thisP.removeFld(i-1);\n        }\n        if (!_runs.isEmpty()) {\n            int size = _runs.size();\n            XSLFTextRun lastRun = _runs.get(size-1);\n            CTTextCharacterProperties cpOther = lastRun.getRPr(false);\n            if (cpOther != null) {\n                if (thisP.isSetEndParaRPr()) {\n                    thisP.unsetEndParaRPr();\n                }\n                CTTextCharacterProperties cp = thisP.addNewEndParaRPr();\n                cp.set(cpOther);\n            }\n            for (int i=size; i>0; i--) {\n                thisP.removeR(i-1);\n            }\n            _runs.clear();\n        }\n    }
53	private ParseNode  Term() {\n        ParseNode result = powerFactor();\n        while(true) {\n            SkipWhite();\n            Ptg operator;\n            switch(look) {\n                case '*':\n                    Match('*');\n                    operator = MultiplyPtg.instance;\n                    break;\n                case '/':\n                    Match('/');\n                    operator = DividePtg.instance;\n                    break;\n                default:\n                    return result;             }\n            ParseNode other = powerFactor();\n            result = new ParseNode(operator, result, other);\n        }\n    }
54	private static DefaultRowHeightRecord createDefaultRowHeight() {\n        DefaultRowHeightRecord retval = new DefaultRowHeightRecord();\n\n        retval.setOptionFlags(( short ) 0);\n        retval.setRowHeight(DefaultRowHeightRecord.DEFAULT_ROW_HEIGHT);\n        return retval;\n    }
55	public static boolean copyStream(InputStream inStream, OutputStream outStream) {\n		try {\n			byte[] buffer = new byte[1024];\n			int bytesRead;\n			while ((bytesRead = inStream.read(buffer)) >= 0) {\n				outStream.write(buffer, 0, bytesRead);\n			}\n		} catch (Exception e) {\n			return false;\n		}\n		return true;\n	}
56	public static int compare(final String str1, final String str2)\n    {\n        if (str1 == null) {\n                        return (str2 == null ? 0 : -1);\n        } else if (str2 == null) {\n                        return 1;\n        }\n        \n        if (str1.equalsIgnoreCase(str2)) {\n            return 0;\n        }\n        final String name1 = str1.toLowerCase(Locale.ROOT);\n        final String name2 = str2.toLowerCase(Locale.ROOT);\n\n        final int len1 = name1.length();\n        final int len2 = name2.length();\n        for (int idx1 = 0, idx2 = 0; idx1 < len1 && idx2 < len2; ) {\n            final char c1 = name1.charAt(idx1++);\n            final char c2 = name2.charAt(idx2++);\n\n            if (Character.isDigit(c1) && Character.isDigit(c2)) {\n                final int beg1 = idx1 - 1;                  while (idx1 < len1 && Character.isDigit(name1.charAt(idx1))) {\n                    idx1++;\n                }\n\n                final int beg2 = idx2 - 1;                  while (idx2 < len2 && Character.isDigit(name2.charAt(idx2))) {\n                    idx2++;\n                }\n\n                                final BigInteger b1 = new BigInteger(name1.substring(beg1, idx1));\n                final BigInteger b2 = new BigInteger(name2.substring(beg2, idx2));\n                final int cmp = b1.compareTo(b2);\n                if (cmp != 0) {\n                    return cmp;\n                }\n            }\n            else if (c1 != c2) {\n                return (c1 - c2);\n            }\n        }\n\n        return (len1 - len2);\n    }
57	public String getText() {\n       String text;\n       try {\n           TextListener tl = triggerExtraction();\n\n           text = tl._text.toString();\n           if(! text.endsWith("\n")) {\n               text = text + "\n";\n           }\n       } catch(IOException e) {\n           throw new RuntimeException(e);\n       }\n\n       return text;\n   }
58	public XSSFTableColumn createColumn(String columnName, int columnIndex) {\n                \n        int columnCount = getColumnCount();\n        if(columnIndex < 0 || columnIndex > columnCount) {\n            throw new IllegalArgumentException("Column index out of bounds");\n        }\n        \n                CTTableColumns columns = ctTable.getTableColumns();\n        if (columns == null) {\n            columns = ctTable.addNewTableColumns();\n        }\n        \n                long nextColumnId = 1; \n        for (XSSFTableColumn tableColumn : getColumns()) {\n            if (columnName != null && columnName.equalsIgnoreCase(tableColumn.getName())) {\n                throw new IllegalArgumentException("Column '" + columnName\n                        + "' already exists. Column names must be unique per table.");\n            }\n            nextColumnId = Math.max(nextColumnId, tableColumn.getId());\n        }\n        \n                CTTableColumn column = columns.insertNewTableColumn(columnIndex);\n        columns.setCount(columns.sizeOfTableColumnArray());\n        \n        column.setId(nextColumnId);\n        if(columnName != null) {\n            column.setName(columnName); \n        } else {\n            column.setName("Column " + nextColumnId);\n        }\n        \n        if (ctTable.getRef() != null) {\n                        int newColumnCount = columnCount + 1;\n            CellReference tableStart = getStartCellReference();\n            CellReference tableEnd = getEndCellReference();\n            SpreadsheetVersion version = getXSSFSheet().getWorkbook().getSpreadsheetVersion();\n            CellReference newTableEnd = new CellReference(tableEnd.getRow(),\n                    tableStart.getCol() + newColumnCount - 1);\n            AreaReference newTableArea = new AreaReference(tableStart, newTableEnd, version);\n\n            setCellRef(newTableArea);\n        }\n        \n        updateHeaders();\n        \n        return getColumns().get(columnIndex);\n    }
59	public static AreaEval createAreaEval(AreaPtg areaPtg, ValueEval[] values) {\n		int nCols = areaPtg.getLastColumn() - areaPtg.getFirstColumn() + 1;\n		int nRows = areaPtg.getLastRow() - areaPtg.getFirstRow() + 1;\n		int nExpected = nRows * nCols;\n		if (values.length != nExpected) {\n			throw new RuntimeException("Expected " + nExpected + " values but got " + values.length);\n		}\n		for (int i = 0; i < nExpected; i++) {\n			if (values[i] == null) {\n				values[i] = NumberEval.ZERO;\n			}\n		}\n		return new MockAreaEval(areaPtg, values);\n	}
60	public static boolean isCellInternalDateFormatted(Cell cell) {\n        if (cell == null) return false;\n        boolean bDate = false;\n\n        double d = cell.getNumericCellValue();\n        if ( DateUtil.isValidExcelDate(d) ) {\n            CellStyle style = cell.getCellStyle();\n            int i = style.getDataFormat();\n            bDate = isInternalDateFormat(i);\n        }\n        return bDate;\n    }
61	public List<Picture> getAllPictures() {\n    ArrayList<Picture> pictures = new ArrayList<>();\n\n    Range range = _document.getOverallRange();\n    for (int i = 0; i < range.numCharacterRuns(); i++) {\n    	CharacterRun run = range.getCharacterRun(i);\n\n        if (run==null) {\n            continue;\n        }\n\n    	Picture picture = extractPicture(run, false);\n    	if (picture != null) {\n    		pictures.add(picture);\n    	}\n	}\n\n    searchForPictures(_dgg.getEscherRecords(), pictures);\n\n    return pictures;\n  }
62	private ParseNode getFunction(String name, Ptg namePtg, ParseNode[] args) {\n\n        FunctionMetadata fm = FunctionMetadataRegistry.getFunctionByName(name.toUpperCase(Locale.ROOT));\n        int numArgs = args.length;\n        if(fm == null) {\n            if (namePtg == null) {\n                throw new IllegalStateException("NamePtg must be supplied for external functions");\n            }\n                        ParseNode[] allArgs = new ParseNode[numArgs+1];\n            allArgs[0] = new ParseNode(namePtg);\n            System.arraycopy(args, 0, allArgs, 1, numArgs);\n            return new ParseNode(FuncVarPtg.create(name, numArgs+1), allArgs);\n        }\n\n        if (namePtg != null) {\n            throw new IllegalStateException("NamePtg no applicable to internal functions");\n        }\n        boolean isVarArgs = !fm.hasFixedArgsLength();\n        int funcIx = fm.getIndex();\n        if (funcIx == FunctionMetadataRegistry.FUNCTION_INDEX_SUM && args.length == 1) {\n                                    return new ParseNode(AttrPtg.getSumSingle(), args);\n                    }\n        validateNumArgs(args.length, fm);\n\n        AbstractFunctionPtg retval;\n        if(isVarArgs) {\n            retval = FuncVarPtg.create(name, numArgs);\n        } else {\n            retval = FuncPtg.create(funcIx);\n        }\n        return new ParseNode(retval, args);\n    }
63	private static int performBinarySearch(ValueVector vector, LookupValueComparer lookupComparer) {\n				BinarySearchIndexes bsi = new BinarySearchIndexes(vector.getSize());\n\n		while(true) {\n			int midIx = bsi.getMidIx();\n\n			if(midIx < 0) {\n				return bsi.getLowIx();\n			}\n			CompareResult cr = lookupComparer.compareTo(vector.getItem(midIx));\n			if(cr.isTypeMismatch()) {\n				int newMidIx = handleMidValueTypeMismatch(lookupComparer, vector, bsi, midIx);\n				if(newMidIx < 0) {\n					continue;\n				}\n				midIx = newMidIx;\n				cr = lookupComparer.compareTo(vector.getItem(midIx));\n			}\n			if(cr.isEqual()) {\n				return findLastIndexInRunOfEqualValues(lookupComparer, vector, midIx, bsi.getHighIx());\n			}\n			bsi.narrowSearch(midIx, cr.isLessThan());\n		}\n	}
64	protected void readProperties() {\n        if (initialized) {\n            return;\n        }\n        DocumentSummaryInformation dsi = readPropertySet(DocumentSummaryInformation.class, DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n        if (dsi != null) {\n            dsInf = dsi;\n        }\n        SummaryInformation si = readPropertySet(SummaryInformation.class, SummaryInformation.DEFAULT_STREAM_NAME);\n        if (si != null) {\n            sInf = si;\n        }\n\n                initialized = true;\n    }
65	@Internal\n    public CTComment newComment(CellAddress ref) {\n        CTComment ct = comments.getCommentList().addNewComment();\n        ct.setRef(ref.formatAsString());\n        ct.setAuthorId(DEFAULT_AUTHOR_ID);\n        \n        if(commentRefs != null) {\n           commentRefs.put(ref, ct);\n        }\n        return ct;\n    }
66	private static String processFormatPattern(String f) {\n        String t = f.replaceAll("MMMMM", MMMMM_START_SYMBOL + "MMM" + MMMMM_TRUNCATE_SYMBOL);\n        t = t.replaceAll("\\[H]", String.valueOf(H_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[HH]", String.valueOf(HH_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[m]", String.valueOf(M_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[mm]", String.valueOf(MM_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[s]", String.valueOf(S_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[ss]", String.valueOf(SS_BRACKET_SYMBOL));\n        t = t.replaceAll("s.000", "s.SSS");\n        t = t.replaceAll("s.00", "s." + LL_BRACKET_SYMBOL);\n        t = t.replaceAll("s.0", "s." + L_BRACKET_SYMBOL);\n        return t;\n    }
67	private int drawDashDotDot(Graphics g,int x, int y, int thickness,\n                              boolean horizontal,\n                              boolean rightBottom) {\n\n      for (int t=0; t < thickness; t++) {\n         if (!rightBottom) {\n            t = 0 - t;                                 }\n         if (horizontal) {\n            g.drawLine(x,y+t,x+5,y+t);\n            g.drawLine(x+8,y+t,x+10,y+t);\n            g.drawLine(x+13,y+t,x+15,y+t);\n         } else {\n            g.drawLine(x+t,y,x+t,y+5);\n            g.drawLine(x+t,y+8,x+t,y+10);\n            g.drawLine(x+t,y+13,x+t,y+15);\n         }\n      }\n      return 18;\n   }
68	private static CellType determineType(CellValueRecordInterface cval) {\n        if (cval instanceof FormulaRecordAggregate) {\n            return CellType.FORMULA;\n        }\n                Record record = ( Record ) cval;\n        switch (record.getSid()) {\n\n            case NumberRecord.sid :   return CellType.NUMERIC;\n            case BlankRecord.sid :    return CellType.BLANK;\n            case LabelSSTRecord.sid : return CellType.STRING;\n            case BoolErrRecord.sid :\n                BoolErrRecord boolErrRecord = ( BoolErrRecord ) record;\n\n                return boolErrRecord.isBoolean()\n                         ? CellType.BOOLEAN\n                         : CellType.ERROR;\n        }\n        throw new RuntimeException("Bad cell value rec (" + cval.getClass().getName() + ")");\n    }
69	public static PackagePartName createPartName(String partName)\n			throws InvalidFormatException {\n		URI partNameURI;\n		try {\n			partNameURI = toURI(partName);\n		} catch (URISyntaxException e) {\n			throw new InvalidFormatException(e.getMessage());\n		}\n		return createPartName(partNameURI);\n	}
70	@Beta\n    public void addRowLabel(int columnIndex) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        final int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_ROW);\n        pivotField.setShowAll(false);\n        for (int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTRowFields rowFields;\n        if(pivotTableDefinition.getRowFields() != null) {\n            rowFields = pivotTableDefinition.getRowFields();\n        } else {\n            rowFields = pivotTableDefinition.addNewRowFields();\n        }\n\n        rowFields.addNewField().setX(columnIndex);\n        rowFields.setCount(rowFields.sizeOfFieldArray());\n    }
71	public Pointer createPointer(byte[] data, int offset) {\n        Pointer p;\n        if(version >= 6) {\n            p = new PointerV6();\n            p.setType(LittleEndian.getInt(data, offset+0));\n            p.setAddress((int)LittleEndian.getUInt(data, offset+4));\n            p.setOffset((int)LittleEndian.getUInt(data, offset+8));\n            p.setLength((int)LittleEndian.getUInt(data, offset+12));\n            p.setFormat(LittleEndian.getShort(data, offset+16));\n\n            return p;\n        } else if(version == 5) {\n            p = new PointerV5();\n            p.setType(LittleEndian.getShort(data, offset+0));\n            p.setFormat(LittleEndian.getShort(data, offset+2));\n            p.setAddress((int)LittleEndian.getUInt(data, offset+4));\n            p.setOffset((int)LittleEndian.getUInt(data, offset+8));\n            p.setLength((int)LittleEndian.getUInt(data, offset+12));\n\n            return p;\n        } else {\n            throw new IllegalArgumentException("Visio files with versions below 5 are not supported, yours was " + version);\n        }\n    }
72	public static long copy(InputStream inp, OutputStream out) throws IOException {\n        final byte[] buff = new byte[4096];\n        long totalCount = 0;\n        for (int count; (count = inp.read(buff)) != -1; totalCount += count) {\n            if (count > 0) {\n                out.write(buff, 0, count);\n            }\n        }\n        return totalCount;\n    }
73	private Set<ValueAndFormat> getMeaningfulValues(CellRangeAddress region, boolean withText, ValueFunction func) {\n        Set<ValueAndFormat> values = meaningfulRegionValues.get(region);\n        if (values != null) {\n            return values;\n        }\n        \n        List<ValueAndFormat> allValues = new ArrayList<>((region.getLastColumn() - region.getFirstColumn() + 1) * (region.getLastRow() - region.getFirstRow() + 1));\n        \n        for (int r=region.getFirstRow(); r <= region.getLastRow(); r++) {\n            final Row row = sheet.getRow(r);\n            if (row == null) {\n                continue;\n            }\n            for (int c = region.getFirstColumn(); c <= region.getLastColumn(); c++) {\n                Cell cell = row.getCell(c);\n                final ValueAndFormat cv = getCellValue(cell);\n                if (withText || cv.isNumber()) {\n                    allValues.add(cv);\n                }\n            }\n        }\n        \n        values = func.evaluate(allValues);\n        meaningfulRegionValues.put(region, values);\n        \n        return values;\n    }
74	public CFRecordsAggregate cloneCFAggregate() {\n        CFRuleBase[] newRecs = new CFRuleBase[rules.size()];\n        for (int i = 0; i < newRecs.length; i++) {\n            newRecs[i] = getRule(i).clone();\n        }\n        return new CFRecordsAggregate(header.clone(), newRecs);\n    }
75	public void unwriteProtectWorkbook() {\n        records.remove(fileShare);\n        records.remove(writeProtect);\n        fileShare = null;\n        writeProtect = null;\n    }
76	public PackageRelationship addRelationship(URI targetUri,\n            TargetMode targetMode, String relationshipType, String id) {\n      if (id == null) {\n                  if (nextRelationshipId == -1) {\n            nextRelationshipId = size() + 1;\n         }\n\n                  do {\n            id = "rId" + nextRelationshipId++;\n         } while (relationshipsByID.get(id) != null);\n      }\n\n        PackageRelationship rel = new PackageRelationship(container,\n                sourcePart, targetUri, targetMode, relationshipType, id);\n        addRelationship(rel);\n        if (targetMode == TargetMode.INTERNAL){\n            internalRelationshipsByTargetName.put(targetUri.toASCIIString(), rel);\n        }\n        return rel;\n    }
77	protected static OPCPackage newPackage() {\n        try {\n            OPCPackage pkg = OPCPackage.create(new ByteArrayOutputStream());                            PackagePartName corePartName = PackagingURIHelper.createPartName(XWPFRelation.DOCUMENT.getDefaultFileName());\n                        pkg.addRelationship(corePartName, TargetMode.INTERNAL, PackageRelationshipTypes.CORE_DOCUMENT);\n                        pkg.createPart(corePartName, XWPFRelation.DOCUMENT.getContentType());\n\n            pkg.getPackageProperties().setCreatorProperty(DOCUMENT_CREATOR);\n\n            return pkg;\n        } catch (Exception e) {\n            throw new POIXMLException(e);\n        }\n    }
78	public void clearStyles() {\n        paragraphStyles.clear();\n        charStyles.clear();\n        reserved = new byte[0];\n        initialised = true;\n    }
79	public void addSlideListWithText(SlideListWithText slwt) {\n						Record endDoc = _children[_children.length - 1];\n		if(endDoc.getRecordType() == RecordTypes.RoundTripCustomTableStyles12Atom.typeID) {\n		    		    endDoc = _children[_children.length - 2];\n		}\n		if(endDoc.getRecordType() != RecordTypes.EndDocument.typeID) {\n			throw new IllegalStateException("The last child record of a Document should be EndDocument, but it was " + endDoc);\n		}\n\n				addChildBefore(slwt, endDoc);\n\n				int newSize = slwts.length + 1;\n		SlideListWithText[] nl = new SlideListWithText[newSize];\n		System.arraycopy(slwts, 0, nl, 0, slwts.length);\n		nl[nl.length-1] = slwt;\n		slwts = nl;\n	}
80	private void convertToCSV() {\n        Sheet sheet;\n        Row row;\n        int lastRowNum;\n        this.csvData = new ArrayList<>();\n\n        System.out.println("Converting files contents to CSV format.");\n\n                int numSheets = this.workbook.getNumberOfSheets();\n\n                for(int i = 0; i < numSheets; i++) {\n\n                                    sheet = this.workbook.getSheetAt(i);\n            if(sheet.getPhysicalNumberOfRows() > 0) {\n\n                                                                                                                lastRowNum = sheet.getLastRowNum();\n                for(int j = 0; j <= lastRowNum; j++) {\n                    row = sheet.getRow(j);\n                    this.rowToCSV(row);\n                }\n            }\n        }\n    }
81	public static synchronized DocumentBuilder newDocumentBuilder() {\n        try {\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n            documentBuilder.setEntityResolver(SAXHelper.IGNORING_ENTITY_RESOLVER);\n            documentBuilder.setErrorHandler(new DocHelperErrorHandler());\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException("cannot create a DocumentBuilder", e);\n        }\n    }
82	protected static CTConnector prototype() {\n        if(prototype == null) {\n            CTConnector shape = CTConnector.Factory.newInstance();\n            CTConnectorNonVisual nv = shape.addNewNvCxnSpPr();\n            CTNonVisualDrawingProps nvp = nv.addNewCNvPr();\n            nvp.setId(1);\n            nvp.setName("Shape 1");\n            nv.addNewCNvCxnSpPr();\n\n            CTShapeProperties sp = shape.addNewSpPr();\n            CTTransform2D t2d = sp.addNewXfrm();\n            CTPositiveSize2D p1 = t2d.addNewExt();\n            p1.setCx(0);\n            p1.setCy(0);\n            CTPoint2D p2 = t2d.addNewOff();\n            p2.setX(0);\n            p2.setY(0);\n\n            CTPresetGeometry2D geom = sp.addNewPrstGeom();\n            geom.setPrst(STShapeType.LINE);\n            geom.addNewAvLst();\n\n            CTShapeStyle style = shape.addNewStyle();\n            CTSchemeColor scheme = style.addNewLnRef().addNewSchemeClr();\n            scheme.setVal(STSchemeColorVal.ACCENT_1);\n            style.getLnRef().setIdx(1);\n\n            CTStyleMatrixReference fillref = style.addNewFillRef();\n            fillref.setIdx(0);\n            fillref.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);\n\n            CTStyleMatrixReference effectRef = style.addNewEffectRef();\n            effectRef.setIdx(0);\n            effectRef.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);\n\n            CTFontReference fontRef = style.addNewFontRef();\n            fontRef.setIdx(STFontCollectionIndex.MINOR);\n            fontRef.addNewSchemeClr().setVal(STSchemeColorVal.TX_1);\n\n            prototype = shape;\n        }\n        return prototype;\n    }
83	private void addCell(HSSFCell cell) {\n\n        int column=cell.getColumnIndex();\n                if(column>=cells.length) {\n            HSSFCell[] oldCells=cells;\n                        int newSize=oldCells.length*3/2+1;\n            if(newSize<column+1) {\n                newSize=column+INITIAL_CAPACITY;\n            }\n            cells=new HSSFCell[newSize];\n            System.arraycopy(oldCells,0,cells,0,oldCells.length);\n        }\n        cells[column]=cell;\n\n                if (row.isEmpty() || column < row.getFirstCol()) {\n            row.setFirstCol((short)column);\n        }\n\n        if (row.isEmpty() || column >= row.getLastCol()) {\n            row.setLastCol((short) (column+1));         }\n    }
84	public void addSlidePersistAtom(SlidePersistAtom spa) {\n				appendChildRecord(spa);\n\n		SlideAtomsSet newSAS = new SlideAtomsSet(spa, new Record[0]);\n\n				SlideAtomsSet[] sas = new SlideAtomsSet[slideAtomsSets.length+1];\n		System.arraycopy(slideAtomsSets, 0, sas, 0, slideAtomsSets.length);\n		sas[sas.length-1] = newSAS;\n		slideAtomsSets = sas;\n	}
85	static int[] buildTableCellEdgesArray( Table table )\n    {\n        Set<Integer> edges = new TreeSet<>();\n\n        for ( int r = 0; r < table.numRows(); r++ )\n        {\n            TableRow tableRow = table.getRow( r );\n            for ( int c = 0; c < tableRow.numCells(); c++ )\n            {\n                TableCell tableCell = tableRow.getCell( c );\n\n                edges.add( Integer.valueOf( tableCell.getLeftEdge() ) );\n                edges.add( Integer.valueOf( tableCell.getLeftEdge()\n                        + tableCell.getWidth() ) );\n            }\n        }\n\n        Integer[] sorted = edges.toArray( new Integer[edges.size()] );\n        int[] result = new int[sorted.length];\n        for ( int i = 0; i < sorted.length; i++ )\n        {\n            result[i] = sorted[i].intValue();\n        }\n\n        return result;\n    }
86	public static TwoDEval resolveTableArrayArg(ValueEval eval) throws EvaluationException {\n		if (eval instanceof TwoDEval) {\n			return (TwoDEval) eval;\n		}\n\n		if(eval instanceof RefEval) {\n			RefEval refEval = (RefEval) eval;\n			\n						return refEval.offset(0, 0, 0, 0);\n		}\n		throw EvaluationException.invalidValue();\n	}
87	public void setOutsideBorders(Object... args){\n        if (args.length == 0) return;\n\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = new BorderEdge[4];\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[0] = (col == 0) ? BorderEdge.left : null;\n                edges[1] = (col == cols - 1) ? BorderEdge.right : null;\n                edges[2] = (row == 0) ? BorderEdge.top : null;\n                edges[3] = (row == rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
88	public static synchronized XMLReader newXMLReader() throws SAXException, ParserConfigurationException {\n        XMLReader xmlReader = saxFactory.newSAXParser().getXMLReader();\n        xmlReader.setEntityResolver(IGNORING_ENTITY_RESOLVER);\n        trySetSAXFeature(xmlReader, XMLConstants.FEATURE_SECURE_PROCESSING);\n        trySetXercesSecurityManager(xmlReader);\n        return xmlReader;\n    }
89	@SuppressWarnings({"unused", "WeakerAccess"})\n    public static boolean isPropertySetStream(final byte[] src, final int offset, final int length) {\n        LittleEndianByteArrayInputStream leis = new LittleEndianByteArrayInputStream(src, offset, length);\n\n        \n        try {\n            final int byteOrder = leis.readUShort();\n            if (byteOrder != BYTE_ORDER_ASSERTION) {\n                return false;\n            }\n            final int format = leis.readUShort();\n            if (format != FORMAT_ASSERTION) {\n                return false;\n            }\n            final long osVersion = leis.readUInt();\n            byte[] clsBuf = new byte[ClassID.LENGTH];\n            leis.readFully(clsBuf);\n\n            final ClassID classID = new ClassID(clsBuf, 0);\n\n            final long sectionCount = leis.readUInt();\n            return (sectionCount >= 0);\n        } catch (RuntimeException e) {\n            return false;\n        }\n    }
90	public void resize(Rectangle2D target, RectAlign align) {\n        PictureShape<?,?> ps = getShape();\n        Dimension dim = ps.getPictureData().getImageDimension();\n        if (dim.width <= 0 || dim.height <= 0) {\n                        ps.setAnchor(target);\n            return;\n        }\n\n        double w = target.getWidth();\n        double h = target.getHeight();\n\n                double sx = w / dim.width;\n        double sy = h / dim.height;\n\n                double dx = 0, dy = 0;\n\n        if (sx > sy) {\n                        w  = sy * dim.width;\n            dx = target.getWidth() - w;\n        } else if (sy > sx) {\n                        h  = sx * dim.height;\n            dy = target.getHeight() - h;\n        } else {\n                        ps.setAnchor(target);\n            return;\n        }\n\n                double x = target.getX();\n        double y = target.getY();\n        switch (align) {\n            case TOP:                           x += dx/2;\n                break;\n            case TOP_RIGHT:                     x += dx;\n                break;\n            case RIGHT:                         x += dx;\n                y += dy/2;\n                break;\n            case BOTTOM_RIGHT:                  x += dx;\n                y += dy;\n                break;\n            case BOTTOM:                        x += dx/2;\n                y += dy;\n                break;\n            case BOTTOM_LEFT:                   y += dy;\n                break;\n            case LEFT:                          y += dy/2;\n                break;\n            case TOP_LEFT:                      \n                break;\n            default:                            x += dx/2;\n                y += dy/2;\n                break;\n        }\n\n        ps.setAnchor(new Rectangle2D.Double(x, y, w, h));\n    }
91	public void replaceText(String pPlaceHolder, String pValue) {\n		while (true) {\n			String text = text();\n			int offset = text.indexOf(pPlaceHolder);\n			if (offset >= 0) {\n				replaceText(pPlaceHolder, pValue, offset);\n			} else {\n				break;\n			}\n		}\n	}
92	private void outHex( int bytes, InputStream in, PrintStream out ) throws IOException, LittleEndian.BufferUnderrunException\n    {\n        switch ( bytes )\n        {\n            case 1:\n                out.print( HexDump.toHex( (byte) in.read() ) );\n                break;\n            case 2:\n                out.print( HexDump.toHex( LittleEndian.readShort( in ) ) );\n                break;\n            case 4:\n                out.print( HexDump.toHex( LittleEndian.readInt( in ) ) );\n                break;\n            default:\n                throw new IOException( "Unable to output variable of that width" );\n        }\n    }
93	public void guess7BitEncoding() {\n            for (MAPIProperty prop : new MAPIProperty[] {\n               MAPIProperty.MESSAGE_CODEPAGE,\n               MAPIProperty.INTERNET_CPID\n      }) {\n        List<PropertyValue> val = mainChunks.getProperties().get(prop);\n        if (val != null && val.size() > 0) {\n           int codepage = ((LongPropertyValue)val.get(0)).getValue();\n           try {\n               String encoding = CodePageUtil.codepageToEncoding(codepage, true);\n               set7BitEncoding(encoding);\n               return;\n            } catch(UnsupportedEncodingException e) {\n               logger.log(POILogger.WARN, "Invalid codepage ID ", codepage, \n                          " set for the message via ", prop, ", ignoring");\n            }\n         }\n      }\n     \n       \n            try {\n         String[] headers = getHeaders();\n         if(headers != null && headers.length > 0) {\n                        Pattern p = Pattern.compile("Content-Type:.*?charset=[\"']?([^;'\"]+)[\"']?", Pattern.CASE_INSENSITIVE);\n\n            for(String header : headers) {\n               if(header.startsWith("Content-Type")) {\n                  Matcher m = p.matcher(header);\n                  if(m.matches()) {\n                                          String charset = m.group(1);\n\n                     if (!charset.equalsIgnoreCase("utf-8")) { \n                        set7BitEncoding(charset);\n                     }\n                     return;\n                  }\n               }\n            }\n         }\n      } catch(ChunkNotFoundException e) {}\n      \n            try {\n         String html = getHtmlBody();\n         if(html != null && html.length() > 0) {\n                        Pattern p = Pattern.compile(\n                  "<META\\s+HTTP-EQUIV=\"Content-Type\"\\s+CONTENT=\"text/html;\\s+charset=(.*?)\""\n            );\n            Matcher m = p.matcher(html);\n            if(m.find()) {\n                              String charset = m.group(1);\n               set7BitEncoding(charset);\n            }\n         }\n      } catch(ChunkNotFoundException e) {}\n   }
94	public static void main(String[] args) throws IOException {\n        if(args.length < 2){\n    		System.err.println("Usage: AddDimensionedImage imageFile outputFile");\n    		return;\n    	}\n\n        final String imageFile = args[0];\n        final String outputFile = args[1];\n\n        try (final Workbook workbook = new HSSFWorkbook();\n             final FileOutputStream fos = new FileOutputStream(outputFile)) {               Sheet sheet = workbook.createSheet("Picture Test");\n            new AddDimensionedImage().addImageToSheet("B5", sheet, sheet.createDrawingPatriarch(),\n                    new File(imageFile).toURI().toURL(), 100, 40,\n                    AddDimensionedImage.EXPAND_ROW_AND_COLUMN);\n            workbook.write(fos);\n        }\n    }
95	public Path2D.Double getBoundsAsPath() {\n\n        Double w = getWidth();\n        Double h = getHeight();\n\n        Path2D.Double bounds = new Path2D.Double();\n        bounds.moveTo(0, 0);\n        bounds.lineTo(w, 0);\n        bounds.lineTo(w, h);\n        bounds.lineTo(0, h);\n        bounds.lineTo(0, 0);\n\n        return bounds;\n    }
96	public static ValueEval getElementFromArray(AreaEval ae, EvaluationCell cell) {\n        CellRangeAddress range =  cell.getArrayFormulaRange();\n        int relativeRowIndex = cell.getRowIndex() - range.getFirstRow();\n        int relativeColIndex = cell.getColumnIndex() - range.getFirstColumn();\n                \n        if (ae.isColumn()) {\n            if (ae.isRow()) {\n                return ae.getRelativeValue(0, 0);\n            }\n            else if(relativeRowIndex < ae.getHeight()) {\n                return ae.getRelativeValue(relativeRowIndex, 0);\n            }\n        }\n        else if (!ae.isRow() && relativeRowIndex < ae.getHeight() && relativeColIndex < ae.getWidth()) {\n            return ae.getRelativeValue(relativeRowIndex, relativeColIndex);\n        }\n        else if (ae.isRow() && relativeColIndex < ae.getWidth()) {\n            return ae.getRelativeValue(0, relativeColIndex);\n        }\n        \n        return ErrorEval.NA;\n    }
97	public double getTextHeight(Graphics2D oldGraphics) {\n                BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n        Graphics2D graphics = img.createGraphics();\n        if (oldGraphics != null) {\n            graphics.addRenderingHints(oldGraphics.getRenderingHints());\n            graphics.setTransform(oldGraphics.getTransform());\n        }\n        DrawFactory.getInstance(graphics).fixFonts(graphics);\n        return drawParagraphs(graphics, 0, 0);\n    }
98	public String signDigest(final DOMSignContext xmlSignContext, final DOMSignedInfo signedInfo) {\n        final PrivateKey key = signatureConfig.getKey();\n        final HashAlgorithm algo = signatureConfig.getDigestAlgo();\n\n        if (algo.hashSize*4/3 > Base64.BASE64DEFAULTLENGTH && !XMLUtils.ignoreLineBreaks()) {\n            throw new EncryptedDocumentException("The hash size of the choosen hash algorithm ("+algo+" = "+algo.hashSize+" bytes), "+\n                "will motivate XmlSec to add linebreaks to the generated digest, which results in an invalid signature (... at least "+\n                "for Office) - please persuade it otherwise by adding '-Dorg.apache.xml.security.ignoreLineBreaks=true' to the JVM "+\n                "system properties.");\n        }\n        \n        try (final DigestOutputStream dos = getDigestStream(algo, key)) {\n            dos.init();\n\n            final Document document = (Document)xmlSignContext.getParent();\n            final Element el = getDsigElement(document, "SignedInfo");\n            final DOMSubTreeData subTree = new DOMSubTreeData(el, true);\n            signedInfo.getCanonicalizationMethod().transform(subTree, xmlSignContext, dos);\n\n            return DatatypeConverter.printBase64Binary(dos.sign());\n        } catch (GeneralSecurityException|IOException|TransformException e) {\n            throw new EncryptedDocumentException(e);\n        }\n    }
99	public void writeProtectWorkbook( String password, String username ) {\n        FileSharingRecord frec = getFileSharing();\n        WriteAccessRecord waccess = getWriteAccess();\n         getWriteProtect();\n        frec.setReadOnly((short)1);\n        frec.setPassword((short)CryptoFunctions.createXorVerifier1(password));\n        frec.setUsername(username);\n        waccess.setUsername(username);\n    }
100	public void unlink(SharedFormulaRecord sharedFormulaRecord) {\n		SharedFormulaGroup svg = _groupsBySharedFormulaRecord.remove(sharedFormulaRecord);\n		if (svg == null) {\n			throw new IllegalStateException("Failed to find formulas for shared formula");\n		}\n		_groupsCache = null; 		svg.unlinkSharedFormulas();\n	}
101	private static void setEdges(TableCell<?,?> cell, BorderEdge edges[], Object... args) {\n        if (cell == null) {\n            return;\n        }\n        for (BorderEdge be : edges) {\n            if (be != null) {\n                if (args.length == 0) {\n                    cell.removeBorder(be);\n                } else {\n                    for (Object o : args) {\n                        if (o instanceof Double) {\n                            cell.setBorderWidth(be, (Double)o);\n                        } else if (o instanceof Color) {\n                            cell.setBorderColor(be, (Color)o);\n                        } else if (o instanceof LineDash) {\n                            cell.setBorderDash(be, (LineDash)o);\n                        } else if (o instanceof LineCompound) {\n                            cell.setBorderCompound(be, (LineCompound)o);\n                        }\n                    }\n                }\n            }\n        }\n    }
102	private void parse() {\n        _pointer=0;\n        GetChar();\n        _rootNode = unionExpression();\n\n        if(_pointer <= _formulaLength) {\n            String msg = "Unused input [" + _formulaString.substring(_pointer-1)\n                + "] after attempting to parse the formula [" + _formulaString + "]";\n            throw new FormulaParseException(msg);\n        }\n    }
103	private void isCellFontSizeMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        short size1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getFontHeightInPoints();\n        short size2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getFontHeightInPoints();\n        if (size1 != size2) {\n            addMessage(loc1, loc2,\n                "Cell Font Size does not Match ::",\n                Short.toString(size1),\n                Short.toString(size2)\n            );\n        }\n    }
104	protected void addRun(CTR run) {\n        int pos;\n        pos = paragraph.sizeOfRArray();\n        paragraph.addNewR();\n        paragraph.setRArray(pos, run);\n    }
105	public static double sum(double[] values) {\n        double sum = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sum += values[i];\n        }\n        return sum;\n    }
106	public double getSpaceAfter(){\n        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){\n            public boolean fetch(CTTextParagraphProperties props){\n                if(props.isSetSpcAft()){\n                    CTTextSpacing spc = props.getSpcAft();\n\n                    if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );\n                    else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );\n                    return true;\n                }\n                return false;\n            }\n        };\n        fetchParagraphProperty(fetcher);\n        return fetcher.getValue() == null ? 0 : fetcher.getValue();\n    }
107	private static double evaluate(int year, int month, int pDay) throws EvaluationException {\n	   		if (year < 0) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n				while (month < 0) {\n		   year--;\n		   month += 12;\n		}\n				\n						if (year == 1900 && month == Calendar.FEBRUARY && pDay == 29) {\n			return 60.0;\n		}\n\n						int day = pDay;\n		if (year == 1900) {\n			if ((month == Calendar.JANUARY && day >= 60) ||\n					(month == Calendar.FEBRUARY && day >= 30)) {\n				day--;\n			}\n		}\n\n				Calendar c = LocaleUtil.getLocaleCalendar(year, month, day);\n		\n						if (pDay < 0 && c.get(Calendar.YEAR) == 1900 &&\n		      month > Calendar.FEBRUARY && \n		      c.get(Calendar.MONTH) < Calendar.MARCH) {\n		   c.add(Calendar.DATE, 1);\n		}\n\n				boolean use1904windowing = false;\n		\n				return DateUtil.getExcelDate(c.getTime(), use1904windowing);\n	}
108	public static double average(double[] values) {\n        double ave = 0;\n        double sum = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sum += values[i];\n        }\n        ave = sum / values.length;\n        return ave;\n    }
109	protected void init(boolean onlyValidation) {\n        if (opcPackage == null) {\n            throw new EncryptedDocumentException("opcPackage is null");\n        }\n        if (uriDereferencer == null) {\n            uriDereferencer = new OOXMLURIDereferencer();\n        }\n        if (uriDereferencer instanceof SignatureConfigurable) {\n            ((SignatureConfigurable)uriDereferencer).setSignatureConfig(this);\n        }\n        if (namespacePrefixes.isEmpty()) {\n            \n                        namespacePrefixes.put(OO_DIGSIG_NS, "mdssi");\n            namespacePrefixes.put(XADES_132_NS, "xd");\n        }\n        \n        if (onlyValidation) {\n            return;\n        }\n\n        if (signatureMarshalListener == null) {\n            signatureMarshalListener = new SignatureMarshalListener();\n        }\n        \n        if (signatureMarshalListener instanceof SignatureConfigurable) {\n            ((SignatureConfigurable)signatureMarshalListener).setSignatureConfig(this);\n        }\n        \n        if (tspService != null) {\n            tspService.setSignatureConfig(this);\n        }\n        \n        if (signatureFacets.isEmpty()) {\n            addSignatureFacet(new OOXMLSignatureFacet());\n            addSignatureFacet(new KeyInfoSignatureFacet());\n            addSignatureFacet(new XAdESSignatureFacet());\n            addSignatureFacet(new Office2010SignatureFacet());\n        }\n\n        for (SignatureFacet sf : signatureFacets) {\n            sf.setSignatureConfig(this);\n        }\n    }
110	public String getTextFromPieces() {\n        String text = doc.getDocumentText();\n\n                text = text.replaceAll( "\r\r\r", "\r\n\r\n\r\n" );\n        text = text.replaceAll( "\r\r", "\r\n\r\n" );\n\n        if ( text.endsWith( "\r" )) {\n            text += "\n";\n        }\n\n        return text;\n    }
111	protected int invokeCipher(int posInChunk, boolean doFinal) throws GeneralSecurityException {\n        byte plain[] = (plainByteFlags.isEmpty()) ? null : chunk.clone();\n\n        int ciLen = (doFinal)\n            ? cipher.doFinal(chunk, 0, posInChunk, chunk)\n            : cipher.update(chunk, 0, posInChunk, chunk);\n\n        if (plain != null) {\n            int i = plainByteFlags.nextSetBit(0);\n            while (i >= 0 && i < posInChunk) {\n                chunk[i] = plain[i];\n                i = plainByteFlags.nextSetBit(i+1);\n            }\n        }\n        \n        return ciLen;\n    }
112	public static double getCellWidth(Cell cell, int defaultCharWidth, DataFormatter formatter, boolean useMergedCells) {\n        Sheet sheet = cell.getSheet();\n        Workbook wb = sheet.getWorkbook();\n        Row row = cell.getRow();\n        int column = cell.getColumnIndex();\n\n                        int colspan = 1;\n        for (CellRangeAddress region : sheet.getMergedRegions()) {\n            if (region.isInRange(row.getRowNum(), column)) {\n                if (!useMergedCells) {\n                                        return -1;\n                }\n                cell = row.getCell(region.getFirstColumn());\n                colspan = 1 + region.getLastColumn() - region.getFirstColumn();\n            }\n        }\n\n        CellStyle style = cell.getCellStyle();\n        CellType cellType = cell.getCellType();\n\n                if (cellType == CellType.FORMULA)\n            cellType = cell.getCachedFormulaResultType();\n\n        Font font = wb.getFontAt(style.getFontIndexAsInt());\n\n        double width = -1;\n        if (cellType == CellType.STRING) {\n            RichTextString rt = cell.getRichStringCellValue();\n            String[] lines = rt.getString().split("\\n");\n            for (String line : lines) {\n                String txt = line + defaultChar;\n\n                AttributedString str = new AttributedString(txt);\n                copyAttributes(font, str, 0, txt.length());\n\n                \n\n                width = getCellWidth(defaultCharWidth, colspan, style, width, str);\n            }\n        } else {\n            String sval = null;\n            if (cellType == CellType.NUMERIC) {\n                                try {\n                    sval = formatter.formatCellValue(cell, dummyEvaluator);\n                } catch (Exception e) {\n                    sval = String.valueOf(cell.getNumericCellValue());\n                }\n            } else if (cellType == CellType.BOOLEAN) {\n                sval = String.valueOf(cell.getBooleanCellValue()).toUpperCase(Locale.ROOT);\n            }\n            if(sval != null) {\n                String txt = sval + defaultChar;\n                AttributedString str = new AttributedString(txt);\n                copyAttributes(font, str, 0, txt.length());\n\n                width = getCellWidth(defaultCharWidth, colspan, style, width, str);\n            }\n        }\n        return width;\n    }
113	protected void generateData() {\n		int size = 0;\n		for(int i=0; i<records.length; i++) {\n			size += records[i].getRecordSize();\n		}\n\n		byte data[] = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n		size = 0;\n		for(int i=0; i<records.length; i++) {\n			int thisSize =\n				records[i].serialize(size, data);\n			size += thisSize;\n		}\n		\n		setData(data);\n	}
114	public boolean changeExternalReference(String oldUrl, String newUrl) {\n        for (ExternalBookBlock ex : _externalBookBlocks) {\n            SupBookRecord externalRecord = ex.getExternalBookRecord();\n            if (externalRecord.isExternalReferences()\n                    && externalRecord.getURL().equals(oldUrl)) {\n\n                externalRecord.setURL(newUrl);\n                return true;\n            }\n        }\n        return false;\n    }
115	static void formatDuplicates(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Code");\n        sheet.createRow(1).createCell(0).setCellValue(4);\n        sheet.createRow(2).createCell(0).setCellValue(3);\n        sheet.createRow(3).createCell(0).setCellValue(6);\n        sheet.createRow(4).createCell(0).setCellValue(3);\n        sheet.createRow(5).createCell(0).setCellValue(5);\n        sheet.createRow(6).createCell(0).setCellValue(8);\n        sheet.createRow(7).createCell(0).setCellValue(0);\n        sheet.createRow(8).createCell(0).setCellValue(2);\n        sheet.createRow(9).createCell(0).setCellValue(8);\n        sheet.createRow(10).createCell(0).setCellValue(6);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("COUNTIF($A$2:$A$11,A2)>1");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontStyle(false, true);\n        font.setFontColorIndex(IndexedColors.BLUE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A11")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(1).setCellValue("<== Duplicates numbers in the column are highlighted.  " +\n                "Condition: Formula Is =COUNTIF($A$2:$A$11,A2)>1   (Blue Font)");\n    }
116	private static boolean shouldCountFeb29(SimpleDate start, SimpleDate end) {\n		if (isLeapYear(start.year)) {\n	        if (start.year == end.year) {\n	            	            return true;\n	        }\n\n	        switch (start.month) {\n				case SimpleDate.JANUARY:\n				case SimpleDate.FEBRUARY:\n					return true;\n			}\n			return false;\n		}\n		\n		if (isLeapYear(end.year)) {\n			switch (end.month) {\n				case SimpleDate.JANUARY:\n					return false;\n				case SimpleDate.FEBRUARY:\n					break;\n				default:\n					return true;\n			}\n			return end.day == LONG_FEB_LEN;\n		}\n		return false;\n	}
117	public String getRecipientEmailAddress() {\n                if (recipientSMTPChunk != null) {\n            return recipientSMTPChunk.getValue();\n        }\n\n                        if (recipientEmailChunk != null) {\n            String email = recipientEmailChunk.getValue();\n            int cne = email.indexOf("/CN=");\n            if (cne < 0) {\n                                return email;\n            } else {\n                                return email.substring(cne + 4);\n            }\n        }\n\n                if (recipientNameChunk != null) {\n            String name = recipientNameChunk.getValue();\n            if (name.contains("@")) {\n                                if (name.startsWith("'") && name.endsWith("'")) {\n                    return name.substring(1, name.length() - 1);\n                }\n                return name;\n            }\n        }\n\n                        if (recipientSearchChunk != null) {\n            String search = recipientSearchChunk.getAs7bitString();\n            int idx = search.indexOf("SMTP:");\n            if (idx >= 0) {\n                return search.substring(idx + 5);\n            }\n        }\n\n                return null;\n    }
118	private String dumpBytes(byte[] data, int offset, int len) {\n		StringBuffer ret = new StringBuffer();\n		for(int i=0; i<len; i++) {\n			int j = i + offset;\n			int b = data[j];\n			if(b < 0) { b += 256; }\n\n			String bs = Integer.toHexString(b);\n			if(bs.length() == 1)\n				ret.append('0');\n			ret.append(bs);\n			ret.append(' ');\n		}\n		return ret.toString();\n	}
119	public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (getClass() != other.getClass()) return false;\n        \n        TextPropCollection o = (TextPropCollection)other;\n        if (o.maskSpecial != this.maskSpecial || o.indentLevel != this.indentLevel) {\n            return false;\n        }\n\n        return textProps.equals(o.textProps);\n    }
120	public BigInteger addNum(XWPFNum num) {\n        ctNumbering.addNewNum();\n        int pos = ctNumbering.sizeOfNumArray() - 1;\n        ctNumbering.setNumArray(pos, num.getCTNum());\n        nums.add(num);\n        return num.getCTNum().getNumId();\n    }
121	private static void verifyZipHeader(InputStream stream) throws NotOfficeXmlFileException, IOException {\n        InputStream is = FileMagic.prepareToCheckMagic(stream);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        switch (fm) {\n        case OLE2:\n            throw new OLE2NotOfficeXmlFileException(\n                "The supplied data appears to be in the OLE2 Format. " +\n                "You are calling the part of POI that deals with OOXML "+\n                "(Office Open XML) Documents. You need to call a different " +\n                "part of POI to process this data (eg HSSF instead of XSSF)");\n        case XML:\n            throw new NotOfficeXmlFileException(\n                "The supplied data appears to be a raw XML file. " +\n                "Formats such as Office 2003 XML are not supported");\n        default:\n        case OOXML:\n        case UNKNOWN:\n                                                break;\n        }\n    }
122	private Record getCoreRecordForRefID(int refID) {\n		Integer coreRecordId = _sheetIdToCoreRecordsLookup.get(refID);\n		if (coreRecordId != null) {\n			return _mostRecentCoreRecords[coreRecordId];\n		}\n		logger.log(POILogger.ERROR,\n				"We tried to look up a reference to a core record, but there was no core ID for reference ID "\n						+ refID);\n		return null;\n	}
123	private static CountryRecord createCountry() {\n        CountryRecord retval = new CountryRecord();\n\n        retval.setDefaultCountry(( short ) 1);\n\n                if ( "ru_RU".equals( LocaleUtil.getUserLocale().toString() ) ) {\n            retval.setCurrentCountry(( short ) 7);\n        } else {\n            retval.setCurrentCountry(( short ) 1);\n        }\n\n        return retval;\n    }
124	private void checkForEmptyCellComments(EmptyCellCommentsCheckType type) {\n       if (commentCellRefs != null && !commentCellRefs.isEmpty()) {\n                                 if (type == EmptyCellCommentsCheckType.END_OF_SHEET_DATA) {\n               while (!commentCellRefs.isEmpty()) {\n                   outputEmptyCellComment(commentCellRefs.remove());\n               }\n               return;\n           }\n\n                      if (this.cellRef == null) {\n               if (type == EmptyCellCommentsCheckType.END_OF_ROW) {\n                   while (!commentCellRefs.isEmpty()) {\n                       if (commentCellRefs.peek().getRow() == rowNum) {\n                           outputEmptyCellComment(commentCellRefs.remove());\n                       } else {\n                           return;\n                       }\n                   }\n                   return;\n               } else {\n                   throw new IllegalStateException("Cell ref should be null only if there are only empty cells in the row; rowNum: " + rowNum);\n               }\n           }\n\n           CellAddress nextCommentCellRef;\n           do {\n               CellAddress cellRef = new CellAddress(this.cellRef);\n               CellAddress peekCellRef = commentCellRefs.peek();\n               if (type == EmptyCellCommentsCheckType.CELL && cellRef.equals(peekCellRef)) {\n                                      commentCellRefs.remove();\n                   return;\n               } else {\n                                      int comparison = peekCellRef.compareTo(cellRef);\n                   if (comparison > 0 && type == EmptyCellCommentsCheckType.END_OF_ROW && peekCellRef.getRow() <= rowNum) {\n                       nextCommentCellRef = commentCellRefs.remove();\n                       outputEmptyCellComment(nextCommentCellRef);\n                   } else if (comparison < 0 && type == EmptyCellCommentsCheckType.CELL && peekCellRef.getRow() <= rowNum) {\n                       nextCommentCellRef = commentCellRefs.remove();\n                       outputEmptyCellComment(nextCommentCellRef);\n                   } else {\n                       nextCommentCellRef = null;\n                   }\n               }\n           } while (nextCommentCellRef != null && !commentCellRefs.isEmpty());\n       }\n   }
125	private static void copy(OPCPackage pkg, PackagePart part, OPCPackage tgt, PackagePart part_tgt) throws OpenXML4JException, IOException {\n        PackageRelationshipCollection rels = part.getRelationships();\n        if(rels != null) for (PackageRelationship rel : rels) {\n            PackagePart p;\n            if(rel.getTargetMode() == TargetMode.EXTERNAL){\n                part_tgt.addExternalRelationship(rel.getTargetURI().toString(), rel.getRelationshipType(), rel.getId());\n                                continue;\n            }\n            URI uri = rel.getTargetURI();\n\n            if(uri.getRawFragment() != null) {\n                part_tgt.addRelationship(uri, rel.getTargetMode(), rel.getRelationshipType(), rel.getId());\n                continue;\n            }\n            PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n            p = pkg.getPart(relName);\n            part_tgt.addRelationship(p.getPartName(), rel.getTargetMode(), rel.getRelationshipType(), rel.getId());\n\n            PackagePart dest;\n            if(!tgt.containPart(p.getPartName())){\n                dest = tgt.createPart(p.getPartName(), p.getContentType());\n                OutputStream out = dest.getOutputStream();\n                IOUtils.copy(p.getInputStream(), out);\n                out.close();\n                copy(pkg, p, tgt, dest);\n            }\n        }\n    }
126	@Beta\n    protected CTPivotCache addPivotCache(String rId) {\n        CTWorkbook ctWorkbook = getCTWorkbook();\n        CTPivotCaches caches;\n        if (ctWorkbook.isSetPivotCaches()) {\n            caches = ctWorkbook.getPivotCaches();\n        } else {\n            caches = ctWorkbook.addNewPivotCaches();\n        }\n        CTPivotCache cache = caches.addNewPivotCache();\n\n        int tableId = getPivotTables().size()+1;\n        cache.setCacheId(tableId);\n        cache.setId(rId);\n        if(pivotCaches == null) {\n            pivotCaches = new ArrayList<>();\n        }\n        pivotCaches.add(cache);\n        return cache;\n    }
127	public void formatValue(StringBuffer toAppendTo, Object value) {\n        if (value instanceof Number) {\n            double val = ((Number) value).doubleValue();\n            if (val == 0) {\n                toAppendTo.append('0');\n                return;\n            }\n\n            String fmt;\n            double exp = Math.log10(Math.abs(val));\n            boolean stripZeros = true;\n            if (exp > 10 || exp < -9)\n                fmt = "%1.5E";\n            else if ((long) val != val)\n                fmt = "%1.9f";\n            else {\n                fmt = "%1.0f";\n                stripZeros = false;\n            }\n\n            Formatter formatter = new Formatter(toAppendTo, locale);\n            try {\n                formatter.format(locale, fmt, value);\n            } finally {\n                formatter.close();\n            }\n            if (stripZeros) {\n                                int removeFrom;\n                if (fmt.endsWith("E"))\n                    removeFrom = toAppendTo.lastIndexOf("E") - 1;\n                else\n                    removeFrom = toAppendTo.length() - 1;\n                while (toAppendTo.charAt(removeFrom) == '0') {\n                    toAppendTo.deleteCharAt(removeFrom--);\n                }\n                if (toAppendTo.charAt(removeFrom) == '.') {\n                    toAppendTo.deleteCharAt(removeFrom--);\n                }\n            }\n        } else if (value instanceof Boolean) {\n            toAppendTo.append(value.toString().toUpperCase(Locale.ROOT));\n        } else {\n            toAppendTo.append(value);\n        }\n    }
128	protected void init(){\n                int type = getTextType();\n\n        int head;\n        int pos = 0;\n\n                short levels = LittleEndian.getShort(_data, 0);\n        pos += LittleEndian.SHORT_SIZE;\n\n        paragraphStyles = new ArrayList<>(levels);\n        charStyles = new ArrayList<>(levels);\n\n        for(short i = 0; i < levels; i++) {\n            TextPropCollection prprops = new TextPropCollection(0, TextPropType.paragraph);\n            if (type >= TextHeaderAtom.CENTRE_BODY_TYPE) {\n                                short indentLevel = LittleEndian.getShort(_data, pos);\n                prprops.setIndentLevel(indentLevel);\n                pos += LittleEndian.SHORT_SIZE;\n            } else {\n                prprops.setIndentLevel((short)-1);\n            }\n\n            head = LittleEndian.getInt(_data, pos);\n            pos += LittleEndian.INT_SIZE;\n            \n            pos += prprops.buildTextPropList( head, _data, pos);\n            paragraphStyles.add(prprops);\n\n            head = LittleEndian.getInt(_data, pos);\n            pos += LittleEndian.INT_SIZE;\n            TextPropCollection chprops = new TextPropCollection(0, TextPropType.character);\n            pos += chprops.buildTextPropList( head, _data, pos);\n            charStyles.add(chprops);\n        }\n    }
129	public static void setFont(Cell cell, Font font) {\n                Workbook wb = cell.getSheet().getWorkbook();\n        final int fontIndex = font.getIndexAsInt();\n        if (!wb.getFontAt(fontIndex).equals(font)) {\n            throw new IllegalArgumentException("Font does not belong to this workbook");\n        }\n\n                \n        setCellStyleProperty(cell, FONT, fontIndex);\n    }
130	private static GutsRecord createGuts() {\n        GutsRecord retval = new GutsRecord();\n\n        retval.setLeftRowGutter(( short ) 0);\n        retval.setTopColGutter(( short ) 0);\n        retval.setRowLevelMax(( short ) 0);\n        retval.setColLevelMax(( short ) 0);\n        return retval;\n    }
131	public static Record createRecordForType(long type, byte[] b, int start, int len) {\n												RecordConstructor c = RecordTypes.forTypeID((short)type).recordConstructor;\n		if (c == null) {\n															c = RecordTypes.UnknownRecordPlaceholder.recordConstructor;\n		}\n\n		final Record toReturn;\n		try {\n			toReturn = c.apply(b, start, len);\n		} catch(RuntimeException e) {\n									if(start + len > b.length ) {\n				logger.log(POILogger.WARN, "Warning: Skipping record of type " + type + " at position " + start + " which claims to be longer than the file! (" + len + " vs " + (b.length-start) + ")");\n				return null;\n			}\n\n			throw new HSLFException("Couldn't instantiate the class for type with id " + type + " on class " + c + " : " + e, e);\n		}\n\n		\n				if(toReturn instanceof PositionDependentRecord) {\n			PositionDependentRecord pdr = (PositionDependentRecord)toReturn;\n			pdr.setLastOnDiskOffset(start);\n		}\n\n				return toReturn;\n	}
132	public EscherDgRecord createDgRecord() {\n        EscherDgRecord dg = new EscherDgRecord();\n        dg.setRecordId( EscherDgRecord.RECORD_ID );\n        short dgId = findNewDrawingGroupId();\n        dg.setOptions( (short) ( dgId << 4 ) );\n        dg.setNumShapes( 0 );\n        dg.setLastMSOSPID( -1 );\n        drawingGroups.add(dg);\n        dgg.addCluster( dgId, 0 );\n        dgg.setDrawingsSaved( dgg.getDrawingsSaved() + 1 );\n        return dg;\n    }
133	private void initParagraphs() {\n		if (!_parRangeFound) {\n			int[] point = findRange(_paragraphs, _start, _end);\n			_parStart = point[0];\n			_parEnd = point[1];\n			_parRangeFound = true;\n		}\n	}
134	public static double coerceValueToDouble(ValueEval ev) throws EvaluationException {\n\n        if (ev == BlankEval.instance) {\n            return 0.0;\n        }\n        if (ev instanceof NumericValueEval) {\n                        return ((NumericValueEval)ev).getNumberValue();\n        }\n        if (ev instanceof StringEval) {\n            Double dd = parseDouble(((StringEval) ev).getStringValue());\n            if (dd == null) {\n                throw EvaluationException.invalidValue();\n            }\n            return dd.doubleValue();\n        }\n        throw new RuntimeException("Unexpected arg eval type (" + ev.getClass().getName() + ")");\n    }
135	public ValueEval evaluate(String sheetName, int rowIndex, int columnIndex) {\n		EvaluationCell cell = _sewb.getEvaluationCell(sheetName, rowIndex, columnIndex);\n\n		switch (cell.getCellType()) {\n			case BOOLEAN:\n				return BoolEval.valueOf(cell.getBooleanCellValue());\n			case ERROR:\n				return ErrorEval.valueOf(cell.getErrorCellValue());\n			case FORMULA:\n				return _evaluator.evaluate(cell);\n			case NUMERIC:\n				return new NumberEval(cell.getNumericCellValue());\n			case STRING:\n				return new StringEval(cell.getStringCellValue());\n			case BLANK:\n				return null;\n			default:\n				throw new IllegalStateException("Bad cell type (" + cell.getCellType() + ")");\n		}\n	}
136	private String tab2space(TextRun tr) {\n        AttributedString string = new AttributedString(" ");\n        String fontFamily = tr.getFontFamily();\n        if (fontFamily == null) {\n            fontFamily = "Lucida Sans";\n        }\n        string.addAttribute(TextAttribute.FAMILY, fontFamily);\n\n        Double fs = tr.getFontSize();\n        if (fs == null) {\n            fs = 12d;\n        }\n        string.addAttribute(TextAttribute.SIZE, fs.floatValue());\n\n        TextLayout l = new TextLayout(string.getIterator(), new FontRenderContext(null, true, true));\n        double wspace = l.getAdvance();\n\n        Double tabSz = paragraph.getDefaultTabSize();\n        if (tabSz == null) {\n            tabSz = wspace*4;\n        }\n\n        int numSpaces = (int)Math.ceil(tabSz / wspace);\n        StringBuilder buf = new StringBuilder();\n        for(int i = 0; i < numSpaces; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    }
137	public void bulletedListInCell(HSSFWorkbook workbook,\n                                   ArrayList<String> listItems,\n                                   HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n                        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n                        for(String listItem : listItems) {\n            buffer.append(InCellLists.BULLET_CHARACTER + " ");\n            buffer.append(listItem);\n            buffer.append("\n");\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
138	public static void numberSpreadsheet(Workbook wb, int numCols){\n\n        System.out.println("Testing " + wb.getClass().getName());\n        printMemoryUsage("before");\n        int i=0, cnt=0;\n        try {\n            Sheet sh = wb.createSheet();\n            for(i=0; ; i++){\n                Row row = sh.createRow(i);\n                for(int j=0; j < numCols; j++){\n                    Cell cell = row.createCell(j);\n                    cell.setCellValue(j);\n                    cnt++;\n                }\n            }\n        } catch (OutOfMemoryError er){\n            System.out.println("Failed at row=" + i + ", objects : " + cnt);\n        } catch (final Exception e) {\n            System.out.println("Unable to reach an OutOfMemoryError");\n            System.out.println(e.getClass().getName() + ": " + e.getMessage());\n        }\n        printMemoryUsage("after");\n    }
139	public int allocateShapeId(EscherDgRecord dg, boolean sort) {\n        final short drawingGroupId = dg.getDrawingGroupId();\n        field_3_numShapesSaved++;\n        \n                                FileIdCluster ficAdd = null;\n        int index = 1;\n        for (FileIdCluster fic : field_5_fileIdClusters) {\n            if (fic.getDrawingGroupId() == drawingGroupId\n                && fic.getNumShapeIdsUsed() < 1024) {\n                ficAdd = fic;\n                break;\n            }\n            index++;\n        }\n\n        if (ficAdd == null) {\n            ficAdd = addCluster( drawingGroupId, 0, sort );\n            maxDgId = Math.max(maxDgId, drawingGroupId);\n        }\n        \n        int shapeId = index*1024 + ficAdd.getNumShapeIdsUsed();\n        ficAdd.incrementUsedShapeId();\n        \n        dg.setNumShapes( dg.getNumShapes() + 1 );\n        dg.setLastMSOSPID( shapeId );\n        field_1_shapeIdMax = Math.max(field_1_shapeIdMax, shapeId + 1);\n        \n        return shapeId;\n    }
140	protected HSLFEscherClientDataRecord getClientData(boolean create) {\n        HSLFEscherClientDataRecord clientData = getEscherChild(EscherClientDataRecord.RECORD_ID);\n        if (clientData == null && create) {\n            clientData = new HSLFEscherClientDataRecord();\n            clientData.setOptions((short)15);\n            clientData.setRecordId(EscherClientDataRecord.RECORD_ID);\n            getSpContainer().addChildBefore(clientData, EscherTextboxRecord.RECORD_ID);\n        }\n        return clientData;\n    }
141	public void processSheet(\n            Styles styles,\n            SharedStrings strings,\n            SheetContentsHandler sheetHandler, \n            InputStream sheetInputStream) throws IOException, SAXException {\n        DataFormatter formatter = new DataFormatter();\n        InputSource sheetSource = new InputSource(sheetInputStream);\n        try {\n            XMLReader sheetParser = SAXHelper.newXMLReader();\n            ContentHandler handler = new XSSFSheetXMLHandler(\n                  styles, null, strings, sheetHandler, formatter, false);\n            sheetParser.setContentHandler(handler);\n            sheetParser.parse(sheetSource);\n         } catch(ParserConfigurationException e) {\n            throw new RuntimeException("SAX parser appears to be broken - " + e.getMessage());\n         }\n    }
142	public Borders getBorderRight() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getRight();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
143	@Beta\n    public XSSFPivotTable createPivotTable(AreaReference source, CellReference position){\n        final String sourceSheetName = source.getFirstCell().getSheetName();\n        if(sourceSheetName != null && !sourceSheetName.equalsIgnoreCase(this.getSheetName())) {\n            final XSSFSheet sourceSheet = getWorkbook().getSheet(sourceSheetName);\n            return createPivotTable(source, position, sourceSheet);\n        }\n        return createPivotTable(source, position, this);\n    }
144	public static void main(final String args[]) throws IOException {\n      if (args.length == 0) {\n         System.err.println("Must specify at least one file to view");\n         System.exit(1);\n      }\n\n      boolean withSizes = false;\n      boolean newPOIFS = true;\n      for (String arg : args) {\n         if (arg.equalsIgnoreCase("-size") || arg.equalsIgnoreCase("-sizes")) {\n            withSizes = true;\n         } else if (arg.equalsIgnoreCase("-old") || arg.equalsIgnoreCase("-old-poifs")) {\n            newPOIFS = false;\n         } else {\n            if (newPOIFS) {\n               viewFile(arg, withSizes);\n            } else {\n               viewFileOld(arg, withSizes);\n            }\n         }\n      }\n   }
145	private static void refreshRecords(List<HSLFTextParagraph> paragraphs) {\n        TextHeaderAtom headerAtom = paragraphs.get(0)._headerAtom;\n        RecordContainer _txtbox = headerAtom.getParentRecord();\n        if (_txtbox instanceof EscherTextboxWrapper) {\n            try {\n                _txtbox.writeOut(null);\n            } catch (IOException e) {\n                throw new HSLFException("failed dummy write", e);\n            }\n        }\n    }
146	public InputStream getData() {\n        if (isCompressed()) {\n            int size = LittleEndian.getInt(_data);\n\n            InputStream compressedStream = new ByteArrayInputStream(_data, 4, _data.length);\n            return new BoundedInputStream(new InflaterInputStream(compressedStream), size);\n        } else {\n            return new ByteArrayInputStream(_data, 0, _data.length);\n        }\n    }
147	@Beta\n    protected void createCacheFields(Sheet sheet) {\n                AreaReference ar = getPivotArea(sheet.getWorkbook());\n        CellReference firstCell = ar.getFirstCell();\n        CellReference lastCell = ar.getLastCell();\n        int columnStart = firstCell.getCol();\n        int columnEnd = lastCell.getCol();\n        Row row = sheet.getRow(firstCell.getRow());\n        CTCacheFields cFields;\n        if(ctPivotCacheDefinition.getCacheFields() != null) {\n            cFields = ctPivotCacheDefinition.getCacheFields();\n        } else {\n            cFields = ctPivotCacheDefinition.addNewCacheFields();\n        }\n                for(int i=columnStart; i<=columnEnd; i++) {\n            CTCacheField cf = cFields.addNewCacheField();\n            if(i==columnEnd){\n                cFields.setCount(cFields.sizeOfCacheFieldArray());\n            }\n                        cf.setNumFmtId(0);\n            Cell cell = row.getCell(i);\n            cell.setCellType(CellType.STRING);\n            cf.setName(row.getCell(i).getStringCellValue());\n            cf.addNewSharedItems();\n        }\n    }
148	void syncWithDataSource() throws IOException {\n       int blocksUsed = 0;\n       for (BATBlock sbat : _sbat_blocks) {\n          ByteBuffer block = _filesystem.getBlockAt(sbat.getOurBlockIndex());\n          sbat.writeData(block);\n\n          if (!sbat.hasFreeSectors()) {\n              blocksUsed += _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\n          } else {\n              blocksUsed += sbat.getUsedSectors(false);\n          }\n       }\n                     _filesystem._get_property_table().getRoot().setSize(blocksUsed);\n    }
149	protected final int getNextPartNumber(POIXMLRelation descriptor, int minIdx) {\n        OPCPackage pkg = packagePart.getPackage();\n\n        try {\n            String name = descriptor.getDefaultFileName();\n            if (name.equals(descriptor.getFileName(9999))) {\n                                PackagePartName ppName = PackagingURIHelper.createPartName(name);\n                if (pkg.containPart(ppName)) {\n                                        return -1;\n                } else {\n                                        return 0;\n                }\n            }\n\n                        int idx = (minIdx < 0) ? 1 : minIdx;\n            int maxIdx = minIdx + pkg.getParts().size();\n            while (idx <= maxIdx) {\n                name = descriptor.getFileName(idx);\n                PackagePartName ppName = PackagingURIHelper.createPartName(name);\n                if (!pkg.containPart(ppName)) {\n                    return idx;\n                }\n                idx++;\n            }\n        } catch (InvalidFormatException e) {\n                        throw new POIXMLException(e);\n        }\n        return -1;\n    }
150	public DrawingManager2 findDrawingGroup() {\n        if(drawingManager != null) {\n                      return drawingManager;\n        }\n\n                for(Record r : records.getRecords() ) {\n            if (!(r instanceof DrawingGroupRecord)) {\n                continue;\n            }\n            DrawingGroupRecord dg = (DrawingGroupRecord)r;\n            dg.processChildRecords();\n            drawingManager = findDrawingManager(dg, escherBSERecords);\n            if (drawingManager != null) {\n                return drawingManager;\n            }\n        }\n\n                        DrawingGroupRecord dg = (DrawingGroupRecord)findFirstRecordBySid(DrawingGroupRecord.sid);\n        drawingManager = findDrawingManager(dg, escherBSERecords);\n        return drawingManager;\n    }
151	public static void main(final String[] args) {\n        PropertyIDMap s1 = getSummaryInformationProperties();\n        PropertyIDMap s2 = getDocumentSummaryInformationProperties();\n        System.out.println("s1: " + s1);\n        System.out.println("s2: " + s2);\n    }
152	private static void copyAttributes(Font font, AttributedString str, @SuppressWarnings("SameParameterValue") int startIdx, int endIdx) {\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\n        str.addAttribute(TextAttribute.SIZE, (float)font.getFontHeightInPoints());\n        if (font.getBold()) str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\n        if (font.getItalic() ) str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\n        if (font.getUnderline() == Font.U_SINGLE ) str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\n    }
153	private ClientAnchorDetail fitImageToRows(Sheet sheet, int rowNumber,\n            double reqImageHeightMM, int resizeBehaviour) {\n        Row row;\n        double rowHeightMM;\n        double rowCoordinatesPerMM;\n        int pictureHeightCoordinates;\n        ClientAnchorDetail rowClientAnchorDetail = null;\n\n                row = sheet.getRow(rowNumber);\n        if(row == null) {\n                        row = sheet.createRow(rowNumber);\n        }\n\n                rowHeightMM = row.getHeightInPoints() / ConvertImageUnits.POINTS_PER_MILLIMETRE;\n\n                                        if(rowHeightMM < reqImageHeightMM) {\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_ROW) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                row.setHeightInPoints((float)(reqImageHeightMM *\n                        ConvertImageUnits.POINTS_PER_MILLIMETRE));\n                if(sheet instanceof HSSFSheet) {                    \n                    rowHeightMM = reqImageHeightMM;\n                    rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                        rowHeightMM;\n                    pictureHeightCoordinates = (int)(reqImageHeightMM *\n                            rowCoordinatesPerMM);\n                }\n                else {\n                    pictureHeightCoordinates = (int)(reqImageHeightMM *\n                            AddDimensionedImage.EMU_PER_MM);\n                }\n                rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n            }\n                                                else if((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                    (resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN)) {\n                rowClientAnchorDetail = this.calculateRowLocation(sheet,\n                        rowNumber, reqImageHeightMM);\n            }\n        }\n                else {\n            if(sheet instanceof HSSFSheet) {\n                rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n                pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n            }\n            else {\n                pictureHeightCoordinates = (int)(reqImageHeightMM *\n                        AddDimensionedImage.EMU_PER_MM);\n            }\n            rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n        }\n        return(rowClientAnchorDetail);\n    }
154	void appendCellReference(StringBuilder sb) {\n        if (_colIndex != -1) {\n            if(_isColAbs) {\n                sb.append(ABSOLUTE_REFERENCE_MARKER);\n            }\n            sb.append( convertNumToColString(_colIndex));\n        }\n        if (_rowIndex != -1) {\n            if(_isRowAbs) {\n                sb.append(ABSOLUTE_REFERENCE_MARKER);\n            }\n            sb.append(_rowIndex+1);\n        }\n    }
155	DocumentEntry createDocument(final POIFSDocument document)\n        throws IOException\n    {\n        DocumentProperty property = document.getDocumentProperty();\n        DocumentNode     rval     = new DocumentNode(property, this);\n\n        (( DirectoryProperty ) getProperty()).addChild(property);\n        _nfilesystem.addDocument(document);\n\n        _entries.add(rval);\n        _byname.put(property.getName(), rval);\n        return rval;\n    }
156	private void appendSpecificTypes(Element root,\n            Entry<PackagePartName, String> entry) {\n        Element specificType = root.getOwnerDocument().createElementNS(TYPES_NAMESPACE_URI, OVERRIDE_TAG_NAME);\n        specificType.setAttribute(PART_NAME_ATTRIBUTE_NAME, entry.getKey().getName());\n        specificType.setAttribute(CONTENT_TYPE_ATTRIBUTE_NAME, entry.getValue());\n        root.appendChild(specificType);\n    }
157	static void updateRowFormulas(XSSFRow row, FormulaShifter formulaShifter) {\n        XSSFSheet sheet = row.getSheet();\n        for (Cell c : row) {\n            XSSFCell cell = (XSSFCell) c;\n\n            CTCell ctCell = cell.getCTCell();\n            if (ctCell.isSetF()) {\n                CTCellFormula f = ctCell.getF();\n                String formula = f.getStringValue();\n                if (formula.length() > 0) {\n                    String shiftedFormula = shiftFormula(row, formula, formulaShifter);\n                    if (shiftedFormula != null) {\n                        f.setStringValue(shiftedFormula);\n                        if(f.getT() == STCellFormulaType.SHARED){\n                            int si = (int)f.getSi();\n                            CTCellFormula sf = sheet.getSharedFormula(si);\n                            sf.setStringValue(shiftedFormula);\n                            updateRefInCTCellFormula(row, formulaShifter, sf);\n                        }\n                    }\n\n                }\n\n                                updateRefInCTCellFormula(row, formulaShifter, f);\n            }\n\n        }\n    }
158	public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackagePart part) {\n        final PackageRelationship rel = getPackageRelationship(parent, part);\n        final String relType = rel.getRelationshipType();\n        final POIXMLRelation descriptor = getDescriptor(relType);\n\n                        if (descriptor == null || descriptor.getRelationClass() == null || POIXMLDocument.PACK_OBJECT_REL_TYPE.equals(relType)) {\n            LOGGER.log(POILogger.DEBUG, "using default POIXMLDocumentPart for " + rel.getRelationshipType());\n            return new POIXMLDocumentPart(parent, part);\n        }\n\n        Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();\n        try {\n            try {\n                return createDocumentPart(cls, PARENT_PART, new Object[]{parent, part});\n            } catch (NoSuchMethodException e) {\n                return createDocumentPart(cls, ORPHAN_PART, new Object[]{part});\n            }\n        } catch (Exception e) {\n            throw new POIXMLException((e.getCause() != null ? e.getCause() : e).getMessage(), e);\n        }\n    }
159	public static double sumsq(double[] values) {\n        double sumsq = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sumsq += values[i]*values[i];\n        }\n        return sumsq;\n    }
160	private static void applyHslModOff(double hsl[], int hslPart, int mod, int off) {\n        if (mod == -1) {\n            mod = 100000;\n        }\n        if (off == -1) {\n            off = 0;\n        }\n        if (!(mod == 100000 && off == 0)) {\n            double fOff = off / 1000d;\n            double fMod = mod / 100000d;\n            hsl[hslPart] = hsl[hslPart]*fMod+fOff;\n        }\n    }
161	private InputStream getXLSFromURL(String urlstring) throws MalformedURLException, IOException {\n    URL url = new URL(urlstring);\n    URLConnection uc = url.openConnection();\n    String field = uc.getHeaderField(0);\n    for (int i=0;field != null; i++) {\n      System.out.println(field);\n      field = uc.getHeaderField(i);\n  }\n      return new BufferedInputStream(uc.getInputStream());\n  }
162	public static String getFromUnicodeLE0Terminated(\n            final byte[] string,\n            final int offset,\n            final int len)\n            throws ArrayIndexOutOfBoundsException, IllegalArgumentException {\n        if ((offset < 0) || (offset >= string.length)) {\n            throw new ArrayIndexOutOfBoundsException("Illegal offset " + offset + " (String data is of length " + string.length + ")");\n        }\n\n        if ((len < 0) || (((string.length - offset) / 2) < len)) {\n            throw new IllegalArgumentException("Illegal length " + len);\n        }\n\n        final int newOffset;\n        final int newMaxLen;\n        final String prefix;\n\n                if (len > 0 && string[offset] == 0 && string[offset+1] == 0) {\n            newOffset = offset+2;\n            prefix = "?";\n\n                        final int cp = (len > 1) ? LittleEndian.getShort(string, offset+2) : 0;\n            newMaxLen = Character.isJavaIdentifierPart(cp) ? len-1 : 0;\n        } else {\n            newOffset = offset;\n            prefix = "";\n            newMaxLen = len;\n        }\n\n        int newLen = 0;\n\n                for(; newLen < newMaxLen; newLen++) {\n            if (string[newOffset + newLen * 2] == 0 && string[newOffset + newLen * 2 + 1] == 0) {\n                break;\n            }\n        }\n        newLen = Math.min(newLen, newMaxLen);\n\n        return prefix + ((newLen == 0) ? "" : new String(string, newOffset, newLen * 2, UTF16LE));\n    }
163	public void setDimensions(int firstrow, short firstcol, int lastrow, short lastcol)\n    {\n        if (log.check( POILogger.DEBUG ))\n        {\n            log.log(POILogger.DEBUG, "Sheet.setDimensions");\n            log.log(POILogger.DEBUG,\n                    (new StringBuffer("firstrow")).append(firstrow)\n                        .append("firstcol").append(firstcol).append("lastrow")\n                        .append(lastrow).append("lastcol").append(lastcol)\n                        .toString());\n        }\n        _dimensions.setFirstCol(firstcol);\n        _dimensions.setFirstRow(firstrow);\n        _dimensions.setLastCol(lastcol);\n        _dimensions.setLastRow(lastrow);\n        if (log.check( POILogger.DEBUG ))\n            log.log(POILogger.DEBUG, "Sheet.setDimensions exiting");\n    }
164	public static HSLFSlideShowImpl create() {\n        InputStream is = HSLFSlideShowImpl.class.getResourceAsStream("/org/apache/poi/hslf/data/empty.ppt");\n        if (is == null) {\n            throw new HSLFException("Missing resource 'empty.ppt'");\n        }\n        try {\n            try {\n                return new HSLFSlideShowImpl(is);\n            } finally {\n                is.close();\n            }\n        } catch (IOException e) {\n            throw new HSLFException(e);\n        }\n    }
165	static void hideDupplicates(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("City");\n        sheet.createRow(1).createCell(0).setCellValue("Boston");\n        sheet.createRow(2).createCell(0).setCellValue("Boston");\n        sheet.createRow(3).createCell(0).setCellValue("Chicago");\n        sheet.createRow(4).createCell(0).setCellValue("Chicago");\n        sheet.createRow(5).createCell(0).setCellValue("New York");\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("A2=A1");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontColorIndex(IndexedColors.WHITE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(1).createCell(1).setCellValue("<== the second (and subsequent) " +\n                "occurences of each region name will have white font colour.  " +\n                "Condition: Formula Is   =A2=A1   (White Font)");\n    }
166	public void walkEscherBasic(int indent, int pos, int len) throws IOException {\n	if(len < 8) { return; }\n\n	final String ind = (indent == 0) ? "%1$s" : "%1$"+indent+"s";\n\n	long type = LittleEndian.getUShort(docstream,pos+2);\n	long atomlen = LittleEndian.getUInt(docstream,pos+4);\n\n	String fmt = ind+"At position %2$d ($2$04x): type is %3$d (%3$04x), len is %4$d (%4$04x)";\n	out.println(String.format(Locale.ROOT, fmt, "", pos, type, atomlen));\n\n	String typeName = RecordTypes.forTypeID((short)type).name();\n	out.println(String.format(Locale.ROOT, ind+"%2$s", "That's an Escher Record: ", typeName));\n\n		if(type == 61453L) {\n			    HexDump.dump(docstream, 0, out, pos+8, 8);\n	    HexDump.dump(docstream, 0, out, pos+20, 8);\n		out.println();\n	}\n\n\n		out.println();\n\n		if(type == 61443L || type == 61444L) {\n		walkEscherBasic((indent+3), pos+8, (int)atomlen);\n	}\n\n		if(atomlen < len) {\n		int atomleni = (int)atomlen;\n		walkEscherBasic(indent, pos+atomleni+8, len-atomleni-8);\n	}\n  }
167	public static void storeDate(Date date, byte[] dest, int offset) {\n        Calendar cal = LocaleUtil.getLocaleCalendar();\n        cal.setTime(date);\n\n        LittleEndian.putShort(dest, offset + 0, (short) cal.get(Calendar.YEAR));\n        LittleEndian.putShort(dest, offset + 2, (short)(cal.get(Calendar.MONTH) + 1));\n        LittleEndian.putShort(dest, offset + 4, (short)(cal.get(Calendar.DAY_OF_WEEK)-1));\n        LittleEndian.putShort(dest, offset + 6, (short) cal.get(Calendar.DAY_OF_MONTH));\n        LittleEndian.putShort(dest, offset + 8, (short) cal.get(Calendar.HOUR_OF_DAY));\n        LittleEndian.putShort(dest, offset + 10,(short) cal.get(Calendar.MINUTE));\n        LittleEndian.putShort(dest, offset + 12,(short) cal.get(Calendar.SECOND));\n        LittleEndian.putShort(dest, offset + 14,(short) cal.get(Calendar.MILLISECOND));\n	}
168	public void update(Observable observable, Object localeObj) {\n        if (!(localeObj instanceof Locale))  return;\n        Locale newLocale = (Locale)localeObj;\n        if (!localeIsAdapting || newLocale.equals(locale)) return;\n        \n        locale = newLocale;\n        \n        dateSymbols = DateFormatSymbols.getInstance(locale);\n        decimalSymbols = DecimalFormatSymbols.getInstance(locale);\n        generalNumberFormat = new ExcelGeneralNumberFormat(locale);\n\n                defaultDateformat = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", dateSymbols);\n        defaultDateformat.setTimeZone(LocaleUtil.getUserTimeZone());       \n\n        \n        formats.clear();\n        Format zipFormat = ZipPlusFourFormat.instance;\n        addFormat("00000\\-0000", zipFormat);\n        addFormat("00000-0000", zipFormat);\n\n        Format phoneFormat = PhoneFormat.instance;\n                addFormat("[<=9999999]###\\-####;\\(###\\)\\ ###\\-####", phoneFormat);\n        addFormat("[<=9999999]###-####;(###) ###-####", phoneFormat);\n        addFormat("###\\-####;\\(###\\)\\ ###\\-####", phoneFormat);\n        addFormat("###-####;(###) ###-####", phoneFormat);\n\n        Format ssnFormat = SSNFormat.instance;\n        addFormat("000\\-00\\-0000", ssnFormat);\n        addFormat("000-00-0000", ssnFormat);\n    }
169	protected void preWrite()\n    {\n        if (_children.size() > 0)\n        {\n            Property[] children = _children.toArray(new Property[ 0 ]);\n\n            Arrays.sort(children, new PropertyComparator());\n            int midpoint = children.length / 2;\n\n            setChildProperty(children[ midpoint ].getIndex());\n            children[ 0 ].setPreviousChild(null);\n            children[ 0 ].setNextChild(null);\n            for (int j = 1; j < midpoint; j++)\n            {\n                children[ j ].setPreviousChild(children[ j - 1 ]);\n                children[ j ].setNextChild(null);\n            }\n            if (midpoint != 0)\n            {\n                children[ midpoint ]\n                    .setPreviousChild(children[ midpoint - 1 ]);\n            }\n            if (midpoint != (children.length - 1))\n            {\n                children[ midpoint ].setNextChild(children[ midpoint + 1 ]);\n                for (int j = midpoint + 1; j < children.length - 1; j++)\n                {\n                    children[ j ].setPreviousChild(null);\n                    children[ j ].setNextChild(children[ j + 1 ]);\n                }\n                children[ children.length - 1 ].setPreviousChild(null);\n                children[ children.length - 1 ].setNextChild(null);\n            }\n            else\n            {\n                children[ midpoint ].setNextChild(null);\n            }\n        }\n    }
170	public void setValueWithMask(int val, int writeMask) {\n	    setWriteMask(writeMask);\n	    super.setValue(maskValue(val));\n	    if (val != super.getValue()) {\n	        logger.log(POILogger.WARN, "Style properties of '"+getName()+"' don't match mask - output will be sanitized");\n	        if (logger.check(POILogger.DEBUG)) {\n	            StringBuilder sb = new StringBuilder("The following style attributes of the '"+getName()+"' property will be ignored:\n");\n	            int i=0;\n	            for (int mask : subPropMasks) {\n	                if (!subPropMatches[i] && (val & mask) != 0) {\n	                    sb.append(subPropNames[i]).append(",");\n	                }\n	                i++;\n	            }\n	            logger.log(POILogger.DEBUG, sb.toString());\n	        }\n	    }\n	}
171	public void validate(SpreadsheetVersion ssVersion) {\n		validateRow(_firstRow, ssVersion);\n		validateRow(_lastRow, ssVersion);\n		validateColumn(_firstCol, ssVersion);\n		validateColumn(_lastCol, ssVersion);\n	}
172	@SuppressWarnings("WeakerAccess")\n    public void setLineTailWidth(DecorationSize style) {\n        CTLineProperties ln = getLn(this, true);\n        if (ln == null) {\n            return;\n        }\n        \n        CTLineEndProperties lnEnd = ln.isSetTailEnd() ? ln.getTailEnd() : ln.addNewTailEnd();\n        if (style == null) {\n            if (lnEnd.isSetW()) {\n                lnEnd.unsetW();\n            }\n        } else {\n            lnEnd.setW(STLineEndWidth.Enum.forInt(style.ooxmlId));\n        }\n    }
173	public static List<String> inspectViewable(final Object viewable,\n                                       final boolean drilldown,\n                                       final int indentLevel,\n                                       final String indentString)\n    {\n        List<String> objects = new ArrayList<>();\n\n        if (viewable instanceof POIFSViewable)\n        {\n            POIFSViewable inspected = ( POIFSViewable ) viewable;\n\n            objects.add(indent(indentLevel, indentString,\n                               inspected.getShortDescription()));\n            if (drilldown)\n            {\n                if (inspected.preferArray())\n                {\n                    Object[] data = inspected.getViewableArray();\n\n                    for (int j = 0; j < data.length; j++)\n                    {\n                        objects.addAll(inspectViewable(data[ j ], drilldown,\n                                                       indentLevel + 1,\n                                                       indentString));\n                    }\n                }\n                else\n                {\n                    Iterator<Object> iter = inspected.getViewableIterator();\n\n                    while (iter.hasNext())\n                    {\n                        objects.addAll(inspectViewable(iter.next(),\n                                                       drilldown,\n                                                       indentLevel + 1,\n                                                       indentString));\n                    }\n                }\n            }\n        }\n        else\n        {\n            objects.add(indent(indentLevel, indentString,\n                               viewable.toString()));\n        }\n        return objects;\n    }
174	private CellType getBaseCellType(boolean blankCells) {\n        switch (_cell.getT().intValue()) {\n            case STCellType.INT_B:\n                return CellType.BOOLEAN;\n            case STCellType.INT_N:\n                if (!_cell.isSetV() && blankCells) {\n                                                                                                                        return CellType.BLANK;\n                }\n                return CellType.NUMERIC;\n            case STCellType.INT_E:\n                return CellType.ERROR;\n            case STCellType.INT_S:             case STCellType.INT_INLINE_STR:             case STCellType.INT_STR:\n                 return CellType.STRING;\n            default:\n                throw new IllegalStateException("Illegal cell type: " + this._cell.getT());\n        }\n    }
175	public Borders getBorderTop() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getTop();\n        }\n        STBorder.Enum ptrn = (ct != null) ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
176	public static String dump(final byte [] data, final long offset, final int index, final int length) {\n        if (data == null || data.length == 0) {\n            return "No Data"+EOL;\n        }\n\n        int data_length = (length == Integer.MAX_VALUE || length < 0 || index+length < 0)\n            ? data.length\n            : Math.min(data.length,index+length);\n        \n        \n        if ((index < 0) || (index >= data.length)) {\n            String err = "illegal index: "+index+" into array of length "+data.length;\n            throw new ArrayIndexOutOfBoundsException(err);\n        }\n        \n        long  display_offset = offset + index;\n        StringBuilder buffer = new StringBuilder(74);\n        \n        for (int j = index; j < data_length; j += 16) {\n            int chars_read = data_length - j;\n\n            if (chars_read > 16) {\n                chars_read = 16;\n            }\n            \n            writeHex(buffer, display_offset, 8, "");\n            for (int k = 0; k < 16; k++) {\n                if (k < chars_read) {\n                    writeHex(buffer, data[ k + j ], 2, " ");\n                } else {\n                    buffer.append("   ");\n                }\n            }\n            buffer.append(' ');\n            for (int k = 0; k < chars_read; k++) {\n                buffer.append(toAscii(data[ k + j ]));\n            }\n            buffer.append(EOL);\n            display_offset += chars_read;\n        }\n        return buffer.toString();\n    }
177	public ValueEval getDynamicReference(String workbookName, String sheetName, String refStrPart1,\n            String refStrPart2, boolean isA1Style) {\n        if (!isA1Style) {\n            throw new RuntimeException("R1C1 style not supported yet");\n        }\n        SheetRefEvaluator se = createExternSheetRefEvaluator(workbookName, sheetName);\n        if (se == null) {\n            return ErrorEval.REF_INVALID;\n        }\n        SheetRangeEvaluator sre = new SheetRangeEvaluator(_sheetIndex, se);\n        \n                SpreadsheetVersion ssVersion = _workbook.getSpreadsheetVersion();\n\n        NameType part1refType = classifyCellReference(refStrPart1, ssVersion);\n        switch (part1refType) {\n            case BAD_CELL_OR_NAMED_RANGE:\n                return ErrorEval.REF_INVALID;\n            case NAMED_RANGE:\n                EvaluationName nm = _workbook.getName(refStrPart1, _sheetIndex);\n                if(!nm.isRange()){\n                    throw new RuntimeException("Specified name '" + refStrPart1 + "' is not a range as expected.");\n                }\n                return _bookEvaluator.evaluateNameFormula(nm.getNameDefinition(), this);\n        }\n        if (refStrPart2 == null) {\n                        switch (part1refType) {\n                case COLUMN:\n                case ROW:\n                    return ErrorEval.REF_INVALID;\n                case CELL:\n                    CellReference cr = new CellReference(refStrPart1);\n                    return new LazyRefEval(cr.getRow(), cr.getCol(), sre);\n            }\n            throw new IllegalStateException("Unexpected reference classification of '" + refStrPart1 + "'.");\n        }\n        NameType part2refType = classifyCellReference(refStrPart1, ssVersion);\n        switch (part2refType) {\n            case BAD_CELL_OR_NAMED_RANGE:\n                return ErrorEval.REF_INVALID;\n            case NAMED_RANGE:\n                throw new RuntimeException("Cannot evaluate '" + refStrPart1\n                        + "'. Indirect evaluation of defined names not supported yet");\n        }\n\n        if (part2refType != part1refType) {\n                        return ErrorEval.REF_INVALID;\n        }\n        int firstRow, firstCol, lastRow, lastCol;\n        switch (part1refType) {\n            case COLUMN:\n                firstRow =0;\n                if (part2refType.equals(NameType.COLUMN))\n                {\n                    lastRow = ssVersion.getLastRowIndex();\n                    firstCol = parseRowRef(refStrPart1);\n                    lastCol = parseRowRef(refStrPart2);\n                }\n                else {\n                    lastRow = ssVersion.getLastRowIndex();\n                    firstCol = parseColRef(refStrPart1);\n                    lastCol = parseColRef(refStrPart2);\n                }\n                break;\n            case ROW:\n                                firstCol = 0;\n                if (part2refType.equals(NameType.ROW))\n                {\n                    firstRow = parseColRef(refStrPart1);\n                    lastRow = parseColRef(refStrPart2);\n                    lastCol = ssVersion.getLastColumnIndex();\n                } else {\n                    lastCol = ssVersion.getLastColumnIndex();\n                    firstRow = parseRowRef(refStrPart1);\n                    lastRow = parseRowRef(refStrPart2);\n                }\n                break;\n            case CELL:\n                CellReference cr;\n                cr = new CellReference(refStrPart1);\n                firstRow = cr.getRow();\n                firstCol = cr.getCol();\n                cr = new CellReference(refStrPart2);\n                lastRow = cr.getRow();\n                lastCol = cr.getCol();\n                break;\n            default:\n                throw new IllegalStateException("Unexpected reference classification of '" + refStrPart1 + "'.");\n        }\n        return new LazyAreaEval(firstRow, firstCol, lastRow, lastCol, sre);\n    }
178	public static List<String> compare(Workbook wb1, Workbook wb2) {\n        Locator loc1 = new Locator();\n        Locator loc2 = new Locator();\n        loc1.workbook = wb1;\n        loc2.workbook = wb2;\n\n        ExcelComparator excelComparator = new ExcelComparator();\n        excelComparator.compareNumberOfSheets(loc1, loc2 );\n        excelComparator.compareSheetNames(loc1, loc2);\n        excelComparator.compareSheetData(loc1, loc2);\n\n        return excelComparator.listOfDifferences;\n    }
179	public String getExtension() {\n		String fragment = this.partNameURI.getPath();\n		if (fragment.length() > 0) {\n			int i = fragment.lastIndexOf(".");\n			if (i > -1) {\n                return fragment.substring(i + 1);\n            }\n		}\n		return "";\n	}
180	public void sortTopLeftToBottomRight() {\n        if (getFirstRow() > getLastRow()) {\n                                    final int firstRow = getFirstRow();\n            final boolean firstRowRel = isFirstRowRelative();\n            setFirstRow(getLastRow());\n            setFirstRowRelative(isLastRowRelative());\n            setLastRow(firstRow);\n            setLastRowRelative(firstRowRel);\n        }\n        if (getFirstColumn() > getLastColumn()) {\n                                    final int firstCol = getFirstColumn();\n            final boolean firstColRel = isFirstColRelative();\n            setFirstColumn(getLastColumn());\n            setFirstColRelative(isLastColRelative());\n            setLastColumn(firstCol);\n            setLastColRelative(firstColRel);\n        }\n    }
181	public Writer createWriter(File fd) throws IOException {\n        FileOutputStream fos = new FileOutputStream(fd);\n        OutputStream decorated;\n        try {\n            decorated = decorateOutputStream(fos);\n        } catch (final IOException e) {\n            fos.close();\n            throw e;\n        }\n        return new BufferedWriter(\n                new OutputStreamWriter(decorated, "UTF-8"));\n    }
182	public ExControl getExControl(){\n        int idx = getControlIndex();\n        Document doc = getSheet().getSlideShow().getDocumentRecord();\n        ExObjList lst = (ExObjList)doc.findFirstOfType(RecordTypes.ExObjList.typeID);\n        if (lst == null) {\n            return null;\n        }\n        \n        for (Record ch : lst.getChildRecords()) {\n            if(ch instanceof ExControl){\n                ExControl c = (ExControl)ch;\n                if(c.getExOleObjAtom().getObjID() == idx){\n                    return c;\n                }\n            }\n        }\n        return null;\n    }
183	public boolean removeEndnote(int pos) {\n        if (ctEndnotes.sizeOfEndnoteArray() >= pos - 1) {\n            ctEndnotes.removeEndnote(pos);\n            listFootnote.remove(pos);\n            return true;\n        } else {\n            return false;\n        }\n    }
184	private static int countTokensToBeSkipped(Ptg[] ptgs, int startIndex, int distInBytes) {\n        int remBytes = distInBytes;\n        int index = startIndex;\n        while (remBytes != 0) {\n            index++;\n            remBytes -= ptgs[index].getSize();\n            if (remBytes < 0) {\n                throw new RuntimeException("Bad skip distance (wrong token size calculation).");\n            }\n            if (index >= ptgs.length) {\n                throw new RuntimeException("Skip distance too far (ran out of formula tokens).");\n            }\n        }\n        return index-startIndex;\n    }
185	public static void main(String args[]) throws IOException\n	{\n		if(args.length < 1) {\n			System.err.println("Useage:");\n			System.err.println("\tQuickButCruddyTextExtractor <file>");\n			System.exit(1);\n		}\n\n		String file = args[0];\n\n		QuickButCruddyTextExtractor ppe = new QuickButCruddyTextExtractor(file);\n		System.out.println(ppe.getTextAsString());\n		ppe.close();\n	}
186	private void initSections() {\n		if (!_sectionRangeFound) {\n			int[] point = findRange(_sections, _sectionStart, _start, _end);\n			_sectionStart = point[0];\n			_sectionEnd = point[1];\n			_sectionRangeFound = true;\n		}\n	}
187	public static double irr(double[] values, double guess) {\n        final int maxIterationCount = 20;\n        final double absoluteAccuracy = 1E-7;\n\n        double x0 = guess;\n        double x1;\n\n        int i = 0;\n        while (i < maxIterationCount) {\n\n                        final double factor = 1.0 + x0;\n            int k = 0;\n            double fValue = values[k];\n            double fDerivative = 0;\n            for (double denominator = factor; ++k < values.length; ) {\n                final double value = values[k];\n                fValue += value / denominator;\n                denominator *= factor;\n                fDerivative -= k * value / denominator;\n            }\n\n                        x1 = x0 - fValue/fDerivative;\n\n            if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n                return x1;\n            }\n\n            x0 = x1;\n            ++i;\n        }\n                return Double.NaN;\n    }
188	static HSLFHyperlink createHyperlink(HSLFTextRun run) {\n                ExHyperlink exHyper = new ExHyperlink();\n        int linkId = run.getTextParagraph().getSheet().getSlideShow().addToObjListAtom(exHyper);\n        ExHyperlinkAtom obj = exHyper.getExHyperlinkAtom();\n        obj.setNumber(linkId);\n        InteractiveInfo info = new InteractiveInfo();\n        info.getInteractiveInfoAtom().setHyperlinkID(linkId);\n                        HSLFHyperlink hyper = new HSLFHyperlink(exHyper, info);\n        hyper.linkToNextSlide();\n        \n        TxInteractiveInfoAtom txinfo = new TxInteractiveInfoAtom();\n        int startIdx = run.getTextParagraph().getStartIdxOfTextRun(run);\n        int endIdx = startIdx + run.getLength();\n        txinfo.setStartIndex(startIdx);\n        txinfo.setEndIndex(endIdx);\n        hyper.setTextRunInfo(txinfo);\n        \n        run.setHyperlink(hyper);\n        return hyper;\n    }
189	protected int pastDaysOfWeek(double start, double end, int dayOfWeek) {\n        int pastDaysOfWeek = 0;\n        int startDay = (int) Math.floor(start < end ? start : end);\n        int endDay = (int) Math.floor(end > start ? end : start);\n        for (; startDay <= endDay; startDay++) {\n            Calendar today = LocaleUtil.getLocaleCalendar();\n            today.setTime(DateUtil.getJavaDate(startDay));\n            if (today.get(Calendar.DAY_OF_WEEK) == dayOfWeek) {\n                pastDaysOfWeek++;\n            }\n        }\n        return start <= end ? pastDaysOfWeek : -pastDaysOfWeek;\n    }
190	private String encodeUtf(String text) {\n        if(text == null) {\n            return null;\n        }\n\n        StringBuilder builder = new StringBuilder();\n        for(char c : text.toCharArray()) {\n                        if(c < 32) {\n                builder.append("_x").append(c < 16 ? "000" : "00").append(Integer.toHexString(c)).append("_");\n            } else {\n                builder.append(c);\n            }\n        }\n\n        return builder.toString();\n    }
191	@SuppressWarnings("WeakerAccess")\n    public void mergeCells(int firstCol, int lastCol)\n    {\n        if (firstCol >= lastCol) {\n            throw new IllegalArgumentException(\n                "Cannot merge, first column >= last column : "\n                + firstCol + " >= " + lastCol\n            );\n        }\n\n        final int colSpan = (lastCol - firstCol) + 1;\n\n        _cells.get(firstCol).setGridSpan(colSpan);\n        for (final XSLFTableCell cell : _cells.subList(firstCol+1, lastCol+1)) {\n            cell.setHMerge();\n        }\n    }
192	public static DVConstraint createNumericConstraint(int validationType, int comparisonOperator, \n			String expr1, String expr2) {\n		switch (validationType) {\n			case ValidationType.ANY:\n				if (expr1 != null || expr2 != null) {\n					throw new IllegalArgumentException("expr1 and expr2 must be null for validation type 'any'");\n				}\n				break;\n			case ValidationType.DECIMAL:\n			case ValidationType.INTEGER:\n			case ValidationType.TEXT_LENGTH:\n				if (expr1 == null) {\n					throw new IllegalArgumentException("expr1 must be supplied");\n				}\n				OperatorType.validateSecondArg(comparisonOperator, expr2);\n				break;\n			default:\n				throw new IllegalArgumentException("Validation Type ("\n						+ validationType + ") not supported with this method");\n		}\n				String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertNumber(expr1) : null;\n				String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertNumber(expr2) : null;\n		return new DVConstraint(validationType, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
193	public void process() throws IOException {\n		MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener(this);\n		formatListener = new FormatTrackingHSSFListener(listener);\n\n		HSSFEventFactory factory = new HSSFEventFactory();\n		HSSFRequest request = new HSSFRequest();\n\n		if(outputFormulaValues) {\n			request.addListenerForAllRecords(formatListener);\n		} else {\n			workbookBuildingListener = new SheetRecordCollectingListener(formatListener);\n			request.addListenerForAllRecords(workbookBuildingListener);\n		}\n\n		factory.processWorkbookEvents(request, fs);\n	}
194	public void walkEscherDDF(int indent, int pos, int len) {\n	if(len < 8) { return; }\n\n	final String ind = (indent == 0) ? "%1$s" : "%1$"+indent+"s";\n\n	byte[] contents = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n	System.arraycopy(docstream,pos,contents,0,len);\n	DefaultEscherRecordFactory erf = new HSLFEscherRecordFactory();\n	EscherRecord record = erf.createRecord(contents,0);\n\n		record.fillFields(contents,0,erf);\n\n	long atomType = LittleEndian.getUShort(contents,2);\n		long atomLen = LittleEndian.getUShort(contents,4);\n		int recordLen = record.getRecordSize();\n\n    String fmt = ind+"At position %2$d (%2$04x): type is %3$d (%3$04x), len is %4$d (%4$04x) (%5$d) - record claims %6$d";\n    out.println(String.format(Locale.ROOT, fmt, "", pos, atomType, atomLen, atomLen+8, recordLen));\n	\n	\n		if(recordLen != 8 && (recordLen != (atomLen+8))) {\n		out.println(String.format(Locale.ROOT, ind+"** Atom length of $2d ($3d) doesn't match record length of %4d", "", atomLen, atomLen+8, recordLen));\n	}\n\n	    String recordStr = record.toString().replace("\n", String.format(Locale.ROOT,  "\n"+ind, ""));\n    out.println(String.format(Locale.ROOT, ind+"%2$s", "", recordStr));\n\n    if(record instanceof EscherContainerRecord) {\n		walkEscherDDF((indent+3), pos + 8, (int)atomLen );\n	}\n\n		if(atomType == 61451L) {\n				recordLen = (int)atomLen + 8;\n	}\n	if(atomType == 61453L) {\n				recordLen = (int)atomLen + 8;\n		record.fillFields( contents, 0, erf );\n		if(! (record instanceof EscherTextboxRecord)) {\n			out.println(String.format(Locale.ROOT, ind+"%2$s", "", "** Really a msofbtClientTextbox !"));\n		}\n	}\n\n		if(recordLen == 8 && atomLen > 8 ) {\n				walkEscherDDF((indent+3), pos + 8, (int)atomLen );\n\n				pos += atomLen;\n		pos += 8;\n		len -= atomLen;\n		len -= 8;\n	} else {\n				pos += atomLen;\n		pos += 8;\n		len -= atomLen;\n		len -= 8;\n	}\n\n		if(len >= 8) {\n		walkEscherDDF(indent, pos, len );\n	}\n  }
195	protected static CTGraphicalObjectFrame prototype() {\n		if (prototype == null) {\n			CTGraphicalObjectFrame graphicFrame = CTGraphicalObjectFrame.Factory.newInstance();\n\n			CTGraphicalObjectFrameNonVisual nvGraphic = graphicFrame.addNewNvGraphicFramePr();\n			CTNonVisualDrawingProps props = nvGraphic.addNewCNvPr();\n			props.setId(0);\n			props.setName("Diagramm 1");\n			nvGraphic.addNewCNvGraphicFramePr();\n\n			CTTransform2D transform = graphicFrame.addNewXfrm();\n			CTPositiveSize2D extPoint = transform.addNewExt();\n			CTPoint2D offPoint = transform.addNewOff();\n\n			extPoint.setCx(0);\n			extPoint.setCy(0);\n			offPoint.setX(0);\n			offPoint.setY(0);\n\n			 graphicFrame.addNewGraphic();\n\n			prototype = graphicFrame;\n		}\n		return prototype;\n	}
196	public boolean removeRow(int pos) throws IndexOutOfBoundsException {\n        if (pos >= 0 && pos < tableRows.size()) {\n            if (ctTbl.sizeOfTrArray() > 0) {\n                ctTbl.removeTr(pos);\n            }\n            tableRows.remove(pos);\n            return true;\n        }\n        return false;\n    }
197	public void checkUpdatedDoc() throws OpenXML4JException, IOException {\n        for (PackagePart pPart : this.doc.getAllEmbeddedParts()) {\n            String ext = pPart.getPartName().getExtension();\n            if (BINARY_EXTENSION.equals(ext) || OPENXML_EXTENSION.equals(ext)) {\n                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is)) {\n                    Sheet sheet = workbook.getSheetAt(SHEET_NUM);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    if(cell.getNumericCellValue() != NEW_VALUE) {\n                        throw new IllegalStateException("Failed to validate document content.");\n                    }\n                }\n            }\n        }\n    }
198	public void setBorderLeft(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetLeft();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
199	public void write() throws IOException {\n        POIFSFileSystem fs = getDirectory().getFileSystem();\n        \n        validateInPlaceWritePossible();        \n        writeProperties(fs, null);\n        fs.writeFilesystem();\n    }
200	public String getCommonXpath() {\n        if (commonXPath == null) {\n            String[] commonTokens = {};\n            for (XSSFTableColumn column : getColumns()) {\n                if (column.getXmlColumnPr()!=null) {\n                    String xpath = column.getXmlColumnPr().getXPath();\n                    String[] tokens =  xpath.split("/");\n                    if (commonTokens.length==0) {\n                        commonTokens = tokens;\n                        \n                    } else {\n                        final int maxLength = Math.min(commonTokens.length, tokens.length);\n                         \n                        for (int i =0; i<maxLength; i++) {\n                            if (!commonTokens[i].equals(tokens[i])) {\n                             List<String> subCommonTokens = Arrays.asList(commonTokens).subList(0, i);\n                             \n                             String[] container = {};\n                             \n                             commonTokens = subCommonTokens.toArray(container);\n                             break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            commonTokens[0] = "";\n            commonXPath = StringUtil.join(commonTokens, "/");\n        }\n        \n        return commonXPath;\n    }
201	private static String[] split(String text, String separator, int max)\n    {\n        StringTokenizer tok = new StringTokenizer(text, separator);\n        int listSize = tok.countTokens();\n        if(max != -1 && listSize > max)\n            listSize = max;\n        String list[] = new String[listSize];\n        for(int i = 0; tok.hasMoreTokens(); i++)\n        {\n            if(max != -1 && i == listSize - 1)\n            {\n                StringBuffer buf = new StringBuffer((text.length() * (listSize - i)) / listSize);\n                while(tok.hasMoreTokens())\n                {\n                    buf.append(tok.nextToken());\n                    if(tok.hasMoreTokens())\n                        buf.append(separator);\n                }\n                list[i] = buf.toString().trim();\n                break;\n            }\n            list[i] = tok.nextToken().trim();\n        }\n\n        return list;\n    }
202	protected static OPCPackage newPackage(XSSFWorkbookType workbookType) {\n        try {\n            OPCPackage pkg = OPCPackage.create(new ByteArrayOutputStream());                            PackagePartName corePartName = PackagingURIHelper.createPartName(XSSFRelation.WORKBOOK.getDefaultFileName());\n                        pkg.addRelationship(corePartName, TargetMode.INTERNAL, PackageRelationshipTypes.CORE_DOCUMENT);\n                        pkg.createPart(corePartName, workbookType.getContentType());\n\n            pkg.getPackageProperties().setCreatorProperty(DOCUMENT_CREATOR);\n\n            return pkg;\n        } catch (Exception e){\n            throw new POIXMLException(e);\n        }\n    }
203	public void addListener(HSSFListener lsnr, short sid) {\n		List<HSSFListener> list = _records.get(Short.valueOf(sid));\n\n		if (list == null) {\n			list = new ArrayList<>(1); 			_records.put(Short.valueOf(sid), list);\n		}\n		list.add(lsnr);\n	}
204	public static boolean canComputeColumnWidth(Font font) {\n                AttributedString str = new AttributedString("1w");\n        copyAttributes(font, str, 0, "1w".length());\n\n        TextLayout layout = new TextLayout(str.getIterator(), fontRenderContext);\n        return (layout.getBounds().getWidth() > 0);\n    }
205	public XSLFSlide createSlide(XSLFSlideLayout layout) {\n        int slideNumber = 256, cnt = 1;\n        CTSlideIdList slideList;\n        XSLFRelation relationType = XSLFRelation.SLIDE;\n        if (!_presentation.isSetSldIdLst()) {\n            slideList = _presentation.addNewSldIdLst();\n        } else {\n            slideList = _presentation.getSldIdLst();\n            for (CTSlideIdListEntry slideId : slideList.getSldIdArray()) {\n                slideNumber = (int) Math.max(slideId.getId() + 1, slideNumber);\n                cnt++;\n            }\n\n            cnt = findNextAvailableFileNameIndex(relationType, cnt);\n        }\n\n        RelationPart rp = createRelationship\n                (relationType, XSLFFactory.getInstance(), cnt, false);\n        XSLFSlide slide = rp.getDocumentPart();\n\n        CTSlideIdListEntry slideId = slideList.addNewSldId();\n        slideId.setId(slideNumber);\n        slideId.setId2(rp.getRelationship().getId());\n\n        layout.copyLayout(slide);\n        slide.getPackagePart().clearRelationships();\n        slide.addRelation(null, XSLFRelation.SLIDE_LAYOUT, layout);\n\n        _slides.add(slide);\n        return slide;\n    }
206	public final int getRecordSize() {\n		ContinuableRecordOutput out = ContinuableRecordOutput.createForCountingOnly();\n		serialize(out);\n		out.terminate();\n		return out.getTotalSize();\n	}
207	public static Record buildRecordAtOffset(byte[] b, int offset) {\n		long type = LittleEndian.getUShort(b,offset+2);\n		long rlen = LittleEndian.getUInt(b,offset+4);\n\n				int rleni = (int)rlen;\n		if(rleni < 0) { rleni = 0; }\n\n		return createRecordForType(type,b,offset,8+rleni);\n	}
208	public static XMLInputFactory newXMLInputFactory() {\n        XMLInputFactory factory = XMLInputFactory.newFactory();\n        trySetProperty(factory, XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        trySetProperty(factory, XMLInputFactory.IS_VALIDATING, false);\n        trySetProperty(factory, XMLInputFactory.SUPPORT_DTD, false);\n        trySetProperty(factory, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        return factory;\n    }
209	public void updateWindowMapMode() {\n        Rectangle2D win = prop.getWindow();\n        HwmfMapMode mapMode = prop.getMapMode();\n        graphicsCtx.setTransform(initialAT);\n\n        switch (mapMode) {\n        default:\n        case MM_ANISOTROPIC:\n                        graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getHeight()/win.getHeight());\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        case MM_ISOTROPIC:\n                                    graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getWidth()/win.getWidth());\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        case MM_LOMETRIC:\n        case MM_HIMETRIC:\n        case MM_LOENGLISH:\n        case MM_HIENGLISH:\n        case MM_TWIPS: {\n                        GraphicsConfiguration gc = graphicsCtx.getDeviceConfiguration();\n            graphicsCtx.transform(gc.getNormalizingTransform());\n            graphicsCtx.scale(1./mapMode.scale, -1./mapMode.scale);\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        }\n        case MM_TEXT:\n                        break;\n        }\n    }
210	public void read(final POIFSFileSystem poifs) throws IOException {\n        registryClosed = true;\n\n                PropertyTable properties = poifs.getPropertyTable();\n\n                RootProperty root = properties.getRoot();\n        processProperties(poifs, root, new POIFSDocumentPath());\n    }
211	private void paintDottedBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             northBorderType == BorderStyle.DOTTED) {\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+2) {\n             g.drawLine(xc,y+k,xc,y+k);\n           }\n        }\n      }\n\n      if (eastBorder &&\n              eastBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; \n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+2) {\n                g.drawLine(width-k,yc,width-k,yc);\n           }\n        }\n      }\n\n      if (southBorder &&\n              southBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(southBorderType);\n        thickness++;\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+2) {\n             g.drawLine(xc,height-k,xc,height-k);\n           }\n        }\n      }\n\n      if (westBorder &&\n            westBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+2) {\n                g.drawLine(x+k,yc,x+k,yc);\n           }\n        }\n      }\n   }
212	private static SimpleFraction buildFractionMaxDenominator(double value, double epsilon, int maxDenominator, int maxIterations)\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)Math.floor(r0);\n        if (a0 > overflow) {\n            throw new IllegalArgumentException("Overflow trying to convert "+value+" to fraction ("+a0+"/"+1l+")");\n        }\n\n                        if (Math.abs(a0 - value) < epsilon) {\n            return new SimpleFraction((int)a0, 1);\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2;\n        long q2;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)Math.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n                        if (epsilon == 0.0f && maxDenominator > 0 && Math.abs(q2) > maxDenominator &&\n                    Math.abs(q1) < maxDenominator){\n\n                return new SimpleFraction((int)p1, (int)q1);\n            }\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new RuntimeException("Overflow trying to convert "+value+" to fraction ("+p2+"/"+q2+")");\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new RuntimeException("Unable to convert "+value+" to fraction after "+maxIterations+" iterations");\n        }\n\n        if (q2 < maxDenominator) {\n            return new SimpleFraction((int) p2, (int)q2);\n        } else {\n            return new SimpleFraction((int)p1, (int)q1);\n        }\n\n    }
213	public String formatNumberDateCell(CellValueRecordInterface cell) {\n		double value;\n		if (cell instanceof NumberRecord) {\n			value = ((NumberRecord) cell).getValue();\n		} else if (cell instanceof FormulaRecord) {\n			value = ((FormulaRecord) cell).getValue();\n		} else {\n			throw new IllegalArgumentException("Unsupported CellValue Record passed in " + cell);\n		}\n\n				int formatIndex = getFormatIndex(cell);\n		String formatString = getFormatString(cell);\n\n		if (formatString == null) {\n			return _defaultFormat.format(value);\n		}\n						return _formatter.formatRawCellContents(value, formatIndex, formatString);\n	}
214	public void commit() throws IOException {\n\n        if(extPart == null && ext != null && ext.props != null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n            try {\n                PackagePartName prtname = PackagingURIHelper.createPartName("/docProps/app.xml");\n                pkg.addRelationship(prtname, TargetMode.INTERNAL, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties");\n                extPart = pkg.createPart(prtname, "application/vnd.openxmlformats-officedocument.extended-properties+xml");\n            } catch (InvalidFormatException e){\n                throw new POIXMLException(e);\n            }\n        }\n        if(custPart == null && cust != null && cust.props != null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n            try {\n                PackagePartName prtname = PackagingURIHelper.createPartName("/docProps/custom.xml");\n                pkg.addRelationship(prtname, TargetMode.INTERNAL, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties");\n                custPart = pkg.createPart(prtname, "application/vnd.openxmlformats-officedocument.custom-properties+xml");\n            } catch (InvalidFormatException e){\n                throw new POIXMLException(e);\n            }\n        }\n        if(extPart != null){\n            try (OutputStream out = extPart.getOutputStream()) {\n                if (extPart.getSize() > 0) {\n                    extPart.clear();\n                }\n                ext.props.save(out, DEFAULT_XML_OPTIONS);\n            }\n        }\n        if(custPart != null){\n            try (OutputStream out = custPart.getOutputStream()) {\n                cust.props.save(out, DEFAULT_XML_OPTIONS);\n            }\n        }\n    }
215	public SharedValueRecordBase getRecordForFirstCell(FormulaRecordAggregate agg) {\n		CellReference firstCell = agg.getFormulaRecord().getFormula().getExpReference();\n						if (firstCell == null) {\n						return null;\n		}\n\n\n		int row = firstCell.getRow();\n		int column = firstCell.getCol();\n		if (agg.getRow() != row || agg.getColumn() != column) {\n						return null;\n		}\n\n        if(!_groupsBySharedFormulaRecord.isEmpty()) {\n            SharedFormulaGroup sfg = findFormulaGroupForCell(firstCell);\n            if(null != sfg) {\n                return sfg.getSFR();\n            }\n        }\n\n						\n		for (TableRecord tr : _tableRecords) {\n			if (tr.isFirstCell(row, column)) {\n				return tr;\n			}\n		}\n		for (ArrayRecord ar : _arrayRecords) {\n			if (ar.isFirstCell(row, column)) {\n				return ar;\n			}\n		}\n		return null;\n	}
216	private static void shiftBreaks(PageBreakRecord breaks, int start, int stop, int count) {\n\n        Iterator<PageBreakRecord.Break> iterator = breaks.getBreaksIterator();\n        List<PageBreakRecord.Break> shiftedBreak = new ArrayList<>();\n        while(iterator.hasNext())\n        {\n            PageBreakRecord.Break breakItem = iterator.next();\n            int breakLocation = breakItem.main;\n            boolean inStart = (breakLocation >= start);\n            boolean inEnd = (breakLocation <= stop);\n            if(inStart && inEnd) {\n                shiftedBreak.add(breakItem);\n            }\n        }\n\n        iterator = shiftedBreak.iterator();\n        while (iterator.hasNext()) {\n            PageBreakRecord.Break breakItem = iterator.next();\n            breaks.removeBreak(breakItem.main);\n            breaks.addBreak((short)(breakItem.main+count), breakItem.subFrom, breakItem.subTo);\n        }\n    }
217	public void importFromXML(String xmlInputString) throws SAXException, XPathExpressionException, IOException {\n\n        DocumentBuilder builder = DocumentHelper.newDocumentBuilder();\n\n        Document doc = builder.parse(new InputSource(new StringReader(xmlInputString.trim())));\n\n        List<XSSFSingleXmlCell> singleXmlCells = _map.getRelatedSingleXMLCell();\n\n        List<XSSFTable> tables = _map.getRelatedTables();\n\n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        XPath xpath = xpathFactory.newXPath();\n\n                                xpath.setNamespaceContext(new DefaultNamespaceContext(doc));\n\n        for (XSSFSingleXmlCell singleXmlCell : singleXmlCells) {\n\n            STXmlDataType.Enum xmlDataType = singleXmlCell.getXmlDataType();\n            String xpathString = singleXmlCell.getXpath();\n            Node result = (Node) xpath.evaluate(xpathString, doc, XPathConstants.NODE);\n                        if (result != null) {\n                String textContent = result.getTextContent();\n                logger.log(POILogger.DEBUG, "Extracting with xpath " + xpathString + " : value is '" + textContent + "'");\n                XSSFCell cell = singleXmlCell.getReferencedCell();\n                logger.log(POILogger.DEBUG, "Setting '" + textContent + "' to cell " + cell.getColumnIndex() + "-" + cell.getRowIndex() + " in sheet "\n                                                + cell.getSheet().getSheetName());\n                setCellValue(textContent, cell, xmlDataType);\n            }\n        }\n\n        for (XSSFTable table : tables) {\n\n            String commonXPath = table.getCommonXpath();\n            NodeList result = (NodeList) xpath.evaluate(commonXPath, doc, XPathConstants.NODESET);\n            int rowOffset = table.getStartCellReference().getRow() + table.getHeaderRowCount();\n            int columnOffset = table.getStartCellReference().getCol();\n\n            table.setDataRowCount(result.getLength());\n\n            for (int i = 0; i < result.getLength(); i++) {\n\n                                \n                Node singleNode = result.item(i).cloneNode(true);\n\n                for (XSSFTableColumn tableColumn : table.getColumns()) {\n\n                    XSSFXmlColumnPr xmlColumnPr = tableColumn.getXmlColumnPr();\n                    if(xmlColumnPr == null) {\n                        continue;\n                    }\n\n                    int rowId = rowOffset + i;\n                    int columnId = columnOffset + tableColumn.getColumnIndex();\n                    String localXPath = xmlColumnPr.getLocalXPath();\n                    localXPath = localXPath.substring(localXPath.indexOf('/', 1) + 1);\n\n                                        String value = (String) xpath.evaluate(localXPath, singleNode, XPathConstants.STRING);\n                    logger.log(POILogger.DEBUG, "Extracting with xpath " + localXPath + " : value is '" + value + "'");\n                    XSSFRow row = table.getXSSFSheet().getRow(rowId);\n                    if (row == null) {\n                        row = table.getXSSFSheet().createRow(rowId);\n                    }\n\n                    XSSFCell cell = row.getCell(columnId);\n                    if (cell == null) {\n                        cell = row.createCell(columnId);\n                    }\n                    logger.log(POILogger.DEBUG, "Setting '" + value + "' to cell " + cell.getColumnIndex() + "-" + cell.getRowIndex() + " in sheet "\n                                                    + table.getXSSFSheet().getSheetName());\n                    setCellValue(value, cell, xmlColumnPr.getXmlDataType());\n                }\n            }\n        }\n    }
218	public void process() throws IOException, OpenXML4JException, SAXException {\n        ReadOnlySharedStringsTable strings = new ReadOnlySharedStringsTable(this.xlsxPackage);\n        XSSFReader xssfReader = new XSSFReader(this.xlsxPackage);\n        StylesTable styles = xssfReader.getStylesTable();\n        XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) xssfReader.getSheetsData();\n        int index = 0;\n        while (iter.hasNext()) {\n            try (InputStream stream = iter.next()) {\n                String sheetName = iter.getSheetName();\n                this.output.println();\n                this.output.println(sheetName + " [index=" + index + "]:");\n                processSheet(styles, strings, new SheetToCSV(), stream);\n            }\n            ++index;\n        }\n    }
219	public FileIdCluster addCluster( int dgId, int numShapedUsed, boolean sort ) {\n        FileIdCluster ficNew = new FileIdCluster(dgId, numShapedUsed);\n        field_5_fileIdClusters.add(ficNew);\n        maxDgId = Math.min(maxDgId, dgId);\n        \n        if (sort) {\n            sortCluster();\n        }\n        \n        return ficNew;\n    }
220	public void dump(byte[] data, int offset, int size, PrintStream out) {\n        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory();\n        int pos = offset;\n        while ( pos < offset + size )\n        {\n            EscherRecord r = recordFactory.createRecord(data, pos);\n            int bytesRead = r.fillFields(data, pos, recordFactory );\n            out.println(r);\n            pos += bytesRead;\n        }\n    }
221	private void isCellBorderMatches(Locator loc1, Locator loc2, char borderSide) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        XSSFCellStyle style1 = ((XSSFCell)loc1.cell).getCellStyle();\n        XSSFCellStyle style2 = ((XSSFCell)loc2.cell).getCellStyle();\n        boolean b1, b2;\n        String borderName;\n        switch (borderSide) {\n            case 't': default:\n                b1 = style1.getBorderTop() == BorderStyle.THIN;\n                b2 = style2.getBorderTop() == BorderStyle.THIN;\n                borderName = "TOP";\n                break;\n            case 'b':\n                b1 = style1.getBorderBottom() == BorderStyle.THIN;\n                b2 = style2.getBorderBottom() == BorderStyle.THIN;\n                borderName = "BOTTOM";\n                break;\n            case 'l':\n                b1 = style1.getBorderLeft() == BorderStyle.THIN;\n                b2 = style2.getBorderLeft() == BorderStyle.THIN;\n                borderName = "LEFT";\n                break;\n            case 'r':\n                b1 = style1.getBorderRight() == BorderStyle.THIN;\n                b2 = style2.getBorderRight() == BorderStyle.THIN;\n                borderName = "RIGHT";\n                break;\n        }\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                "Cell Border Attributes does not Match ::",\n                (b1 ? "" : "NOT ")+borderName+" BORDER",\n                (b2 ? "" : "NOT ")+borderName+" BORDER"\n            );\n        }\n    }
222	public CTShape findCommentShape(int row, int col){\n        for(XmlObject itm : _items){\n            if(itm instanceof CTShape){\n                CTShape sh = (CTShape)itm;\n                if(sh.sizeOfClientDataArray() > 0){\n                    CTClientData cldata = sh.getClientDataArray(0);\n                    if(cldata.getObjectType() == STObjectType.NOTE){\n                        int crow = cldata.getRowArray(0).intValue();\n                        int ccol = cldata.getColumnArray(0).intValue();\n                        if(crow == row && ccol == col) {\n                            return sh;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }
223	public void setSummaryEntries(DirectoryNode dir, String encryptedStream, POIFSFileSystem entries)\n    throws IOException, GeneralSecurityException {\n        CryptoAPIDocumentOutputStream bos = new CryptoAPIDocumentOutputStream(this);         byte buf[] = new byte[8];\n        \n        bos.write(buf, 0, 8);         List<StreamDescriptorEntry> descList = new ArrayList<>();\n\n        int block = 0;\n        for (Entry entry : entries.getRoot()) {\n            if (entry.isDirectoryEntry()) {\n                continue;\n            }\n            StreamDescriptorEntry descEntry = new StreamDescriptorEntry();\n            descEntry.block = block;\n            descEntry.streamOffset = bos.size();\n            descEntry.streamName = entry.getName();\n            descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);\n            descEntry.reserved2 = 0;\n            \n            bos.setBlock(block);\n            DocumentInputStream dis = dir.createDocumentInputStream(entry);\n            IOUtils.copy(dis, bos);\n            dis.close();\n            \n            descEntry.streamSize = bos.size() - descEntry.streamOffset;\n            descList.add(descEntry);\n            \n            block++;\n        }\n        \n        int streamDescriptorArrayOffset = bos.size();\n        \n        bos.setBlock(0);\n        LittleEndian.putUInt(buf, 0, descList.size());\n        bos.write(buf, 0, 4);\n        \n        for (StreamDescriptorEntry sde : descList) {\n            LittleEndian.putUInt(buf, 0, sde.streamOffset);\n            bos.write(buf, 0, 4);\n            LittleEndian.putUInt(buf, 0, sde.streamSize);\n            bos.write(buf, 0, 4);\n            LittleEndian.putUShort(buf, 0, sde.block);\n            bos.write(buf, 0, 2);\n            LittleEndian.putUByte(buf, 0, (short)sde.streamName.length());\n            bos.write(buf, 0, 1);\n            LittleEndian.putUByte(buf, 0, (short)sde.flags);\n            bos.write(buf, 0, 1);\n            LittleEndian.putUInt(buf, 0, sde.reserved2);\n            bos.write(buf, 0, 4);\n            byte nameBytes[] = StringUtil.getToUnicodeLE(sde.streamName);\n            bos.write(nameBytes, 0, nameBytes.length);\n            LittleEndian.putShort(buf, 0, (short)0);             bos.write(buf, 0, 2);\n        }\n        \n        int savedSize = bos.size();\n        int streamDescriptorArraySize = savedSize - streamDescriptorArrayOffset;\n        LittleEndian.putUInt(buf, 0, streamDescriptorArrayOffset);\n        LittleEndian.putUInt(buf, 4, streamDescriptorArraySize);\n\n        bos.reset();\n        bos.setBlock(0);\n        bos.write(buf, 0, 8);\n        bos.setSize(savedSize);\n        \n        dir.createDocument(encryptedStream, new ByteArrayInputStream(bos.getBuf(), 0, savedSize));\n    }
224	private int writeHidden(RowRecord pRowRecord, int row) {\n        int rowIx = row;\n        RowRecord rowRecord = pRowRecord;\n        int level = rowRecord.getOutlineLevel();\n        while (rowRecord != null && getRow(rowIx).getOutlineLevel() >= level) {\n            rowRecord.setZeroHeight(true);\n            rowIx++;\n            rowRecord = getRow(rowIx);\n        }\n        return rowIx;\n    }
225	public static Workbook create(final DirectoryNode root, String password) throws IOException {\n                if (root.hasEntry(Decryptor.DEFAULT_POIFS_ENTRY)) {\n            InputStream stream = null;\n            try {\n                stream = DocumentFactoryHelper.getDecryptedStream(root, password);\n\n                return createXSSFWorkbook(stream);\n            } finally {\n                IOUtils.closeQuietly(stream);\n\n                                                root.getFileSystem().close();\n            }\n        }\n\n                        boolean passwordSet = false;\n        if (password != null) {\n            Biff8EncryptionKey.setCurrentUserPassword(password);\n            passwordSet = true;\n        }\n        try {\n            return createHSSFWorkbook(root);\n        } finally {\n            if (passwordSet) {\n                Biff8EncryptionKey.setCurrentUserPassword(null);\n            }\n        }\n    }
226	protected static Record[] normalizeRecords(Record records[]) {\n                \n        UserEditAtom uea = null;\n        PersistPtrHolder pph = null;\n        TreeMap<Integer,Integer> slideLocations = new TreeMap<>();\n        TreeMap<Integer,Record> recordMap = new TreeMap<>();\n        List<Integer> obsoleteOffsets = new ArrayList<>();\n        int duplicatedCount = 0;\n        for (Record r : records) {\n            assert(r instanceof PositionDependentRecord);\n            PositionDependentRecord pdr = (PositionDependentRecord)r;\n            if (pdr instanceof UserEditAtom) {\n                uea = (UserEditAtom)pdr;\n                continue;\n            }\n\n            if (pdr instanceof PersistPtrHolder) {\n                if (pph != null) {\n                    duplicatedCount++;\n                }\n                pph = (PersistPtrHolder)pdr;\n                for (Map.Entry<Integer,Integer> me : pph.getSlideLocationsLookup().entrySet()) {\n                    Integer oldOffset = slideLocations.put(me.getKey(), me.getValue());\n                    if (oldOffset != null) {\n                        obsoleteOffsets.add(oldOffset);\n                    }\n                }\n                continue;\n            }\n\n            recordMap.put(pdr.getLastOnDiskOffset(), r);\n        }\n\n        if (uea == null || pph == null || uea.getPersistPointersOffset() != pph.getLastOnDiskOffset()) {\n            throw new EncryptedDocumentException("UserEditAtom and PersistPtrHolder must exist and their offset need to match.");\n        }\n\n        recordMap.put(pph.getLastOnDiskOffset(), pph);\n        recordMap.put(uea.getLastOnDiskOffset(), uea);\n\n        if (duplicatedCount == 0 && obsoleteOffsets.isEmpty()) {\n            return records;\n        }\n\n        uea.setLastUserEditAtomOffset(0);\n        pph.clear();\n        for (Map.Entry<Integer,Integer> me : slideLocations.entrySet()) {\n            pph.addSlideLookup(me.getKey(), me.getValue());\n        }\n\n        for (Integer oldOffset : obsoleteOffsets) {\n            recordMap.remove(oldOffset);\n        }\n\n        return recordMap.values().toArray(new Record[recordMap.size()]);\n    }
227	private static CTWorksheet newSheet(){\n        CTWorksheet worksheet = CTWorksheet.Factory.newInstance();\n        CTSheetFormatPr ctFormat = worksheet.addNewSheetFormatPr();\n        ctFormat.setDefaultRowHeight(DEFAULT_ROW_HEIGHT);\n\n        CTSheetView ctView = worksheet.addNewSheetViews().addNewSheetView();\n        ctView.setWorkbookViewId(0);\n\n        worksheet.addNewDimension().setRef("A1");\n\n        worksheet.addNewSheetData();\n\n        CTPageMargins ctMargins = worksheet.addNewPageMargins();\n        ctMargins.setBottom(DEFAULT_MARGIN_BOTTOM);\n        ctMargins.setFooter(DEFAULT_MARGIN_FOOTER);\n        ctMargins.setHeader(DEFAULT_MARGIN_HEADER);\n        ctMargins.setLeft(DEFAULT_MARGIN_LEFT);\n        ctMargins.setRight(DEFAULT_MARGIN_RIGHT);\n        ctMargins.setTop(DEFAULT_MARGIN_TOP);\n\n        return worksheet;\n    }
228	public byte[] read(final byte[] src, final int offset) {\n        \n        bytes[0] = src[3 + offset];\n        bytes[1] = src[2 + offset];\n        bytes[2] = src[1 + offset];\n        bytes[3] = src[0 + offset];\n\n        \n        bytes[4] = src[5 + offset];\n        bytes[5] = src[4 + offset];\n\n        \n        bytes[6] = src[7 + offset];\n        bytes[7] = src[6 + offset];\n\n        \n        System.arraycopy(src, 8 + offset, bytes, 8, 8);\n\n        return bytes;\n    }
229	public static double product(double[] values) {\n        double product = 0;\n        if (values!=null && values.length > 0) {\n            product = 1;\n            for (int i=0, iSize=values.length; i<iSize; i++) {\n                product *= values[i];\n            }\n        }\n        return product;\n    }
230	public boolean equalsContents(final Object o) {\n        final CustomProperty c = (CustomProperty) o;\n        final String name1 = c.getName();\n        final String name2 = this.getName();\n        boolean equalNames = true;\n        if (name1 == null) {\n            equalNames = name2 == null;\n        } else {\n            equalNames = name1.equals(name2);\n        }\n        return equalNames && c.getID() == this.getID()\n                && c.getType() == this.getType()\n                && c.getValue().equals(this.getValue());\n    }
231	public void extractMessageBody(File dest) throws IOException {\n        MAPIAttribute body = getBodyAttribute();\n        if (body == null) {\n            System.err.println("No message body found, " + dest + " not created");\n            return;\n        }\n        if (body instanceof MAPIStringAttribute) {\n            String name = dest.toString();\n            if (name.endsWith(".rtf")) { \n                name = name.substring(0, name.length()-4);\n            }\n            dest = new File(name + ".txt");\n        }\n        \n        OutputStream fout = new FileOutputStream(dest);\n        try {\n            if (body instanceof MAPIStringAttribute) {\n                                String text = ((MAPIStringAttribute)body).getDataString();\n                fout.write(text.getBytes(StringUtil.UTF8));\n            } else {\n                                fout.write(body.getData());\n            }\n        } finally {\n            fout.close();\n        }\n    }
232	protected <T extends TextProp> T getPropVal(TextPropCollection props, String propName) {\n        String propNames[] = propName.split(",");\n        for (String pn : propNames) {\n            T prop = props.findByName(pn);\n            if (isValidProp(prop)) {\n                return prop;\n            }\n        }\n\n        return getMasterPropVal(props, propName);\n    }
233	public BigInteger addAbstractNum(XWPFAbstractNum abstractNum) {\n        int pos = abstractNums.size();\n        if (abstractNum.getAbstractNum() != null) {             ctNumbering.addNewAbstractNum().set(abstractNum.getAbstractNum());\n        } else {\n            ctNumbering.addNewAbstractNum();\n            abstractNum.getAbstractNum().setAbstractNumId(BigInteger.valueOf(pos));\n            ctNumbering.setAbstractNumArray(pos, abstractNum.getAbstractNum());\n        }\n        abstractNums.add(abstractNum);\n        return abstractNum.getCTAbstractNum().getAbstractNumId();\n    }
234	private void write() {\n        int pos = 0;\n        _data = IOUtils.safelyAllocate(indents.size()*6, MAX_RECORD_LENGTH);\n        for (IndentProp prop : indents) {\n            LittleEndian.putInt(_data, pos, prop.getCharactersCovered());\n            LittleEndian.putShort(_data, pos+4, (short)prop.getIndentLevel());\n            pos += 6;\n        }\n    }
235	public void addChildBefore(EscherRecord record, int insertBeforeRecordId) {\n        int idx = 0;\n        for (EscherRecord rec : this) {\n            if(rec.getRecordId() == (short)insertBeforeRecordId) {\n                break;\n            }\n                        idx++;\n        }\n        _childRecords.add(idx, record);\n    }
236	public Borders getBorderBottom() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getBottom();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
237	private static Record createRecord(RecordInputStream in) {\n        switch (in.getSid()) {\n            case AreaFormatRecord.sid:        return new AreaFormatRecord(in);\n            case AreaRecord.sid:              return new AreaRecord(in);\n            case ArrayRecord.sid:             return new ArrayRecord(in);\n            case AxisLineFormatRecord.sid:    return new AxisLineFormatRecord(in);\n            case AxisOptionsRecord.sid:       return new AxisOptionsRecord(in);\n            case AxisParentRecord.sid:        return new AxisParentRecord(in);\n            case AxisRecord.sid:              return new AxisRecord(in);\n            case AxisUsedRecord.sid:          return new AxisUsedRecord(in);\n            case AutoFilterInfoRecord.sid:    return new AutoFilterInfoRecord(in);\n            case BOFRecord.sid:               return new BOFRecord(in);\n            case BackupRecord.sid:            return new BackupRecord(in);\n            case BarRecord.sid:               return new BarRecord(in);\n            case BeginRecord.sid:             return new BeginRecord(in);\n            case BlankRecord.sid:             return new BlankRecord(in);\n            case BookBoolRecord.sid:          return new BookBoolRecord(in);\n            case BoolErrRecord.sid:           return new BoolErrRecord(in);\n            case BottomMarginRecord.sid:      return new BottomMarginRecord(in);\n            case BoundSheetRecord.sid:        return new BoundSheetRecord(in);\n            case CFHeaderRecord.sid:          return new CFHeaderRecord(in);\n            case CFHeader12Record.sid:        return new CFHeader12Record(in);\n            case CFRuleRecord.sid:            return new CFRuleRecord(in);\n            case CFRule12Record.sid:          return new CFRule12Record(in);\n                        case CalcCountRecord.sid:         return new CalcCountRecord(in);\n            case CalcModeRecord.sid:          return new CalcModeRecord(in);\n            case CategorySeriesAxisRecord.sid:return new CategorySeriesAxisRecord(in);\n            case ChartFormatRecord.sid:       return new ChartFormatRecord(in);\n            case ChartRecord.sid:             return new ChartRecord(in);\n            case CodepageRecord.sid:          return new CodepageRecord(in);\n            case ColumnInfoRecord.sid:        return new ColumnInfoRecord(in);\n            case ContinueRecord.sid:          return new ContinueRecord(in);\n            case CountryRecord.sid:           return new CountryRecord(in);\n            case DBCellRecord.sid:            return new DBCellRecord(in);\n            case DSFRecord.sid:               return new DSFRecord(in);\n            case DatRecord.sid:               return new DatRecord(in);\n            case DataFormatRecord.sid:        return new DataFormatRecord(in);\n            case DateWindow1904Record.sid:    return new DateWindow1904Record(in);\n            case DConRefRecord.sid:           return new DConRefRecord(in);\n            case DefaultColWidthRecord.sid:   return new DefaultColWidthRecord(in);\n            case DefaultDataLabelTextPropertiesRecord.sid: return new DefaultDataLabelTextPropertiesRecord(in);\n            case DefaultRowHeightRecord.sid:  return new DefaultRowHeightRecord(in);\n            case DeltaRecord.sid:             return new DeltaRecord(in);\n            case DimensionsRecord.sid:        return new DimensionsRecord(in);\n            case DrawingGroupRecord.sid:      return new DrawingGroupRecord(in);\n            case DrawingRecordForBiffViewer.sid: return new DrawingRecordForBiffViewer(in);\n            case DrawingSelectionRecord.sid:  return new DrawingSelectionRecord(in);\n            case DVRecord.sid:                return new DVRecord(in);\n            case DVALRecord.sid:              return new DVALRecord(in);\n            case EOFRecord.sid:               return new EOFRecord(in);\n            case EndRecord.sid:               return new EndRecord(in);\n            case ExtSSTRecord.sid:            return new ExtSSTRecord(in);\n            case ExtendedFormatRecord.sid:    return new ExtendedFormatRecord(in);\n            case ExternSheetRecord.sid:       return new ExternSheetRecord(in);\n            case ExternalNameRecord.sid:      return new ExternalNameRecord(in);\n            case FeatRecord.sid:              return new FeatRecord(in);\n            case FeatHdrRecord.sid:           return new FeatHdrRecord(in);\n            case FilePassRecord.sid:          return new FilePassRecord(in);\n            case FileSharingRecord.sid:       return new FileSharingRecord(in);\n            case FnGroupCountRecord.sid:      return new FnGroupCountRecord(in);\n            case FontBasisRecord.sid:         return new FontBasisRecord(in);\n            case FontIndexRecord.sid:         return new FontIndexRecord(in);\n            case FontRecord.sid:              return new FontRecord(in);\n            case FooterRecord.sid:            return new FooterRecord(in);\n            case FormatRecord.sid:            return new FormatRecord(in);\n            case FormulaRecord.sid:           return new FormulaRecord(in);\n            case FrameRecord.sid:             return new FrameRecord(in);\n            case GridsetRecord.sid:           return new GridsetRecord(in);\n            case GutsRecord.sid:              return new GutsRecord(in);\n            case HCenterRecord.sid:           return new HCenterRecord(in);\n            case HeaderRecord.sid:            return new HeaderRecord(in);\n            case HideObjRecord.sid:           return new HideObjRecord(in);\n            case HorizontalPageBreakRecord.sid: return new HorizontalPageBreakRecord(in);\n            case HyperlinkRecord.sid:         return new HyperlinkRecord(in);\n            case IndexRecord.sid:             return new IndexRecord(in);\n            case InterfaceEndRecord.sid:      return InterfaceEndRecord.create(in);\n            case InterfaceHdrRecord.sid:      return new InterfaceHdrRecord(in);\n            case IterationRecord.sid:         return new IterationRecord(in);\n            case LabelRecord.sid:             return new LabelRecord(in);\n            case LabelSSTRecord.sid:          return new LabelSSTRecord(in);\n            case LeftMarginRecord.sid:        return new LeftMarginRecord(in);\n            case LegendRecord.sid:            return new LegendRecord(in);\n            case LineFormatRecord.sid:        return new LineFormatRecord(in);\n            case LinkedDataRecord.sid:        return new LinkedDataRecord(in);\n            case MMSRecord.sid:               return new MMSRecord(in);\n            case MergeCellsRecord.sid:        return new MergeCellsRecord(in);\n            case MulBlankRecord.sid:          return new MulBlankRecord(in);\n            case MulRKRecord.sid:             return new MulRKRecord(in);\n            case NameRecord.sid:              return new NameRecord(in);\n            case NameCommentRecord.sid:       return new NameCommentRecord(in);\n            case NoteRecord.sid:              return new NoteRecord(in);\n            case NumberRecord.sid:            return new NumberRecord(in);\n            case ObjRecord.sid:               return new ObjRecord(in);\n            case ObjectLinkRecord.sid:        return new ObjectLinkRecord(in);\n            case PaletteRecord.sid:           return new PaletteRecord(in);\n            case PaneRecord.sid:              return new PaneRecord(in);\n            case PasswordRecord.sid:          return new PasswordRecord(in);\n            case PasswordRev4Record.sid:      return new PasswordRev4Record(in);\n            case PlotAreaRecord.sid:          return new PlotAreaRecord(in);\n            case PlotGrowthRecord.sid:        return new PlotGrowthRecord(in);\n            case PrecisionRecord.sid:         return new PrecisionRecord(in);\n            case PrintGridlinesRecord.sid:    return new PrintGridlinesRecord(in);\n            case PrintHeadersRecord.sid:      return new PrintHeadersRecord(in);\n            case PrintSetupRecord.sid:        return new PrintSetupRecord(in);\n            case ProtectRecord.sid:           return new ProtectRecord(in);\n            case ProtectionRev4Record.sid:    return new ProtectionRev4Record(in);\n            case RKRecord.sid:                return new RKRecord(in);\n            case RecalcIdRecord.sid:          return new RecalcIdRecord(in);\n            case RefModeRecord.sid:           return new RefModeRecord(in);\n            case RefreshAllRecord.sid:        return new RefreshAllRecord(in);\n            case RightMarginRecord.sid:       return new RightMarginRecord(in);\n            case RowRecord.sid:               return new RowRecord(in);\n            case SCLRecord.sid:               return new SCLRecord(in);\n            case SSTRecord.sid:               return new SSTRecord(in);\n            case SaveRecalcRecord.sid:        return new SaveRecalcRecord(in);\n            case SelectionRecord.sid:         return new SelectionRecord(in);\n            case SeriesIndexRecord.sid:       return new SeriesIndexRecord(in);\n            case SeriesListRecord.sid:        return new SeriesListRecord(in);\n            case SeriesRecord.sid:            return new SeriesRecord(in);\n            case SeriesTextRecord.sid:        return new SeriesTextRecord(in);\n            case SeriesToChartGroupRecord.sid:return new SeriesToChartGroupRecord(in);\n            case SharedFormulaRecord.sid:     return new SharedFormulaRecord(in);\n            case SheetPropertiesRecord.sid:   return new SheetPropertiesRecord(in);\n            case StringRecord.sid:            return new StringRecord(in);\n            case StyleRecord.sid:             return new StyleRecord(in);\n            case SupBookRecord.sid:           return new SupBookRecord(in);\n            case TabIdRecord.sid:             return new TabIdRecord(in);\n            case TableStylesRecord.sid:       return new TableStylesRecord(in);\n            case TableRecord.sid:             return new TableRecord(in);\n            case TextObjectRecord.sid:        return new TextObjectRecord(in);\n            case TextRecord.sid:              return new TextRecord(in);\n            case TickRecord.sid:              return new TickRecord(in);\n            case TopMarginRecord.sid:         return new TopMarginRecord(in);\n            case UncalcedRecord.sid:          return new UncalcedRecord(in);\n            case UnitsRecord.sid:             return new UnitsRecord(in);\n            case UseSelFSRecord.sid:          return new UseSelFSRecord(in);\n            case VCenterRecord.sid:           return new VCenterRecord(in);\n            case ValueRangeRecord.sid:        return new ValueRangeRecord(in);\n            case VerticalPageBreakRecord.sid: return new VerticalPageBreakRecord(in);\n            case WSBoolRecord.sid:            return new WSBoolRecord(in);\n            case WindowOneRecord.sid:         return new WindowOneRecord(in);\n            case WindowProtectRecord.sid:     return new WindowProtectRecord(in);\n            case WindowTwoRecord.sid:         return new WindowTwoRecord(in);\n            case WriteAccessRecord.sid:       return new WriteAccessRecord(in);\n            case WriteProtectRecord.sid:      return new WriteProtectRecord(in);\n\n                        case CatLabRecord.sid:            return new CatLabRecord(in);\n            case ChartEndBlockRecord.sid:     return new ChartEndBlockRecord(in);\n            case ChartEndObjectRecord.sid:    return new ChartEndObjectRecord(in);\n            case ChartFRTInfoRecord.sid:      return new ChartFRTInfoRecord(in);\n            case ChartStartBlockRecord.sid:   return new ChartStartBlockRecord(in);\n            case ChartStartObjectRecord.sid:  return new ChartStartObjectRecord(in);\n\n                        case StreamIDRecord.sid:           return new StreamIDRecord(in);\n            case ViewSourceRecord.sid:         return new ViewSourceRecord(in);\n            case PageItemRecord.sid:           return new PageItemRecord(in);\n            case ViewDefinitionRecord.sid:     return new ViewDefinitionRecord(in);\n            case ViewFieldsRecord.sid:         return new ViewFieldsRecord(in);\n            case DataItemRecord.sid:           return new DataItemRecord(in);\n            case ExtendedPivotTableViewFieldsRecord.sid: return new ExtendedPivotTableViewFieldsRecord(in);\n        }\n        return new UnknownRecord(in);\n    }
238	public void createSplitPane(int xSplitPos, int ySplitPos, int topRow, int leftmostColumn, int activePane) {\n        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n        if (paneLoc != -1)\n            _records.remove(paneLoc);\n\n        int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n        PaneRecord r = new PaneRecord();\n        r.setX((short)xSplitPos);\n        r.setY((short)ySplitPos);\n        r.setTopRow((short) topRow);\n        r.setLeftColumn((short) leftmostColumn);\n        r.setActivePane((short) activePane);\n        _records.add(loc+1, r);\n\n        windowTwo.setFreezePanes(false);\n        windowTwo.setFreezePanesNoSplit(false);\n\n        SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n        if (sel != null) {\n            sel.setPane(PANE_LOWER_RIGHT);\n        }\n\n    }
239	public void writeOut(OutputStream out) throws IOException {\n                \n        @SuppressWarnings("resource")\n        LittleEndianOutputStream leosOut = new LittleEndianOutputStream(out);\n        \n        switch (mode) {\n        case parsed: {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            LittleEndianOutputStream leos = new LittleEndianOutputStream(bos);\n            \n            leos.writeShort(getFlags1());\n            leos.write(getLabel().getBytes(ISO1));\n            leos.write(0);\n            leos.write(getFileName().getBytes(ISO1));\n            leos.write(0);\n            leos.writeShort(getFlags2());\n            leos.writeShort(getUnknown1());\n            leos.writeInt(getCommand().length() + 1);\n            leos.write(getCommand().getBytes(ISO1));\n            leos.write(0);\n            leos.writeInt(getDataSize());\n            leos.write(getDataBuffer());\n            leos.writeShort(getFlags3());\n            leos.close();             \n            leosOut.writeInt(bos.size());             bos.writeTo(out);\n            break;\n        }\n        case compact:\n            leosOut.writeInt(getDataSize()+LittleEndianConsts.SHORT_SIZE);\n            leosOut.writeShort(getFlags1());\n            out.write(getDataBuffer());\n            break;\n        default:\n        case unparsed:\n            leosOut.writeInt(getDataSize());\n            out.write(getDataBuffer());\n            break;\n        }\n\n    }
240	public void addValueRecord(int row, CellValueRecordInterface col) {\n\n        if(log.check(POILogger.DEBUG)) {\n          log.log(POILogger.DEBUG, "add value record  row" + row);\n        }\n        DimensionsRecord d = _dimensions;\n\n        if (col.getColumn() >= d.getLastCol()) {\n            d.setLastCol(( short ) (col.getColumn() + 1));\n        }\n        if (col.getColumn() < d.getFirstCol()) {\n            d.setFirstCol(col.getColumn());\n        }\n        _rowsAggregate.insertCell(col);\n    }
241	public HSSFColor findColor(byte red, byte green, byte blue)\n    {\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;\n            b = _palette.getColor(++i))\n        {\n            if (b[0] == red && b[1] == green && b[2] == blue)\n            {\n                return new CustomColor(i, b);\n            }\n        }\n        return null;\n    }
242	public XSSFSheet cloneSheet(int sheetNum, String newName) {\n        validateSheetIndex(sheetNum);\n        XSSFSheet srcSheet = sheets.get(sheetNum);\n\n        if (newName == null) {\n            String srcName = srcSheet.getSheetName();\n            newName = getUniqueSheetName(srcName);\n        } else {\n            validateSheetName(newName);\n        }\n\n        XSSFSheet clonedSheet = createSheet(newName);\n\n                List<RelationPart> rels = srcSheet.getRelationParts();\n                XSSFDrawing dg = null;\n        for(RelationPart rp : rels) {\n            POIXMLDocumentPart r = rp.getDocumentPart();\n                        if(r instanceof XSSFDrawing) {\n                dg = (XSSFDrawing)r;\n                continue;\n            }\n\n            addRelation(rp, clonedSheet);\n        }\n\n        try {\n            for(PackageRelationship pr : srcSheet.getPackagePart().getRelationships()) {\n                if (pr.getTargetMode() == TargetMode.EXTERNAL) {\n                    clonedSheet.getPackagePart().addExternalRelationship\n                            (pr.getTargetURI().toASCIIString(), pr.getRelationshipType(), pr.getId());\n                }\n            }\n        } catch (InvalidFormatException e) {\n            throw new POIXMLException("Failed to clone sheet", e);\n        }\n\n\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n            srcSheet.write(out);\n            try (ByteArrayInputStream bis = new ByteArrayInputStream(out.toByteArray())) {\n                clonedSheet.read(bis);\n            }\n        } catch (IOException e){\n            throw new POIXMLException("Failed to clone sheet", e);\n        }\n        CTWorksheet ct = clonedSheet.getCTWorksheet();\n        if(ct.isSetLegacyDrawing()) {\n            logger.log(POILogger.WARN, "Cloning sheets with comments is not yet supported.");\n            ct.unsetLegacyDrawing();\n        }\n        if (ct.isSetPageSetup()) {\n            logger.log(POILogger.WARN, "Cloning sheets with page setup is not yet supported.");\n            ct.unsetPageSetup();\n        }\n\n        clonedSheet.setSelected(false);\n\n                if (dg != null) {\n            if(ct.isSetDrawing()) {\n                                                ct.unsetDrawing();\n            }\n            XSSFDrawing clonedDg = clonedSheet.createDrawingPatriarch();\n                        clonedDg.getCTDrawing().set(dg.getCTDrawing());\n\n            clonedDg = clonedSheet.createDrawingPatriarch();\n\n                        List<RelationPart> srcRels = srcSheet.createDrawingPatriarch().getRelationParts();\n            for (RelationPart rp : srcRels) {\n                addRelation(rp, clonedDg);\n            }\n        }\n        return clonedSheet;\n    }
243	@SuppressWarnings("unchecked")\n    public DOMSignedInfo preSign(final DOMSignContext xmlSignContext)\n    throws XMLSignatureException, MarshalException {\n        signatureConfig.init(false);\n\n        final Document document = (Document)xmlSignContext.getParent();\n\n                        EventTarget target = (EventTarget)document;\n        EventListener creationListener = signatureConfig.getSignatureMarshalListener();\n        if (creationListener != null) {\n            if (creationListener instanceof SignatureMarshalListener) {\n                ((SignatureMarshalListener)creationListener).setEventTarget(target);\n            }\n            SignatureMarshalListener.setListener(target, creationListener, true);\n        }\n\n        \n        URIDereferencer uriDereferencer = signatureConfig.getUriDereferencer();\n        if (null != uriDereferencer) {\n            xmlSignContext.setURIDereferencer(uriDereferencer);\n        }\n\n        for (Map.Entry<String,String> me : signatureConfig.getNamespacePrefixes().entrySet()) {\n            xmlSignContext.putNamespacePrefix(me.getKey(), me.getValue());\n        }\n        xmlSignContext.setDefaultNamespacePrefix("");\n        \n        XMLSignatureFactory signatureFactory = signatureConfig.getSignatureFactory();\n\n        \n        List<Reference> references = new ArrayList<>();\n\n        \n        List<XMLObject> objects = new ArrayList<>();\n        for (SignatureFacet signatureFacet : signatureConfig.getSignatureFacets()) {\n            LOG.log(POILogger.DEBUG, "invoking signature facet: " + signatureFacet.getClass().getSimpleName());\n            signatureFacet.preSign(document, references, objects);\n        }\n\n        \n        SignedInfo signedInfo;\n        try {\n            SignatureMethod signatureMethod = signatureFactory.newSignatureMethod\n                (signatureConfig.getSignatureMethodUri(), null);\n            CanonicalizationMethod canonicalizationMethod = signatureFactory\n                .newCanonicalizationMethod(signatureConfig.getCanonicalizationMethod(),\n                (C14NMethodParameterSpec) null);\n            signedInfo = signatureFactory.newSignedInfo(\n                canonicalizationMethod, signatureMethod, references);\n        } catch (GeneralSecurityException e) {\n            throw new XMLSignatureException(e);\n        }\n\n        \n        String signatureValueId = signatureConfig.getPackageSignatureId() + "-signature-value";\n        javax.xml.crypto.dsig.XMLSignature xmlSignature = signatureFactory\n            .newXMLSignature(signedInfo, null, objects, signatureConfig.getPackageSignatureId(),\n            signatureValueId);\n\n        \n        xmlSignature.sign(xmlSignContext);\n\n        \n        for (XMLObject object : objects) {\n            LOG.log(POILogger.DEBUG, "object java type: " + object.getClass().getName());\n            List<XMLStructure> objectContentList = object.getContent();\n            for (XMLStructure objectContent : objectContentList) {\n                LOG.log(POILogger.DEBUG, "object content java type: " + objectContent.getClass().getName());\n                if (!(objectContent instanceof Manifest)) {\n                    continue;\n                }\n                Manifest manifest = (Manifest) objectContent;\n                List<Reference> manifestReferences = manifest.getReferences();\n                for (Reference manifestReference : manifestReferences) {\n                    if (manifestReference.getDigestValue() != null) {\n                        continue;\n                    }\n\n                    DOMReference manifestDOMReference = (DOMReference)manifestReference;\n                    manifestDOMReference.digest(xmlSignContext);\n                }\n            }\n        }\n\n        \n        List<Reference> signedInfoReferences = signedInfo.getReferences();\n        for (Reference signedInfoReference : signedInfoReferences) {\n            DOMReference domReference = (DOMReference)signedInfoReference;\n\n                        if (domReference.getDigestValue() != null) {\n                continue;\n            }\n\n            domReference.digest(xmlSignContext);\n        }\n\n        return (DOMSignedInfo)signedInfo;\n    }
244	private void outputCompressed(OutputStream res) throws IOException {\n				if(rawCodeLen < 3) {\n		for(int i=0; i<rawCodeLen; i++) {\n			outputUncompressed(rawCode[i], res);\n		}\n		return;\n	}\n	\n		int codesAt = findRawCodeInBuffer();\n   codesAt -= 18;\n	if(codesAt < 0) {\n	   codesAt += 4096;\n	}\n\n		maskBitsSet++;\n	\n				int bp1 = (codesAt & 255);\n	int bp2 = (rawCodeLen-3) + ((codesAt-bp1) >> 4);\n	buffer[bufferLen] = HDGFLZW.fromInt(bp1);\n	bufferLen++;\n   buffer[bufferLen] = HDGFLZW.fromInt(bp2);\n   bufferLen++;\n   \n      for(int i=0; i<rawCodeLen; i++) {\n      dict[(posOut&4095)] = rawCode[i];\n      posOut++; \n   }\n\n		if(maskBitsSet == 8) {\n		output8Codes(res);\n	}\n}
245	private void init() {\n						\n	    isEncrypted = (LittleEndian.getInt(encHeaderToken) == LittleEndian.getInt(_contents,12)); \n	    \n				currentEditOffset = LittleEndian.getUInt(_contents,16);\n\n				docFinalVersion = LittleEndian.getUShort(_contents,22);\n		docMajorNo = _contents[24];\n		docMinorNo = _contents[25];\n\n				long usernameLen = LittleEndian.getUShort(_contents,20);\n		if(usernameLen > 512) {\n						logger.log(POILogger.WARN, "Warning - invalid username length " + usernameLen + " found, treating as if there was no username set");\n			usernameLen = 0;\n		}\n\n						if(_contents.length >= 28+(int)usernameLen + 4) {\n			releaseVersion = LittleEndian.getUInt(_contents,28+(int)usernameLen);\n		} else {\n						releaseVersion = 0;\n		}\n\n				int start = 28+(int)usernameLen+4;\n		int len = 2*(int)usernameLen;\n\n		if(_contents.length >= start+len) {\n			byte[] textBytes = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n			System.arraycopy(_contents,start,textBytes,0,len);\n			lastEditUser = StringUtil.getFromUnicodeLE(textBytes);\n		} else {\n						byte[] textBytes = IOUtils.safelyAllocate(usernameLen, MAX_RECORD_LENGTH);\n			System.arraycopy(_contents,28,textBytes,0,(int)usernameLen);\n			lastEditUser = StringUtil.getFromCompressedUnicode(textBytes,0,(int)usernameLen);\n		}\n	}
246	private static int unpaddedLength(byte[] buf) {\n        final int end = (buf.length-(buf.length+3)%4);\n        for (int i = buf.length; i>end; i--) {\n            if (buf[i-1] != 0) {\n                return i;\n            }\n        }\n        return end;\n    }
247	public static PropertySet create(final DirectoryEntry dir, final String name)\n    throws FileNotFoundException, NoPropertySetStreamException, IOException, UnsupportedEncodingException {\n        InputStream inp = null;\n        try {\n            DocumentEntry entry = (DocumentEntry)dir.getEntry(name);\n            inp = new DocumentInputStream(entry);\n            try {\n                return create(inp);\n            } catch (MarkUnsupportedException e) {\n                return null;\n            }\n        } finally {\n            if (inp != null) {\n                inp.close();\n            }\n        }\n    }
248	protected EmbeddedObjectRefSubRecord findObjectRecord() {\n        Iterator<SubRecord> subRecordIter = getObjRecord().getSubRecords().iterator();\n\n        while (subRecordIter.hasNext()) {\n            Object subRecord = subRecordIter.next();\n            if (subRecord instanceof EmbeddedObjectRefSubRecord) {\n                return (EmbeddedObjectRefSubRecord) subRecord;\n            }\n        }\n\n        throw new IllegalStateException("Object data does not contain a reference to an embedded object OLE2 directory");\n    }
249	private int writeDataIntoDrawingRecord(byte[] drawingData, int writtenEscherBytes, int pos, byte[] data, int i) {\n        int temp = 0;\n                if (writtenEscherBytes + drawingData.length > RecordInputStream.MAX_RECORD_DATA_SIZE && i != 1) {\n            for (int j = 0; j < drawingData.length; j += RecordInputStream.MAX_RECORD_DATA_SIZE) {\n                byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];\n                System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));\n                ContinueRecord drawing = new ContinueRecord(buf);\n                temp += drawing.serialize(pos + temp, data);\n            }\n        } else {\n            for (int j = 0; j < drawingData.length; j += RecordInputStream.MAX_RECORD_DATA_SIZE) {\n                if (j == 0) {\n                    DrawingRecord drawing = new DrawingRecord();\n                    byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];\n                    System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));\n                    drawing.setData(buf);\n                    temp += drawing.serialize(pos + temp, data);\n                } else {\n                    byte[] buf = new byte[Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j)];\n                    System.arraycopy(drawingData, j, buf, 0, Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE, drawingData.length - j));\n                    ContinueRecord drawing = new ContinueRecord(buf);\n                    temp += drawing.serialize(pos + temp, data);\n                }\n            }\n        }\n        return temp;\n    }
250	public static <\n        S extends Shape<S,P>,\n        P extends TextParagraph<S,P,? extends TextRun>\n    > SlideShow<S,P> create(final DirectoryNode root, String password) throws IOException {\n                if (root.hasEntry(Decryptor.DEFAULT_POIFS_ENTRY)) {\n            InputStream stream = null;\n            try {\n                stream = DocumentFactoryHelper.getDecryptedStream(root, password);\n\n                return createXSLFSlideShow(stream);\n            } finally {\n                IOUtils.closeQuietly(stream);\n\n                                                root.getFileSystem().close();\n            }\n        }\n\n                        boolean passwordSet = false;\n        if (password != null) {\n            Biff8EncryptionKey.setCurrentUserPassword(password);\n            passwordSet = true;\n        }\n        try {\n            return createHSLFSlideShow(root);\n        } finally {\n            if (passwordSet) {\n                Biff8EncryptionKey.setCurrentUserPassword(null);\n            }\n        }\n    }
251	public static BATBlock createBATBlock(final POIFSBigBlockSize bigBlockSize, ByteBuffer data)\n    {\n              BATBlock block = new BATBlock(bigBlockSize);\n       \n              byte[] buffer = new byte[LittleEndian.INT_SIZE];\n       for(int i=0; i<block._values.length; i++) {\n          data.get(buffer);\n          block._values[i] = LittleEndian.getInt(buffer);\n       }\n       block.recomputeFree();\n       \n              return block;\n    }
252	public void setParentTextSize(int size) {\n        if (initialised) {\n            return;\n        }\n        \n        int pos = 0;\n        int textHandled = 0;\n\n        paragraphStyles.clear();\n        charStyles.clear();\n        \n                        int prsize = size;\n        while(pos < rawContents.length && textHandled < prsize) {\n                        int textLen = LittleEndian.getInt(rawContents,pos);\n            textLen = checkTextLength(textLen, textHandled, size);\n            textHandled += textLen;\n            pos += 4;\n\n            short indent = LittleEndian.getShort(rawContents,pos);\n            pos += 2;\n\n                        int paraFlags = LittleEndian.getInt(rawContents,pos);\n            pos += 4;\n\n                        TextPropCollection thisCollection = new TextPropCollection(textLen, TextPropType.paragraph);\n            thisCollection.setIndentLevel(indent);\n            int plSize = thisCollection.buildTextPropList(paraFlags, rawContents, pos);\n            pos += plSize;\n\n                        paragraphStyles.add(thisCollection);\n\n                        if(pos < rawContents.length && textHandled == size) {\n                prsize++;\n            }\n\n        }\n        if (rawContents.length > 0 && textHandled != (size+1)){\n            logger.log(POILogger.WARN, "Problem reading paragraph style runs: textHandled = " + textHandled + ", text.size+1 = " + (size+1));\n        }\n\n                textHandled = 0;\n        int chsize = size;\n        while(pos < rawContents.length && textHandled < chsize) {\n                        int textLen = LittleEndian.getInt(rawContents,pos);\n            textLen = checkTextLength(textLen, textHandled, size);\n            textHandled += textLen;\n            pos += 4;\n\n                        int charFlags = LittleEndian.getInt(rawContents,pos);\n            pos += 4;\n\n                                    TextPropCollection thisCollection = new TextPropCollection(textLen, TextPropType.character);\n            int chSize = thisCollection.buildTextPropList(charFlags, rawContents, pos);\n            pos += chSize;\n\n                        charStyles.add(thisCollection);\n\n                        if(pos < rawContents.length && textHandled == size) {\n                chsize++;\n            }\n        }\n        if (rawContents.length > 0 && textHandled != (size+1)){\n            logger.log(POILogger.WARN, "Problem reading character style runs: textHandled = " + textHandled + ", text.size+1 = " + (size+1));\n        }\n\n                if(pos < rawContents.length) {\n            reserved = IOUtils.safelyAllocate(rawContents.length-pos, rawContents.length);\n            System.arraycopy(rawContents,pos,reserved,0,reserved.length);\n        }\n\n        initialised = true;\n    }
253	private static int findDataValidationTableInsertPos(List<RecordBase> records) {\n		int i = records.size() - 1;\n		if (!(records.get(i) instanceof EOFRecord)) {\n			throw new IllegalStateException("Last sheet record should be EOFRecord");\n		}\n		while (i > 0) {\n			i--;\n			RecordBase rb = records.get(i);\n			if (isDVTPriorRecord(rb)) {\n				Record nextRec = (Record) records.get(i + 1);\n				if (!isDVTSubsequentRecord(nextRec.getSid())) {\n					throw new IllegalStateException("Unexpected (" + nextRec.getClass().getName()\n							+ ") found after (" + rb.getClass().getName() + ")");\n				}\n				return i+1;\n			}\n			Record rec = (Record) rb;\n			if (!isDVTSubsequentRecord(rec.getSid())) {\n				throw new IllegalStateException("Unexpected (" + rec.getClass().getName()\n						+ ") while looking for DV Table insert pos");\n			}\n		}\n		return 0;\n	}
254	public static ChunkHeader createChunkHeader(int documentVersion, byte[] data, int offset) {\n		if(documentVersion >= 6) {\n			ChunkHeaderV6 ch;\n			if(documentVersion > 6) {\n				ch = new ChunkHeaderV11();\n			} else {\n				ch = new ChunkHeaderV6();\n			}\n			ch.setType((int)LittleEndian.getUInt(data, offset + 0));\n			ch.setId((int)LittleEndian.getUInt(data, offset + 4));\n			ch.setUnknown1((int)LittleEndian.getUInt(data, offset + 8));\n			ch.setLength((int)LittleEndian.getUInt(data, offset + 12));\n			ch.setUnknown2(LittleEndian.getShort(data, offset + 16));\n			ch.setUnknown3(LittleEndian.getUByte(data, offset + 18));\n\n			return ch;\n		} else if(documentVersion == 5 || documentVersion == 4) {\n			ChunkHeaderV4V5 ch = new ChunkHeaderV4V5();\n\n			ch.setType(LittleEndian.getShort(data, offset + 0));\n			ch.setId(LittleEndian.getShort(data, offset + 2));\n			ch.setUnknown2(LittleEndian.getUByte(data, offset + 4));\n			ch.setUnknown3(LittleEndian.getUByte(data, offset + 5));\n			ch.setUnknown1(LittleEndian.getShort(data, offset + 6));\n			ch.setLength((int)LittleEndian.getUInt(data, offset + 8));\n\n			return ch;\n		} else {\n			throw new IllegalArgumentException("Visio files with versions below 4 are not supported, yours was " + documentVersion);\n		}\n	}
255	static int getCopyLenBits(int offset) {\n        for (int n = 11; n >= 4; n--) {\n            if ((offset & POWER2[n]) != 0) {\n                return 15 - n;\n            }\n        }\n        return 12;\n    }
256	private int findChildLocation(Record child) {\n	    int i=0;\n		for(Record r : _children) {\n			if (r.equals(child)) {\n				return i;\n			}\n			i++;\n		}\n		return -1;\n	}
257	public XDDFTextRun appendLineBreak() {\n        CTTextLineBreak br = _p.addNewBr();\n                for (XDDFTextRun tr : new IteratorIterable<>(new ReverseListIterator<>(_runs))) {\n            CTTextCharacterProperties prevProps = tr.getProperties();\n                        if (prevProps != null) {\n                br.setRPr((CTTextCharacterProperties) prevProps.copy());\n                break;\n            }\n        }\n        XDDFTextRun run = new XDDFTextRun(br, this);\n        _runs.add(run);\n        return run;\n    }
258	public ASN1ObjectIdentifier mapDigestAlgoToOID(HashAlgorithm digestAlgo) {\n        switch (digestAlgo) {\n        case sha1:   return X509ObjectIdentifiers.id_SHA1;\n        case sha256: return NISTObjectIdentifiers.id_sha256;\n        case sha384: return NISTObjectIdentifiers.id_sha384;\n        case sha512: return NISTObjectIdentifiers.id_sha512;\n        default:\n            throw new IllegalArgumentException("unsupported digest algo: " + digestAlgo);\n        }\n    }
259	public XWPFFooter createFooter(HeaderFooterType type) {\n        XWPFHeaderFooterPolicy hfPolicy = createHeaderFooterPolicy();\n                if (type == HeaderFooterType.FIRST) {\n            CTSectPr ctSectPr = getSection();\n            if (!ctSectPr.isSetTitlePg()) {\n                CTOnOff titlePg = ctSectPr.addNewTitlePg();\n                titlePg.setVal(STOnOff.ON);\n            }\n                                }\n        return hfPolicy.createFooter(STHdrFtr.Enum.forInt(type.toInt()));\n    }
260	private int calculateNewFirstCell(int firstcell) {\n        int cellIx = firstcell + 1;\n        HSSFCell r = retrieveCell(cellIx);\n\n        while (r == null) {\n            if (cellIx <= cells.length) {\n                return 0;\n            }\n            r = retrieveCell(++cellIx);\n        }\n        return cellIx;\n    }
261	private ParseNode parseRangeable() {\n        SkipWhite();\n        int savePointer = _pointer;\n        SheetIdentifier sheetIden = parseSheetName();\n        \n        if (sheetIden == null) {\n            resetPointer(savePointer);\n        } else {\n            SkipWhite();\n            savePointer = _pointer;\n        }\n\n        SimpleRangePart part1 = parseSimpleRangePart();\n        if (part1 == null) {\n            if (sheetIden != null) {\n                if(look == '#'){                      return new ParseNode(ErrPtg.valueOf(parseErrorLiteral()));  \n                } else {\n                                        String name = parseAsName();\n                    if (name.length() == 0) {\n                        throw new FormulaParseException("Cell reference or Named Range "\n                                + "expected after sheet name at index " + _pointer + ".");\n                    }\n                    Ptg nameXPtg = _book.getNameXPtg(name, sheetIden);\n                    if (nameXPtg == null) {\n                        throw new FormulaParseException("Specified name '" + name +\n                                "' for sheet " + sheetIden.asFormulaString() + " not found");\n                    }\n                    return new ParseNode(nameXPtg);\n                }\n            }\n            return parseNonRange(savePointer);\n        }\n        boolean whiteAfterPart1 = IsWhite(look);\n        if (whiteAfterPart1) {\n            SkipWhite();\n        }\n\n        if (look == ':') {\n            int colonPos = _pointer;\n            GetChar();\n            SkipWhite();\n            SimpleRangePart part2 = parseSimpleRangePart();\n            if (part2 != null && !part1.isCompatibleForArea(part2)) {\n                                \n                part2 = null;\n            }\n            if (part2 == null) {\n                                                resetPointer(colonPos);\n                if (!part1.isCell()) {\n                    String prefix = "";\n                    if (sheetIden != null) {\n                        prefix = "'" + sheetIden.getSheetIdentifier().getName() + '!';\n                    }\n                    throw new FormulaParseException(prefix + part1.getRep() + "' is not a proper reference.");\n                }\n            }\n            return createAreaRefParseNode(sheetIden, part1, part2);\n        }\n\n        if (look == '.') {\n            GetChar();\n            int dotCount = 1;\n            while (look =='.') {\n                dotCount ++;\n                GetChar();\n            }\n            boolean whiteBeforePart2 = IsWhite(look);\n\n            SkipWhite();\n            SimpleRangePart part2 = parseSimpleRangePart();\n            String part1And2 = _formulaString.substring(savePointer-1, _pointer-1);\n            if (part2 == null) {\n                if (sheetIden != null) {\n                    throw new FormulaParseException("Complete area reference expected after sheet name at index "\n                            + _pointer + ".");\n                }\n                return parseNonRange(savePointer);\n            }\n\n\n            if (whiteAfterPart1 || whiteBeforePart2) {\n                if (part1.isRowOrColumn() || part2.isRowOrColumn()) {\n                                                            throw new FormulaParseException("Dotted range (full row or column) expression '"\n                            + part1And2 + "' must not contain whitespace.");\n                }\n                return createAreaRefParseNode(sheetIden, part1, part2);\n            }\n\n            if (dotCount == 1 && part1.isRow() && part2.isRow()) {\n                                return parseNonRange(savePointer);\n            }\n\n            if (part1.isRowOrColumn() || part2.isRowOrColumn()) {\n                if (dotCount != 2) {\n                    throw new FormulaParseException("Dotted range (full row or column) expression '" + part1And2\n                            + "' must have exactly 2 dots.");\n                }\n            }\n            return createAreaRefParseNode(sheetIden, part1, part2);\n        }\n        if (part1.isCell() && isValidCellReference(part1.getRep())) {\n            return createAreaRefParseNode(sheetIden, part1, null);\n        }\n        if (sheetIden != null) {\n            throw new FormulaParseException("Second part of cell reference expected after sheet name at index "\n                    + _pointer + ".");\n        }\n\n        return parseNonRange(savePointer);\n    }
262	public void listInCell(HSSFWorkbook workbook, ArrayList<String> listItems, HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n        for(String listItem : listItems) {\n            buffer.append(listItem);\n            buffer.append("\n");\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
263	public static List<List<HSLFTextParagraph>> findTextParagraphs(PPDrawing ppdrawing, HSLFSheet sheet) {\n        List<List<HSLFTextParagraph>> runsV = new ArrayList<>();\n        for (EscherTextboxWrapper wrapper : ppdrawing.getTextboxWrappers()) {\n            List<HSLFTextParagraph> p = findTextParagraphs(wrapper, sheet);\n            if (p != null) {\n                runsV.add(p);\n            }\n        }\n        return runsV;\n    }
264	public EscherContainerRecord getEscherContainer() {\n		for(Iterator<EscherRecord> it = escherRecords.iterator(); it.hasNext();) {\n			Object er = it.next();\n			if(er instanceof EscherContainerRecord) {\n				return (EscherContainerRecord)er;\n			}\n		}\n		return null;\n	}
265	public boolean save(OutputStream outStream) {\n        Document xmlOutDoc = DocumentHelper.createDocument();\n\n                Element typesElem = xmlOutDoc.createElementNS(TYPES_NAMESPACE_URI, TYPES_TAG_NAME);\n        xmlOutDoc.appendChild(typesElem);\n\n                for (Entry<String, String> entry : defaultContentType.entrySet()) {\n            appendDefaultType(typesElem, entry);\n        }\n\n                if (overrideContentType != null) {\n            for (Entry<PackagePartName, String> entry : overrideContentType\n                    .entrySet()) {\n                appendSpecificTypes(typesElem, entry);\n            }\n        }\n        xmlOutDoc.normalize();\n\n                return this.saveImpl(xmlOutDoc, outStream);\n    }
266	public void extractAttachments(File dir) throws IOException {\n        int count = 0;\n        for(Attachment att : message.getAttachments()) {\n            count++;\n            \n                        String filename = att.getLongFilename();\n            if(filename == null || filename.length() == 0) {\n                filename = att.getFilename();\n            }\n            if(filename == null || filename.length() == 0) {\n                filename = "attachment" + count;\n                if(att.getExtension() != null) {\n                    filename += att.getExtension();\n                }\n            }\n            \n                        File file = new File(dir, filename);\n            OutputStream fout = new FileOutputStream(file);\n            try {\n                fout.write( att.getContents() );\n            } finally {\n                fout.close();\n            }\n        }\n    }
267	public XWPFParagraph createParagraph() {\n        XWPFParagraph paragraph = new XWPFParagraph(headerFooter.addNewP(), this);\n        paragraphs.add(paragraph);\n        bodyElements.add(paragraph);\n        return paragraph;\n    }
268	private XSSFGraphicFrame createGraphicFrame(XSSFClientAnchor anchor) {\n        CTTwoCellAnchor ctAnchor = createTwoCellAnchor(anchor);\n        CTGraphicalObjectFrame ctGraphicFrame = ctAnchor.addNewGraphicFrame();\n        ctGraphicFrame.set(XSSFGraphicFrame.prototype());\n        ctGraphicFrame.setXfrm(createXfrm(anchor));\n\n        long frameId = numOfGraphicFrames++;\n        XSSFGraphicFrame graphicFrame = new XSSFGraphicFrame(this, ctGraphicFrame);\n        graphicFrame.setAnchor(anchor);\n        graphicFrame.setId(frameId);\n        graphicFrame.setName("Diagramm" + frameId);\n        return graphicFrame;\n    }
269	public final void addProp(TextProp textProp) {\n	    if (textProp == null) {\n	        throw new HSLFException("TextProp must not be null");\n	    }\n\n	    String propName = textProp.getName();\n	    validatePropName(propName);\n	    \n	    textProps.put(propName, textProp);\n	}
270	public static void main(String[] args) {\n		if(args.length <= 0) {\n			System.err.println("No files names provided");\n		} else {\n			for (String arg : args) {\n				try {\n					Msg2txt processor = new Msg2txt(arg);\n					processor.processMessage();\n				} catch (IOException e) {\n					System.err.println("Could not process " + arg + ": " + e);\n				}\n			}\n		}\n	}
271	public void deletePartRecursive(PackagePartName partName) {\n		if (partName == null || !this.containPart(partName)) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		PackagePart partToDelete = this.getPart(partName);\n				this.removePart(partName);\n				try {\n			for (PackageRelationship relationship : partToDelete\n					.getRelationships()) {\n				PackagePartName targetPartName = PackagingURIHelper\n						.createPartName(PackagingURIHelper.resolvePartUri(\n								partName.getURI(), relationship.getTargetURI()));\n				this.deletePartRecursive(targetPartName);\n			}\n		} catch (InvalidFormatException e) {\n			logger.log(POILogger.WARN, "An exception occurs while deleting part '"\n					+ partName.getName()\n					+ "'. Some parts may remain in the package. - "\n					+ e.getMessage());\n			return;\n		}\n				PackagePartName relationshipPartName = PackagingURIHelper\n				.getRelationshipPartName(partName);\n		if (relationshipPartName != null && containPart(relationshipPartName)) {\n			this.removePart(relationshipPartName);\n		}\n	}
272	private ClientAnchorDetail fitImageToRows(HSSFSheet sheet, int rowNumber,\n            double reqImageHeightMM, int resizeBehaviour) {\n        double rowCoordinatesPerMM;\n        int pictureHeightCoordinates;\n        ClientAnchorDetail rowClientAnchorDetail = null;\n\n                HSSFRow row = sheet.getRow(rowNumber);\n        if(row == null) {\n                        row = sheet.createRow(rowNumber);\n        }\n\n                double rowHeightMM = row.getHeightInPoints() / ConvertImageUnits.POINTS_PER_MILLIMETRE;\n\n                                        if(rowHeightMM < reqImageHeightMM) {\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_ROW) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                row.setHeightInPoints((float)(reqImageHeightMM *\n                        ConvertImageUnits.POINTS_PER_MILLIMETRE));\n                rowHeightMM = reqImageHeightMM;\n                rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n                pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n                rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n            }\n                                                else if((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                    (resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN)) {\n                rowClientAnchorDetail = this.calculateRowLocation(sheet,\n                        rowNumber, reqImageHeightMM);\n            }\n        }\n                else {\n            rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n            pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n            rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n        }\n        return(rowClientAnchorDetail);\n    }
273	public ExHyperlink get(int id){\n        for(int i=0; i<_children.length; i++) {\n            if(_children[i] instanceof ExHyperlink) {\n                ExHyperlink rec = (ExHyperlink)_children[i];\n                if (rec.getExHyperlinkAtom().getNumber() == id){\n                    return rec;\n                }\n            }\n        }\n        return null;\n    }
274	public static CFRule12Record create(HSSFSheet sheet, IconSet iconSet) {\n        Threshold[] ts = new Threshold[iconSet.num];\n        for (int i=0; i<ts.length; i++) {\n            ts[i] = new IconMultiStateThreshold();\n        }\n        \n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_ICON_SET, \n                                              ComparisonOperator.NO_COMPARISON);\n        IconMultiStateFormatting imf = r.createMultiStateFormatting();\n        imf.setIconSet(iconSet);\n        imf.setThresholds(ts);\n        return r;\n    }
275	private void onSheetDelete(int index) {\n                final XSSFSheet sheet = getSheetAt(index);\n\n        sheet.onSheetDelete();\n\n                workbook.getSheets().removeSheet(index);\n\n                if(calcChain != null) {\n            removeRelation(calcChain);\n            calcChain = null;\n        }\n\n                List<XSSFName> toRemove = new ArrayList<>();\n        for (XSSFName nm : namedRanges) {\n            CTDefinedName ct = nm.getCTName();\n            if(!ct.isSetLocalSheetId()) {\n                continue;\n            }\n            if (ct.getLocalSheetId() == index) {\n                toRemove.add(nm);\n            } else if (ct.getLocalSheetId() > index){\n                                ct.setLocalSheetId(ct.getLocalSheetId()-1);\n            }\n        }\n        for (XSSFName nm : toRemove) {\n            removeName(nm);\n        }\n    }
276	private static int propLen(\n        TreeBidiMap<Long,Long> offset2Id,\n        Long entryOffset,\n        long maxSize) {\n        Long nextKey = offset2Id.nextKey(entryOffset);\n        long begin = entryOffset;\n        long end = (nextKey != null) ? nextKey : maxSize;\n        return (int)(end - begin);\n    }
277	public static boolean validatePassword(XmlObject xobj, String password, String prefix) {\n                if (password == null) return false;\n        \n        XmlCursor cur = xobj.newCursor();\n        String xorHashVal = cur.getAttributeText(getAttrName(prefix, "password"));\n        String algoName = cur.getAttributeText(getAttrName(prefix, "algorithmName"));\n        String hashVal = cur.getAttributeText(getAttrName(prefix, "hashValue"));\n        String saltVal = cur.getAttributeText(getAttrName(prefix, "saltValue"));\n        String spinCount = cur.getAttributeText(getAttrName(prefix, "spinCount"));\n        cur.dispose();\n\n        if (xorHashVal != null) {\n            int hash1 = Integer.parseInt(xorHashVal, 16);\n            int hash2 = CryptoFunctions.createXorVerifier1(password);\n            return hash1 == hash2;\n        } else {\n            if (hashVal == null || algoName == null || saltVal == null || spinCount == null) {\n                return false;\n            }\n            \n            byte hash1[] = DatatypeConverter.parseBase64Binary(hashVal);\n            HashAlgorithm hashAlgo = HashAlgorithm.fromString(algoName);\n            byte salt[] = DatatypeConverter.parseBase64Binary(saltVal);\n            int spinCnt = Integer.parseInt(spinCount);\n            byte hash2[] = CryptoFunctions.hashPassword(password, hashAlgo, salt, spinCnt, false);\n            return Arrays.equals(hash1, hash2);\n        }\n    }
278	public int addChildBefore(Record newChild, Record before) {\n				int loc = findChildLocation(before);\n		if(loc == -1) {\n			throw new IllegalArgumentException("Asked to add a new child before another record, but that record wasn't one of our children!");\n		}\n\n				addChildAt(newChild, loc);\n		return loc;\n	}
279	public static String getDigestMethodUri(HashAlgorithm digestAlgo) {\n        switch (digestAlgo) {\n        case sha1:   return DigestMethod.SHA1;\n        case sha224: return DigestMethod_SHA224;\n        case sha256: return DigestMethod.SHA256;\n        case sha384: return DigestMethod_SHA384;\n        case sha512: return DigestMethod.SHA512;\n        case ripemd160: return DigestMethod.RIPEMD160;\n        default: throw new EncryptedDocumentException("Hash algorithm "\n            +digestAlgo+" not supported for signing.");\n        }\n    }
280	public XSSFPatternFormatting createPatternFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTFill fill;\n        if(!dxf.isSetFill()) {\n            fill = dxf.addNewFill();\n        } else {\n            fill = dxf.getFill();\n        }\n\n        return new XSSFPatternFormatting(fill, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
281	public boolean addRow(XWPFTableRow row, int pos) {\n        if (pos >= 0 && pos <= tableRows.size()) {\n            ctTbl.insertNewTr(pos);\n            ctTbl.setTrArray(pos, row.getCtRow());\n            tableRows.add(pos, row);\n            return true;\n        }\n        return false;\n    }
282	static void overlapping(Sheet sheet) {\n        for (int i=0; i<40; i++) {\n            int rn = i+1;\n            Row r = sheet.createRow(i);\n            r.createCell(0).setCellValue("This is row " + rn + " (" + i + ")");\n            String str = "";\n            if (rn%2 == 0) {\n                str = str + "even ";\n            }\n            if (rn%3 == 0) {\n                str = str + "x3 ";\n            }\n            if (rn%5 == 0) {\n                str = str + "x5 ";\n            }\n            if (rn%10 == 0) {\n                str = str + "x10 ";\n            }\n            if (str.length() == 0) {\n                str = "nothing special...";\n            }\n            r.createCell(1).setCellValue("It is " + str);\n        }\n        sheet.autoSizeColumn(0);\n        sheet.autoSizeColumn(1);\n        \n        sheet.getRow(1).createCell(3).setCellValue("Even rows are blue");\n        sheet.getRow(2).createCell(3).setCellValue("Multiples of 3 have a grey background");\n        sheet.getRow(4).createCell(3).setCellValue("Multiples of 5 are bold");\n        sheet.getRow(9).createCell(3).setCellValue("Multiples of 10 are red (beats even)");\n        \n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n                ConditionalFormattingRule rule1 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),10)=0");\n        FontFormatting font1 = rule1.createFontFormatting();\n        font1.setFontColorIndex(IndexedColors.RED.index);\n        \n                ConditionalFormattingRule rule2 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),2)=0");\n        FontFormatting font2 = rule2.createFontFormatting();\n        font2.setFontColorIndex(IndexedColors.BLUE.index);\n        \n                ConditionalFormattingRule rule3 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),5)=0");\n        FontFormatting font3 = rule3.createFontFormatting();\n        font3.setFontStyle(false, true);\n        \n                ConditionalFormattingRule rule4 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),3)=0");\n        PatternFormatting fill4 = rule4.createPatternFormatting();\n        fill4.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);\n        fill4.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n        \n                CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:F41")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        sheetCF.addConditionalFormatting(regions, rule3);\n        sheetCF.addConditionalFormatting(regions, rule4);\n    }
283	protected void writeDocument(Document document) throws MarshalException {\n        XmlOptions xo = new XmlOptions();\n        Map<String,String> namespaceMap = new HashMap<>();\n        for(Map.Entry<String,String> entry : signatureConfig.getNamespacePrefixes().entrySet()){\n            namespaceMap.put(entry.getValue(), entry.getKey());\n        }\n        xo.setSaveSuggestedPrefixes(namespaceMap);\n        xo.setUseDefaultNamespace();\n\n        LOG.log(POILogger.DEBUG, "output signed Office OpenXML document");\n\n        \n        OPCPackage pkg = signatureConfig.getOpcPackage();\n\n        PackagePartName sigPartName, sigsPartName;\n        try {\n                        sigPartName = PackagingURIHelper.createPartName("/_xmlsignatures/sig1.xml");\n                        sigsPartName = PackagingURIHelper.createPartName("/_xmlsignatures/origin.sigs");\n        } catch (InvalidFormatException e) {\n            throw new MarshalException(e);\n        }\n\n        PackagePart sigPart = pkg.getPart(sigPartName);\n        if (sigPart == null) {\n            sigPart = pkg.createPart(sigPartName, ContentTypes.DIGITAL_SIGNATURE_XML_SIGNATURE_PART);\n        }\n\n        try {\n            OutputStream os = sigPart.getOutputStream();\n            SignatureDocument sigDoc = SignatureDocument.Factory.parse(document, DEFAULT_XML_OPTIONS);\n            sigDoc.save(os, xo);\n            os.close();\n        } catch (Exception e) {\n            throw new MarshalException("Unable to write signature document", e);\n        }\n\n        PackagePart sigsPart = pkg.getPart(sigsPartName);\n        if (sigsPart == null) {\n                        sigsPart = pkg.createPart(sigsPartName, ContentTypes.DIGITAL_SIGNATURE_ORIGIN_PART);\n        }\n\n        PackageRelationshipCollection relCol = pkg.getRelationshipsByType(PackageRelationshipTypes.DIGITAL_SIGNATURE_ORIGIN);\n        for (PackageRelationship pr : relCol) {\n            pkg.removeRelationship(pr.getId());\n        }\n        pkg.addRelationship(sigsPartName, TargetMode.INTERNAL, PackageRelationshipTypes.DIGITAL_SIGNATURE_ORIGIN);\n\n        sigsPart.addRelationship(sigPartName, TargetMode.INTERNAL, PackageRelationshipTypes.DIGITAL_SIGNATURE);\n    }
284	private XSLFNotes createNotesSlide(XSLFSlide slide) {\n\n        if (_notesMaster == null) {\n            createNotesMaster();\n        }\n\n        int slideIndex = XSLFRelation.SLIDE.getFileNameIndex(slide);\n\n        XSLFRelation relationType = XSLFRelation.NOTES;\n        slideIndex = findNextAvailableFileNameIndex(relationType, slideIndex);\n\n                XSLFNotes notesSlide = (XSLFNotes) createRelationship\n                (relationType, XSLFFactory.getInstance(), slideIndex);\n                slide.addRelation(null, relationType, notesSlide);\n        notesSlide.addRelation(null, XSLFRelation.NOTES_MASTER, _notesMaster);\n        notesSlide.addRelation(null, XSLFRelation.SLIDE, slide);\n\n        notesSlide.importContent(_notesMaster);\n\n        return notesSlide;\n    }
285	public void setSelectedTabs(Collection<Integer> indexes) {\n\n        for (int index : indexes) {\n            validateSheetIndex(index);\n        }\n                Set<Integer> set = new HashSet<>(indexes);\n        int nSheets = _sheets.size();\n        for (int i=0; i<nSheets; i++) {\n            boolean bSelect = set.contains(i);\n            getSheetAt(i).setSelected(bSelect);\n        }\n                short nSelected = (short) set.size();\n        workbook.getWindowOne().setNumSelectedTabs(nSelected);\n    }
286	private String parseAsColumnQuantifier() {\n        if ( look != '[') {\n            return null;\n        }\n        GetChar();\n        if (look == '#') {\n            return null;\n        }\n        if (look == '@') {\n            GetChar();\n        }\n        StringBuilder name = new StringBuilder();\n        while (look!=']') {\n           name.appendCodePoint(look);\n           GetChar();\n        }\n        Match(']');\n        return name.toString();\n    }
287	public void groupColumnRange(int fromColumn, int toColumn, boolean indent) {\n\n                _columnInfos.groupColumnRange( fromColumn, toColumn, indent);\n\n                int maxLevel = _columnInfos.getMaxOutlineLevel();\n\n        GutsRecord guts = getGutsRecord();\n        guts.setColLevelMax( (short) ( maxLevel+1 ) );\n        if (maxLevel == 0) {\n            guts.setTopColGutter( (short)0 );\n        } else {\n            guts.setTopColGutter( (short) ( 29 + (12 * (maxLevel-1)) ) );\n        }\n    }
288	public boolean isValidCell(CellReference cellRef) {\n        final DataValidationContext context = getValidationContextForCell(cellRef);\n\n        if (context == null) return true;\n        \n        final Cell cell = SheetUtil.getCell(workbook.getSheet(cellRef.getSheetName()), cellRef.getRow(), cellRef.getCol());\n        \n                \n                if (   cell == null\n            || isType(cell, CellType.BLANK)  \n            || (isType(cell,CellType.STRING) \n                && (cell.getStringCellValue() == null || cell.getStringCellValue().isEmpty())\n               )\n           ) {\n            return context.getValidation().getEmptyCellAllowed();\n        }\n        \n                \n        return ValidationEnum.isValid(cell, context);\n    }
289	private static HorizontalAlignment getHorizontalAlignment(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        HorizontalAlignment align;\n        if (value instanceof HorizontalAlignment) {\n            align = (HorizontalAlignment) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map used a Short value for "\n                        + name + ". Should use HorizontalAlignment enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            align = HorizontalAlignment.forInt(code);\n        }\n        else if (value == null) {\n            align = HorizontalAlignment.GENERAL;\n        }\n        else {\n            throw new RuntimeException("Unexpected horizontal alignment style class. Must be HorizontalAlignment or Short (deprecated).");\n        }\n        return align;\n    }
290	private static String unescapeString(CharSequence text) {\n        int len = text.length();\n        StringBuilder sb = new StringBuilder(len);\n        int i = 0;\n        while (i < len) {\n            char ch = text.charAt(i);\n            if (ch == '\'') {\n                                i++;\n                if (i >= len) {\n                    return null;\n                }\n                ch = text.charAt(i);\n                if (ch != '\'') {\n                    return null;\n                }\n            }\n            sb.append(ch);\n            i++;\n        }\n        return sb.toString();\n    }
291	public void processRecordInternally(Record record) {\n		if (record instanceof FormatRecord) {\n			FormatRecord fr = (FormatRecord) record;\n			_customFormatRecords.put(Integer.valueOf(fr.getIndexCode()), fr);\n		}\n		if (record instanceof ExtendedFormatRecord) {\n			ExtendedFormatRecord xr = (ExtendedFormatRecord) record;\n			_xfRecords.add(xr);\n		}\n	}
292	private static double evaluate(int hours, int minutes, int seconds) throws EvaluationException {\n\n		if (hours > 32767 || minutes > 32767 || seconds > 32767) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		int totalSeconds = hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;\n\n		if (totalSeconds < 0) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		return (totalSeconds % SECONDS_PER_DAY) / (double)SECONDS_PER_DAY;\n	}
293	public static String toFormulaString(FormulaRenderingWorkbook book, Ptg[] ptgs) {\n        if (ptgs == null || ptgs.length == 0) {\n            throw new IllegalArgumentException("ptgs must not be null");\n        }\n        Stack<String> stack = new Stack<>();\n\n        for (Ptg ptg : ptgs) {\n                        if(ptg instanceof MemAreaPtg || ptg instanceof MemFuncPtg || ptg instanceof MemErrPtg) {\n                                                                continue;\n            }\n            if (ptg instanceof ParenthesisPtg) {\n                String contents = stack.pop();\n                stack.push ("(" + contents + ")");\n                continue;\n            }\n            if (ptg instanceof AttrPtg) {\n                AttrPtg attrPtg = ((AttrPtg) ptg);\n                if (attrPtg.isOptimizedIf() || attrPtg.isOptimizedChoose() || attrPtg.isSkip()) {\n                    continue;\n                }\n                if (attrPtg.isSpace()) {\n                                        continue;\n                                                                            }\n                if (attrPtg.isSemiVolatile()) {\n                                        continue;\n                }\n                if (attrPtg.isSum()) {\n                    String[] operands = getOperands(stack, attrPtg.getNumberOfOperands());\n                    stack.push(attrPtg.toFormulaString(operands));\n                    continue;\n                }\n                throw new RuntimeException("Unexpected tAttr: " + attrPtg);\n            }\n\n            if (ptg instanceof WorkbookDependentFormula) {\n                WorkbookDependentFormula optg = (WorkbookDependentFormula) ptg;\n                stack.push(optg.toFormulaString(book));\n                continue;\n            }\n            if (! (ptg instanceof OperationPtg)) {\n                stack.push(ptg.toFormulaString());\n                continue;\n            }\n\n            OperationPtg o = (OperationPtg) ptg;\n            String[] operands = getOperands(stack, o.getNumberOfOperands());\n            stack.push(o.toFormulaString(operands));\n        }\n        if(stack.isEmpty()) {\n                                    throw new IllegalStateException("Stack underflow");\n        }\n        String result = stack.pop();\n        if(!stack.isEmpty()) {\n                                    throw new IllegalStateException("too much stuff left on the stack");\n        }\n        return result;\n    }
294	private static void validateFunctionName(String functionName) {\n		int len = functionName.length();\n		int ix = len - 1;\n		if (!Character.isDigit(functionName.charAt(ix))) {\n			return;\n		}\n		while(ix >= 0) {\n			if (!Character.isDigit(functionName.charAt(ix))) {\n				break;\n			}\n			ix--;\n		}\n		if(DIGIT_ENDING_FUNCTION_NAMES_SET.contains(functionName)) {\n			return;\n		}\n		throw new RuntimeException("Invalid function name '" + functionName\n				+ "' (is footnote number incorrectly appended)");\n	}
295	public HSSFColor findSimilarColor(int red, int green, int blue) {\n        HSSFColor result = null;\n        int minColorDistance = Integer.MAX_VALUE;\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;\n            b = _palette.getColor(++i))\n        {\n            int colorDistance = Math.abs(red - unsignedInt(b[0])) +\n            	Math.abs(green - unsignedInt(b[1])) +\n            	Math.abs(blue - unsignedInt(b[2]));\n            if (colorDistance < minColorDistance)\n            {\n                minColorDistance = colorDistance;\n                result = getColor(i);\n            }\n        }\n        return result;\n    }
296	public List<EvaluationConditionalFormatRule> getConditionalFormattingForCell(final CellReference cellRef) {\n        List<EvaluationConditionalFormatRule> rules = values.get(cellRef);\n        \n        if (rules == null) {\n                        rules = new ArrayList<>();\n            \n            final Sheet sheet;\n            if (cellRef.getSheetName() != null) {\n                sheet = workbook.getSheet(cellRef.getSheetName());\n            } else {\n                sheet = workbook.getSheetAt(workbook.getActiveSheetIndex());\n            }\n            \n            \n            boolean stopIfTrue = false;\n            for (EvaluationConditionalFormatRule rule : getRules(sheet)) {\n                \n                if (stopIfTrue) {\n                    continue;                 }\n\n                if (rule.matches(cellRef)) {\n                    rules.add(rule);\n                    stopIfTrue = rule.getRule().getStopIfTrue();\n                }\n            }\n            Collections.sort(rules);\n            values.put(cellRef, rules);\n        }\n        \n        return Collections.unmodifiableList(rules);\n    }
297	private Ptg rowCopyAreaPtg(AreaPtgBase aptg) {\n        boolean changed = false;\n    \n        final int aFirstRow = aptg.getFirstRow();\n        final int aLastRow = aptg.getLastRow();\n    \n        if (aptg.isFirstRowRelative()) {\n            final int destFirstRowIndex = aFirstRow + _amountToMove;\n            if (destFirstRowIndex < 0 || _version.getLastRowIndex() < destFirstRowIndex)\n                return createDeletedRef(aptg);\n            aptg.setFirstRow(destFirstRowIndex);\n            changed = true;\n        }\n        if (aptg.isLastRowRelative()) {\n            final int destLastRowIndex = aLastRow + _amountToMove;\n            if (destLastRowIndex < 0 || _version.getLastRowIndex() < destLastRowIndex)\n                return createDeletedRef(aptg);\n            aptg.setLastRow(destLastRowIndex);\n            changed = true;\n        }\n        if (changed) {\n            aptg.sortTopLeftToBottomRight();\n        }\n\n        return changed ? aptg : null;\n    }
298	public static Cell createCell(Row row, int column, String value, CellStyle style) {\n        Cell cell = getCell(row, column);\n\n        cell.setCellValue(cell.getRow().getSheet().getWorkbook().getCreationHelper()\n                .createRichTextString(value));\n        if (style != null) {\n            cell.setCellStyle(style);\n        }\n        return cell;\n    }
299	public void adjustForDelete(int start, int length) {\n        int end = start + length;\n\n        if (_cpEnd > start) {\n            \n            if (_cpStart < end) {\n                                _cpEnd = end >= _cpEnd ? start : _cpEnd - length;\n                _cpStart = Math.min(start, _cpStart);\n            } else {\n                                _cpEnd -= length;\n                _cpStart -= length;\n            }\n        }\n    }
300	static void dataBars(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Data Bars");\n        Row r = sheet.createRow(1);\n        r.createCell(1).setCellValue("Green Positive");\n        r.createCell(2).setCellValue("Blue Mix");\n        r.createCell(3).setCellValue("Red Negative");\n        r = sheet.createRow(2);\n        r.createCell(1).setCellValue(0);\n        r.createCell(2).setCellValue(0);\n        r.createCell(3).setCellValue(0);\n        r = sheet.createRow(3);\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(-5);\n        r.createCell(3).setCellValue(-5);\n        r = sheet.createRow(4);\n        r.createCell(1).setCellValue(10);\n        r.createCell(2).setCellValue(10);\n        r.createCell(3).setCellValue(-10);\n        r = sheet.createRow(5);\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(5);\n        r.createCell(3).setCellValue(-5);\n        r = sheet.createRow(6);\n        r.createCell(1).setCellValue(20);\n        r.createCell(2).setCellValue(-10);\n        r.createCell(3).setCellValue(-20);\n        sheet.setColumnWidth(0, 3000);\n        sheet.setColumnWidth(1, 5000);\n        sheet.setColumnWidth(2, 5000);\n        sheet.setColumnWidth(3, 5000);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n        ExtendedColor color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FF63BE7B");\n        CellRangeAddress[] regions = { CellRangeAddress.valueOf("B2:B7") };\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db1 = rule1.getDataBarFormatting();\n        db1.getMinThreshold().setRangeType(RangeType.MIN);\n        db1.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule1);\n        \n        color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FF5A8AC6");\n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("C2:C7") };\n        ConditionalFormattingRule rule2 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db2 = rule2.getDataBarFormatting();\n        db2.getMinThreshold().setRangeType(RangeType.MIN);\n        db2.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        \n        color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FFF8696B");\n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("D2:D7") };\n        ConditionalFormattingRule rule3 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db3 = rule3.getDataBarFormatting();\n        db3.getMinThreshold().setRangeType(RangeType.MIN);\n        db3.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule3);\n    }
301	public static String convertNumToColString(int col) {\n                        int excelColNum = col + 1;\n\n        StringBuilder colRef = new StringBuilder(2);\n        int colRemain = excelColNum;\n\n        while(colRemain > 0) {\n            int thisPart = colRemain % 26;\n            if(thisPart == 0) { thisPart = 26; }\n            colRemain = (colRemain - thisPart) / 26;\n\n                        char colChar = (char)(thisPart+64);\n            colRef.insert(0, colChar);\n        }\n\n        return colRef.toString();\n    }
302	public static String decodeURI(URI uri) {\n		StringBuilder retVal = new StringBuilder(64);\n		String uriStr = uri.toASCIIString();\n		char c;\n		final int length = uriStr.length();\n		for (int i = 0; i < length; ++i) {\n			c = uriStr.charAt(i);\n			if (c == '%') {\n												if (((length - i) < 2)) {\n					throw new IllegalArgumentException("The uri " + uriStr\n							+ " contain invalid encoded character !");\n				}\n\n								char decodedChar = (char) Integer.parseInt(uriStr.substring(\n						i + 1, i + 3), 16);\n				retVal.append(decodedChar);\n				i += 2;\n				continue;\n			}\n			retVal.append(c);\n		}\n		return retVal.toString();\n	}
303	public static Calendar getLocaleCalendar(int year, int month, int day, int hour, int minute, int second) {\n        Calendar cal = getLocaleCalendar();\n        cal.set(year,  month, day, hour, minute, second);\n        cal.clear(Calendar.MILLISECOND);\n        return cal;\n    }
304	public ExtendedFormatRecord createCellXF() {\n        ExtendedFormatRecord xf = createExtendedFormat();\n\n        records.add(records.getXfpos()+1, xf);\n        records.setXfpos( records.getXfpos() + 1 );\n        numxfs++;\n        return xf;\n    }
305	private void processChunkParseCommands() throws IOException {\n		String line;\n		InputStream cpd = null;\n		BufferedReader inp = null;\n		try {\n	        cpd = ChunkFactory.class.getResourceAsStream(chunkTableName);\n	        if(cpd == null) {\n	            throw new IllegalStateException("Unable to find HDGF chunk definition on the classpath - " + chunkTableName);\n	        }\n\n	        inp = new BufferedReader(new InputStreamReader(cpd, LocaleUtil.CHARSET_1252));\n		    \n		    while( (line = inp.readLine()) != null ) {\n    			if (line.isEmpty() || "# \t".contains(line.substring(0,1))) {\n    			    continue;\n    			}\n    \n    			    			if(!line.matches("^start [0-9]+$")) {\n    				throw new IllegalStateException("Expecting start xxx, found " + line);\n    			}\n    			int chunkType = Integer.parseInt(line.substring(6));\n    			ArrayList<CommandDefinition> defsL = new ArrayList<>();\n    \n    			    			while( (line = inp.readLine()) != null ) {\n    			    if (line.startsWith("end")) {\n    			        break;\n    			    }\n    				StringTokenizer st = new StringTokenizer(line, " ");\n    				int defType = Integer.parseInt(st.nextToken());\n    				int offset = Integer.parseInt(st.nextToken());\n    				String name = st.nextToken("\uffff").substring(1);\n    \n    				CommandDefinition def = new CommandDefinition(defType,offset,name);\n    				defsL.add(def);\n    			}\n    \n    			CommandDefinition[] defs = defsL.toArray(new CommandDefinition[defsL.size()]);\n    \n    			    			chunkCommandDefinitions.put(Integer.valueOf(chunkType), defs);\n    		}\n		} finally {\n    		if (inp != null) {\n    		    inp.close();\n    		}\n    		if (cpd != null) {\n    		    cpd.close();\n    		}\n		}\n	}
306	private void GetChar() {\n                        if (IsWhite(look)) {\n            if (look == ' ') {\n                _inIntersection = true;\n            }\n        }\n        else {\n            _inIntersection = false;\n        }\n        \n                if (_pointer > _formulaLength) {\n            throw new RuntimeException("too far");\n        }\n        if (_pointer < _formulaLength) {\n            look=_formulaString.codePointAt(_pointer);\n        } else {\n                                    look = (char)0;\n            _inIntersection = false;\n        }\n        _pointer += Character.charCount(look);\n            }
307	protected PackageRelationship getPackageRelationship(POIXMLDocumentPart parent, PackagePart part) {\n         try {\n             String partName = part.getPartName().getName();\n             for (PackageRelationship pr : parent.getPackagePart().getRelationships()) {\n                 String packName = pr.getTargetURI().toASCIIString();\n                 if (packName.equalsIgnoreCase(partName)) {\n                     return pr;\n                 }\n             }\n         } catch (InvalidFormatException e) {\n             throw new POIXMLException("error while determining package relations", e);\n         }\n         \n         throw new POIXMLException("package part isn't a child of the parent document.");\n     }
308	public String getTextAsString() {\n		StringBuffer ret = new StringBuffer();\n		List<String> textV = getTextAsVector();\n		for(String text : textV) {\n			ret.append(text);\n			if(! text.endsWith("\n")) {\n				ret.append('\n');\n			}\n		}\n		return ret.toString();\n	}
309	public static boolean isCellDateFormatted(Cell cell, ConditionalFormattingEvaluator cfEvaluator) {\n        if (cell == null) return false;\n        boolean bDate = false;\n\n        double d = cell.getNumericCellValue();\n        if ( DateUtil.isValidExcelDate(d) ) {\n            ExcelNumberFormat nf = ExcelNumberFormat.from(cell, cfEvaluator);\n            if(nf==null) return false;\n            bDate = isADateFormat(nf);\n        }\n        return bDate;\n    }
310	public static void main(String[] args) throws IOException {\n        if(args.length < 2) {\n            System.err.println("Use:");\n            System.err.println("  HMEFContentsExtractor <filename> <output dir>");\n            System.err.println("");\n            System.err.println("");\n            System.err.println("Where <filename> is the winmail.dat file to extract,");\n            System.err.println(" and <output dir> is where to place the extracted files");\n            System.exit(2);\n        }\n        \n        final String filename = args[0];\n        final String outputDir = args[1];\n        \n        HMEFContentsExtractor ext = new HMEFContentsExtractor(new File(filename));\n        \n        File dir = new File(outputDir);\n        File rtf = new File(dir, "message.rtf");\n        if(! dir.exists()) {\n            throw new FileNotFoundException("Output directory " + dir.getName() + " not found");\n        }\n        \n        System.out.println("Extracting...");\n        ext.extractMessageBody(rtf);\n        ext.extractAttachments(dir);\n        System.out.println("Extraction completed");\n    }
311	public void copy(TextPropCollection other) {\n	    if (other == null) {\n	        throw new HSLFException("trying to copy null TextPropCollection");\n	    }\n	    if (this == other) return;\n        this.charactersCovered = other.charactersCovered;\n        this.indentLevel = other.indentLevel;\n        this.maskSpecial = other.maskSpecial;\n        this.textProps.clear();\n        for (TextProp tp : other.textProps.values()) {\n            TextProp tpCopy = (tp instanceof BitMaskTextProp)\n                ? ((BitMaskTextProp)tp).cloneAll()\n                : tp.clone();\n            addProp(tpCopy);\n        }\n	}
312	public static SubRecord createSubRecord(LittleEndianInput in, int cmoOt) {\n		int sid = in.readUShort();\n		int secondUShort = in.readUShort(); \n		switch (sid) {\n			case CommonObjectDataSubRecord.sid:\n				return new CommonObjectDataSubRecord(in, secondUShort);\n			case EmbeddedObjectRefSubRecord.sid:\n				return new EmbeddedObjectRefSubRecord(in, secondUShort);\n			case GroupMarkerSubRecord.sid:\n				return new GroupMarkerSubRecord(in, secondUShort);\n			case EndSubRecord.sid:\n				return new EndSubRecord(in, secondUShort);\n			case NoteStructureSubRecord.sid:\n				return new NoteStructureSubRecord(in, secondUShort);\n			case LbsDataSubRecord.sid:\n				return new LbsDataSubRecord(in, secondUShort, cmoOt);\n            case FtCblsSubRecord.sid:\n                return new FtCblsSubRecord(in, secondUShort);\n            case FtPioGrbitSubRecord.sid:\n            	return new FtPioGrbitSubRecord(in, secondUShort);\n            case FtCfSubRecord.sid:\n            	return new FtCfSubRecord(in, secondUShort);\n		}\n		return new UnknownSubRecord(in, sid, secondUShort);\n	}
313	public Path2D.Double getBoundsAsPath() {\n\n        Rectangle2D.Double rect = getTextBounds();\n        Double w = rect.getWidth();\n        Double h = rect.getHeight();\n\n        Path2D.Double bounds = new Path2D.Double();\n        bounds.moveTo(0, 0);\n        bounds.lineTo(w, 0);\n        bounds.lineTo(w, h);\n        bounds.lineTo(0, h);\n        bounds.lineTo(0, 0);\n\n        return bounds;\n    }
314	public void processAttachment(AttachmentChunks attachment, \n	      File dir) throws IOException {\n	   String fileName = attachment.getAttachFileName().toString();\n	   if(attachment.getAttachLongFileName() != null) {\n	      fileName = attachment.getAttachLongFileName().toString();\n	   }\n	   \n		File f = new File(dir, fileName);\n		OutputStream fileOut = null;\n		try {\n			fileOut = new FileOutputStream(f);\n			fileOut.write(attachment.getAttachData().getValue());\n		} finally {\n			if(fileOut != null) {\n				fileOut.close();\n			}\n		}\n	}
315	public static boolean marshallRelationshipPart(\n			PackageRelationshipCollection rels, PackagePartName relPartName,\n			ZipArchiveOutputStream zos) {\n				Document xmlOutDoc = DocumentHelper.createDocument();\n						Element root = xmlOutDoc.createElementNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIPS_TAG_NAME);\n        xmlOutDoc.appendChild(root);\n\n										\n		URI sourcePartURI = PackagingURIHelper\n				.getSourcePartUriFromRelationshipPartUri(relPartName.getURI());\n\n		for (PackageRelationship rel : rels) {\n			            Element relElem = xmlOutDoc.createElementNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIP_TAG_NAME);\n            root.appendChild(relElem);\n\n						relElem.setAttribute(PackageRelationship.ID_ATTRIBUTE_NAME, rel.getId());\n\n						relElem.setAttribute(PackageRelationship.TYPE_ATTRIBUTE_NAME, rel.getRelationshipType());\n\n						String targetValue;\n			URI uri = rel.getTargetURI();\n			if (rel.getTargetMode() == TargetMode.EXTERNAL) {\n												targetValue = uri.toString();\n\n								relElem.setAttribute(PackageRelationship.TARGET_MODE_ATTRIBUTE_NAME, "External");\n			} else {\n                URI targetURI = rel.getTargetURI();\n                targetValue = PackagingURIHelper.relativizeURI(\n						sourcePartURI, targetURI, true).toString();\n			}\n			relElem.setAttribute(PackageRelationship.TARGET_ATTRIBUTE_NAME, targetValue);\n		}\n\n		xmlOutDoc.normalize();\n\n				\n				ZipArchiveEntry ctEntry = new ZipArchiveEntry(ZipHelper.getZipURIFromOPCName(\n				relPartName.getURI().toASCIIString()).getPath());\n		try {\n			zos.putArchiveEntry(ctEntry);\n			try {\n				return StreamHelper.saveXmlInStream(xmlOutDoc, zos);\n			} finally {\n				zos.closeArchiveEntry();\n			}\n		} catch (IOException e) {\n			logger.log(POILogger.ERROR,"Cannot create zip entry " + relPartName, e);\n			return false;\n		}\n	}
316	public void write(final byte[] dst, final int offset)\n    throws ArrayStoreException {\n        \n        if (dst.length < LENGTH) {\n            throw new ArrayStoreException\n                ("Destination byte[] must have room for at least 16 bytes, " +\n                 "but has a length of only " + dst.length + ".");\n        }\n        \n        \n        dst[0 + offset] = bytes[3];\n        dst[1 + offset] = bytes[2];\n        dst[2 + offset] = bytes[1];\n        dst[3 + offset] = bytes[0];\n\n        \n        dst[4 + offset] = bytes[5];\n        dst[5 + offset] = bytes[4];\n\n        \n        dst[6 + offset] = bytes[7];\n        dst[7 + offset] = bytes[6];\n\n        \n        System.arraycopy(bytes, 8, dst, 8 + offset, 8);\n    }
317	public HSLFFontInfo addFont(FontInfo fontInfo) {\n        HSLFFontInfo fi = getFontInfo(fontInfo.getTypeface());\n        if (fi != null) {\n            return fi;\n        }\n\n        fi = new HSLFFontInfo(fontInfo);\n        fi.setIndex(fonts.size());\n        fonts.put(fi.getTypeface(), fi);\n        \n        FontEntityAtom fnt = fi.createRecord();\n\n                appendChildRecord(fnt);\n\n                return fi;\n    }
318	public Rectangle2D.Double getTextBounds() {\n\n        double txtPinX = _parent.getTxtPinX();\n        double txtPinY = _parent.getTxtPinY();\n\n        double txtLocPinX = _parent.getTxtLocPinX();\n        double txtLocPinY = _parent.getTxtLocPinY();\n\n        double txtWidth = _parent.getTxtWidth();\n        double txtHeight = _parent.getTxtHeight();\n\n        double x = txtPinX - txtLocPinX;\n        double y = txtPinY - txtLocPinY;\n\n        return new Rectangle2D.Double(x, y, txtWidth, txtHeight);\n    }
319	protected int getFreeBlock() throws IOException {\n       int sectorsPerSBAT = _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\n       \n              int offset = 0;\n        for (BATBlock sbat : _sbat_blocks) {\n                        if (sbat.hasFreeSectors()) {\n                                for (int j = 0; j < sectorsPerSBAT; j++) {\n                    int sbatValue = sbat.getValueAt(j);\n                    if (sbatValue == POIFSConstants.UNUSED_BLOCK) {\n                                                return offset + j;\n                    }\n                }\n            }\n\n                        offset += sectorsPerSBAT;\n        }\n       \n                            \n              BATBlock newSBAT = BATBlock.createEmptyBATBlock(_filesystem.getBigBlockSizeDetails(), false);\n       int batForSBAT = _filesystem.getFreeBlock();\n       newSBAT.setOurBlockIndex(batForSBAT);\n       \n              if(_header.getSBATCount() == 0) {\n                    _header.setSBATStart(batForSBAT);\n          _header.setSBATBlockCount(1);\n       } else {\n                    ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\n          int batOffset = _header.getSBATStart();\n          while(true) {\n             loopDetector.claim(batOffset);\n             int nextBat = _filesystem.getNextBlock(batOffset);\n             if(nextBat == POIFSConstants.END_OF_CHAIN) {\n                break;\n             }\n             batOffset = nextBat;\n          }\n          \n                    _filesystem.setNextBlock(batOffset, batForSBAT);\n          \n                    _header.setSBATBlockCount(\n                _header.getSBATCount() + 1\n          );\n       }\n       \n              _filesystem.setNextBlock(batForSBAT, POIFSConstants.END_OF_CHAIN);\n       _sbat_blocks.add(newSBAT);\n       \n              return offset;\n    }
320	protected void onDeleteFormula(XSSFCell cell){\n\n        CTCellFormula f = cell.getCTCell().getF();\n        if (f != null && f.getT() == STCellFormulaType.SHARED && f.isSetRef() && f.getStringValue() != null) {\n\n            CellRangeAddress ref = CellRangeAddress.valueOf(f.getRef());\n            if(ref.getNumberOfCells() > 1){\n                DONE:\n                for(int i = cell.getRowIndex(); i <= ref.getLastRow(); i++){\n                    XSSFRow row = getRow(i);\n                    if(row != null) for(int j = cell.getColumnIndex(); j <= ref.getLastColumn(); j++){\n                        XSSFCell nextCell = row.getCell(j);\n                        if(nextCell != null && nextCell != cell){\n                            CTCellFormula nextF = nextCell.getCTCell().getF();\n                            nextF.setStringValue(nextCell.getCellFormula());\n                            CellRangeAddress nextRef = new CellRangeAddress(\n                                    nextCell.getRowIndex(), ref.getLastRow(),\n                                    nextCell.getColumnIndex(), ref.getLastColumn());\n                            nextF.setRef(nextRef.formatAsString());\n\n                            sharedFormulas.put((int)nextF.getSi(), nextF);\n                            break DONE;\n                        }\n                    }\n                }\n            }\n\n        }\n    }
321	public XWPFEndnote createEndnote() {\n        CTFtnEdn newNote = CTFtnEdn.Factory.newInstance(); \n        newNote.setType(STFtnEdn.NORMAL);\n\n        XWPFEndnote footnote = addEndnote(newNote);\n        footnote.getCTFtnEdn().setId(getIdManager().nextId());\n        return footnote;\n        \n    }
322	protected void preSerialize(){\n        Map<Integer, NoteRecord> tailRecords = _boundAggregate.getTailRecords();\n        \n        Set<String> coordinates = new HashSet<>(tailRecords.size());\n        for(NoteRecord rec : tailRecords.values()){\n            String noteRef = new CellReference(rec.getRow(),\n                    rec.getColumn(), true, true).formatAsString();             if(coordinates.contains(noteRef )){\n                throw new IllegalStateException("found multiple cell comments for cell " + noteRef );\n            } else {\n                coordinates.add(noteRef);\n            }\n        }\n    }
323	private void compareNumberOfColumnsInSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n            \n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n\n            Iterator<Row> ri1 = loc1.sheet.rowIterator();\n            Iterator<Row> ri2 = loc2.sheet.rowIterator();\n            \n            int num1 = (ri1.hasNext()) ? ri1.next().getPhysicalNumberOfCells() : 0;\n            int num2 = (ri2.hasNext()) ? ri2.next().getPhysicalNumberOfCells() : 0;\n            \n            if (num1 != num2) {\n                String str = String.format(Locale.ROOT, "%s\nworkbook1 -> %s [%d] != workbook2 -> %s [%d]",\n                    "Number Of Columns does not Match ::",\n                    loc1.sheet.getSheetName(), num1,\n                    loc2.sheet.getSheetName(), num2\n                );\n                listOfDifferences.add(str);\n            }\n        }\n    }
324	public void cloneStyleFrom(FontRecord source) {\n		field_1_font_height         = source.field_1_font_height;\n		field_2_attributes          = source.field_2_attributes;\n		field_3_color_palette_index = source.field_3_color_palette_index;\n		field_4_bold_weight         = source.field_4_bold_weight;\n		field_5_super_sub_script    = source.field_5_super_sub_script;\n		field_6_underline           = source.field_6_underline;\n		field_7_family              = source.field_7_family;\n		field_8_charset             = source.field_8_charset;\n		field_9_zero                = source.field_9_zero;\n		field_11_font_name          = source.field_11_font_name;\n	}
325	public void moveCell(HSSFCell cell, short newColumn) {\n                if(cells.length > newColumn && cells[newColumn] != null) {\n            throw new IllegalArgumentException("Asked to move cell to column " + newColumn + " but there's already a cell there");\n        }\n\n                if(! cells[cell.getColumnIndex()].equals(cell)) {\n            throw new IllegalArgumentException("Asked to move a cell, but it didn't belong to our row");\n        }\n\n                        removeCell(cell, false);\n        cell.updateCellNum(newColumn);\n        addCell(cell);\n    }
326	public void cloneDrawings(InternalSheet sheet){\n\n        findDrawingGroup();\n\n        if(drawingManager == null) {\n                        return;\n        }\n\n                int aggLoc = sheet.aggregateDrawingRecords(drawingManager, false);\n        if(aggLoc == -1) {\n            return;\n        }\n        \n        EscherAggregate agg = (EscherAggregate) sheet.findFirstRecordBySid(EscherAggregate.sid);\n        EscherContainerRecord escherContainer = agg.getEscherContainer();\n        if (escherContainer == null) {\n            return;\n        }\n\n        EscherDggRecord dgg = drawingManager.getDgg();\n\n                int dgId = drawingManager.findNewDrawingGroupId();\n        dgg.addCluster( dgId, 0 );\n        dgg.setDrawingsSaved(dgg.getDrawingsSaved() + 1);\n\n        EscherDgRecord dg = null;\n        for(EscherRecord er : escherContainer) {\n            if(er instanceof EscherDgRecord) {\n                dg = (EscherDgRecord)er;\n                                dg.setOptions( (short) ( dgId << 4 ) );\n            } else if (er instanceof EscherContainerRecord){\n                                for(EscherRecord er2 : (EscherContainerRecord)er) {\n                    for(EscherRecord shapeChildRecord : (EscherContainerRecord)er2) {\n                        int recordId = shapeChildRecord.getRecordId();\n                        if (recordId == EscherSpRecord.RECORD_ID){\n                            if (dg == null) {\n                                throw new RecordFormatException("EscherDgRecord wasn't set/processed before.");\n                            }\n                            EscherSpRecord sp = (EscherSpRecord)shapeChildRecord;\n                            int shapeId = drawingManager.allocateShapeId(dg);\n                                                        dg.setNumShapes(dg.getNumShapes()-1);\n                            sp.setShapeId(shapeId);\n                        } else if (recordId == EscherOptRecord.RECORD_ID){\n                            EscherOptRecord opt = (EscherOptRecord)shapeChildRecord;\n                            EscherSimpleProperty prop = opt.lookup(\n                                    EscherProperties.BLIP__BLIPTODISPLAY );\n                            if (prop != null){\n                                int pictureIndex = prop.getPropertyValue();\n                                                                EscherBSERecord bse = getBSERecord(pictureIndex);\n                                bse.setRef(bse.getRef() + 1);\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n    }
327	private static HashAlgorithm getDigestMethodAlgo(String digestMethodUri) {\n        if (digestMethodUri == null || digestMethodUri.isEmpty()) {\n            return null;\n        }\n        switch (digestMethodUri) {\n            case DigestMethod.SHA1:   return HashAlgorithm.sha1;\n            case DigestMethod_SHA224: return HashAlgorithm.sha224;\n            case DigestMethod.SHA256: return HashAlgorithm.sha256;\n            case DigestMethod_SHA384: return HashAlgorithm.sha384;\n            case DigestMethod.SHA512: return HashAlgorithm.sha512;\n            case DigestMethod.RIPEMD160: return HashAlgorithm.ripemd160;\n            default: throw new EncryptedDocumentException("Hash algorithm "\n                    +digestMethodUri+" not supported for signing.");\n        }\n    }
328	public boolean removeRun(int pos) {\n        if (pos >= 0 && pos < runs.size()) {\n                        XWPFRun run = runs.get(pos);\n            if (run instanceof XWPFHyperlinkRun ||\n                run instanceof XWPFFieldRun) {\n                                                throw new IllegalArgumentException("Removing Field or Hyperlink runs not yet supported");\n            }\n            runs.remove(pos);\n            iruns.remove(run);\n                                    int rPos = 0;\n            for(int i=0;i<pos;i++) {\n              XWPFRun currRun = runs.get(i);\n              if(!(currRun instanceof XWPFHyperlinkRun || currRun instanceof XWPFFieldRun)) {\n                rPos++;\n              }\n            }\n            getCTP().removeR(rPos);\n            return true;\n        }\n        return false;\n    }
329	private static int getDimensionsIndex(List<RecordBase> records) {\n		int nRecs = records.size();\n		for(int i=0; i<nRecs; i++) {\n			if(records.get(i) instanceof DimensionsRecord) {\n				return i;\n			}\n		}\n				throw new RuntimeException("DimensionsRecord not found");\n	}
330	private PackageRelationshipCollection getRelationshipsCore(String filter)\n            throws InvalidFormatException {\n        this._container.throwExceptionIfWriteOnly();\n        if (_relationships == null) {\n            this.throwExceptionIfRelationship();\n            _relationships = new PackageRelationshipCollection(this);\n        }\n        return new PackageRelationshipCollection(_relationships, filter);\n    }
331	private int appendChild(Record newChild) {\n				Record[] nc = new Record[(_children.length + 1)];\n		System.arraycopy(_children, 0, nc, 0, _children.length);\n				nc[_children.length] = newChild;\n		_children = nc;\n		return _children.length;\n	}
332	public static String compress(byte[] data) throws IOException {\n        java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\n        java.util.zip.GZIPOutputStream gz = new java.util.zip.GZIPOutputStream(bos);\n        gz.write(data);\n        gz.finish();\n        return DatatypeConverter.printBase64Binary(bos.toByteArray());        \n    }
333	public XSSFBorderFormatting createBorderFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTBorder border;\n        if(!dxf.isSetBorder()) {\n            border = dxf.addNewBorder();\n        } else {\n            border = dxf.getBorder();\n        }\n\n        return new XSSFBorderFormatting(border, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
334	String importBlip(String blipId, POIXMLDocumentPart parent) {\n        final XSLFPictureData parData = parent.getRelationPartById(blipId).getDocumentPart();\n        final XSLFPictureData pictureData;\n        if (getPackagePart().getPackage() == parent.getPackagePart().getPackage()) {\n                        pictureData = parData;\n        } else {\n            XMLSlideShow ppt = getSlideShow();\n            pictureData = ppt.addPicture(parData.getData(), parData.getType());\n        }\n\n        RelationPart rp = addRelation(blipId, XSLFRelation.IMAGES, pictureData);\n        return rp.getRelationship().getId();\n    }
335	public final void removeBreak(int main) {\n        Integer rowKey = Integer.valueOf(main);\n        Break region = _breakMap.get(rowKey);\n        _breaks.remove(region);\n        _breakMap.remove(rowKey);\n    }
336	private Ptg rowCopyRefPtg(RefPtgBase rptg) {\n        final int refRow = rptg.getRow();\n        if (rptg.isRowRelative()) {\n                        final int destRowIndex = _firstMovedIndex + _amountToMove;\n            if (destRowIndex < 0 || _version.getLastRowIndex() < destRowIndex) {\n                return createDeletedRef(rptg);\n            }\n\n                        final int newRowIndex = refRow + _amountToMove;\n            if(newRowIndex < 0 || _version.getLastRowIndex() < newRowIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            rptg.setRow(newRowIndex);\n            return rptg;\n        }\n        return null;\n    }
337	private ParseNode parseNonRange(int savePointer) {\n        resetPointer(savePointer);\n\n        if (Character.isDigit(look)) {\n            return new ParseNode(parseNumber());\n        }\n        if (look == '"') {\n            return new ParseNode(new StringPtg(parseStringLiteral()));\n        }\n        \n        // from now on we can only be dealing with non-quoted identifiers\n        // which will either be named ranges or functions\n        String name = parseAsName();\n\n        if (look == '(') {\n            return function(name);\n        }\n        if(look == '['){\n            return parseStructuredReference(name);\n        }\n        if (name.equalsIgnoreCase("TRUE") || name.equalsIgnoreCase("FALSE")) {\n            return  new ParseNode(BoolPtg.valueOf(name.equalsIgnoreCase("TRUE")));\n        }\n        if (_book == null) {\n            // Only test cases omit the book (expecting it not to be needed)\n            throw new IllegalStateException("Need book to evaluate name '" + name + "'");\n        }\n        EvaluationName evalName = _book.getName(name, _sheetIndex);\n        if (evalName == null) {\n            throw new FormulaParseException("Specified named range '"\n                    + name + "' does not exist in the current workbook.");\n        }\n        if (evalName.isRange()) {\n            return new ParseNode(evalName.createPtg());\n        }\n        // TODO - what about NameX ?\n        throw new FormulaParseException("Specified name '"\n                + name + "' is not a range as expected.");\n    }
338	private static WriteAccessRecord createWriteAccess() {\n        WriteAccessRecord retval = new WriteAccessRecord();\n\n        String defaultUserName = "POI";\n        try {\n            String username = System.getProperty("user.name");\n                        if(username == null) {\n                username = defaultUserName;\n            }\n\n            retval.setUsername(username);\n        } catch (AccessControlException e) {\n            LOG.log(POILogger.WARN, "can't determine user.name", e);\n                                    retval.setUsername(defaultUserName);\n        }\n        return retval;\n    }
339	public String makeConcise(String result, int form) {\n        if (form > 0) {\n            result = result.replaceAll("XLV", "VL");             result = result.replaceAll("XCV", "VC");             result = result.replaceAll("CDL", "LD");             result = result.replaceAll("CML", "LM");             result = result.replaceAll("CMVC", "LMVL");         }\n        if (form == 1) {\n            result = result.replaceAll("CDXC", "LDXL");             result = result.replaceAll("CDVC", "LDVL");             result = result.replaceAll("CMXC", "LMXL");             result = result.replaceAll("XCIX", "VCIV");             result = result.replaceAll("XLIX", "VLIV");         }\n        if (form > 1) {\n            result = result.replaceAll("XLIX", "IL");             result = result.replaceAll("XCIX", "IC");             result = result.replaceAll("CDXC", "XD");             result = result.replaceAll("CDVC", "XDV");             result = result.replaceAll("CDIC", "XDIX");             result = result.replaceAll("LMVL", "XMV");             result = result.replaceAll("CMIC", "XMIX");             result = result.replaceAll("CMXC", "XM");         }\n        if (form > 2) {\n            result = result.replaceAll("XDV", "VD");              result = result.replaceAll("XDIX", "VDIV");             result = result.replaceAll("XMV", "VM");             result = result.replaceAll("XMIX", "VMIV");         }\n        if (form == 4) {\n            result = result.replaceAll("VDIV", "ID");             result = result.replaceAll("VMIV", "IM");         }\n\n        return result;\n    }
340	public static <\n        S extends Shape<S,P>,\n        P extends TextParagraph<S,P,? extends TextRun>\n    > SlideShow<S,P> create(InputStream inp, String password) throws IOException, EncryptedDocumentException {\n        InputStream is = FileMagic.prepareToCheckMagic(inp);\n        FileMagic fm = FileMagic.valueOf(is);\n        \n        switch (fm) {\n        case OLE2:\n            POIFSFileSystem fs = new POIFSFileSystem(is);\n            return create(fs, password);\n        case OOXML:\n            return createXSLFSlideShow(is);\n        default:\n            throw new IOException("Your InputStream was neither an OLE2 stream, nor an OOXML stream");\n        }\n    }
341	protected static void setDigestAlgAndValue(\n            DigestAlgAndValueType digestAlgAndValue,\n            byte[] data,\n            HashAlgorithm digestAlgo) {\n        DigestMethodType digestMethod = digestAlgAndValue.addNewDigestMethod();\n        digestMethod.setAlgorithm(SignatureConfig.getDigestMethodUri(digestAlgo));\n        \n        MessageDigest messageDigest = CryptoFunctions.getMessageDigest(digestAlgo);\n        byte[] digestValue = messageDigest.digest(data);\n        digestAlgAndValue.setDigestValue(digestValue);\n    }
342	public int getNumBorders(CellAddress cell) {\n        Map<String, Object> cellProperties = _propertyTemplate.get(cell);\n        if (cellProperties == null) {\n            return 0;\n        }\n\n        int count = 0;\n        for (String property : cellProperties.keySet()) {\n            if (property.equals(CellUtil.BORDER_TOP))\n                count += 1;\n            if (property.equals(CellUtil.BORDER_BOTTOM))\n                count += 1;\n            if (property.equals(CellUtil.BORDER_LEFT))\n                count += 1;\n            if (property.equals(CellUtil.BORDER_RIGHT))\n                count += 1;\n        }\n        return count;\n    }
343	public void writeRow(int rownum, SXSSFRow row) throws IOException {\n        if (_numberOfFlushedRows == 0)\n            _lowestIndexOfFlushedRows = rownum;\n        _numberLastFlushedRow = Math.max(rownum, _numberLastFlushedRow);\n        _numberOfCellsOfLastFlushedRow = row.getLastCellNum();\n        _numberOfFlushedRows++;\n        beginRow(rownum, row);\n        Iterator<Cell> cells = row.allCellsIterator();\n        int columnIndex = 0;\n        while (cells.hasNext()) {\n            writeCell(columnIndex++, cells.next());\n        }\n        endRow();\n    }
344	public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IOException {\n        if (poifsDir.hasEntry("WordDocument")) {\n                        try {\n                return new WordExtractor(poifsDir);\n            } catch (OldWordFileFormatException e) {\n                return new Word6Extractor(poifsDir);\n            }\n        }\n\n        if (poifsDir.hasEntry(HSLFSlideShow.POWERPOINT_DOCUMENT)) {\n            return new SlideShowExtractor(SlideShowFactory.create(poifsDir));\n        }\n\n        if (poifsDir.hasEntry("VisioDocument")) {\n            return new VisioTextExtractor(poifsDir);\n        }\n\n        if (poifsDir.hasEntry("Quill")) {\n            return new PublisherTextExtractor(poifsDir);\n        }\n\n        final String[] outlookEntryNames = new String[] {\n                                                                                                "__substg1.0_1000001E",                 "__substg1.0_1000001F",                 "__substg1.0_0047001E",                 "__substg1.0_0047001F",                 "__substg1.0_0037001E",                 "__substg1.0_0037001F",         };\n        for (String entryName : outlookEntryNames) {\n            if (poifsDir.hasEntry(entryName)) {\n                return new OutlookTextExtactor(poifsDir);\n            }\n        }\n\n        throw new IllegalArgumentException("No supported documents found in the OLE2 stream");\n    }
345	public CellFormatResult apply(Cell c) {\n        switch (ultimateType(c)) {\n        case BLANK:\n            return apply("");\n        case BOOLEAN:\n            return apply(c.getBooleanCellValue());\n        case NUMERIC:\n            Double value = c.getNumericCellValue();\n            if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                if (DateUtil.isValidExcelDate(value)) {\n                    return apply(c.getDateCellValue(), value);\n                } else {\n                    return apply(INVALID_VALUE_FOR_FORMAT);\n                }\n            } else {\n                return apply(value);\n            }\n        case STRING:\n            return apply(c.getStringCellValue());\n        default:\n            return apply("?");\n        }\n    }
346	public static boolean hasLineBreakMeasurerBug() {\n        String version = System.getProperty("java.version");\n        String os = System.getProperty("os.name").toLowerCase(Locale.ROOT);\n        boolean ignore = Boolean.getBoolean("org.apache.poi.JvmBugs.LineBreakMeasurer.ignore");\n        boolean hasBug = (!ignore && (os.contains("win") && ("1.6.0_45".equals(version) || "1.7.0_21".equals(version))));\n        if (hasBug) {\n            LOG.log(POILogger.WARN, "JVM has LineBreakMeasurer bug - see POI bug #54904 - caller code might default to Lucida Sans");\n        }\n        return hasBug;\n    }
347	public XWPFPicture addPicture(InputStream pictureData, int pictureType, String filename, int width, int height)\n            throws InvalidFormatException, IOException {\n        String relationId;\n        XWPFPictureData picData;\n\n                                if (parent.getPart() instanceof XWPFHeaderFooter) {\n            XWPFHeaderFooter headerFooter = (XWPFHeaderFooter) parent.getPart();\n            relationId = headerFooter.addPictureData(pictureData, pictureType);\n            picData = (XWPFPictureData) headerFooter.getRelationById(relationId);\n        } else {\n            @SuppressWarnings("resource")\n            XWPFDocument doc = parent.getDocument();\n            relationId = doc.addPictureData(pictureData, pictureType);\n            picData = (XWPFPictureData) doc.getRelationById(relationId);\n        }\n\n                try {\n            CTDrawing drawing = run.addNewDrawing();\n            CTInline inline = drawing.addNewInline();\n\n                                    String xml =\n                    "<a:graphic xmlns:a=\"" + CTGraphicalObject.type.getName().getNamespaceURI() + "\">" +\n                            "<a:graphicData uri=\"" + CTPicture.type.getName().getNamespaceURI() + "\">" +\n                            "<pic:pic xmlns:pic=\"" + CTPicture.type.getName().getNamespaceURI() + "\" />" +\n                            "</a:graphicData>" +\n                            "</a:graphic>";\n            InputSource is = new InputSource(new StringReader(xml));\n            org.w3c.dom.Document doc = DocumentHelper.readDocument(is);\n            inline.set(XmlToken.Factory.parse(doc.getDocumentElement(), DEFAULT_XML_OPTIONS));\n\n                        inline.setDistT(0);\n            inline.setDistR(0);\n            inline.setDistB(0);\n            inline.setDistL(0);\n\n            CTNonVisualDrawingProps docPr = inline.addNewDocPr();\n            long id = getParent().getDocument().getDrawingIdManager().reserveNew();\n            docPr.setId(id);\n            \n            docPr.setName("Drawing " + id);\n            docPr.setDescr(filename);\n\n            CTPositiveSize2D extent = inline.addNewExtent();\n            extent.setCx(width);\n            extent.setCy(height);\n\n                        CTGraphicalObject graphic = inline.getGraphic();\n            CTGraphicalObjectData graphicData = graphic.getGraphicData();\n            CTPicture pic = getCTPictures(graphicData).get(0);\n\n                        CTPictureNonVisual nvPicPr = pic.addNewNvPicPr();\n\n            CTNonVisualDrawingProps cNvPr = nvPicPr.addNewCNvPr();\n            "0"\n            cNvPr.setId(0L);\n            \n            cNvPr.setName("Picture " + id);\n            cNvPr.setDescr(filename);\n\n            CTNonVisualPictureProperties cNvPicPr = nvPicPr.addNewCNvPicPr();\n            cNvPicPr.addNewPicLocks().setNoChangeAspect(true);\n\n            CTBlipFillProperties blipFill = pic.addNewBlipFill();\n            CTBlip blip = blipFill.addNewBlip();\n            blip.setEmbed(parent.getPart().getRelationId(picData));\n            blipFill.addNewStretch().addNewFillRect();\n\n            CTShapeProperties spPr = pic.addNewSpPr();\n            CTTransform2D xfrm = spPr.addNewXfrm();\n\n            CTPoint2D off = xfrm.addNewOff();\n            off.setX(0);\n            off.setY(0);\n\n            CTPositiveSize2D ext = xfrm.addNewExt();\n            ext.setCx(width);\n            ext.setCy(height);\n\n            CTPresetGeometry2D prstGeom = spPr.addNewPrstGeom();\n            prstGeom.setPrst(STShapeType.RECT);\n            prstGeom.addNewAvLst();\n\n                        XWPFPicture xwpfPicture = new XWPFPicture(pic, this);\n            pictures.add(xwpfPicture);\n            return xwpfPicture;\n        } catch (XmlException | SAXException e) {\n            throw new IllegalStateException(e);\n        }\n    }
348	static void sameCell(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue(84);\n        sheet.createRow(1).createCell(0).setCellValue(74);\n        sheet.createRow(2).createCell(0).setCellValue(50);\n        sheet.createRow(3).createCell(0).setCellValue(51);\n        sheet.createRow(4).createCell(0).setCellValue(49);\n        sheet.createRow(5).createCell(0).setCellValue(41);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule(ComparisonOperator.GT, "70");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n                ConditionalFormattingRule rule2 = sheetCF.createConditionalFormattingRule(ComparisonOperator.LT, "50");\n        PatternFormatting fill2 = rule2.createPatternFormatting();\n        fill2.setFillBackgroundColor(IndexedColors.GREEN.index);\n        fill2.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1, rule2);\n\n        sheet.getRow(0).createCell(2).setCellValue("<== Condition 1: Cell Value Is greater than 70 (Blue Fill)");\n        sheet.getRow(4).createCell(2).setCellValue("<== Condition 2: Cell Value Is less than 50 (Green Fill)");\n    }
349	private void buildSlidesAndNotes() {\n						if (_documentRecord == null) {\n			throw new CorruptPowerPointFileException(\n					"The PowerPoint file didn't contain a Document Record in its PersistPtr blocks. It is probably corrupt.");\n		}\n\n																																\n		findMasterSlides();\n\n		        Map<Integer,Integer> slideIdToNotes = new HashMap<>();\n\n                findNotesSlides(slideIdToNotes);\n\n				findSlides(slideIdToNotes);\n	}
350	public HSSFColor addColor( byte red, byte green, byte blue )\n    {\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        short i;\n        for (i = PaletteRecord.FIRST_COLOR_INDEX; i < PaletteRecord.STANDARD_PALETTE_SIZE + PaletteRecord.FIRST_COLOR_INDEX; b = _palette.getColor(++i))\n        {\n            if (b == null)\n            {\n                setColorAtIndex( i, red, green, blue );\n                return getColor(i);\n            }\n        }\n        throw new RuntimeException("Could not find free color index");\n    }
351	private void updateName(XSSFName name, String oldName, String newName) {\n        String formula = name.getRefersToFormula();\n        if (formula != null) {\n            int sheetIndex = name.getSheetIndex();\n            int rowIndex = -1;             Ptg[] ptgs = FormulaParser.parse(formula, _fpwb, FormulaType.NAMEDRANGE, sheetIndex, rowIndex);\n            for (Ptg ptg : ptgs) {\n                updatePtg(ptg, oldName, newName);\n            }\n            String updatedFormula = FormulaRenderer.toFormulaString(_fpwb, ptgs);\n            if (!formula.equals(updatedFormula)) name.setRefersToFormula(updatedFormula);\n        }\n    }
352	protected void breakText(Graphics2D graphics){\n        lines.clear();\n\n        DrawFactory fact = DrawFactory.getInstance(graphics);\n        fact.fixFonts(graphics);\n        StringBuilder text = new StringBuilder();\n        AttributedString at = getAttributedString(graphics, text);\n        boolean emptyParagraph = text.toString().trim().isEmpty();\n\n        AttributedCharacterIterator it = at.getIterator();\n        LineBreakMeasurer measurer = new LineBreakMeasurer(it, graphics.getFontRenderContext());\n        for (;;) {\n            int startIndex = measurer.getPosition();\n\n                        double wrappingWidth = getWrappingWidth(lines.isEmpty(), graphics) + 1;\n                        if(wrappingWidth < 0) {\n                wrappingWidth = 1;\n            }\n\n            int nextBreak = text.indexOf("\n", startIndex + 1);\n            if (nextBreak == -1) {\n                nextBreak = it.getEndIndex();\n            }\n\n            TextLayout layout = measurer.nextLayout((float)wrappingWidth, nextBreak, true);\n            if (layout == null) {\n                                                   layout = measurer.nextLayout((float)wrappingWidth, nextBreak, false);\n            }\n\n            if(layout == null) {\n                                break;\n            }\n\n            int endIndex = measurer.getPosition();\n                        if(endIndex < it.getEndIndex() && text.charAt(endIndex) == '\n'){\n                measurer.setPosition(endIndex + 1);\n            }\n\n            TextAlign hAlign = paragraph.getTextAlign();\n            if(hAlign == TextAlign.JUSTIFY || hAlign == TextAlign.JUSTIFY_LOW) {\n                layout = layout.getJustifiedLayout((float)wrappingWidth);\n            }\n\n            AttributedString str = (emptyParagraph)\n                ? null                 : new AttributedString(it, startIndex, endIndex);\n            DrawTextFragment line = fact.getTextFragment(layout, str);\n            lines.add(line);\n\n            maxLineHeight = Math.max(maxLineHeight, line.getHeight());\n\n            if(endIndex == it.getEndIndex()) {\n                break;\n            }\n        }\n\n        rawText = text.toString();\n    }
353	public static InternalWorkbook createWorkbook() {\n        LOG.log( DEBUG, "creating new workbook from scratch" );\n\n        InternalWorkbook retval = new InternalWorkbook();\n        List<Record> records = new ArrayList<>(30);\n        retval.records.setRecords(records);\n        List<FormatRecord> formats = retval.formats;\n\n        records.add(createBOF());\n        records.add(new InterfaceHdrRecord(CODEPAGE));\n        records.add(createMMS());\n        records.add(InterfaceEndRecord.instance);\n        records.add(createWriteAccess());\n        records.add(createCodepage());\n        records.add(createDSF());\n        records.add(createTabId());\n        retval.records.setTabpos(records.size() - 1);\n        records.add(createFnGroupCount());\n        records.add(createWindowProtect());\n        records.add(createProtect());\n        retval.records.setProtpos(records.size() - 1);\n        records.add(createPassword());\n        records.add(createProtectionRev4());\n        records.add(createPasswordRev4());\n        retval.windowOne = createWindowOne();\n        records.add(retval.windowOne);\n        records.add(createBackup());\n        retval.records.setBackuppos(records.size() - 1);\n        records.add(createHideObj());\n        records.add(createDateWindow1904());\n        records.add(createPrecision());\n        records.add(createRefreshAll());\n        records.add(createBookBool());\n        records.add(createFont());\n        records.add(createFont());\n        records.add(createFont());\n        records.add(createFont());\n        retval.records.setFontpos( records.size() - 1 );           retval.numfonts = 4;\n\n                for (int i = 0; i <= 7; i++) {\n            FormatRecord rec = createFormat(i);\n            retval.maxformatid = retval.maxformatid >= rec.getIndexCode() ? retval.maxformatid : rec.getIndexCode();\n            formats.add(rec);\n            records.add(rec);\n        }\n\n        for (int k = 0; k < 21; k++) {\n            records.add(InternalWorkbook.createExtendedFormat(k));\n            retval.numxfs++;\n        }\n        retval.records.setXfpos( records.size() - 1 );\n        for (int k = 0; k < 6; k++) {\n            records.add(InternalWorkbook.createStyle(k));\n        }\n        records.add(InternalWorkbook.createUseSelFS());\n\n        int nBoundSheets = 1;         for (int k = 0; k < nBoundSheets; k++) {\n            BoundSheetRecord bsr = createBoundSheet(k);\n\n            records.add(bsr);\n            retval.boundsheets.add(bsr);\n            retval.records.setBspos(records.size() - 1);\n        }\n        records.add( InternalWorkbook.createCountry() );\n        for ( int k = 0; k < nBoundSheets; k++ ) {\n            retval.getOrCreateLinkTable().checkExternSheet(k);\n        }\n        retval.sst = new SSTRecord();\n        records.add(retval.sst);\n        records.add(InternalWorkbook.createExtendedSST());\n\n        records.add(EOFRecord.instance);\n        LOG.log( DEBUG, "exit create new workbook from scratch" );\n\n        return retval;\n    }
354	public PackageRelationship addExternalRelationship(String target,\n            String relationshipType, String id) {\n        if (target == null) {\n            throw new IllegalArgumentException("target is null for type " + relationshipType);\n        }\n        if (relationshipType == null) {\n            throw new IllegalArgumentException("relationshipType");\n        }\n\n        if (_relationships == null) {\n            _relationships = new PackageRelationshipCollection();\n        }\n\n        URI targetURI;\n        try {\n            targetURI = new URI(target);\n        } catch (URISyntaxException e) {\n            throw new IllegalArgumentException("Invalid target - " + e);\n        }\n\n        return _relationships.addRelationship(targetURI, TargetMode.EXTERNAL,\n                relationshipType, id);\n    }
355	private static int findLastIndexInRunOfEqualValues(LookupValueComparer lookupComparer, ValueVector vector,\n				int firstFoundIndex, int maxIx) {\n		for(int i=firstFoundIndex+1; i<maxIx; i++) {\n			if(!lookupComparer.compareTo(vector.getItem(i)).isEqual()) {\n				return i-1;\n			}\n		}\n		return maxIx - 1;\n	}
356	public void setLogBase(double logBase) {\n        if (logBase < MIN_LOG_BASE || MAX_LOG_BASE < logBase) {\n            throw new IllegalArgumentException("Axis log base must be between 2 and 1000 (inclusive), got: " + logBase);\n        }\n        CTScaling scaling = getCTScaling();\n        if (scaling.isSetLogBase()) {\n            scaling.getLogBase().setVal(logBase);\n        } else {\n            scaling.addNewLogBase().setVal(logBase);\n        }\n    }
357	@SuppressWarnings("WeakerAccess")\n	public void reorderSlide(int oldSlideNumber, int newSlideNumber) {\n				if (oldSlideNumber < 1 || newSlideNumber < 1) {\n			throw new IllegalArgumentException("Old and new slide numbers must be greater than 0");\n		}\n		if (oldSlideNumber > _slides.size() || newSlideNumber > _slides.size()) {\n			throw new IllegalArgumentException(\n					"Old and new slide numbers must not exceed the number of slides ("\n							+ _slides.size() + ")");\n		}\n\n						SlideListWithText slwt = _documentRecord.getSlideSlideListWithText();\n		if (slwt == null) {\n			throw new IllegalStateException("Slide record not defined.");\n		}\n		SlideAtomsSet[] sas = slwt.getSlideAtomsSets();\n\n		SlideAtomsSet tmp = sas[oldSlideNumber - 1];\n		sas[oldSlideNumber - 1] = sas[newSlideNumber - 1];\n		sas[newSlideNumber - 1] = tmp;\n\n		Collections.swap(_slides, oldSlideNumber - 1, newSlideNumber - 1);\n		_slides.get(newSlideNumber - 1).setSlideNumber(newSlideNumber);\n		_slides.get(oldSlideNumber - 1).setSlideNumber(oldSlideNumber);\n\n		ArrayList<Record> lst = new ArrayList<>();\n		for (SlideAtomsSet s : sas) {\n			lst.add(s.getSlidePersistAtom());\n			lst.addAll(Arrays.asList(s.getSlideRecords()));\n		}\n\n		Record[] r = lst.toArray(new Record[0]);\n		slwt.setChildRecord(r);\n	}
358	private void newDrawing(){\n        CTShapeLayout layout = CTShapeLayout.Factory.newInstance();\n        layout.setExt(STExt.EDIT);\n        CTIdMap idmap = layout.addNewIdmap();\n        idmap.setExt(STExt.EDIT);\n        idmap.setData("1");\n        _items.add(layout);\n        _qnames.add(QNAME_SHAPE_LAYOUT);\n\n        CTShapetype shapetype = CTShapetype.Factory.newInstance();\n        _shapeTypeId = COMMENT_SHAPE_TYPE_ID;\n        shapetype.setId(_shapeTypeId);\n        shapetype.setCoordsize("21600,21600");\n        shapetype.setSpt(202);\n        shapetype.setPath2("m,l,21600r21600,l21600,xe");\n        shapetype.addNewStroke().setJoinstyle(STStrokeJoinStyle.MITER);\n        CTPath path = shapetype.addNewPath();\n        path.setGradientshapeok(STTrueFalse.T);\n        path.setConnecttype(STConnectType.RECT);\n        _items.add(shapetype);\n        _qnames.add(QNAME_SHAPE_TYPE);\n    }
359	public void updateEmbeddedDoc() throws OpenXML4JException, IOException {\n        List<PackagePart> embeddedDocs = this.doc.getAllEmbeddedParts();\n        for (PackagePart pPart : embeddedDocs) {\n            String ext = pPart.getPartName().getExtension();\n            if (BINARY_EXTENSION.equals(ext) || OPENXML_EXTENSION.equals(ext)) {\n                                                                                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is);\n                     OutputStream os = pPart.getOutputStream()) {\n                    Sheet sheet = workbook.getSheetAt(SHEET_NUM);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    cell.setCellValue(NEW_VALUE);\n                    workbook.write(os);\n                }\n            }\n        }\n\n        if (!embeddedDocs.isEmpty()) {\n                        try (FileOutputStream fos = new FileOutputStream(this.docFile)) {\n                this.doc.write(fos);\n            }\n        }\n    }
360	public static InputStream getDecryptedStream(final DirectoryNode root, String password)\n            throws IOException {\n        EncryptionInfo info = new EncryptionInfo(root);\n        Decryptor d = Decryptor.getInstance(info);\n\n        try {\n            boolean passwordCorrect = false;\n            if (password != null && d.verifyPassword(password)) {\n                passwordCorrect = true;\n            }\n            if (!passwordCorrect && d.verifyPassword(Decryptor.DEFAULT_PASSWORD)) {\n                passwordCorrect = true;\n            }\n\n            if (passwordCorrect) {\n                return d.getDataStream(root);\n            } else if (password != null) {\n                throw new EncryptedDocumentException("Password incorrect");\n            } else {\n                throw new EncryptedDocumentException("The supplied spreadsheet is protected, but no password was supplied");\n            }\n        } catch (GeneralSecurityException e) {\n            throw new IOException(e);\n        }\n    }
361	public void protectSheet(String password, boolean shouldProtectObjects,\n			boolean shouldProtectScenarios) {\n		if (password == null) {\n			_passwordRecord = null;\n			_protectRecord = null;\n			_objectProtectRecord = null;\n			_scenarioProtectRecord = null;\n			return;\n		}\n\n		ProtectRecord prec = getProtect();\n		PasswordRecord pass = getPassword();\n		prec.setProtect(true);\n		pass.setPassword((short)CryptoFunctions.createXorVerifier1(password));\n		if (_objectProtectRecord == null && shouldProtectObjects) {\n			ObjectProtectRecord rec = createObjectProtect();\n			rec.setProtect(true);\n			_objectProtectRecord = rec;\n		}\n		if (_scenarioProtectRecord == null && shouldProtectScenarios) {\n			ScenarioProtectRecord srec = createScenarioProtect();\n			srec.setProtect(true);\n			_scenarioProtectRecord = srec;\n		}\n	}
362	public Pointer[] createContainerPointers(Pointer parent, byte[] data) {\n                int numPointersOffset = parent.getNumPointersOffset(data);\n                int numPointers = parent.getNumPointers(numPointersOffset, data);\n                int skip = parent.getPostNumPointersSkip();\n\n                int pos = numPointersOffset + skip;\n        Pointer[] childPointers = new Pointer[numPointers];\n        for(int i=0; i<numPointers; i++) {\n            childPointers[i] = this.createPointer(data, pos);\n            pos += childPointers[i].getSizeInBytes();\n        }\n\n        return childPointers;\n    }
363	public ArrayList<PackagePart> getParts() throws InvalidFormatException {\n		throwExceptionIfWriteOnly();\n\n				if (partList == null) {\n			\n\n								    			boolean hasCorePropertiesPart = false;\n			boolean needCorePropertiesPart = true;\n\n			partList = getPartsImpl();\n			for (PackagePart part : new ArrayList<>(partList.sortedValues())) {\n			    part.loadRelationships();\n\n								if (ContentTypes.CORE_PROPERTIES_PART.equals(part.getContentType())) {\n					if (!hasCorePropertiesPart) {\n						hasCorePropertiesPart = true;\n					} else {\n					   logger.log(POILogger.WARN, "OPC Compliance error [M4.1]: " +\n					   		"there is more than one core properties relationship in the package! " +\n					   		"POI will use only the first, but other software may reject this file.");\n					}\n				}\n\n				PartUnmarshaller partUnmarshaller = partUnmarshallers.get(part._contentType);\n\n				if (partUnmarshaller != null) {\n					UnmarshallContext context = new UnmarshallContext(this, part._partName);\n					try {\n						PackagePart unmarshallPart = partUnmarshaller.unmarshall(context, part.getInputStream());\n						partList.remove(part.getPartName());\n						partList.put(unmarshallPart._partName, unmarshallPart);\n\n																		if (unmarshallPart instanceof PackagePropertiesPart &&\n								hasCorePropertiesPart &&\n								needCorePropertiesPart) {\n							this.packageProperties = (PackagePropertiesPart) unmarshallPart;\n							needCorePropertiesPart = false;\n						}\n					} catch (IOException ioe) {\n						logger.log(POILogger.WARN, "Unmarshall operation : IOException for "\n								+ part._partName);\n						continue;\n					} catch (InvalidOperationException invoe) {\n						throw new InvalidFormatException(invoe.getMessage(), invoe);\n					}\n				}\n			}\n		}\n		return new ArrayList<>(partList.sortedValues());\n	}
364	public XSSFTextBox createTextbox(XSSFClientAnchor anchor){\n        long shapeId = newShapeId();\n        CTTwoCellAnchor ctAnchor = createTwoCellAnchor(anchor);\n        CTShape ctShape = ctAnchor.addNewSp();\n        ctShape.set(XSSFSimpleShape.prototype());\n        ctShape.getNvSpPr().getCNvPr().setId(shapeId);\n        XSSFTextBox shape = new XSSFTextBox(this, ctShape);\n        shape.anchor = anchor;\n        return shape;\n\n    }
365	private static PackagePart getPartFromOPCPackage(OPCPackage pkg, String coreDocumentRel) {\n        PackageRelationship coreRel = pkg.getRelationshipsByType(coreDocumentRel).getRelationship(0);\n\n        if (coreRel != null) {\n            PackagePart pp = pkg.getPart(coreRel);\n            if (pp == null) {\n                throw new POIXMLException("OOXML file structure broken/invalid - core document '" + coreRel.getTargetURI() + "' not found.");\n            }\n            return pp;\n        }\n\n        coreRel = pkg.getRelationshipsByType(PackageRelationshipTypes.STRICT_CORE_DOCUMENT).getRelationship(0);\n        if (coreRel != null) {\n            throw new POIXMLException("Strict OOXML isn't currently supported, please see bug #57699");\n        }\n\n        throw new POIXMLException("OOXML file structure broken/invalid - no core document found!");\n    }
366	@SuppressWarnings("resource")\n    protected static HSLFHyperlink find(HSLFShape shape){\n        HSLFSlideShow ppt = shape.getSheet().getSlideShow();\n                ExObjList exobj = ppt.getDocumentRecord().getExObjList(false);\n        HSLFEscherClientDataRecord cldata = shape.getClientData(false);\n\n        if (exobj != null && cldata != null) {\n            List<HSLFHyperlink> lst = new ArrayList<>();\n            find(cldata.getHSLFChildRecords(), exobj, lst);\n            return lst.isEmpty() ? null : lst.get(0);\n        }\n\n        return null;\n    }
367	protected static synchronized void initXmlProvider() {\n        if (isInitialized) {\n            return;\n        }\n        isInitialized = true;\n\n        try {\n            Init.init();\n            RelationshipTransformService.registerDsigProvider();\n            CryptoFunctions.registerBouncyCastle();\n        } catch (Exception e) {\n            throw new RuntimeException("Xml & BouncyCastle-Provider initialization failed", e);\n        }\n    }
368	static void shadeBands(Sheet sheet) {\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("MOD(ROW(),6)<3");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:Z100")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.createRow(0).createCell(1).setCellValue("Shade Bands of Rows");\n        sheet.createRow(1).createCell(1).setCellValue("Condition: Formula Is  =MOD(ROW(),6)<2   (Light Grey Fill)");\n    }
369	private String decodeFlags( int flags )\n    {\n        StringBuffer result = new StringBuffer();\n        result.append( ( flags & FLAG_GROUP ) != 0 ? "|GROUP" : "" );\n        result.append( ( flags & FLAG_CHILD ) != 0 ? "|CHILD" : "" );\n        result.append( ( flags & FLAG_PATRIARCH ) != 0 ? "|PATRIARCH" : "" );\n        result.append( ( flags & FLAG_DELETED ) != 0 ? "|DELETED" : "" );\n        result.append( ( flags & FLAG_OLESHAPE ) != 0 ? "|OLESHAPE" : "" );\n        result.append( ( flags & FLAG_HAVEMASTER ) != 0 ? "|HAVEMASTER" : "" );\n        result.append( ( flags & FLAG_FLIPHORIZ ) != 0 ? "|FLIPHORIZ" : "" );\n        result.append( ( flags & FLAG_FLIPVERT ) != 0 ? "|FLIPVERT" : "" );\n        result.append( ( flags & FLAG_CONNECTOR ) != 0 ? "|CONNECTOR" : "" );\n        result.append( ( flags & FLAG_HAVEANCHOR ) != 0 ? "|HAVEANCHOR" : "" );\n        result.append( ( flags & FLAG_BACKGROUND ) != 0 ? "|BACKGROUND" : "" );\n        result.append( ( flags & FLAG_HASSHAPETYPE ) != 0 ? "|HASSHAPETYPE" : "" );\n\n                if(result.length() > 0) {\n            result.deleteCharAt(0);\n        }\n        return result.toString();\n    }
370	public static byte[][] decompress(byte[] data, int offset, int length) throws IOException {\n		ByteArrayInputStream bais = new ByteArrayInputStream(data, offset, length);\n\n				HDGFLZW lzw = new HDGFLZW();\n		byte[] decompressed = lzw.decompress(bais);\n\n				byte[][] ret = new byte[2][];\n		ret[0] = new byte[4];\n		ret[1] = new byte[decompressed.length - 4];\n\n		System.arraycopy(decompressed, 0, ret[0], 0, 4);\n		System.arraycopy(decompressed, 4, ret[1], 0, ret[1].length);\n\n				return ret;\n	}
371	public static XSSFBCellRange parse(byte[] data, int offset, XSSFBCellRange cellRange) {\n        if (cellRange == null) {\n            cellRange = new XSSFBCellRange();\n        }\n        cellRange.firstRow = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.lastRow = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.firstCol = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.lastCol = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset));\n\n        return cellRange;\n    }
372	public boolean verifyPassword(KeyPair keyPair, X509Certificate x509) throws GeneralSecurityException {\n        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)getEncryptionInfo().getVerifier();\n        AgileEncryptionHeader header = (AgileEncryptionHeader)getEncryptionInfo().getHeader();\n        HashAlgorithm hashAlgo = header.getHashAlgorithm();\n        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();\n        int blockSize = header.getBlockSize();\n        \n        AgileCertificateEntry ace = null;\n        for (AgileCertificateEntry aceEntry : ver.getCertificates()) {\n            if (x509.equals(aceEntry.x509)) {\n                ace = aceEntry;\n                break;\n            }\n        }\n        if (ace == null) {\n            return false;\n        }\n        \n        Cipher cipher = Cipher.getInstance("RSA");\n        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        byte keyspec[] = cipher.doFinal(ace.encryptedKey);\n        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);\n        \n        Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);\n        x509Hmac.init(secretKey);\n        byte certVerifier[] = x509Hmac.doFinal(ace.x509.getEncoded());\n\n        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); \n        cipher = getCipher(secretKey, cipherAlgo, header.getChainingMode(), vec, Cipher.DECRYPT_MODE);\n        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());\n        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);\n\n        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);\n        cipher = getCipher(secretKey, cipherAlgo, header.getChainingMode(), vec, Cipher.DECRYPT_MODE);\n        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());\n        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);\n        \n        \n        if (Arrays.equals(ace.certVerifier, certVerifier)) {\n            setSecretKey(secretKey);\n            setIntegrityHmacKey(hmacKey);\n            setIntegrityHmacValue(hmacValue);\n            return true;\n        } else {\n            return false;\n        }\n    }
373	public static double evaluate(double[] v) throws EvaluationException {\n		if (v.length < 2) {\n			throw new EvaluationException(ErrorEval.NA);\n		}\n\n				int[] counts = new int[v.length];\n		Arrays.fill(counts, 1);\n		for (int i = 0, iSize = v.length; i < iSize; i++) {\n			for (int j = i + 1, jSize = v.length; j < jSize; j++) {\n				if (v[i] == v[j])\n					counts[i]++;\n			}\n		}\n		double maxv = 0;\n		int maxc = 0;\n		for (int i = 0, iSize = counts.length; i < iSize; i++) {\n			if (counts[i] > maxc) {\n				maxv = v[i];\n				maxc = counts[i];\n			}\n		}\n		if (maxc > 1) {\n			return maxv;\n		}\n		throw new EvaluationException(ErrorEval.NA);\n\n	}
374	boolean changeName(final String oldName, final String newName)\n    {\n        boolean   rval  = false;\n        EntryNode child = ( EntryNode ) _byname.get(oldName);\n\n        if (child != null)\n        {\n            rval = (( DirectoryProperty ) getProperty())\n                .changeName(child.getProperty(), newName);\n            if (rval)\n            {\n                _byname.remove(oldName);\n                _byname.put(child.getProperty().getName(), child);\n            }\n        }\n        return rval;\n    }
375	public static NameType classifyCellReference(String str, SpreadsheetVersion ssVersion) {\n        int len = str.length();\n        if (len < 1) {\n            throw new IllegalArgumentException("Empty string not allowed");\n        }\n        char firstChar = str.charAt(0);\n        switch (firstChar) {\n            case ABSOLUTE_REFERENCE_MARKER:\n            case '.':\n            case '_':\n                break;\n            default:\n                if (!Character.isLetter(firstChar) && !Character.isDigit(firstChar)) {\n                    throw new IllegalArgumentException("Invalid first char (" + firstChar\n                            + ") of cell reference or named range.  Letter expected");\n                }\n        }\n        if (!Character.isDigit(str.charAt(len-1))) {\n                        return validateNamedRangeName(str, ssVersion);\n        }\n        Matcher cellRefPatternMatcher = STRICTLY_CELL_REF_PATTERN.matcher(str);\n        if (!cellRefPatternMatcher.matches()) {\n            return validateNamedRangeName(str, ssVersion);\n        }\n        String lettersGroup = cellRefPatternMatcher.group(1);\n        String digitsGroup = cellRefPatternMatcher.group(2);\n        if (cellReferenceIsWithinRange(lettersGroup, digitsGroup, ssVersion)) {\n                        return NameType.CELL;\n        }\n                                                if (str.indexOf(ABSOLUTE_REFERENCE_MARKER) >= 0) {\n                        return NameType.BAD_CELL_OR_NAMED_RANGE;\n        }\n        return NameType.NAMED_RANGE;\n    }
376	private void fixTabIdRecord() {\n        Record rec = records.get(records.getTabpos());\n\n                                if(records.getTabpos() <= 0) {\n            return;\n        }\n\n        TabIdRecord tir = ( TabIdRecord ) rec;\n        short[]     tia = new short[ boundsheets.size() ];\n\n        for (short k = 0; k < tia.length; k++) {\n            tia[ k ] = k;\n        }\n        tir.setTabIdArray(tia);\n    }
377	public void newDocumentLink() {\n        _range = new CellRangeAddress(0, 0, 0, 0);\n        _guid = STD_MONIKER;\n        _linkOpts = HLINK_LABEL | HLINK_PLACE;\n        setLabel("");\n        _moniker = FILE_MONIKER;\n        setAddress("");\n        setTextMark("");\n    }
378	protected void shift(int n) {\n        int rownum = getRowNum() + n;\n        String msg = "Row[rownum=" + getRowNum() + "] contains cell(s) included in a multi-cell array formula. " +\n                "You cannot change part of an array.";\n        for(Cell c : this){\n            ((XSSFCell)c).updateCellReferencesForShifting(msg);\n          }\n        setRowNum(rownum);\n    }
379	public void newUrlLink() {\n        _range = new CellRangeAddress(0, 0, 0, 0);\n        _guid = STD_MONIKER;\n        _linkOpts = HLINK_URL | HLINK_ABS | HLINK_LABEL;\n        setLabel("");\n        _moniker = URL_MONIKER;\n        setAddress("");\n        _uninterpretedTail = URL_TAIL;\n    }
380	private void setRunAttributes(CTFont ctFont, CTRPrElt pr){\n        if(ctFont.sizeOfBArray() > 0) pr.addNewB().setVal(ctFont.getBArray(0).getVal());\n        if(ctFont.sizeOfUArray() > 0) pr.addNewU().setVal(ctFont.getUArray(0).getVal());\n        if(ctFont.sizeOfIArray() > 0) pr.addNewI().setVal(ctFont.getIArray(0).getVal());\n        if(ctFont.sizeOfColorArray() > 0) {\n            CTColor c1 = ctFont.getColorArray(0);\n            CTColor c2 = pr.addNewColor();\n            if(c1.isSetAuto()) c2.setAuto(c1.getAuto());\n            if(c1.isSetIndexed()) c2.setIndexed(c1.getIndexed());\n            if(c1.isSetRgb()) c2.setRgb(c1.getRgb());\n            if(c1.isSetTheme()) c2.setTheme(c1.getTheme());\n            if(c1.isSetTint()) c2.setTint(c1.getTint());\n        }\n        if(ctFont.sizeOfSzArray() > 0) pr.addNewSz().setVal(ctFont.getSzArray(0).getVal());\n        if(ctFont.sizeOfNameArray() > 0) pr.addNewRFont().setVal(ctFont.getNameArray(0).getVal());\n        if(ctFont.sizeOfFamilyArray() > 0) pr.addNewFamily().setVal(ctFont.getFamilyArray(0).getVal());\n        if(ctFont.sizeOfSchemeArray() > 0) pr.addNewScheme().setVal(ctFont.getSchemeArray(0).getVal());\n        if(ctFont.sizeOfCharsetArray() > 0) pr.addNewCharset().setVal(ctFont.getCharsetArray(0).getVal());\n        if(ctFont.sizeOfCondenseArray() > 0) pr.addNewCondense().setVal(ctFont.getCondenseArray(0).getVal());\n        if(ctFont.sizeOfExtendArray() > 0) pr.addNewExtend().setVal(ctFont.getExtendArray(0).getVal());\n        if(ctFont.sizeOfVertAlignArray() > 0) pr.addNewVertAlign().setVal(ctFont.getVertAlignArray(0).getVal());\n        if(ctFont.sizeOfOutlineArray() > 0) pr.addNewOutline().setVal(ctFont.getOutlineArray(0).getVal());\n        if(ctFont.sizeOfShadowArray() > 0) pr.addNewShadow().setVal(ctFont.getShadowArray(0).getVal());\n        if(ctFont.sizeOfStrikeArray() > 0) pr.addNewStrike().setVal(ctFont.getStrikeArray(0).getVal());\n    }
381	public static long skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);\n        }\n        if (toSkip == 0) {\n            return 0L;\n        }\n        \n        if (SKIP_BYTE_BUFFER == null) {\n            SKIP_BYTE_BUFFER = new byte[SKIP_BUFFER_SIZE];\n        }\n        long remain = toSkip;\n        while (remain > 0) {\n                        final long n = input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));\n            if (n < 0) {                 break;\n            }\n            remain -= n;\n        }\n        if (toSkip == remain) {\n            return -1L;\n        }\n        return toSkip - remain;\n    }
382	private double convertOoxml2AwtAngle(double ooAngle, double width, double height) {\n        double aspect = (height / width);\n                double awtAngle = -ooAngle;\n                double awtAngle2 = awtAngle%360.;\n        double awtAngle3 = awtAngle-awtAngle2;\n                        switch ((int)(awtAngle2 / 90)) {\n            case -3:\n                                awtAngle3 -= 360;\n                awtAngle2 += 360;\n                break;\n            case -2:\n            case -1:\n                                awtAngle3 -= 180;\n                awtAngle2 += 180;\n                break;\n            default:\n            case 0:\n                                break;\n            case 2:\n            case 1:\n                                awtAngle3 += 180;\n                awtAngle2 -= 180;\n                break;\n            case 3:\n                                awtAngle3 += 360;\n                awtAngle2 -= 360;\n                break;\n        }\n\n                awtAngle = Math.toDegrees(Math.atan2(Math.tan(Math.toRadians(awtAngle2)), aspect)) + awtAngle3;\n        return awtAngle;\n    }
383	public boolean nameAlreadyExists(NameRecord name) {\n                for (int i = getNumNames() - 1; i >= 0; i--) {\n            NameRecord rec = getNameRecord(i);\n            if (rec != name) {\n                if (isDuplicatedNames(name, rec))\n                    return true;\n            }\n        }\n        return false;\n    }
384	private boolean isValid(Document xml) throws SAXException{\n        try{\n            String language = "http://www.w3.org/2001/XMLSchema";\n            SchemaFactory factory = SchemaFactory.newInstance(language);\n\n            Source source = new DOMSource(map.getSchema());\n            Schema schema = factory.newSchema(source);\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(xml));\n            \n                        return true;\n        } catch(IOException e) {\n            LOG.log(POILogger.ERROR, "document is not valid", e);\n        }\n\n        return false;\n    }
385	public void processRecords(InputStream in) throws RecordFormatException {\n		Record last_record = null;\n\n		RecordInputStream recStream = new RecordInputStream(in);\n\n		while (recStream.hasNextRecord()) {\n			recStream.nextRecord();\n			Record[] recs = RecordFactory.createRecord(recStream);   			if (recs.length > 1) {\n				for (Record rec : recs) {\n					if ( last_record != null ) {\n						if (!processRecord(last_record)) {\n							return;\n						}\n					}\n					last_record = rec; 				}										} else {\n				Record record = recs[ 0 ];\n\n				if (record != null) {\n					if (last_record != null) {\n						if (!processRecord(last_record)) {\n							return;\n						}\n					}\n					 last_record = record;\n				}\n			}\n		}\n\n		if (last_record != null) {\n			processRecord(last_record);\n		}\n	}
386	public void setBorderBetween(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetBetween() ? ct.getBetween() : ct.addNewBetween();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetBetween();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
387	public void paint(Graphics2D g) {\n        g.setBackground(Color.CYAN);\n        AffineTransform origTransform = g.getTransform();\n        for (Painting c : paintings) {\n            c.draw(g);\n        }\n        g.setTransform(origTransform);\n\n        clear();\n    }
388	private Ptg columnCopyAreaPtg(AreaPtgBase aptg) {\n        boolean changed = false;\n\n        final int aFirstColumn = aptg.getFirstColumn();\n        final int aLastColumn = aptg.getLastColumn();\n\n        if (aptg.isFirstColRelative()) {\n            final int destFirstColumnIndex = aFirstColumn + _amountToMove;\n            if (destFirstColumnIndex < 0 || _version.getLastColumnIndex() < destFirstColumnIndex)\n                return createDeletedRef(aptg);\n            aptg.setFirstColumn(destFirstColumnIndex);\n            changed = true;\n        }\n        if (aptg.isLastColRelative()) {\n            final int destLastColumnIndex = aLastColumn + _amountToMove;\n            if (destLastColumnIndex < 0 || _version.getLastColumnIndex() < destLastColumnIndex)\n                return createDeletedRef(aptg);\n            aptg.setLastColumn(destLastColumnIndex);\n            changed = true;\n        }\n        if (changed) {\n            aptg.sortTopLeftToBottomRight();\n        }\n\n        return changed ? aptg : null;\n    }
389	public double getSpaceBefore(){\n        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){\n            public boolean fetch(CTTextParagraphProperties props){\n                if(props.isSetSpcBef()){\n                    CTTextSpacing spc = props.getSpcBef();\n\n                    if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );\n                    else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );\n                    return true;\n                }\n                return false;\n            }\n        };\n        fetchParagraphProperty(fetcher);\n\n        return fetcher.getValue() == null ? 0 : fetcher.getValue();\n    }
390	public static synchronized CellFormat getInstance(Locale locale, String format) {\n        Map<String, CellFormat> formatMap = formatCache.get(locale);\n        if (formatMap == null) {\n            formatMap = new WeakHashMap<>();\n            formatCache.put(locale, formatMap);\n        }\n        CellFormat fmt = formatMap.get(format);\n        if (fmt == null) {\n            if (format.equals("General") || format.equals("@"))\n                fmt = createGeneralFormat(locale);\n            else\n                fmt = new CellFormat(locale, format);\n            formatMap.put(format, fmt);\n        }\n        return fmt;\n    }
391	public void updateHeaders() {\n        XSSFSheet sheet = (XSSFSheet)getParent();\n        CellReference ref = getStartCellReference();\n        if (ref == null) return;\n\n        int headerRow = ref.getRow();\n        int firstHeaderColumn = ref.getCol();\n        XSSFRow row = sheet.getRow(headerRow);\n        DataFormatter formatter = new DataFormatter();\n\n        if (row != null && row.getCTRow().validate()) {\n            int cellnum = firstHeaderColumn;\n            CTTableColumns ctTableColumns = getCTTable().getTableColumns();\n            if(ctTableColumns != null) {\n                for (CTTableColumn col : ctTableColumns.getTableColumnList()) {\n                    XSSFCell cell = row.getCell(cellnum);\n                    if (cell != null) {\n                        col.setName(formatter.formatCellValue(cell));\n                    }\n                    cellnum++;\n                }\n            }\n        }\n        tableColumns = null;\n        columnMap = null;\n        xmlColumnPrs = null;\n        commonXPath = null;\n    }
392	public static CellRangeAddress createEnclosingCellRange(CellRangeAddress crA, CellRangeAddress crB) {\n        if( crB == null) {\n            return crA.copy();\n        }\n        \n        int minRow = lt(crB.getFirstRow(),   crA.getFirstRow())   ?crB.getFirstRow()   :crA.getFirstRow();\n        int maxRow = gt(crB.getLastRow(),    crA.getLastRow())    ?crB.getLastRow()    :crA.getLastRow();\n        int minCol = lt(crB.getFirstColumn(),crA.getFirstColumn())?crB.getFirstColumn():crA.getFirstColumn();\n        int maxCol = gt(crB.getLastColumn(), crA.getLastColumn()) ?crB.getLastColumn() :crA.getLastColumn();\n\n        return new CellRangeAddress(minRow, maxRow, minCol, maxCol);\n    }
393	public int calculateWorkdays(double start, double end, double[] holidays) {\n        int saturdaysPast = this.pastDaysOfWeek(start, end, Calendar.SATURDAY);\n        int sundaysPast = this.pastDaysOfWeek(start, end, Calendar.SUNDAY);\n        int nonWeekendHolidays = this.calculateNonWeekendHolidays(start, end, holidays);\n        return (int) (end - start + 1) - saturdaysPast - sundaysPast - nonWeekendHolidays;\n    }
394	public static Calendar parseDate(String strVal) throws EvaluationException {\n        String[] parts = Pattern.compile("/").split(strVal);\n        if (parts.length != 3) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        String part2 = parts[2];\n        int spacePos = part2.indexOf(' ');\n        if (spacePos > 0) {\n                        part2 = part2.substring(0, spacePos);\n        }\n        int f0;\n        int f1;\n        int f2;\n        try {\n            f0 = Integer.parseInt(parts[0]);\n            f1 = Integer.parseInt(parts[1]);\n            f2 = Integer.parseInt(part2);\n        } catch (NumberFormatException e) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        if (f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)) {\n                        throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n\n        if (f0 >= 1900 && f0 < 9999) {\n                        return makeDate(f0, f1, f2);\n        }\n                        throw new RuntimeException("Unable to determine date format for text '" + strVal + "'");\n    }
395	private void paintDashDotDotBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             ((northBorderType == BorderStyle.DASH_DOT_DOT) ||\n              (northBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n        for (int l=x; l < width;) {\n          l=l+drawDashDotDot(g, l, y, thickness, true, true);\n        }\n\n      }\n\n      if (eastBorder &&\n              ((eastBorderType == BorderStyle.DASH_DOT_DOT) ||\n               (eastBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n\n      	g.setColor(eastColor);\n\n        for (int l=y;l < height;) {\n                    l=l+drawDashDotDot(g,width-1,l,thickness,false,false);\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.DASH_DOT_DOT) ||\n               (southBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(southBorderType);\n\n      	g.setColor(southColor);\n\n        for (int l=x; l < width;) {\n                    l=l+drawDashDotDot(g, l, height-1, thickness, true, false);\n        }\n      }\n\n      if (westBorder &&\n            ((westBorderType == BorderStyle.DASH_DOT_DOT) ||\n             (westBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int l=y;l < height;) {\n                    l=l+drawDashDotDot(g,x,l,thickness,false,true);\n        }\n\n      }\n   }
396	@Internal\n    public XWPFEndnote addEndnote(CTFtnEdn note) {\n        CTFtnEdn newNote = ctEndnotes.addNewEndnote();\n        newNote.set(note);\n        XWPFEndnote xNote = new XWPFEndnote(newNote, this);\n        listFootnote.add(xNote);\n        return xNote;\n    }
397	private static void applyAttributes(CTRPrElt pr, CTTextCharacterProperties rPr) {\n\n        if (pr.sizeOfBArray() > 0) {\n            rPr.setB(pr.getBArray(0).getVal());\n        }\n        if (pr.sizeOfUArray() > 0) {\n            STUnderlineValues.Enum u1 = pr.getUArray(0).getVal();\n            if (u1 == STUnderlineValues.SINGLE) {\n                rPr.setU(STTextUnderlineType.SNG);\n            } else if (u1 == STUnderlineValues.DOUBLE) {\n                rPr.setU(STTextUnderlineType.DBL);\n            } else if (u1 == STUnderlineValues.NONE) {\n                rPr.setU(STTextUnderlineType.NONE);\n            }\n        }\n        if (pr.sizeOfIArray() > 0) {\n            rPr.setI(pr.getIArray(0).getVal());\n        }\n\n        if (pr.sizeOfRFontArray() > 0) {\n            CTTextFont rFont = rPr.isSetLatin() ? rPr.getLatin() : rPr.addNewLatin();\n            rFont.setTypeface(pr.getRFontArray(0).getVal());\n        }\n\n        if (pr.sizeOfSzArray() > 0) {\n            int sz = (int) (pr.getSzArray(0).getVal() * 100);\n            rPr.setSz(sz);\n        }\n\n        if (pr.sizeOfColorArray() > 0) {\n            CTSolidColorFillProperties fill = rPr.isSetSolidFill() ? rPr.getSolidFill() : rPr.addNewSolidFill();\n            org.openxmlformats.schemas.spreadsheetml.x2006.main.CTColor xlsColor = pr.getColorArray(0);\n            if (xlsColor.isSetRgb()) {\n                CTSRgbColor clr = fill.isSetSrgbClr() ? fill.getSrgbClr() : fill.addNewSrgbClr();\n                clr.setVal(xlsColor.getRgb());\n            } else if (xlsColor.isSetIndexed()) {\n                HSSFColor indexed = HSSFColor.getIndexHash().get((int) xlsColor.getIndexed());\n                if (indexed != null) {\n                    byte[] rgb = new byte[3];\n                    rgb[0] = (byte) indexed.getTriplet()[0];\n                    rgb[1] = (byte) indexed.getTriplet()[1];\n                    rgb[2] = (byte) indexed.getTriplet()[2];\n                    CTSRgbColor clr = fill.isSetSrgbClr() ? fill.getSrgbClr() : fill.addNewSrgbClr();\n                    clr.setVal(rgb);\n                }\n            }\n        }\n    }
398	private void isCellFontBoldMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        boolean b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getBold();\n        boolean b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getBold();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 ? "" : "NOT ")+"BOLD",\n                (b2 ? "" : "NOT ")+"BOLD"\n            );\n        }\n    }
399	public void setBorderTop(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        if (ct == null) {\n            throw new RuntimeException("invalid paragraph state");\n        }\n\n        CTBorder pr = (ct.isSetTop()) ? ct.getTop() : ct.addNewTop();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetTop();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
400	private void validateSheetIndex(int index) {\n        int lastSheetIx = sheets.size() - 1;\n        if (index < 0 || index > lastSheetIx) {\n            String range = "(0.." +    lastSheetIx + ")";\n            if (lastSheetIx == -1) {\n                range = "(no sheets)";\n            }\n            throw new IllegalArgumentException("Sheet index ("\n                    + index +") is out of range " + range);\n        }\n    }
401	public void removeRelationship(String id) {\n        PackageRelationship rel = relationshipsByID.get(id);\n        if (rel != null) {\n            relationshipsByID.remove(rel.getId());\n            relationshipsByType.values().remove(rel);\n            internalRelationshipsByTargetName.values().remove(rel);\n        }\n    }
402	public void debug() {\n		System.err.println("Trailer is at " + trailerPointer.getOffset());\n		System.err.println("Trailer has type " + trailerPointer.getType());\n		System.err.println("Trailer has length " + trailerPointer.getLength());\n		System.err.println("Trailer has format " + trailerPointer.getFormat());\n\n		for(int i=0; i<trailer.getPointedToStreams().length; i++) {\n			Stream stream = trailer.getPointedToStreams()[i];\n			Pointer ptr = stream.getPointer();\n\n			System.err.println("Looking at pointer " + i);\n			System.err.println("\tType is " + ptr.getType() + "\t\t" + Integer.toHexString(ptr.getType()));\n			System.err.println("\tOffset is " + ptr.getOffset() + "\t\t" + Long.toHexString(ptr.getOffset()));\n			System.err.println("\tAddress is " + ptr.getAddress() + "\t" + Long.toHexString(ptr.getAddress()));\n			System.err.println("\tLength is " + ptr.getLength() + "\t\t" + Long.toHexString(ptr.getLength()));\n			System.err.println("\tFormat is " + ptr.getFormat() + "\t\t" + Long.toHexString(ptr.getFormat()));\n			System.err.println("\tCompressed is " + ptr.destinationCompressed());\n			System.err.println("\tStream is " + stream.getClass());\n\n			if(stream instanceof PointerContainingStream) {\n				PointerContainingStream pcs = (PointerContainingStream)stream;\n\n				if(pcs.getPointedToStreams() != null && pcs.getPointedToStreams().length > 0) {\n					System.err.println("\tContains " + pcs.getPointedToStreams().length + " other pointers/streams");\n					for(int j=0; j<pcs.getPointedToStreams().length; j++) {\n						Stream ss = pcs.getPointedToStreams()[j];\n						Pointer sptr = ss.getPointer();\n						System.err.println("\t\t" + j + " - Type is " + sptr.getType() + "\t\t" + Integer.toHexString(sptr.getType()));\n						System.err.println("\t\t" + j + " - Length is " + sptr.getLength() + "\t\t" + Long.toHexString(sptr.getLength()));\n					}\n				}\n			}\n\n			if(stream instanceof StringsStream) {\n				System.err.println("\t\t**strings**");\n				StringsStream ss = (StringsStream)stream;\n				System.err.println("\t\t" + ss._getContentsLength());\n			}\n		}\n	}
403	int getStartIdxOfTextRun(HSLFTextRun textrun) {\n        int idx = 0;\n        for (HSLFTextParagraph p : parentList) {\n            for (HSLFTextRun r : p) {\n                if (r == textrun) {\n                    return idx;\n                }\n                idx += r.getLength();\n            }\n        }\n        return -1;\n    }
404	public static OPCPackage clone(OPCPackage pkg, File file) throws OpenXML4JException, IOException {\n\n        String path = file.getAbsolutePath();\n\n        OPCPackage dest = OPCPackage.create(path);\n        PackageRelationshipCollection rels = pkg.getRelationships();\n        for (PackageRelationship rel : rels) {\n            PackagePart part = pkg.getPart(rel);\n            PackagePart part_tgt;\n            if (rel.getRelationshipType().equals(PackageRelationshipTypes.CORE_PROPERTIES)) {\n                copyProperties(pkg.getPackageProperties(), dest.getPackageProperties());\n                continue;\n            }\n            dest.addRelationship(part.getPartName(), rel.getTargetMode(), rel.getRelationshipType());\n            part_tgt = dest.createPart(part.getPartName(), part.getContentType());\n\n            OutputStream out = part_tgt.getOutputStream();\n            IOUtils.copy(part.getInputStream(), out);\n            out.close();\n\n            if(part.hasRelationships()) {\n                copy(pkg, part, dest, part_tgt);\n            }\n        }\n        dest.close();\n\n                new File(path).deleteOnExit();\n        return OPCPackage.open(path);\n    }
405	private short genericProcessEvents(HSSFRequest req, InputStream in)\n		throws HSSFUserException {\n		short userCode = 0;\n\n				RecordFactoryInputStream recordStream = new RecordFactoryInputStream(in, false);\n\n				while(true) {\n			Record r = recordStream.nextRecord();\n			if(r == null) {\n				break;\n			}\n			userCode = req.processRecord(r);\n			if (userCode != 0) {\n				break;\n			}\n		}\n\n				return userCode;\n	}
406	public Map<String, String> readMacros() throws IOException {\n        Map<String, Module> modules = readMacroModules();\n        Map<String, String> moduleSources = new HashMap<>();\n        for (Map.Entry<String, Module> entry : modules.entrySet()) {\n            moduleSources.put(entry.getKey(), entry.getValue().getContent());\n        }\n        return moduleSources;\n    }
407	public int findFirstRecordLocBySid( short sid ) {         int max = _records.size();\n        for (int i=0; i< max; i++) {\n            Object rb = _records.get(i);\n            if (!(rb instanceof Record)) {\n                continue;\n            }\n            Record record = (Record) rb;\n            if (record.getSid() == sid) {\n                return i;\n            }\n        }\n        return -1;\n    }
408	private static boolean isValidRangeOperand(ParseNode a) {\n        Ptg tkn = a.getToken();\n                if (tkn instanceof OperandPtg) {\n                        return true;\n        }\n\n                if (tkn instanceof AbstractFunctionPtg) {\n            AbstractFunctionPtg afp = (AbstractFunctionPtg) tkn;\n            byte returnClass = afp.getDefaultOperandClass();\n            return Ptg.CLASS_REF == returnClass;\n        }\n        if (tkn instanceof ValueOperatorPtg) {\n            return false;\n        }\n        if (tkn instanceof OperationPtg) {\n            return true;\n        }\n\n                if (tkn instanceof ParenthesisPtg) {\n                        return isValidRangeOperand(a.getChildren()[0]);\n        }\n\n                if (tkn == ErrPtg.REF_INVALID) {\n            return true;\n        }\n\n                return false;\n    }
409	protected static List<ValueEval> getValidationValuesForConstraint(DataValidationContext context) {\n        final DataValidationConstraint val = context.getValidation().getValidationConstraint();\n        if (val.getValidationType() != ValidationType.LIST) return null;\n        \n        String formula = val.getFormula1();\n        \n        final List<ValueEval> values = new ArrayList<>();\n        \n        if (val.getExplicitListValues() != null && val.getExplicitListValues().length > 0) {\n                        for (String s : val.getExplicitListValues()) {\n                if (s != null) values.add(new StringEval(s));             }\n        } else if (formula != null) {\n                                    ValueEval eval = context.getEvaluator().getWorkbookEvaluator().evaluateList(formula, context.getTarget(), context.getRegion());\n                                    if (eval instanceof TwoDEval) {\n                TwoDEval twod = (TwoDEval) eval;\n                for (int i=0; i < twod.getHeight(); i++) {\n                    final ValueEval cellValue = twod.getValue(i,  0);\n                    values.add(cellValue);\n                }\n            }\n        }\n        return Collections.unmodifiableList(values);\n    }
410	private static BorderStyle getBorderStyle(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        BorderStyle border;\n        if (value instanceof BorderStyle) {\n            border = (BorderStyle) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map uses Short values for "\n                        + name + ". Should use BorderStyle enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            border = BorderStyle.valueOf(code);\n        }\n        else if (value == null) {\n            border = BorderStyle.NONE;\n        }\n        else {\n            throw new RuntimeException("Unexpected border style class. Must be BorderStyle or Short (deprecated).");\n        }\n        return border;\n    }
411	public void createFreezePane(int colSplit, int rowSplit, int topRow, int leftmostColumn) {\n        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n        if (paneLoc != -1)\n            _records.remove(paneLoc);\n\n                if(colSplit == 0 && rowSplit == 0){\n            windowTwo.setFreezePanes(false);\n            windowTwo.setFreezePanesNoSplit(false);\n            SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n            if (sel != null) {\n                sel.setPane(PaneInformation.PANE_UPPER_LEFT);\n            }\n            return;\n        }\n\n        int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n        PaneRecord pane = new PaneRecord();\n        pane.setX((short)colSplit);\n        pane.setY((short)rowSplit);\n        pane.setTopRow((short) topRow);\n        pane.setLeftColumn((short) leftmostColumn);\n        if (rowSplit == 0) {\n            pane.setTopRow((short)0);\n            pane.setActivePane((short)1);\n        } else if (colSplit == 0) {\n            pane.setLeftColumn((short)0);\n            pane.setActivePane((short)2);\n        } else {\n            pane.setActivePane((short)0);\n        }\n        _records.add(loc+1, pane);\n\n        windowTwo.setFreezePanes(true);\n        windowTwo.setFreezePanesNoSplit(true);\n\n        SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n        if (sel != null) {\n            sel.setPane((byte) pane.getActivePane());\n        }\n    }
412	private int findFirstRow(int firstrow) {\n        int rownum = firstrow + 1;\n        HSSFRow r = getRow(rownum);\n\n        while (r == null && rownum <= getLastRowNum()) {\n            r = getRow(++rownum);\n        }\n\n        if (rownum > getLastRowNum())\n            return 0;\n\n        return rownum;\n    }
413	private void createChart() {\n        CTPlotArea plotArea = getCTPlotArea();\n\n        plotArea.addNewLayout();\n        chart.addNewPlotVisOnly().setVal(true);\n\n        CTPrintSettings printSettings = chartSpace.addNewPrintSettings();\n        printSettings.addNewHeaderFooter();\n\n        CTPageMargins pageMargins = printSettings.addNewPageMargins();\n        pageMargins.setB(0.75);\n        pageMargins.setL(0.70);\n        pageMargins.setR(0.70);\n        pageMargins.setT(0.75);\n        pageMargins.setHeader(0.30);\n        pageMargins.setFooter(0.30);\n        printSettings.addNewPageSetup();\n    }
414	protected void processCommands() {\n		if(commandDefinitions == null) {\n			throw new IllegalStateException("You must supply the command definitions before calling processCommands!");\n		}\n\n						ArrayList<Command> commandList = new ArrayList<>();\n		for(CommandDefinition cdef : commandDefinitions) {\n			int type = cdef.getType();\n			int offset = cdef.getOffset();\n\n						if(type == 10) {\n				name = cdef.getName();\n				continue;\n			} else if(type == 18) {\n				continue;\n			}\n\n\n						Command command;\n			if(type == 11 || type == 21) {\n				command = new BlockOffsetCommand(cdef);\n			} else {\n				command = new Command(cdef);\n			}\n\n									switch(type) {\n			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n			case 11: case 21:\n			case 12: case 16: case 17: case 18: case 28: case 29:\n								break;\n			default:\n								if(offset >= 19) {\n					offset -= 19;\n				}\n			}\n\n						if(offset >= contents.length) {\n				logger.log(POILogger.WARN,\n						"Command offset " + offset + " past end of data at " + contents.length\n				);\n				continue;\n			}\n\n			try {\n								switch(type) {\n								case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n					int val = contents[offset] & (1<<type);\n					command.value = Boolean.valueOf(val > 0);\n					break;\n				case 8:\n					command.value = Byte.valueOf(contents[offset]);\n					break;\n				case 9:\n					command.value = Double.valueOf(\n							LittleEndian.getDouble(contents, offset)\n					);\n					break;\n				case 12:\n															\n										if(contents.length < 8) {\n						command.value = "";\n						break;\n					}\n\n										int startsAt = 8;\n					int endsAt = startsAt;\n					for(int j=startsAt; j<contents.length-1 && endsAt == startsAt; j++) {\n						if(contents[j] == 0 && contents[j+1] == 0) {\n							endsAt = j;\n						}\n					}\n					if(endsAt == startsAt) {\n						endsAt = contents.length;\n					}\n\n					int strLen = endsAt - startsAt;\n					command.value = new String(contents, startsAt, strLen, header.getChunkCharset().name());\n					break;\n				case 25:\n					command.value = Short.valueOf(\n						LittleEndian.getShort(contents, offset)\n					);\n					break;\n				case 26:\n					command.value = Integer.valueOf(\n							LittleEndian.getInt(contents, offset)\n					);\n					break;\n\n								case 11: case 21:\n					if(offset < contents.length - 3) {\n						int bOffset = (int)LittleEndian.getUInt(contents, offset);\n						BlockOffsetCommand bcmd = (BlockOffsetCommand)command;\n						bcmd.setOffset(bOffset);\n					}\n					break;\n\n				default:\n					logger.log(POILogger.INFO,\n							"Command of type " + type + " not processed!");\n				}\n			}\n			catch (Exception e) {\n				logger.log(POILogger.ERROR, "Unexpected error processing command, ignoring and continuing. Command: " +\n						command, e);\n			}\n\n						commandList.add(command);\n		}\n\n				this.commands = commandList.toArray(\n							new Command[commandList.size()] );\n\n					}
415	public PackagePart createPart(PackagePartName partName, String contentType,\n			ByteArrayOutputStream content) {\n		PackagePart addedPart = this.createPart(partName, contentType);\n		if (addedPart == null) {\n			return null;\n		}\n				if (content != null) {\n			try {\n				OutputStream partOutput = addedPart.getOutputStream();\n				if (partOutput == null) {\n					return null;\n				}\n\n				partOutput.write(content.toByteArray(), 0, content.size());\n				partOutput.close();\n\n			} catch (IOException ioe) {\n				return null;\n			}\n		} else {\n			return null;\n		}\n		return addedPart;\n	}
416	public String getText() {\n        StringBuffer text = new StringBuffer();\n        \n                CodepageRecord codepage = null;\n        \n                while (ris.hasNextRecord()) {\n            int sid = ris.getNextSid();\n            ris.nextRecord();\n\n            switch (sid) {\n                case  FILE_PASS_RECORD_SID:\n                    throw new EncryptedDocumentException("Encryption not supported for Old Excel files");\n\n                case OldSheetRecord.sid:\n                    OldSheetRecord shr = new OldSheetRecord(ris);\n                    shr.setCodePage(codepage);\n                    text.append("Sheet: ");\n                    text.append(shr.getSheetname());\n                    text.append('\n');\n                    break;\n            \n                case OldLabelRecord.biff2_sid:\n                case OldLabelRecord.biff345_sid:\n                    OldLabelRecord lr = new OldLabelRecord(ris);\n                    lr.setCodePage(codepage);\n                    text.append(lr.getValue());\n                    text.append('\n');\n                    break;\n                case OldStringRecord.biff2_sid:\n                case OldStringRecord.biff345_sid:\n                    OldStringRecord sr = new OldStringRecord(ris);\n                    sr.setCodePage(codepage);\n                    text.append(sr.getString());\n                    text.append('\n');\n                    break;\n                    \n                case NumberRecord.sid:\n                    NumberRecord nr = new NumberRecord(ris);\n                    handleNumericCell(text, nr.getValue());\n                    break;\n                case OldFormulaRecord.biff2_sid:\n                case OldFormulaRecord.biff3_sid:\n                case OldFormulaRecord.biff4_sid:\n                                        if (biffVersion == 5) {\n                        FormulaRecord fr = new FormulaRecord(ris);\n                        if (fr.getCachedResultType() == CellType.NUMERIC.getCode()) {\n                            handleNumericCell(text, fr.getValue());\n                        }\n                    } else {\n                        OldFormulaRecord fr = new OldFormulaRecord(ris);\n                        if (fr.getCachedResultType() == CellType.NUMERIC.getCode()) {\n                            handleNumericCell(text, fr.getValue());\n                        }\n                    }\n                    break;\n                case RKRecord.sid:\n                    RKRecord rr = new RKRecord(ris);\n                    handleNumericCell(text, rr.getRKNumber());\n                    break;\n                    \n                case CodepageRecord.sid:\n                    codepage = new CodepageRecord(ris);\n                    break;\n                    \n                default:\n                    ris.readFully(IOUtils.safelyAllocate(ris.remaining(), MAX_RECORD_LENGTH));\n            }\n        }\n\n        close();\n        ris = null;\n\n        return text.toString();\n    }
417	protected static HSLFTextRun appendText(List<HSLFTextParagraph> paragraphs, String text, boolean newParagraph) {\n        text = toInternalString(text);\n\n                assert(!paragraphs.isEmpty() && !paragraphs.get(0).getTextRuns().isEmpty());\n\n        HSLFTextParagraph htp = paragraphs.get(paragraphs.size() - 1);\n        HSLFTextRun htr = htp.getTextRuns().get(htp.getTextRuns().size() - 1);\n\n        boolean addParagraph = newParagraph;\n        for (String rawText : text.split("(?<=\r)")) {\n                        boolean lastRunEmpty = (htr.getLength() == 0);\n            boolean lastParaEmpty = lastRunEmpty && (htp.getTextRuns().size() == 1);\n\n            if (addParagraph && !lastParaEmpty) {\n                TextPropCollection tpc = htp.getParagraphStyle();\n                HSLFTextParagraph prevHtp = htp;\n                htp = new HSLFTextParagraph(htp._headerAtom, htp._byteAtom, htp._charAtom, paragraphs);\n                htp.getParagraphStyle().copy(tpc);\n                htp.setParentShape(prevHtp.getParentShape());\n                htp.setShapeId(prevHtp.getShapeId());\n                htp.supplySheet(prevHtp.getSheet());\n                paragraphs.add(htp);\n            }\n            addParagraph = true;\n\n            if (!lastRunEmpty) {\n                TextPropCollection tpc = htr.getCharacterStyle();\n                htr = new HSLFTextRun(htp);\n                htr.getCharacterStyle().copy(tpc);\n                htp.addTextRun(htr);\n            }\n            htr.setText(rawText);\n        }\n\n        storeText(paragraphs);\n\n        return htr;\n    }
418	public static CustomGeometry convertCustomGeometry(XMLStreamReader staxReader) {\n        try {\n            JAXBContext jaxbContext = JAXBContext.newInstance(BINDING_PACKAGE);\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            JAXBElement<CTCustomGeometry2D> el = unmarshaller.unmarshal(staxReader, CTCustomGeometry2D.class);\n            return new CustomGeometry(el.getValue());\n        } catch (JAXBException e) {\n            LOG.log(POILogger.ERROR, "Unable to parse single custom geometry", e);\n            return null;\n        }\n    }
419	public boolean release(long id) {\n        if (id < lowerbound || id > upperbound) {\n            throw new IllegalArgumentException("Value for parameter 'id' was out of bounds, had " + id + ", but should be within [" + lowerbound + ":" + upperbound + "]");\n        }\n\n        if (id == upperbound) {\n            Segment lastSegment = segments.getLast();\n            if (lastSegment.end == upperbound - 1) {\n                lastSegment.end = upperbound;\n                return true;\n            } else if (lastSegment.end == upperbound) {\n                return false;\n            } else {\n                segments.add(new Segment(upperbound, upperbound));\n                return true;\n            }\n        }\n\n        if (id == lowerbound) {\n            Segment firstSegment = segments.getFirst();\n            if (firstSegment.start == lowerbound + 1) {\n                firstSegment.start = lowerbound;\n                return true;\n            } else if (firstSegment.start == lowerbound) {\n                return false;\n            } else {\n                segments.addFirst(new Segment(lowerbound, lowerbound));\n                return true;\n            }\n        }\n\n        long higher = id + 1;\n        long lower = id - 1;\n        ListIterator<Segment> iter = segments.listIterator();\n\n        while (iter.hasNext()) {\n            Segment segment = iter.next();\n            if (segment.end < lower) {\n                continue;\n            }\n            if (segment.start > higher) {\n                iter.previous();\n                iter.add(new Segment(id, id));\n                return true;\n            }\n            if (segment.start == higher) {\n                segment.start = id;\n                return true;\n            }\n            else if (segment.end == lower) {\n                segment.end = id;\n                \n                if (iter.hasNext()) {\n                  Segment next = iter.next();\n                    if (next.start == segment.end + 1) {\n                        segment.end = next.end;\n                        iter.remove();\n                    }\n                }\n                return true;\n            }\n            else {\n                \n                break;\n            }\n        }\n        return false;\n    }
420	protected final void recurseClearCachedFormulaResults() {\n		FormulaCellCacheEntry[] formulaCells = getConsumingCells();\n\n		for (int i = 0; i < formulaCells.length; i++) {\n			FormulaCellCacheEntry fc = formulaCells[i];\n			fc.clearFormulaEntry();\n			fc.recurseClearCachedFormulaResults();\n		}\n	}
421	public void addBreak(int main, int subFrom, int subTo) {\n\n        Integer key = Integer.valueOf(main);\n        Break region = _breakMap.get(key);\n        if(region == null) {\n            region = new Break(main, subFrom, subTo);\n            _breakMap.put(key, region);\n            _breaks.add(region);\n        } else {\n            region.main = main;\n            region.subFrom = subFrom;\n            region.subTo = subTo;\n        }\n    }
422	private void saveCSVFile(File file)\n                                     throws FileNotFoundException, IOException {\n        ArrayList<String> line;\n        StringBuffer buffer;\n        String csvLineElement;\n\n                try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {\n\n            System.out.println("Saving the CSV file [" + file.getName() + "]");\n\n                                                for(int i = 0; i < this.csvData.size(); i++) {\n                buffer = new StringBuffer();\n\n                                                                                                                                                                                                                line = this.csvData.get(i);\n                for(int j = 0; j < this.maxRowWidth; j++) {\n                    if(line.size() > j) {\n                        csvLineElement = line.get(j);\n                        if(csvLineElement != null) {\n                            buffer.append(this.escapeEmbeddedCharacters(\n                                    csvLineElement));\n                        }\n                    }\n                    if(j < (this.maxRowWidth - 1)) {\n                        buffer.append(this.separator);\n                    }\n                }\n\n                                bw.write(buffer.toString().trim());\n\n                                                                if(i < (this.csvData.size() - 1)) {\n                    bw.newLine();\n                }\n            }\n        }\n    }
423	public void addNum(BigInteger abstractNumID, BigInteger numID) {\n        CTNum ctNum = this.ctNumbering.addNewNum();\n        ctNum.addNewAbstractNumId();\n        ctNum.getAbstractNumId().setVal(abstractNumID);\n        ctNum.setNumId(numID);\n        XWPFNum num = new XWPFNum(ctNum, this);\n        nums.add(num);\n    }
424	public static void main(String[] args) {\n                                                                                                                                                ToCSV converter;\n        boolean converted = true;\n        long startTime = System.currentTimeMillis();\n        try {\n            converter = new ToCSV();\n            if(args.length == 2) {\n                                                converter.convertExcelToCSV(args[0], args[1]);\n            }\n            else if(args.length == 3){\n                                                converter.convertExcelToCSV(args[0], args[1], args[2]);\n            }\n            else if(args.length == 4) {\n                                                converter.convertExcelToCSV(args[0], args[1],\n                                            args[2], Integer.parseInt(args[3]));\n            }\n            else {\n                                                System.out.println("Usage: java ToCSV [Source File/Folder] " +\n                    "[Destination Folder] [Separator] [Formatting Convention]\n" +\n                    "\tSource File/Folder\tThis argument should contain the name of and\n" +\n                    "\t\t\t\tpath to either a single Excel workbook or a\n" +\n                    "\t\t\t\tfolder containing one or more Excel workbooks.\n" +\n                    "\tDestination Folder\tThe name of and path to the folder that the\n" +\n                    "\t\t\t\tCSV files should be written out into. The\n" +\n                    "\t\t\t\tfolder must exist before running the ToCSV\n" +\n                    "\t\t\t\tcode as it will not check for or create it.\n" +\n                    "\tSeparator\t\tOptional. The character or characters that\n" +\n                    "\t\t\t\tshould be used to separate fields in the CSV\n" +\n                    "\t\t\t\trecord. If no value is passed then the comma\n" +\n                    "\t\t\t\twill be assumed.\n" +\n                    "\tFormatting Convention\tOptional. This argument can take one of two\n" +\n                    "\t\t\t\tvalues. Passing 0 (zero) will result in a CSV\n" +\n                    "\t\t\t\tfile that obeys Excel's formatting conventions\n" +\n                    "\t\t\t\twhilst passing 1 (one) will result in a file\n" +\n                    "\t\t\t\tthat obeys UNIX formatting conventions. If no\n" +\n                    "\t\t\t\tvalue is passed, then the CSV file produced\n" +\n                    "\t\t\t\twill obey Excel's formatting conventions.");\n                converted = false;\n            }\n        }\n                                                        catch(Exception ex) {\n            System.out.println("Caught an: " + ex.getClass().getName());\n            System.out.println("Message: " + ex.getMessage());\n            System.out.println("Stacktrace follows:.....");\n            ex.printStackTrace(System.out);\n            converted = false;\n        }\n        \n        if (converted) {\n            System.out.println("Conversion took " + \n                  (int)((System.currentTimeMillis() - startTime)/1000) + " seconds");\n        }\n    }
425	public CellRangeAddress8Bit removeArrayFormula(int rowIndex, int columnIndex) {\n		for (ArrayRecord ar : _arrayRecords) {\n			if (ar.isInRange(rowIndex, columnIndex)) {\n				_arrayRecords.remove(ar);\n				return ar.getRange();\n			}\n		}\n		String ref = new CellReference(rowIndex, columnIndex, false, false).formatAsString();\n		throw new IllegalArgumentException("Specified cell " + ref\n				+ " is not part of an array formula.");\n	}
426	private void paintNormalBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n\n      if (northBorder &&\n             ((northBorderType == BorderStyle.THIN) ||\n              (northBorderType == BorderStyle.MEDIUM) ||\n              (northBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x,y+k,width,y+k);\n        }\n      }\n\n      if (eastBorder &&\n             ((eastBorderType == BorderStyle.THIN) ||\n              (eastBorderType == BorderStyle.MEDIUM) ||\n              (eastBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(width-k,y,width-k,height);\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.THIN) ||\n               (southBorderType == BorderStyle.MEDIUM) ||\n               (southBorderType == BorderStyle.THICK)\n              )\n         ) {\n\n        int thickness = getThickness(southBorderType);\n\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x,height - k,width,height - k);\n        }\n      }\n\n      if (westBorder &&\n             ((westBorderType == BorderStyle.THIN) ||\n              (westBorderType == BorderStyle.MEDIUM) ||\n              (westBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x+k,y,x+k,height);\n        }\n      }\n   }
427	public final RelationPart createRelationship(POIXMLRelation descriptor, POIXMLFactory factory, int idx, boolean noRelation) {\n        try {\n            PackagePartName ppName = PackagingURIHelper.createPartName(descriptor.getFileName(idx));\n            PackageRelationship rel = null;\n            PackagePart part = packagePart.getPackage().createPart(ppName, descriptor.getContentType());\n            if (!noRelation) {\n                \n                rel = packagePart.addRelationship(ppName, TargetMode.INTERNAL, descriptor.getRelation());\n            }\n            POIXMLDocumentPart doc = factory.newDocumentPart(descriptor);\n            doc.packagePart = part;\n            doc.parent = this;\n            if (!noRelation) {\n                \n                addRelation(rel, doc);\n            }\n\n            return new RelationPart(rel, doc);\n        } catch (PartAlreadyExistsException pae) {\n                                    throw pae;\n        } catch (Exception e) {\n                        throw new POIXMLException(e);\n        }\n    }
428	private void paintDoubleBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             northBorderType == BorderStyle.DOUBLE) {\n\n      	g.setColor(northColor);\n\n        int leftx=x;\n        int rightx=width;\n\n                                        if (westBorder)\n           leftx = x+3;\n\n        if (eastBorder)\n           rightx = width-3;\n\n           g.drawLine(x,y,width,y);\n           g.drawLine(leftx,y+2,rightx,y+2);\n      }\n\n      if (eastBorder &&\n              eastBorderType == BorderStyle.DOUBLE\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; \n      	g.setColor(eastColor);\n\n        int topy=y;\n        int bottomy=height;\n\n        if (northBorder)\n          topy=y+3;\n\n        if (southBorder)\n            bottomy=height-3;\n\n        g.drawLine(width-1,y,width-1,height);\n        g.drawLine(width-3,topy,width-3,bottomy);\n      }\n\n      if (southBorder &&\n              southBorderType == BorderStyle.DOUBLE\n         ) {\n\n      	g.setColor(southColor);\n\n        int leftx=y;\n        int rightx=width;\n\n        if (westBorder)\n           leftx=x+3;\n\n        if (eastBorder)\n           rightx=width-3;\n\n\n        g.drawLine(x,height - 1,width,height - 1);\n        g.drawLine(leftx,height - 3,rightx,height - 3);\n      }\n\n      if (westBorder &&\n            westBorderType == BorderStyle.DOUBLE\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        int topy=y;\n        int bottomy=height-3;\n\n        if (northBorder)\n           topy=y+2;\n\n        if (southBorder)\n           bottomy=height-3;\n\n        g.drawLine(x,y,x,height);\n        g.drawLine(x+2,topy,x+2,bottomy);\n      }\n   }
429	public static int convertColStringToIndex(String ref) {\n        int retval=0;\n        char[] refs = ref.toUpperCase(Locale.ROOT).toCharArray();\n        for (int k=0; k<refs.length; k++) {\n            char thechar = refs[k];\n            if (thechar == ABSOLUTE_REFERENCE_MARKER) {\n                if (k != 0) {\n                    throw new IllegalArgumentException("Bad col ref format '" + ref + "'");\n                }\n                continue;\n            }\n\n                        retval = (retval * 26) + (thechar - 'A' + 1);\n        }\n        return retval-1;\n    }
430	@SuppressWarnings("deprecation")\n    private void buildRunsInOrderFromXml(XmlObject object) {\n        XmlCursor c = object.newCursor();\n        c.selectPath("child::*");\n        while (c.toNextSelection()) {\n            XmlObject o = c.getObject();\n            if (o instanceof CTR) {\n                XWPFRun r = new XWPFRun((CTR) o, this);\n                runs.add(r);\n                iruns.add(r);\n            }\n            if (o instanceof CTHyperlink) {\n                CTHyperlink link = (CTHyperlink)o;\n                for (CTR r : link.getRArray()) {\n                    XWPFHyperlinkRun hr = new XWPFHyperlinkRun(link, r, this);\n                    runs.add(hr);\n                    iruns.add(hr);\n                }\n            }\n            if (o instanceof CTSimpleField) {\n                CTSimpleField field = (CTSimpleField)o;\n                for (CTR r : field.getRArray()) {\n                    XWPFFieldRun fr = new XWPFFieldRun(field, r, this);\n                    runs.add(fr);\n                    iruns.add(fr);\n                }\n            }\n            if (o instanceof CTSdtBlock) {\n                XWPFSDT cc = new XWPFSDT((CTSdtBlock) o, part);\n                iruns.add(cc);\n            }\n            if (o instanceof CTSdtRun) {\n                XWPFSDT cc = new XWPFSDT((CTSdtRun) o, part);\n                iruns.add(cc);\n            }\n            if (o instanceof CTRunTrackChange) {\n                for (CTR r : ((CTRunTrackChange) o).getRArray()) {\n                    XWPFRun cr = new XWPFRun(r, this);\n                    runs.add(cr);\n                    iruns.add(cr);\n                }\n            }\n            if (o instanceof CTSmartTagRun) {\n                                                buildRunsInOrderFromXml(o);\n            }\n            if (o instanceof CTRunTrackChange) {\n                                for (CTRunTrackChange change : ((CTRunTrackChange) o).getInsArray()) {\n                    buildRunsInOrderFromXml(change);\n                }\n            }\n        }\n        c.dispose();\n    }
431	public short findNewDrawingGroupId() {\n        BitSet bs = new BitSet();\n        bs.set(0);\n        for (FileIdCluster fic : field_5_fileIdClusters) {\n            bs.set(fic.getDrawingGroupId());\n        }\n        return (short)bs.nextClearBit(0);\n    }
432	public void setBorderRight(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetRight() ? ct.getRight() : ct.addNewRight();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetRight();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
433	public static void createShapeTree(EscherContainerRecord container, EscherAggregate agg, HSSFShapeContainer out, DirectoryNode root) {\n        if (container.getRecordId() == EscherContainerRecord.SPGR_CONTAINER) {\n            ObjRecord obj = null;\n            EscherClientDataRecord clientData = ((EscherContainerRecord) container.getChild(0)).getChildById(EscherClientDataRecord.RECORD_ID);\n            if (null != clientData) {\n                obj = (ObjRecord) agg.getShapeToObjMapping().get(clientData);\n            }\n            HSSFShapeGroup group = new HSSFShapeGroup(container, obj);\n            List<EscherContainerRecord> children = container.getChildContainers();\n                        for (int i = 0; i < children.size(); i++) {\n                EscherContainerRecord spContainer = children.get(i);\n                if (i != 0) {\n                    createShapeTree(spContainer, agg, group, root);\n                }\n            }\n            out.addShape(group);\n        } else if (container.getRecordId() == EscherContainerRecord.SP_CONTAINER) {\n            Map<EscherRecord, Record> shapeToObj = agg.getShapeToObjMapping();\n            ObjRecord objRecord = null;\n            TextObjectRecord txtRecord = null;\n\n            for (EscherRecord record : container) {\n                switch (record.getRecordId()) {\n                    case EscherClientDataRecord.RECORD_ID:\n                        objRecord = (ObjRecord) shapeToObj.get(record);\n                        break;\n                    case EscherTextboxRecord.RECORD_ID:\n                        txtRecord = (TextObjectRecord) shapeToObj.get(record);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (objRecord == null) {\n                throw new RecordFormatException("EscherClientDataRecord can't be found.");\n            }\n            if (isEmbeddedObject(objRecord)) {\n                HSSFObjectData objectData = new HSSFObjectData(container, objRecord, root);\n                out.addShape(objectData);\n                return;\n            }\n            CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord) objRecord.getSubRecords().get(0);\n            final HSSFShape shape;\n            switch (cmo.getObjectType()) {\n                case CommonObjectDataSubRecord.OBJECT_TYPE_PICTURE:\n                    shape = new HSSFPicture(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_RECTANGLE:\n                    shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_LINE:\n                    shape = new HSSFSimpleShape(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_COMBO_BOX:\n                    shape = new HSSFCombobox(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING:\n                    EscherOptRecord optRecord = container.getChildById(EscherOptRecord.RECORD_ID);\n                    if(optRecord == null) {\n                    	shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                    } else {\n                        EscherProperty property = optRecord.lookup(EscherProperties.GEOMETRY__VERTICES);\n                        if (null != property) {\n                            shape = new HSSFPolygon(container, objRecord, txtRecord);\n                        } else {\n                            shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                        }\n                    }\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_TEXT:\n                    shape = new HSSFTextbox(container, objRecord, txtRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_COMMENT:\n                    shape = new HSSFComment(container, objRecord, txtRecord, agg.getNoteRecordByObj(objRecord));\n                    break;\n                default:\n                    shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n            }\n            out.addShape(shape);\n        }\n    }
434	private void updateHeaderFooterText(String[] parts) {\n		String _left = parts[0];\n		String _center = parts[1];\n		String _right = parts[2];\n		\n		if (_center.length() < 1 && _left.length() < 1 && _right.length() < 1) {\n			setHeaderFooterText("");\n			return;\n		}\n		StringBuilder sb = new StringBuilder(64);\n		sb.append("&C");\n		sb.append(_center);\n		sb.append("&L");\n		sb.append(_left);\n		sb.append("&R");\n		sb.append(_right);\n		String text = sb.toString();\n		setHeaderFooterText(text);\n	}
435	private void unhookOldEnvironments(WorkbookEvaluator[] evaluators) {\n        Set<CollaboratingWorkbooksEnvironment> oldEnvs = new HashSet<>();\n        for(int i=0; i<evaluators.length; i++) {\n            oldEnvs.add(evaluators[i].getEnvironment());\n        }\n        CollaboratingWorkbooksEnvironment[] oldCWEs = new CollaboratingWorkbooksEnvironment[oldEnvs.size()];\n        oldEnvs.toArray(oldCWEs);\n        for (int i = 0; i < oldCWEs.length; i++) {\n            oldCWEs[i].unhook();\n        }\n    }
436	public void exportToXML(OutputStream os, String encoding, boolean validate) throws SAXException, TransformerException{\n        List<XSSFSingleXmlCell> singleXMLCells = map.getRelatedSingleXMLCell();\n        List<XSSFTable> tables = map.getRelatedTables();\n\n        String rootElement = map.getCtMap().getRootElement();\n\n        Document doc = DocumentHelper.createDocument();\n\n        final Element root;\n\n        if (isNamespaceDeclared()) {\n            root = doc.createElementNS(getNamespace(),rootElement);\n        } else {\n            root = doc.createElementNS("", rootElement);\n        }\n        doc.appendChild(root);\n\n\n        List<String> xpaths = new Vector<>();\n        Map<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<>();\n        Map<String,XSSFTable> tableMappings = new HashMap<>();\n\n        for(XSSFSingleXmlCell simpleXmlCell : singleXMLCells) {\n            xpaths.add(simpleXmlCell.getXpath());\n            singleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);\n        }\n        for(XSSFTable table : tables) {\n            String commonXPath = table.getCommonXpath();\n            xpaths.add(commonXPath);\n            tableMappings.put(commonXPath, table);\n        }\n\n        indexMap.clear();\n        xpaths.sort(this);\n        indexMap.clear();\n        \n        for(String xpath : xpaths) {\n\n            XSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);\n            XSSFTable table = tableMappings.get(xpath);\n\n            if (!xpath.matches(".*\\[.*")) {\n\n                                if (simpleXmlCell!=null) {\n                    XSSFCell cell = simpleXmlCell.getReferencedCell();\n                    if (cell!=null) {\n                        Node currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);\n                        mapCellOnNode(cell,currentNode);\n                        \n                                                                        if ("".equals(currentNode.getTextContent()) && currentNode.getParentNode() != null) {\n                            currentNode.getParentNode().removeChild(currentNode);\n                        }\n                    }\n                }\n\n                                if (table!=null) {\n\n                    List<XSSFTableColumn> tableColumns = table.getColumns();\n\n                    XSSFSheet sheet = table.getXSSFSheet();\n\n                    int startRow = table.getStartCellReference().getRow() + table.getHeaderRowCount();\n                    int endRow = table.getEndCellReference().getRow();\n\n                    for(int i = startRow; i<= endRow; i++) {\n                        XSSFRow row = sheet.getRow(i);\n\n                        Node tableRootNode = getNodeByXPath(table.getCommonXpath(), doc.getFirstChild(), doc, true);\n\n                        short startColumnIndex = table.getStartCellReference().getCol();\n                        for (XSSFTableColumn tableColumn : tableColumns) {\n                            XSSFCell cell = row.getCell(startColumnIndex + tableColumn.getColumnIndex());\n                            if (cell != null) {\n                                XSSFXmlColumnPr xmlColumnPr = tableColumn.getXmlColumnPr();\n                                if (xmlColumnPr != null) {\n                                    String localXPath = xmlColumnPr.getLocalXPath();\n                                    Node currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);\n                                    mapCellOnNode(cell, currentNode);\n                                }\n                            }\n                        }\n                    }\n                }\n            } \n        }\n\n        boolean isValid = true;\n        if (validate) {\n            isValid =isValid(doc);\n        }\n\n        if (isValid) {\n\n                        \n                        TransformerFactory transfac = TransformerFactory.newInstance();\n            Transformer trans = transfac.newTransformer();\n            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");\n            trans.setOutputProperty(OutputKeys.INDENT, "yes");\n            trans.setOutputProperty(OutputKeys.ENCODING, encoding);\n\n            \n            StreamResult result = new StreamResult(os);\n            DOMSource source = new DOMSource(doc);\n            trans.transform(source, result);\n\n        }\n    }
437	private int calculateNewLastCellPlusOne(int lastcell) {\n        int cellIx = lastcell - 1;\n        HSSFCell r = retrieveCell(cellIx);\n\n        while (r == null) {\n            if (cellIx < 0) {\n                return 0;\n            }\n            r = retrieveCell(--cellIx);\n        }\n        return cellIx+1;\n    }
438	public static InternalWorkbook createWorkbook(List<Record> recs) {\n        LOG.log(DEBUG, "Workbook (readfile) created with reclen=", recs.size());\n        InternalWorkbook retval = new InternalWorkbook();\n        List<Record> records = new ArrayList<>(recs.size() / 3);\n        retval.records.setRecords(records);\n\n        boolean eofPassed = false;\n        for (int k = 0; k < recs.size(); k++) {\n            Record rec = recs.get(k);\n            String logObj;\n            switch (rec.getSid()) {\n\n                case EOFRecord.sid :\n                    logObj = "workbook eof";\n                    break;\n\n                case BoundSheetRecord.sid :\n                    logObj = "boundsheet";\n                    retval.boundsheets.add((BoundSheetRecord) rec);\n                    retval.records.setBspos( k );\n                    break;\n\n                case SSTRecord.sid :\n                    logObj = "sst";\n                    retval.sst = ( SSTRecord ) rec;\n                    break;\n\n                case FontRecord.sid :\n                    logObj = "font";\n                    retval.records.setFontpos( k );\n                    retval.numfonts++;\n                    break;\n\n                case ExtendedFormatRecord.sid :\n                    logObj = "XF";\n                    retval.records.setXfpos( k );\n                    retval.numxfs++;\n                    break;\n\n                case TabIdRecord.sid :\n                    logObj = "tabid";\n                    retval.records.setTabpos( k );\n                    break;\n\n                case ProtectRecord.sid :\n                    logObj = "protect";\n                    retval.records.setProtpos( k );\n                    break;\n\n                case BackupRecord.sid :\n                    logObj = "backup";\n                    retval.records.setBackuppos( k );\n                    break;\n\n                case ExternSheetRecord.sid :\n                    throw new RecordFormatException("Extern sheet is part of LinkTable");\n\n                case NameRecord.sid :\n                case SupBookRecord.sid :\n                                        LOG.log(DEBUG, "found SupBook record at " + k);\n                    retval.linkTable = new LinkTable(recs, k, retval.records, retval.commentRecords);\n                    k+=retval.linkTable.getRecordCount() - 1;\n                    continue;\n\n                case FormatRecord.sid :\n                    logObj = "format";\n                    FormatRecord fr = (FormatRecord) rec;\n                    retval.formats.add(fr);\n                    retval.maxformatid = retval.maxformatid >= fr.getIndexCode() ? retval.maxformatid : fr.getIndexCode();\n                    break;\n\n                case DateWindow1904Record.sid :\n                    logObj = "datewindow1904";\n                    retval.uses1904datewindowing = ((DateWindow1904Record)rec).getWindowing() == 1;\n                    break;\n\n                case PaletteRecord.sid:\n                    logObj = "palette";\n                    retval.records.setPalettepos( k );\n                    break;\n\n                case WindowOneRecord.sid:\n                    logObj = "WindowOneRecord";\n                    retval.windowOne = (WindowOneRecord) rec;\n                    break;\n\n                case WriteAccessRecord.sid:\n                    logObj = "WriteAccess";\n                    retval.writeAccess = (WriteAccessRecord) rec;\n                    break;\n\n                case WriteProtectRecord.sid:\n                    logObj = "WriteProtect";\n                    retval.writeProtect = (WriteProtectRecord) rec;\n                    break;\n\n                case FileSharingRecord.sid:\n                    logObj = "FileSharing";\n                    retval.fileShare = (FileSharingRecord) rec;\n                    break;\n\n                case NameCommentRecord.sid:\n                    logObj = "NameComment";\n                    final NameCommentRecord ncr = (NameCommentRecord) rec;\n                    retval.commentRecords.put(ncr.getNameText(), ncr);\n                    break;\n\n                case HyperlinkRecord.sid:\n                                        logObj = "Hyperlink";\n                    retval.hyperlinks.add((HyperlinkRecord)rec);\n                    break;\n\n                default:\n                    logObj = "(sid=" + rec.getSid() + ")";\n                    break;\n            }\n            if (!eofPassed) {\n                records.add(rec);\n            }\n            LOG.log(DEBUG, "found "+logObj+" record at " + k);\n            if (rec.getSid() == EOFRecord.sid) {\n                eofPassed = true;\n            }\n        }\n                                        \n        if (retval.windowOne == null) {\n            retval.windowOne = createWindowOne();\n        }\n        LOG.log(DEBUG, "exit create workbook from existing file function");\n        return retval;\n    }
439	private CTTextParagraphProperties getDefaultMasterStyle(){\n        CTPlaceholder ph = _shape.getPlaceholderDetails().getCTPlaceholder(false);\n        String defaultStyleSelector;  \n        switch(ph == null ? -1 : ph.getType().intValue()) {\n            case STPlaceholderType.INT_TITLE:\n            case STPlaceholderType.INT_CTR_TITLE:\n                defaultStyleSelector = "titleStyle";\n                break;\n            case -1:             case STPlaceholderType.INT_FTR:\n            case STPlaceholderType.INT_SLD_NUM:\n            case STPlaceholderType.INT_DT:\n                defaultStyleSelector = "otherStyle";\n                break;\n            default:\n                defaultStyleSelector = "bodyStyle";\n                break;\n        }\n        int level = getIndentLevel();\n\n                final String nsPML = "http://schemas.openxmlformats.org/presentationml/2006/main";\n        XSLFSheet masterSheet = _shape.getSheet();\n        for (XSLFSheet m = masterSheet; m != null; m = (XSLFSheet)m.getMasterSheet()) {\n            masterSheet = m;\n            XmlObject xo = masterSheet.getXmlObject();\n            XmlCursor cur = xo.newCursor();\n            try {\n                cur.push();\n                if ((cur.toChild(nsPML, "txStyles") && cur.toChild(nsPML, defaultStyleSelector)) ||\n            		(cur.pop() && cur.toChild(nsPML, "notesStyle"))) {\n                    while (level >= 0) {\n                        cur.push();\n                    	if (cur.toChild(XSLFRelation.NS_DRAWINGML, "lvl" +(level+1)+ "pPr")) {\n                    		return (CTTextParagraphProperties)cur.getObject();\n                    	}\n                    	cur.pop();\n                    	level--;\n                    }\n                }\n            } finally {\n            	cur.dispose();\n            }\n        }\n        \n        return null;\n    }
440	public DirectoryEntry createDirectory(final String name)\n        throws IOException\n    {\n        DirectoryProperty property = new DirectoryProperty(name);\n\n        DirectoryNode rval = new DirectoryNode(property, _nfilesystem, this);\n       _nfilesystem.addDirectory(property);\n\n        (( DirectoryProperty ) getProperty()).addChild(property);\n        _entries.add(rval);\n        _byname.put(name, rval);\n        return rval;\n    }
441	public void addStyle(XWPFStyle style) {\n        listStyle.add(style);\n        ctStyles.addNewStyle();\n        int pos = ctStyles.sizeOfStyleArray() - 1;\n        ctStyles.setStyleArray(pos, style.getCTStyle());\n    }
442	public int serialize( int offset, byte[] data ) {\n        LOG.log( DEBUG, "Serializing Workbook with offsets" );\n\n        int pos = 0;\n\n        SSTRecord lSST = null;\n        int sstPos = 0;\n        boolean wroteBoundSheets = false;\n        for ( Record record : records.getRecords() ) {\n            int len = 0;\n            if (record instanceof SSTRecord) {\n                lSST = (SSTRecord)record;\n                sstPos = pos;\n            }\n            if (record.getSid() == ExtSSTRecord.sid && lSST != null) {\n                record = lSST.createExtSSTRecord(sstPos + offset);\n            }\n            if (record instanceof BoundSheetRecord) {\n                 if(!wroteBoundSheets) {\n                    for (BoundSheetRecord bsr : boundsheets) {\n                        len += bsr.serialize(pos+offset+len, data);\n                    }\n                    wroteBoundSheets = true;\n                 }\n            } else {\n               len = record.serialize( pos + offset, data );\n            }\n            pos += len;\n        }\n        \n        LOG.log( DEBUG, "Exiting serialize workbook" );\n        return pos;\n    }
443	private void openWorkbook(File file) throws FileNotFoundException,\n                                           IOException {\n        System.out.println("Opening workbook [" + file.getName() + "]");\n        try (FileInputStream fis = new FileInputStream(file)) {\n\n                                                            this.workbook = WorkbookFactory.create(fis);\n            this.evaluator = this.workbook.getCreationHelper().createFormulaEvaluator();\n            this.formatter = new DataFormatter(true);\n        }\n    }
444	public void preWrite() {\n        List<Property> pList = new ArrayList<>();\n                int i=0;\n        for (Property p : _properties) {\n                        if (p == null) continue;\n            p.setIndex(i++);\n            pList.add(p);\n        }\n\n                for (Property p : pList) p.preWrite();\n    }
445	public static boolean isValidPartName(URI partUri) {\n		if (partUri == null)\n			throw new IllegalArgumentException("partUri");\n\n		try {\n			createPartName(partUri);\n			return true;\n		} catch (Exception e) {\n			return false;\n		}\n	}
446	private void output8Codes(OutputStream res) throws IOException {\n		res.write(new byte[] { HDGFLZW.fromInt(nextMask) } );\n	res.write(buffer, 0, bufferLen);\n\n		nextMask = 0;\n	maskBitsSet = 0;\n	bufferLen = 0;\n}
447	public void multiLevelBulletedListInCell(HSSFWorkbook workbook,\n                                             ArrayList<MultiLevelListItem> multiLevelListItems,\n                                             HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n                        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n                for(MultiLevelListItem multiLevelListItem : multiLevelListItems) {\n                                    buffer.append(InCellLists.BULLET_CHARACTER);\n            buffer.append(" ");\n            buffer.append(multiLevelListItem.getItemText());\n            buffer.append("\n");\n                                    ArrayList<String> lowerLevelItems = multiLevelListItem.getLowerLevelItems();\n            if(!(lowerLevelItems == null) && !(lowerLevelItems.isEmpty())) {\n                for(String item : lowerLevelItems) {\n                    buffer.append(InCellLists.TAB);\n                    buffer.append(InCellLists.BULLET_CHARACTER);\n                    buffer.append(" ");\n                    buffer.append(item);\n                    buffer.append("\n");\n                }\n            }\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
448	protected void read(POIXMLFactory factory, Map<PackagePart, POIXMLDocumentPart> context) throws OpenXML4JException {\n        PackagePart pp = getPackagePart();\n                POIXMLDocumentPart otherChild = context.put(pp, this);\n        if (otherChild != null && otherChild != this) {\n            throw new POIXMLException("Unique PackagePart-POIXMLDocumentPart relation broken!");\n        }\n\n        if (!pp.hasRelationships()) return;\n\n        PackageRelationshipCollection rels = packagePart.getRelationships();\n        List<POIXMLDocumentPart> readLater = new ArrayList<>();\n\n                for (PackageRelationship rel : rels) {\n            if (rel.getTargetMode() == TargetMode.INTERNAL) {\n                URI uri = rel.getTargetURI();\n\n                                PackagePartName relName;\n                if (uri.getRawFragment() != null) {\n                    relName = PackagingURIHelper.createPartName(uri.getPath());\n                } else {\n                    relName = PackagingURIHelper.createPartName(uri);\n                }\n\n                final PackagePart p = packagePart.getPackage().getPart(relName);\n                if (p == null) {\n                    logger.log(POILogger.ERROR, "Skipped invalid entry " + rel.getTargetURI());\n                    continue;\n                }\n\n                POIXMLDocumentPart childPart = context.get(p);\n                if (childPart == null) {\n                    childPart = factory.createDocumentPart(this, p);\n                                                            if (this instanceof XDDFChart && childPart instanceof XSSFWorkbook) {\n                        ((XDDFChart) this).setWorkbook((XSSFWorkbook) childPart);\n                    }\n                    childPart.parent = this;\n                                        context.put(p, childPart);\n                    readLater.add(childPart);\n                }\n\n                addRelation(rel, childPart);\n            }\n        }\n\n        for (POIXMLDocumentPart childPart : readLater) {\n            childPart.read(factory, context);\n        }\n    }
449	default InputStream readObjectData() throws IOException {\n        final String progId = getProgId();\n        if (progId == null) {\n            throw new IllegalStateException(\n                "Ole object hasn't been initialized or provided in the source xml. " +\n                "use updateObjectData() first or check the corresponding slideXXX.xml");\n        }\n\n        final Application app = Application.lookup(progId);\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream(50000);\n        try (final InputStream is = FileMagic.prepareToCheckMagic(readObjectDataRaw())) {\n            final FileMagic fm = FileMagic.valueOf(is);\n            if (fm == FileMagic.OLE2) {\n                try (final POIFSFileSystem poifs = new POIFSFileSystem(is)) {\n                    String[] names = {\n                        (app == null) ? null : app.getMetaData().getOleEntry(),\n                                                "Package",\n                        "Contents",\n                        "CONTENTS",\n                        "CONTENTSV30",\n                    };\n                    final DirectoryNode root = poifs.getRoot();\n                    String entryName = null;\n                    for (String n : names) {\n                        if (root.hasEntry(n)) {\n                            entryName = n;\n                            break;\n                        }\n                    }\n                    if (entryName == null) {\n                        poifs.writeFilesystem(bos);\n                    } else {\n                        try (final InputStream is2 = poifs.createDocumentInputStream(entryName)) {\n                            IOUtils.copy(is2, bos);\n                        }\n                    }\n                }\n            } else {\n                IOUtils.copy(is, bos);\n            }\n        }\n\n        return new ByteArrayInputStream(bos.toByteArray());\n    }
450	public ValueEval evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex) {\n		try {\n			if (args.length < 1  ||  args.length > 2) {\n				return ErrorEval.VALUE_INVALID;\n			}\n\n						ValueEval serialDateVE = OperandResolver.getSingleValue(args[0], srcRowIndex, srcColumnIndex);\n			double serialDate = OperandResolver.coerceValueToDouble(serialDateVE);\n			if (!DateUtil.isValidExcelDate(serialDate)) {\n				return ErrorEval.NUM_ERROR;									}\n			Calendar date = DateUtil.getJavaCalendar(serialDate, false);					int weekday = date.get(Calendar.DAY_OF_WEEK);		\n						int returnOption = 1;								if (args.length == 2) {\n				ValueEval ve = OperandResolver.getSingleValue(args[1], srcRowIndex, srcColumnIndex);\n				if (ve == MissingArgEval.instance  ||  ve == BlankEval.instance) {\n					return ErrorEval.NUM_ERROR;						}\n				returnOption = OperandResolver.coerceValueToInt(ve);\n				if (returnOption == 2) {\n					returnOption = 11;								}\n			} \n						double result;\n			if (returnOption == 1) {\n				result = weekday;\n						} else if (returnOption == 3) {\n				result = (weekday + 6 - 1) % 7;\n			} else if (returnOption >= 11  &&  returnOption <= 17) {\n				result = (weekday + 6 - (returnOption - 10)) % 7 + 1;					} else {\n				return ErrorEval.NUM_ERROR;					}\n\n			return new NumberEval(result);\n		} catch (EvaluationException e) {\n			return e.getErrorEval();\n		}\n	}
451	public static URI getZipURIFromOPCName(String opcItemName) {\n        if (opcItemName == null) {\n            throw new IllegalArgumentException("opcItemName");\n        }\n\n        String retVal = opcItemName;\n        while (retVal.startsWith(FORWARD_SLASH)) {\n            retVal = retVal.substring(1);\n        }\n        try {\n            return new URI(retVal);\n        } catch (URISyntaxException e) {\n            return null;\n        }\n    }
452	public void dumpPictures(byte[] data, int padding) throws IOException {\n        int pos = 0;\n        while (pos < data.length) {\n            byte[] header = new byte[PICT_HEADER_SIZE];\n\n            System.arraycopy(data, pos, header, 0, header.length);\n            int size = LittleEndian.getInt(header, 4) - 17;\n            byte[] pictdata = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n            System.arraycopy(data, pos + PICT_HEADER_SIZE, pictdata, 0, pictdata.length);\n            pos += PICT_HEADER_SIZE + size;\n\n            padding++;\n            write(out, "<picture size=\""+size+"\" type=\""+getPictureType(header)+"\">" + CR, padding);\n            padding++;\n            write(out, "<header>" + CR, padding);\n            dump(out, header, 0, header.length, padding, true);\n            write(out, "</header>" + CR, padding);\n            write(out, "<imgdata>" + CR, padding);\n            dump(out, pictdata, 0, Math.min(pictdata.length, 100), padding, true);\n            write(out, "</imgdata>" + CR, padding);\n            padding--;\n            write(out, "</picture>" + CR, padding);\n            padding--;\n\n        }\n    }
453	public static ZipSecureFile openZipFile(File file) throws IOException, NotOfficeXmlFileException {\n        if (!file.exists()) {\n            throw new FileNotFoundException("File does not exist");\n        }\n        if (file.isDirectory()) {\n            throw new IOException("File is a directory");\n        }\n        \n                try (FileInputStream input = new FileInputStream(file)) {\n            verifyZipHeader(input);\n        }\n\n                return new ZipSecureFile(file);\n    }
454	public static AreaReference[] generateContiguous(SpreadsheetVersion version, String reference) {\n        if (null == version) {\n            version = DEFAULT_SPREADSHEET_VERSION;         }\n        List<AreaReference> refs = new ArrayList<>();\n        StringTokenizer st = new StringTokenizer(reference, ",");\n        while(st.hasMoreTokens()) {\n            refs.add(\n                    new AreaReference(st.nextToken(), version)\n            );\n        }\n        return refs.toArray(new AreaReference[refs.size()]);\n    }
455	public XSSFFontFormatting createFontFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTFont font;\n        if(!dxf.isSetFont()) {\n            font = dxf.addNewFont();\n        } else {\n            font = dxf.getFont();\n        }\n\n        return new XSSFFontFormatting(font, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
456	public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount, boolean iteratorFirst) {\n                if (password == null) {\n            password = Decryptor.DEFAULT_PASSWORD;\n        }\n        \n        MessageDigest hashAlg = getMessageDigest(hashAlgorithm);\n        \n        hashAlg.update(salt);\n        byte[] hash = hashAlg.digest(StringUtil.getToUnicodeLE(password));\n        byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];\n\n        byte[] first = (iteratorFirst ? iterator : hash);\n        byte[] second = (iteratorFirst ? hash : iterator);\n        \n        try {\n            for (int i = 0; i < spinCount; i++) {\n                LittleEndian.putInt(iterator, 0, i);\n                hashAlg.reset();\n                hashAlg.update(first);\n                hashAlg.update(second);\n                hashAlg.digest(hash, 0, hash.length);             }\n        } catch (DigestException e) {\n            throw new EncryptedDocumentException("error in password hashing");\n        }\n        \n        return hash;\n    }
457	private void compareDataInAllSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n\n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n\n            compareDataInSheet(loc1, loc2);\n        }\n    }
458	static void multiCell(Sheet sheet) {\n                Row row0 = sheet.createRow(0);\n        row0.createCell(0).setCellValue("Units");\n        row0.createCell(1).setCellValue("Cost");\n        row0.createCell(2).setCellValue("Total");\n\n        Row row1 = sheet.createRow(1);\n        row1.createCell(0).setCellValue(71);\n        row1.createCell(1).setCellValue(29);\n        row1.createCell(2).setCellValue(2059);\n\n        Row row2 = sheet.createRow(2);\n        row2.createCell(0).setCellValue(85);\n        row2.createCell(1).setCellValue(29);\n        row2.createCell(2).setCellValue(2059);\n\n        Row row3 = sheet.createRow(3);\n        row3.createCell(0).setCellValue(71);\n        row3.createCell(1).setCellValue(29);\n        row3.createCell(2).setCellValue(2059);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("$A2>75");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:C4")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(4).setCellValue("<== Condition 1: Formula Is =$B2>75   (Blue Fill)");\n    }
459	@SuppressWarnings("WeakerAccess")\n    public void setLineHeadWidth(DecorationSize style) {\n        CTLineProperties ln = getLn(this, true);\n        if (ln == null) {\n            return;\n        }\n        CTLineEndProperties lnEnd = ln.isSetHeadEnd() ? ln.getHeadEnd() : ln.addNewHeadEnd();\n        if (style == null) {\n            if (lnEnd.isSetW()) {\n                lnEnd.unsetW();\n            }\n        } else {\n            lnEnd.setW(STLineEndWidth.Enum.forInt(style.ooxmlId));\n        }\n    }
460	public List<String> getTextAsVector() {\n	    List<String> textV = new ArrayList<>();\n\n				int walkPos = 0;\n\n				while(walkPos != -1) {\n            walkPos = findTextRecords(walkPos,textV);\n		}\n\n				return textV;\n	}
461	public static Record [] createRecord(RecordInputStream in) {\n        Record record = createSingleRecord(in);\n        if (record instanceof DBCellRecord) {\n                        return new Record[] { null, };\n        }\n        if (record instanceof RKRecord) {\n            return new Record[] { convertToNumberRecord((RKRecord) record), };\n        }\n        if (record instanceof MulRKRecord) {\n            return convertRKRecords((MulRKRecord)record);\n        }\n        return new Record[] { record, };\n    }
462	public PackageRelationship getRelationship(int index) {\n        if (index < 0 || index > relationshipsByID.values().size())\n            throw new IllegalArgumentException("index");\n\n        int i = 0;\n        for (PackageRelationship rel : relationshipsByID.values()) {\n            if (index == i++)\n                return rel;\n        }\n\n        return null;\n    }
463	public String getLocalXPath() {\n        StringBuilder localXPath = new StringBuilder();\n        int numberOfCommonXPathAxis = table.getCommonXpath().split("/").length-1;\n\n        String[] xPathTokens = ctXmlColumnPr.getXpath().split("/");\n        for (int i = numberOfCommonXPathAxis; i < xPathTokens.length; i++) {\n            localXPath.append("/" + xPathTokens[i]);\n        }\n        return localXPath.toString();\n    }
464	protected PackagePart addPackagePart(PackagePart part) {\n		throwExceptionIfReadOnly();\n		if (part == null) {\n			throw new IllegalArgumentException("part");\n		}\n\n		if (partList.containsKey(part._partName)) {\n			if (!partList.get(part._partName).isDeleted()) {\n				throw new InvalidOperationException(\n						"A part with the name '"\n								+ part._partName.getName()\n								+ "' already exists : Packages shall not contain equivalent part names and package implementers shall neither create nor recognize packages with equivalent part names. [M1.12]");\n			}\n									part.setDeleted(false);\n						this.partList.remove(part._partName);\n		}\n		this.partList.put(part._partName, part);\n		this.isDirty = true;\n		return part;\n	}
465	private void paintDashedBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             ((northBorderType == BorderStyle.DASHED) ||\n              (northBorderType == BorderStyle.HAIR))\n         ) {\n        int thickness = getThickness(northBorderType);\n\n        int dashlength = 1;\n\n        if (northBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+5) {\n             g.drawLine(xc,y+k,xc+dashlength,y+k);\n           }\n        }\n      }\n\n      if (eastBorder &&\n              ((eastBorderType == BorderStyle.DASHED) ||\n               (eastBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; \n\n        int dashlength = 1;\n\n        if (eastBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+5) {\n                g.drawLine(width-k,yc,width-k,yc+dashlength);\n           }\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.DASHED) ||\n               (southBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(southBorderType);\n        thickness++;\n\n        int dashlength = 1;\n\n        if (southBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+5) {\n             g.drawLine(xc,height-k,xc+dashlength,height-k);\n           }\n        }\n      }\n\n      if (westBorder &&\n            ((westBorderType == BorderStyle.DASHED) ||\n             (westBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n        int dashlength = 1;\n\n        if (westBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+5) {\n                g.drawLine(x+k,yc,x+k,yc+dashlength);\n           }\n        }\n      }\n   }
466	public void updateNamesAfterCellShift(FormulaShifter shifter) {\n        for (int i = 0 ; i < getNumNames() ; ++i){\n            NameRecord nr = getNameRecord(i);\n            Ptg[] ptgs = nr.getNameDefinition();\n            if (shifter.adjustFormula(ptgs, nr.getSheetNumber())) {\n                nr.setNameDefinition(ptgs);\n            }\n        }\n    }
467	HSSFSimpleShape createComboBox(HSSFAnchor anchor) {\n        HSSFCombobox shape = new HSSFCombobox(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
468	private void isCellFontItalicsMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        boolean b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getItalic();\n        boolean b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getItalic();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 ? "" : "NOT ")+"ITALICS",\n                (b2 ? "" : "NOT ")+"ITALICS"\n            );\n        }\n    }
469	private String[] getParts(String string) {\n    	String[] parts = new String[] { "", "", "" };\n    	if(string == null)\n    		return parts;\n    	\n    	    	    	    	int lAt = 0;\n    	int cAt = 0;\n    	int rAt = 0;\n    	\n    	while(\n    		    		(lAt = string.indexOf(HeaderFooterEntity_L)) > -2 &&\n    		(cAt = string.indexOf(HeaderFooterEntity_C)) > -2 &&  \n    		(rAt = string.indexOf(HeaderFooterEntity_R)) > -2 &&\n    		(lAt > -1 || cAt > -1 || rAt > -1)\n    	) {\n    		    		if(rAt > cAt && rAt > lAt) {\n        		parts[2] = string.substring(rAt + HeaderFooterEntity_R.length());\n        		string = string.substring(0, rAt);\n    		} else if(cAt > rAt && cAt > lAt) {\n        		parts[1] = string.substring(cAt + HeaderFooterEntity_C.length());\n        		string = string.substring(0, cAt);\n    		} else {\n        		parts[0] = string.substring(lAt + HeaderFooterEntity_L.length());\n        		string = string.substring(0, lAt);\n    		}\n    	}\n    	\n    	return parts;\n    }
470	private static FillPatternType getFillPattern(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        FillPatternType pattern;\n        if (value instanceof FillPatternType) {\n            pattern = (FillPatternType) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map uses Short values for "\n                        + name + ". Should use FillPatternType enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            pattern = FillPatternType.forInt(code);\n        }\n        else if (value == null) {\n            pattern = FillPatternType.NO_FILL;\n        }\n        else {\n            throw new RuntimeException("Unexpected fill pattern style class. Must be FillPatternType or Short (deprecated).");\n        }\n        return pattern;\n    }
471	protected static void preserveSpaces(STXstring xs) {\n        String text = xs.getStringValue();\n        if (text != null && text.length() > 0) {\n            char firstChar = text.charAt(0);\n            char lastChar  = text.charAt(text.length() - 1);\n            if(Character.isWhitespace(firstChar) || Character.isWhitespace(lastChar)) {\n                XmlCursor c = xs.newCursor();\n                c.toNextToken();\n                c.insertAttributeWithValue(new QName("http://www.w3.org/XML/1998/namespace", "space"), "preserve");\n                c.dispose();\n            }\n        }\n    }
472	public CellFormatResult apply(JLabel label, Cell c) {\n        switch (ultimateType(c)) {\n            case BLANK:\n                return apply(label, "");\n            case BOOLEAN:\n                return apply(label, c.getBooleanCellValue());\n            case NUMERIC:\n                Double value = c.getNumericCellValue();\n                if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                    if (DateUtil.isValidExcelDate(value)) {\n                        return apply(label, c.getDateCellValue(), value);\n                    } else {\n                        return apply(label, INVALID_VALUE_FOR_FORMAT);\n                    }\n                } else {\n                    return apply(label, value);\n                }\n            case STRING:\n                return apply(label, c.getStringCellValue());\n            default:\n                return apply(label, "?");\n            }\n    }
473	public static String getZipItemNameFromOPCName(String opcItemName) {\n        if (opcItemName == null) {\n            throw new IllegalArgumentException("opcItemName cannot be null");\n        }\n\n        String retVal = opcItemName;\n        while (retVal.startsWith(FORWARD_SLASH)) {\n            retVal = retVal.substring(1);\n        }\n        return retVal;\n    }
474	public BigInteger addNum(BigInteger abstractNumID) {\n        CTNum ctNum = this.ctNumbering.addNewNum();\n        ctNum.addNewAbstractNumId();\n        ctNum.getAbstractNumId().setVal(abstractNumID);\n        ctNum.setNumId(BigInteger.valueOf(nums.size() + 1));\n        XWPFNum num = new XWPFNum(ctNum, this);\n        nums.add(num);\n        return ctNum.getNumId();\n    }
475	public void traverse(CellHandler handler) {\n        int firstRow = range.getFirstRow();\n        int lastRow = range.getLastRow();\n        int firstColumn = range.getFirstColumn();\n        int lastColumn = range.getLastColumn();\n        final int width = lastColumn - firstColumn + 1;\n        SimpleCellWalkContext ctx = new SimpleCellWalkContext();\n        Row currentRow = null;\n        Cell currentCell = null;\n\n        for (ctx.rowNumber = firstRow; ctx.rowNumber <= lastRow; ++ctx.rowNumber) {\n            currentRow = sheet.getRow(ctx.rowNumber);\n            if (currentRow == null) {\n                continue;\n            }\n            for (ctx.colNumber = firstColumn; ctx.colNumber <= lastColumn; ++ctx.colNumber) {\n                currentCell = currentRow.getCell(ctx.colNumber);\n\n                if (currentCell == null) {\n                    continue;\n                }\n                if (isEmpty(currentCell) && !traverseEmptyCells) {\n                    continue;\n                }\n\n                ctx.ordinalNumber =\n                        (ctx.rowNumber - firstRow) * width +\n                                (ctx.colNumber - firstColumn + 1);\n\n                handler.onCell(currentCell, ctx);\n            }\n        }\n    }
476	private void syncWithDataSource() throws IOException {\n                        _mini_store.syncWithDataSource();\n        \n                POIFSStream propStream = new POIFSStream(this, _header.getPropertyStart());\n        _property_table.preWrite();\n        _property_table.write(propStream);\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream(\n                _header.getBigBlockSize().getBigBlockSize()\n        );\n        _header.writeData(baos);\n        getBlockAt(-1).put(baos.toByteArray());\n\n       \n              for(BATBlock bat : _bat_blocks) {\n          ByteBuffer block = getBlockAt(bat.getOurBlockIndex());\n          bat.writeData(block);\n       }\n              for(BATBlock bat : _xbat_blocks) {\n           ByteBuffer block = getBlockAt(bat.getOurBlockIndex());\n           bat.writeData(block);\n        }\n    }
477	private CTTwoCellAnchor createTwoCellAnchor(XSSFClientAnchor anchor) {\n        CTTwoCellAnchor ctAnchor = drawing.addNewTwoCellAnchor();\n        ctAnchor.setFrom(anchor.getFrom());\n        ctAnchor.setTo(anchor.getTo());\n        ctAnchor.addNewClientData();\n        anchor.setTo(ctAnchor.getTo());\n        anchor.setFrom(ctAnchor.getFrom());\n        STEditAs.Enum aditAs;\n        switch(anchor.getAnchorType()) {\n            case DONT_MOVE_AND_RESIZE: aditAs = STEditAs.ABSOLUTE; break;\n            case MOVE_AND_RESIZE: aditAs = STEditAs.TWO_CELL; break;\n            case MOVE_DONT_RESIZE: aditAs = STEditAs.ONE_CELL; break;\n            default: aditAs = STEditAs.ONE_CELL;\n        }\n        ctAnchor.setEditAs(aditAs);\n        return ctAnchor;\n    }
478	public int addOlePackage(POIFSFileSystem poiData, String label, String fileName, String command)\n    throws IOException {\n    	DirectoryNode root = poiData.getRoot();\n    	Map<String,ClassID> olemap = getOleMap();\n    	for (Map.Entry<String,ClassID> entry : olemap.entrySet()) {\n    		if (root.hasEntry(entry.getKey())) {\n    			root.setStorageClsid(entry.getValue());\n    			break;\n    		}\n    	}\n\n    	ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    	poiData.writeFilesystem(bos);\n        return addOlePackage(bos.toByteArray(), label, fileName, command);\n    }
479	public static void buildAxDataSource(CTAxDataSource ctAxDataSource, ChartDataSource<?> dataSource) {\n        if (dataSource.isNumeric()) {\n            if (dataSource.isReference()) {\n                buildNumRef(ctAxDataSource.addNewNumRef(), dataSource);\n            } else {\n                buildNumLit(ctAxDataSource.addNewNumLit(), dataSource);\n            }\n        } else {\n            if (dataSource.isReference()) {\n                buildStrRef(ctAxDataSource.addNewStrRef(), dataSource);\n            } else {\n                buildStrLit(ctAxDataSource.addNewStrLit(), dataSource);\n            }\n        }\n    }
480	public static void evaluateAllFormulaCells(SXSSFWorkbook wb, boolean skipOutOfWindow) {\n        SXSSFFormulaEvaluator eval = new SXSSFFormulaEvaluator(wb);\n        \n                for (Sheet sheet : wb) {\n            if (((SXSSFSheet)sheet).areAllRowsFlushed()) {\n                throw new SheetsFlushedException();\n            }\n        }\n        \n                for (Sheet sheet : wb) {\n            \n                        int lastFlushedRowNum = ((SXSSFSheet) sheet).getLastFlushedRowNum();\n            if (lastFlushedRowNum > -1) {\n                if (! skipOutOfWindow) throw new RowFlushedException(0);\n                logger.log(POILogger.INFO, "Rows up to " + lastFlushedRowNum + " have already been flushed, skipping");\n            }\n            \n                        for (Row r : sheet) {\n                for (Cell c : r) {\n                    if (c.getCellType() == CellType.FORMULA) {\n                        eval.evaluateFormulaCell(c);\n                    }\n                }\n            }\n        }\n    }
481	private CellFormatPart getApplicableFormatPart(Object value) {\n        \n        if (value instanceof Number) {\n            \n            double val = ((Number) value).doubleValue();\n            \n            if (formatPartCount == 1) {\n                if (!posNumFmt.hasCondition()\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else {\n                    return new CellFormatPart(locale, "General");\n                }\n            } else if (formatPartCount == 2) {\n                if ((!posNumFmt.hasCondition() && val >= 0)\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else if (!negNumFmt.hasCondition()\n                        || (negNumFmt.hasCondition() && negNumFmt.applies(val))) {\n                    return negNumFmt;\n                } else {\n                                        return new CellFormatPart(QUOTE + INVALID_VALUE_FOR_FORMAT + QUOTE);\n                }\n            } else {\n                if ((!posNumFmt.hasCondition() && val > 0)\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else if ((!negNumFmt.hasCondition() && val < 0)\n                        || (negNumFmt.hasCondition() && negNumFmt.applies(val))) {\n                    return negNumFmt;\n                                } else {\n                    return zeroNumFmt;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException("value must be a Number");\n        }\n        \n    }
482	public static CellRangeAddress valueOf(String ref) {\n        int sep = ref.indexOf(":");\n        CellReference a;\n        CellReference b;\n        if (sep == -1) {\n            a = new CellReference(ref);\n            b = a;\n        } else {\n            a = new CellReference(ref.substring(0, sep));\n            b = new CellReference(ref.substring(sep + 1));\n        }\n        return new CellRangeAddress(a.getRow(), b.getRow(), a.getCol(), b.getCol());\n    }
483	public int getFontIndex(FontRecord font) {\n        for(int i=0; i<=numfonts; i++) {\n            FontRecord thisFont =\n                ( FontRecord ) records.get((records.getFontpos() - (numfonts - 1)) + i);\n            if(thisFont == font) {\n                                return (i > 3) ? i+1 : i;\n            }\n        }\n        throw new IllegalArgumentException("Could not find that font!");\n    }
484	public void replaceText( String newText, boolean addAfter )\n    {\n        if ( addAfter )\n        {\n            int originalEnd = getEndOffset();\n            insertAfter( newText );\n            new Range( getStartOffset(), originalEnd, this ).delete();\n        }\n        else\n        {\n            int originalStart = getStartOffset();\n            int originalEnd = getEndOffset();\n\n            insertBefore( newText );\n            new Range( originalStart + newText.length(), originalEnd\n                    + newText.length(), this ).delete();\n        }\n    }
485	public static void assertEquals(File expected, File actual) {\n		assertNotNull(expected);\n		assertNotNull(actual);\n\n		assertTrue("File does not exist [" + expected.getAbsolutePath()\n				+ "]", expected.exists());\n		assertTrue("File does not exist [" + actual.getAbsolutePath()\n				+ "]", actual.exists());\n\n		assertTrue("Expected file not readable", expected.canRead());\n		assertTrue("Actual file not readable", actual.canRead());\n\n		try {\n			TreeMap<String, ByteArrayOutputStream> file1 = decompress(expected);\n			TreeMap<String, ByteArrayOutputStream> file2 = decompress(actual);\n			equals(file1, file2);\n		} catch (IOException e) {\n			throw new AssertionFailedError(e.toString());\n		}\n	}
486	public List<PackagePart> getPartsByName(final Pattern namePattern) {\n	    if (namePattern == null) {\n	        throw new IllegalArgumentException("name pattern must not be null");\n	    }\n	    Matcher matcher = namePattern.matcher("");\n	    ArrayList<PackagePart> result = new ArrayList<>();\n	    for (PackagePart part : partList.sortedValues()) {\n	        PackagePartName partName = part.getPartName();\n	        if (matcher.reset(partName.getName()).matches()) {\n	            result.add(part);\n	        }\n	    }\n	    return result;\n	}
487	private static void centerAcrossSelection(XSSFWorkbook wb, XSSFRow row,\n            int start_column, int end_column, VerticalAlignment valign) {\n        CreationHelper ch = wb.getCreationHelper();\n\n                XSSFCellStyle cellStyle = wb.createCellStyle();\n        cellStyle.setAlignment(HorizontalAlignment.CENTER_SELECTION);\n        cellStyle.setVerticalAlignment(valign);\n\n                for (int i = start_column; i <= end_column; i++) {\n            XSSFCell cell = row.createCell(i);\n            cell.setCellStyle(cellStyle);\n        }\n\n                XSSFCell cell = row.getCell(start_column);\n        cell.setCellValue(ch.createRichTextString("Align It"));\n\n                CTRowImpl ctRow = (CTRowImpl) row.getCTRow();\n\n                                        Object span = start_column + ":" + end_column;\n\n        List<Object> spanList = new ArrayList<>();\n        spanList.add(span);\n\n                ctRow.setSpans(spanList);\n    }
488	private int getSizeOfInitialSheetRecords(int bofRecordIndex) {\n\n        int result = 0;\n                for (int j = bofRecordIndex + 1; j < _records.size(); j++) {\n            RecordBase tmpRec = _records.get(j);\n            if (tmpRec instanceof RowRecordsAggregate) {\n                break;\n            }\n            result += tmpRec.getRecordSize();\n        }\n        if (_isUncalced) {\n            result += UncalcedRecord.getStaticRecordSize();\n        }\n        return result;\n    }
489	public static synchronized FontDetails getFontDetails(Font font) {\n						if (fontMetricsProps == null) {\n		    try {\n		        fontMetricsProps = loadMetrics();\n		    } catch (IOException e) {\n		        throw new RuntimeException("Could not load font metrics", e);\n		    }\n		}\n\n				String fontName = font.getName();\n\n								String fontStyle = "";\n		if (font.isPlain()) {\n			fontStyle += "plain";\n		}\n		if (font.isBold()) {\n			fontStyle += "bold";\n		}\n		if (font.isItalic()) {\n			fontStyle += "italic";\n		}\n\n						String fontHeight = FontDetails.buildFontHeightProperty(fontName);\n		String styleHeight = FontDetails.buildFontHeightProperty(fontName + "." + fontStyle);\n		\n		if (fontMetricsProps.get(fontHeight) == null\n			&& fontMetricsProps.get(styleHeight) != null) {\n						fontName += "." + fontStyle;\n		}\n\n				FontDetails fontDetails = fontDetailsMap.get(fontName);\n		if (fontDetails == null) {\n			fontDetails = FontDetails.create(fontName, fontMetricsProps);\n			fontDetailsMap.put(fontName, fontDetails);\n		}\n        return fontDetails;\n	}
490	@Beta\n    private XSSFPivotTable createPivotTable() {\n        XSSFWorkbook wb = getWorkbook();\n        List<XSSFPivotTable> pivotTables = wb.getPivotTables();\n        int tableId = getWorkbook().getPivotTables().size()+1;\n                XSSFPivotTable pivotTable = (XSSFPivotTable) createRelationship(XSSFRelation.PIVOT_TABLE,\n                XSSFFactory.getInstance(), tableId);\n        pivotTable.setParentSheet(this);\n        pivotTables.add(pivotTable);\n        XSSFWorkbook workbook = getWorkbook();\n\n                XSSFPivotCacheDefinition pivotCacheDefinition = (XSSFPivotCacheDefinition) workbook.\n                createRelationship(XSSFRelation.PIVOT_CACHE_DEFINITION, XSSFFactory.getInstance(), tableId);\n        String rId = workbook.getRelationId(pivotCacheDefinition);\n                PackagePart pivotPackagePart = pivotTable.getPackagePart();\n        pivotPackagePart.addRelationship(pivotCacheDefinition.getPackagePart().getPartName(),\n                TargetMode.INTERNAL, XSSFRelation.PIVOT_CACHE_DEFINITION.getRelation());\n\n        pivotTable.setPivotCacheDefinition(pivotCacheDefinition);\n\n                pivotTable.setPivotCache(new XSSFPivotCache(workbook.addPivotCache(rId)));\n\n                XSSFPivotCacheRecords pivotCacheRecords = (XSSFPivotCacheRecords) pivotCacheDefinition.\n                createRelationship(XSSFRelation.PIVOT_CACHE_RECORDS, XSSFFactory.getInstance(), tableId);\n\n                pivotTable.getPivotCacheDefinition().getCTPivotCacheDefinition().setId(pivotCacheDefinition.getRelationId(pivotCacheRecords));\n\n        wb.setPivotTables(pivotTables);\n\n        return pivotTable;\n    }
491	private int findLastRow(int lastrow) {\n        if (lastrow < 1) {\n            return 0;\n        }\n        int rownum = lastrow - 1;\n        HSSFRow r = getRow(rownum);\n\n        while (r == null && rownum > 0) {\n            r = getRow(--rownum);\n        }\n        if (r == null) {\n            return 0;\n        }\n        return rownum;\n    }
492	public static double getColumnWidth(Sheet sheet, int column, boolean useMergedCells, int firstRow, int lastRow){\n        DataFormatter formatter = new DataFormatter();\n        int defaultCharWidth = getDefaultCharWidth(sheet.getWorkbook());\n\n        double width = -1;\n        for (int rowIdx = firstRow; rowIdx <= lastRow; ++rowIdx) {\n            Row row = sheet.getRow(rowIdx);\n            if( row != null ) {\n                double cellWidth = getColumnWidthForRow(row, column, defaultCharWidth, formatter, useMergedCells);\n                width = Math.max(width, cellWidth);\n            }\n        }\n        return width;\n    }
493	default boolean hasDirectoryEntry() {\n        try (final InputStream is = FileMagic.prepareToCheckMagic(getInputStream())) {\n            FileMagic fm = FileMagic.valueOf(is);\n            return fm == FileMagic.OLE2;\n        } catch (IOException e) {\n            POILogger LOG = POILogFactory.getLogger(ObjectData.class);\n            LOG.log(POILogger.WARN, "Can't determine filemagic of ole stream", e);\n            return false;\n        }\n    }
494	protected CTOleObject readOleObject(long shapeId) {\n        if (!getCTWorksheet().isSetOleObjects()) {\n            return null;\n        }\n\n                String xquery = "declare namespace p='"+XSSFRelation.NS_SPREADSHEETML+"' .//p:oleObject";\n        XmlCursor cur = getCTWorksheet().getOleObjects().newCursor();\n        try {\n            cur.selectPath(xquery);\n            CTOleObject coo = null;\n            while (cur.toNextSelection()) {\n                String sId = cur.getAttributeText(new QName(null, "shapeId"));\n                if (sId == null || Long.parseLong(sId)  != shapeId) {\n                    continue;\n                }\n\n                XmlObject xObj = cur.getObject();\n                if (xObj instanceof CTOleObject) {\n                                        coo = (CTOleObject)xObj;\n                } else {\n                    XMLStreamReader reader = cur.newXMLStreamReader();\n                    try {\n                        CTOleObjects coos = CTOleObjects.Factory.parse(reader);\n                        if (coos.sizeOfOleObjectArray() == 0) {\n                            continue;\n                        }\n                        coo = coos.getOleObjectArray(0);\n                    } catch (XmlException e) {\n                        logger.log(POILogger.INFO, "can't parse CTOleObjects", e);\n                    } finally {\n                        try {\n                            reader.close();\n                        } catch (XMLStreamException e) {\n                            logger.log(POILogger.INFO, "can't close reader", e);\n                        }\n                    }\n                }\n\n                                                if (cur.toChild(XSSFRelation.NS_SPREADSHEETML, "objectPr")) {\n                    break;\n                }\n            }\n            return (coo == null) ? null : coo;\n        } finally {\n            cur.dispose();\n        }\n    }
495	public ValueEval evaluate(String formula, CellReference ref) {\n        final String sheetName = ref == null ? null : ref.getSheetName();\n        int sheetIndex;\n        if (sheetName == null) {\n            sheetIndex = -1;         } else {\n            sheetIndex = getWorkbook().getSheetIndex(sheetName);\n        }\n        int rowIndex = ref == null ? -1 : ref.getRow();\n        short colIndex = ref == null ? -1 : ref.getCol();\n        final OperationEvaluationContext ec = new OperationEvaluationContext(\n                this, \n                getWorkbook(), \n                sheetIndex, \n                rowIndex, \n                colIndex, \n                new EvaluationTracker(_cache)\n            );\n        Ptg[] ptgs = FormulaParser.parse(formula, (FormulaParsingWorkbook) getWorkbook(), FormulaType.CELL, sheetIndex, rowIndex);\n        return evaluateNameFormula(ptgs, ec);\n    }
496	public static Font makeFont(HSSFFont font) {\n    boolean isbold = font.getBold();\n    boolean isitalics = font.getItalic();\n    int fontstyle = Font.PLAIN;\n    if (isbold) {\n      fontstyle = Font.BOLD;\n    }\n    if (isitalics) {\n      fontstyle = fontstyle | Font.ITALIC;\n    }\n\n    int fontheight = font.getFontHeightInPoints();\n    if (fontheight == 9) {\n            fontheight = 10;\n    }\n\n    return new Font(font.getFontName(), fontstyle, fontheight);\n  }
497	public void addThumbnail(String filename, InputStream data) throws IOException {\n                if (filename == null || filename.isEmpty()) {\n            throw new IllegalArgumentException("filename");\n        }\n\n                String contentType = ContentTypes\n                .getContentTypeFromFileExtension(filename);\n        PackagePartName thumbnailPartName;\n        try {\n            thumbnailPartName = PackagingURIHelper.createPartName("/docProps/"\n                    + filename);\n        } catch (InvalidFormatException e) {\n            String partName = "/docProps/thumbnail" +\n                    filename.substring(filename.lastIndexOf(".") + 1);\n            try {\n                thumbnailPartName = PackagingURIHelper.createPartName(partName);\n            } catch (InvalidFormatException e2) {\n                throw new InvalidOperationException(\n                        "Can't add a thumbnail file named '" + filename + "'", e2);\n            }\n        }\n\n                if (this.getPart(thumbnailPartName) != null) {\n            throw new InvalidOperationException(\n                    "You already add a thumbnail named '" + filename + "'");\n        }\n\n                PackagePart thumbnailPart = this.createPart(thumbnailPartName,\n                contentType, false);\n\n                this.addRelationship(thumbnailPartName, TargetMode.INTERNAL,\n                PackageRelationshipTypes.THUMBNAIL);\n\n                StreamHelper.copyStream(data, thumbnailPart.getOutputStream());\n    }
498	protected short processRecord(Record rec) throws HSSFUserException {\n		List<HSSFListener> listeners = _records.get(Short.valueOf(rec.getSid()));\n		short userCode = 0;\n\n		if (listeners != null) {\n\n			for (int k = 0; k < listeners.size(); k++) {\n				Object listenObj = listeners.get(k);\n				if (listenObj instanceof AbortableHSSFListener) {\n					AbortableHSSFListener listener = (AbortableHSSFListener) listenObj;\n					userCode = listener.abortableProcessRecord(rec);\n					if (userCode != 0)\n						break;\n				} else {\n					HSSFListener listener = (HSSFListener) listenObj;\n					listener.processRecord(rec);\n				}\n			}\n		}\n		return userCode;\n	}
499	public int getRowCellBlockSize(int startRow, int endRow) {\n		int result = 0;\n		for(int rowIx=startRow; rowIx<=endRow && rowIx<records.length; rowIx++) {\n			result += getRowSerializedSize(records[rowIx]);\n		}\n		return result;\n	}
500	protected static int getSoundReference(HSLFShape shape){\n        int soundRef = -1;\n                InteractiveInfoAtom info = shape.getClientDataRecord(RecordTypes.InteractiveInfo.typeID);\n        if (info != null && info.getAction() == InteractiveInfoAtom.ACTION_MEDIA) {\n            soundRef = info.getSoundRef();\n        }\n        return soundRef;\n    }
501	public void updateColumnWidths(Row row) {\n                implicitlyTrackColumnsInRow(row);\n        \n                                if (maxColumnWidths.size() < row.getPhysicalNumberOfCells()) {\n                        for (final Entry<Integer, ColumnWidthPair> e : maxColumnWidths.entrySet()) {\n                final int column = e.getKey();\n                final Cell cell = row.getCell(column); \n                                \n                                \n                if (cell != null) {\n                    final ColumnWidthPair pair = e.getValue();\n                    updateColumnWidth(cell, pair);\n                }\n            }\n        }\n        else {\n                        for (final Cell cell : row) {\n                final int column = cell.getColumnIndex();\n\n                                \n                                \n                if (maxColumnWidths.containsKey(column)) {\n                    final ColumnWidthPair pair = maxColumnWidths.get(column);\n                    updateColumnWidth(cell, pair);\n                }\n            }\n        }\n    }
502	public static void optimiseCellStyles(HSSFWorkbook workbook) {\n                     short[] newPos = new short[workbook.getWorkbook().getNumExFormats()];\n       boolean[] isUsed = new boolean[newPos.length];\n       boolean[] zapRecords = new boolean[newPos.length];\n       for(int i=0; i<newPos.length; i++) {\n           isUsed[i] = false;\n           newPos[i] = (short)i;\n           zapRecords[i] = false;\n       }\n\n                     ExtendedFormatRecord[] xfrs = new ExtendedFormatRecord[newPos.length];\n       for(int i=0; i<newPos.length; i++) {\n           xfrs[i] = workbook.getWorkbook().getExFormatAt(i);\n       }\n\n	   	   	   	   	   	   for (int i = 21; i < newPos.length; i++) {\n		   		   		   int earlierDuplicate = -1;\n		   for (int j = 0; j < i && earlierDuplicate == -1; j++) {\n			   ExtendedFormatRecord xfCheck = workbook.getWorkbook().getExFormatAt(j);\n			   if (xfCheck.equals(xfrs[i]) &&\n					   					   !isUserDefined(workbook, j)) {\n				   earlierDuplicate = j;\n			   }\n		   }\n\n                      if(earlierDuplicate != -1) {\n               newPos[i] = (short)earlierDuplicate;\n               zapRecords[i] = true;\n           }\n       }\n\n	   	   	   for (int sheetNum = 0; sheetNum < workbook.getNumberOfSheets(); sheetNum++) {\n		   HSSFSheet s = workbook.getSheetAt(sheetNum);\n		   for (Row row : s) {\n			   for (Cell cellI : row) {\n				   HSSFCell cell = (HSSFCell) cellI;\n				   short oldXf = cell.getCellValueRecord().getXFIndex();\n				   				   if(oldXf < newPos.length) {\n					   isUsed[oldXf] = true;\n				   }\n			   }\n\n			   			   short oldXf = ((HSSFRow) row).getRowRecord().getXFIndex();\n			   			   if(oldXf < newPos.length) {\n				   isUsed[oldXf] = true;\n			   }\n		   }\n\n		   		   for (int col = s.getSheet().getMinColumnIndex(); col <= s.getSheet().getMaxColumnIndex(); col++) {\n			   short oldXf = s.getSheet().getXFIndexForColAt((short) col);\n			   			   if(oldXf < newPos.length) {\n				   isUsed[oldXf] = true;\n			   }\n		   }\n	   }\n\n	   	   for (int i = 21; i < isUsed.length; i++) {\n		   		   if (isUserDefined(workbook, i)) {\n			   isUsed[i] = true;\n		   }\n\n		   		   if(newPos[i] != i && isUsed[i]) {\n		   		isUsed[newPos[i]] = true;\n		   }\n	   }\n\n              for (int i=21; i<isUsed.length; i++) {\n           if (! isUsed[i]) {\n                              zapRecords[i] = true;\n               newPos[i] = 0;\n           }\n       }\n\n                                   for(int i=21; i<newPos.length; i++) {\n                                 short preDeletePos = newPos[i];\n           short newPosition = preDeletePos;\n           for(int j=0; j<preDeletePos; j++) {\n               if(zapRecords[j]) newPosition--;\n           }\n\n		   		   newPos[i] = newPosition;\n		   		   if (i != newPosition && newPosition != 0) {\n			   workbook.getWorkbook().updateStyleRecord(i, newPosition);\n\n			   ExtendedFormatRecord exFormat = workbook.getWorkbook().getExFormatAt(i);\n			   short oldParent = exFormat.getParentIndex();\n			   			   if(oldParent < newPos.length) {\n				   short newParent = newPos[oldParent];\n				   exFormat.setParentIndex(newParent);\n			   }\n		   }\n	   }\n\n                            int max = newPos.length;\n       int removed = 0;        for(int i=21; i<max; i++) {\n           if(zapRecords[i + removed]) {\n               workbook.getWorkbook().removeExFormatRecord(i);\n               i--;\n               max--;\n               removed++;\n           }\n       }\n\n	   	   for (int sheetNum = 0; sheetNum < workbook.getNumberOfSheets(); sheetNum++) {\n		   HSSFSheet s = workbook.getSheetAt(sheetNum);\n		   for (Row row : s) {\n			   for (Cell cell : row) {\n				   short oldXf = ((HSSFCell) cell).getCellValueRecord().getXFIndex();\n				   				   if(oldXf >= newPos.length) {\n				   		continue;\n				   }\n				   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n				   cell.setCellStyle(newStyle);\n			   }\n\n			   			   short oldXf = ((HSSFRow) row).getRowRecord().getXFIndex();\n			   			   if(oldXf >= newPos.length) {\n				   continue;\n			   }\n			   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n			   row.setRowStyle(newStyle);\n		   }\n\n		   		   for (int col = s.getSheet().getMinColumnIndex(); col <= s.getSheet().getMaxColumnIndex(); col++) {\n			   short oldXf = s.getSheet().getXFIndexForColAt((short) col);\n			   			   if(oldXf >= newPos.length) {\n				   continue;\n			   }\n			   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n			   s.setDefaultColumnStyle(col, newStyle);\n		   }\n	   }\n   }
503	public void convertExcelToCSV(String strSource, String strDestination,\n                                  String separator, int formattingConvention)\n                       throws FileNotFoundException, IOException,\n                              IllegalArgumentException {\n        File source = new File(strSource);\n        File destination = new File(strDestination);\n        File[] filesList;\n        String destinationFilename;\n\n                if(!source.exists()) {\n            throw new IllegalArgumentException("The source for the Excel " +\n                    "file(s) cannot be found.");\n        }\n\n                                if(!destination.exists()) {\n            throw new IllegalArgumentException("The folder/directory for the " +\n                    "converted CSV file(s) does not exist.");\n        }\n        if(!destination.isDirectory()) {\n            throw new IllegalArgumentException("The destination for the CSV " +\n                    "file(s) is not a directory/folder.");\n        }\n\n                        if(formattingConvention != ToCSV.EXCEL_STYLE_ESCAPING &&\n           formattingConvention != ToCSV.UNIX_STYLE_ESCAPING) {\n            throw new IllegalArgumentException("The value passed to the " +\n                    "formattingConvention parameter is out of range.");\n        }\n\n                        this.separator = separator;\n        this.formattingConvention = formattingConvention;\n\n                        if(source.isDirectory()) {\n                                    filesList = source.listFiles(new ExcelFilenameFilter());\n        }\n        else {\n                                                filesList = new File[]{source};\n        }\n\n                                                                                                if (filesList != null) {\n            for(File excelFile : filesList) {\n                                this.openWorkbook(excelFile);\n    \n                                this.convertToCSV();\n    \n                                                destinationFilename = excelFile.getName();\n                destinationFilename = destinationFilename.substring(\n                        0, destinationFilename.lastIndexOf(".")) +\n                        ToCSV.CSV_FILE_EXTENSION;\n    \n                                                this.saveCSVFile(new File(destination, destinationFilename));\n            }\n        }\n    }
504	private void appendDefaultType(Element root, Entry<String, String> entry) {\n        Element defaultType = root.getOwnerDocument().createElementNS(TYPES_NAMESPACE_URI, DEFAULT_TAG_NAME);\n        defaultType.setAttribute(EXTENSION_ATTRIBUTE_NAME, entry.getKey());\n        defaultType.setAttribute(CONTENT_TYPE_ATTRIBUTE_NAME, entry.getValue());\n        root.appendChild(defaultType);\n    }
505	public static void main(final String args[]) {\n        if (args.length == 0) {\n            System.err.println("Must specify at least one file to view");\n            System.exit(1);\n        }\n        boolean printNames = (args.length > 1);\n\n        for (String arg : args) {\n            viewFile(arg, printNames);\n        }\n    }
506	public boolean validateProtectionPassword(String password) {\n        BigInteger sid = safeGetDocumentProtection().getCryptAlgorithmSid();\n        byte hash[] = safeGetDocumentProtection().getHash();\n        byte salt[] = safeGetDocumentProtection().getSalt();\n        BigInteger spinCount = safeGetDocumentProtection().getCryptSpinCount();\n\n        if (sid == null || hash == null || salt == null || spinCount == null) return false;\n\n        HashAlgorithm hashAlgo;\n        switch (sid.intValue()) {\n            case 1:\n                hashAlgo = HashAlgorithm.md2;\n                break;\n            case 2:\n                hashAlgo = HashAlgorithm.md4;\n                break;\n            case 3:\n                hashAlgo = HashAlgorithm.md5;\n                break;\n            case 4:\n                hashAlgo = HashAlgorithm.sha1;\n                break;\n            case 12:\n                hashAlgo = HashAlgorithm.sha256;\n                break;\n            case 13:\n                hashAlgo = HashAlgorithm.sha384;\n                break;\n            case 14:\n                hashAlgo = HashAlgorithm.sha512;\n                break;\n            default:\n                return false;\n        }\n\n        String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n                                byte hash2[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount.intValue(), false);\n\n        return Arrays.equals(hash, hash2);\n    }
507	private void addRow(HSSFRow row, boolean addLow) {\n        _rows.put(Integer.valueOf(row.getRowNum()), row);\n        if (addLow) {\n            _sheet.addRow(row.getRowRecord());\n        }\n        boolean firstRow = _rows.size() == 1;\n        if (row.getRowNum() > getLastRowNum() || firstRow) {\n            _lastrow = row.getRowNum();\n        }\n        if (row.getRowNum() < getFirstRowNum() || firstRow) {\n            _firstrow = row.getRowNum();\n        }\n    }
508	public static URI relativizeURI(URI sourceURI, URI targetURI, boolean msCompatible) {\n		StringBuilder retVal = new StringBuilder();\n		String[] segmentsSource = sourceURI.getPath().split("/", -1);\n		String[] segmentsTarget = targetURI.getPath().split("/", -1);\n\n				if (segmentsSource.length == 0) {\n			throw new IllegalArgumentException(\n					"Can't relativize an empty source URI !");\n		}\n\n				if (segmentsTarget.length == 0) {\n			throw new IllegalArgumentException(\n					"Can't relativize an empty target URI !");\n		}\n\n						if(sourceURI.toString().equals("/")) {\n            String path = targetURI.getPath();\n            if(msCompatible && path.length() > 0 && path.charAt(0) == '/') {\n                try {\n                    targetURI = new URI(path.substring(1));\n                } catch (Exception e) {\n                    _logger.log(POILogger.WARN, e);\n                    return null;\n                }\n            }\n			return targetURI;\n		}\n\n\n								int segmentsTheSame = 0;\n		for (int i = 0; i < segmentsSource.length && i < segmentsTarget.length; i++) {\n			if (segmentsSource[i].equals(segmentsTarget[i])) {\n								segmentsTheSame++;\n			} else {\n				break;\n			}\n		}\n\n				if ((segmentsTheSame == 0 || segmentsTheSame == 1) &&\n				segmentsSource[0].isEmpty() && segmentsTarget[0].isEmpty()) {\n			for (int i = 0; i < segmentsSource.length - 2; i++) {\n				retVal.append("../");\n			}\n			for (int i = 0; i < segmentsTarget.length; i++) {\n				if (segmentsTarget[i].isEmpty())\n					continue;\n				retVal.append(segmentsTarget[i]);\n				if (i != segmentsTarget.length - 1)\n					retVal.append("/");\n			}\n\n			try {\n				return new URI(retVal.toString());\n			} catch (Exception e) {\n				_logger.log(POILogger.WARN, e);\n				return null;\n			}\n		}\n\n				if (segmentsTheSame == segmentsSource.length\n				&& segmentsTheSame == segmentsTarget.length) {\n            if(sourceURI.equals(targetURI)){\n                                                                                retVal.append(segmentsSource[segmentsSource.length - 1]);\n            } else {\n                retVal.append("");\n            }\n\n		} else {\n			\n												if (segmentsTheSame == 1) {\n				retVal.append("/");\n			} else {\n				for (int j = segmentsTheSame; j < segmentsSource.length - 1; j++) {\n					retVal.append("../");\n				}\n			}\n\n						for (int j = segmentsTheSame; j < segmentsTarget.length; j++) {\n				if (retVal.length() > 0\n						&& retVal.charAt(retVal.length() - 1) != '/') {\n					retVal.append("/");\n				}\n				retVal.append(segmentsTarget[j]);\n			}\n		}\n\n                String fragment = targetURI.getRawFragment();\n        if (fragment != null) {\n            retVal.append("#").append(fragment);\n        }\n\n		try {\n			return new URI(retVal.toString());\n		} catch (Exception e) {\n			_logger.log(POILogger.WARN, e);\n			return null;\n		}\n	}
509	@SuppressWarnings("WeakerAccess")\n	public HSLFSlide removeSlide(int index) {\n		int lastSlideIdx = _slides.size() - 1;\n		if (index < 0 || index > lastSlideIdx) {\n			throw new IllegalArgumentException("Slide index (" + index + ") is out of range (0.."\n					+ lastSlideIdx + ")");\n		}\n\n		SlideListWithText slwt = _documentRecord.getSlideSlideListWithText();\n		if (slwt == null) {\n			throw new IllegalStateException("Slide record not defined.");\n		}\n		SlideAtomsSet[] sas = slwt.getSlideAtomsSets();\n\n		List<Record> records = new ArrayList<>();\n		List<SlideAtomsSet> sa = new ArrayList<>(Arrays.asList(sas));\n\n		HSLFSlide removedSlide = _slides.remove(index);\n		_notes.remove(removedSlide.getNotes());\n		sa.remove(index);\n\n		int i=0;\n		for (HSLFSlide s : _slides) {\n            s.setSlideNumber(i++);\n        }\n\n		for (SlideAtomsSet s : sa) {\n            records.add(s.getSlidePersistAtom());\n            records.addAll(Arrays.asList(s.getSlideRecords()));\n		}\n		if (sa.isEmpty()) {\n			_documentRecord.removeSlideListWithText(slwt);\n		} else {\n			slwt.setSlideAtomsSets(sa.toArray(new SlideAtomsSet[0]));\n			slwt.setChildRecord(records.toArray(new Record[0]));\n		}\n\n		\n        int notesId = removedSlide.getSlideRecord().getSlideAtom().getNotesID();\n		if (notesId != 0) {\n			SlideListWithText nslwt = _documentRecord.getNotesSlideListWithText();\n			records = new ArrayList<>();\n			ArrayList<SlideAtomsSet> na = new ArrayList<>();\n			if (nslwt != null) {\n				for (SlideAtomsSet ns : nslwt.getSlideAtomsSets()) {\n					if (ns.getSlidePersistAtom().getSlideIdentifier() == notesId) {\n						continue;\n					}\n					na.add(ns);\n					records.add(ns.getSlidePersistAtom());\n					if (ns.getSlideRecords() != null) {\n						records.addAll(Arrays.asList(ns.getSlideRecords()));\n					}\n				}\n\n				if (!na.isEmpty()) {\n					nslwt.setSlideAtomsSets(na.toArray(new SlideAtomsSet[0]));\n					nslwt.setChildRecord(records.toArray(new Record[0]));\n				}\n			}\n			if (na.isEmpty()) {\n				_documentRecord.removeSlideListWithText(nslwt);\n			}\n		}\n\n		return removedSlide;\n	}
510	private static int getColumnForString(AreaEval db,String name)\n            throws EvaluationException {\n        int resultColumn = -1;\n        final int width = db.getWidth();\n        for(int column = 0; column < width; ++column) {\n            ValueEval columnNameValueEval = resolveReference(db, 0, column);\n            if(columnNameValueEval instanceof BlankEval) {\n                continue;\n            }\n            if(columnNameValueEval instanceof ErrorEval) {\n                continue;\n            }\n            String columnName = OperandResolver.coerceValueToString(columnNameValueEval);\n            if(name.equals(columnName)) {\n                resultColumn = column;\n                break;\n            }\n        }\n        return resultColumn;\n    }
511	public static DocumentBuilderFactory getDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setExpandEntityReferences(false);\n        trySetSAXFeature(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        trySetSAXFeature(factory, "http://xml.org/sax/features/external-general-entities", false);\n        trySetSAXFeature(factory, "http://xml.org/sax/features/external-parameter-entities", false);\n        trySetSAXFeature(factory, "http://apache.org/xml/features/nonvalidating/load-external-dtd", false);\n        trySetSAXFeature(factory, "http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false);\n        return factory;\n    }
512	@Beta\n    public void addDataColumn(int columnIndex, boolean isDataField) {\n        checkColumnIndex(columnIndex);\n\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n\n        pivotField.setDataField(isDataField);\n        pivotField.setShowAll(false);\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n    }
513	public XWPFFooter createFooter(Enum type, XWPFParagraph[] pars) {\n        XWPFFooter footer = getFooter(type);\n\n        if (footer == null) {\n            FtrDocument ftrDoc = FtrDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.FOOTER;\n            int i = getRelationIndex(relation);\n\n            XWPFFooter wrapper = (XWPFFooter) doc.createRelationship(relation,\n                    XWPFFactory.getInstance(), i);\n            wrapper.setXWPFDocument(doc);\n\n            CTHdrFtr ftr = buildFtr(type, wrapper, pars);\n            wrapper.setHeaderFooter(ftr);\n            ftrDoc.setFtr(ftr);\n            assignFooter(wrapper, type);\n            footer = wrapper;\n        }\n\n        return footer;\n    }
514	public Data transform(Data data, XMLCryptoContext context) throws TransformException {\n        LOG.log(POILogger.DEBUG, "transform(data,context)");\n        LOG.log(POILogger.DEBUG, "data java type: " + data.getClass().getName());\n        OctetStreamData octetStreamData = (OctetStreamData) data;\n        LOG.log(POILogger.DEBUG, "URI: " + octetStreamData.getURI());\n        InputStream octetStream = octetStreamData.getOctetStream();\n        \n        Document doc;\n        try {\n            doc = DocumentHelper.readDocument(octetStream);\n        } catch (Exception e) {\n            throw new TransformException(e.getMessage(), e);\n        }\n        \n                Element root = doc.getDocumentElement();\n        NodeList nl = root.getChildNodes();\n        TreeMap<String,Element> rsList = new TreeMap<>();\n        for (int i=nl.getLength()-1; i>=0; i--) {\n            Node n = nl.item(i);\n            if ("Relationship".equals(n.getLocalName())) {\n                Element el = (Element)n;\n                String id = el.getAttribute("Id");\n                if (sourceIds.contains(id)) {\n                    String targetMode = el.getAttribute("TargetMode");\n                    if (targetMode == null || targetMode.isEmpty()) {\n                        el.setAttribute("TargetMode", "Internal");\n                    }\n                    rsList.put(id, el);\n                }\n            }\n            root.removeChild(n);\n        }\n\n        for (Element el : rsList.values()) {\n            root.appendChild(el);\n        }\n        \n        LOG.log(POILogger.DEBUG, "# Relationship elements: ", rsList.size());\n        \n        return new ApacheNodeSetData(new XMLSignatureInput(root));\n    }
515	public static short[] getShortArray( byte[] data, int offset, int size )\n    {\n        short[] result = new short[size / SHORT_SIZE];\n        for ( int i = 0; i < result.length; i++ )\n        {\n            result[i] = getShort( data, offset + i * SHORT_SIZE );\n        }\n        return result;\n    }
516	static Boolean parseBoolean(String strRep) {\n        if (strRep.length() < 1) {\n            return null;\n        }\n        switch(strRep.charAt(0)) {\n            case 't':\n            case 'T':\n                if("TRUE".equalsIgnoreCase(strRep)) {\n                    return Boolean.TRUE;\n                }\n                break;\n            case 'f':\n            case 'F':\n                if("FALSE".equalsIgnoreCase(strRep)) {\n                    return Boolean.FALSE;\n                }\n                break;\n        }\n        return null;\n    }
517	private static String[] separateAreaRefs(String reference) {\n                                                        \n        \n        int len = reference.length();\n        int delimiterPos = -1;\n        boolean insideDelimitedName = false;\n        for(int i=0; i<len; i++) {\n            switch(reference.charAt(i)) {\n                case CELL_DELIMITER:\n                    if(!insideDelimitedName) {\n                        if(delimiterPos >=0) {\n                            throw new IllegalArgumentException("More than one cell delimiter '" \n                                    + CELL_DELIMITER + "' appears in area reference '" + reference + "'");\n                        }\n                        delimiterPos = i;\n                    }\n                    continue;                 case SPECIAL_NAME_DELIMITER:\n                    break;\n                default:\n                    continue;             }\n            if(!insideDelimitedName) {\n                insideDelimitedName = true;\n                continue;\n            }\n            \n            if(i >= len-1) {\n                                                throw new IllegalArgumentException("Area reference '" + reference \n                        + "' ends with special name delimiter '"  + SPECIAL_NAME_DELIMITER + "'");\n            }\n            if(reference.charAt(i+1) == SPECIAL_NAME_DELIMITER) {\n                                i++;             } else {\n                                insideDelimitedName = false;\n            }\n        }\n        if(delimiterPos < 0) {\n            return new String[] { reference, };\n        }\n\n        String partA = reference.substring(0, delimiterPos);\n        String partB = reference.substring(delimiterPos+1);\n        if(partB.indexOf(SHEET_NAME_DELIMITER) >= 0) {\n                                                \n            throw new RuntimeException("Unexpected " + SHEET_NAME_DELIMITER \n                    + " in second cell reference of '" + reference + "'");\n        }\n        \n        int plingPos = partA.lastIndexOf(SHEET_NAME_DELIMITER);\n        if(plingPos < 0) {\n            return new String [] { partA, partB, };\n        }\n        \n        String sheetName = partA.substring(0, plingPos + 1);         \n        return new String [] { partA, sheetName + partB, };\n    }
518	private void updateRawContents() throws IOException {\n        if (initialised) {\n                        \n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    \n                        for(TextPropCollection tpc : paragraphStyles) {\n                tpc.writeOut(baos);\n            }\n    \n                        for(TextPropCollection tpc : charStyles) {\n                tpc.writeOut(baos);\n            }\n    \n            rawContents = baos.toByteArray();\n        }\n        \n                int newSize = rawContents.length + reserved.length;\n        LittleEndian.putInt(_header,4,newSize);\n    }
519	public static OPCPackage create(File file) {\n		if (file == null || (file.exists() && file.isDirectory())) {\n			throw new IllegalArgumentException("file");\n		}\n\n		if (file.exists()) {\n			throw new InvalidOperationException(\n					"This package (or file) already exists : use the open() method or delete the file.");\n		}\n\n				OPCPackage pkg = new ZipPackage();\n		pkg.originalPackagePath = file.getAbsolutePath();\n\n		configurePackage(pkg);\n		return pkg;\n	}
520	public int adjustForInsert(int listIndex, int length) {\n        int size = _textPieces.size();\n\n        TextPiece tp = _textPieces.get(listIndex);\n\n                tp.setEnd(tp.getEnd() + length);\n\n                for (int x = listIndex + 1; x < size; x++) {\n            tp = _textPieces.get(x);\n            tp.setStart(tp.getStart() + length);\n            tp.setEnd(tp.getEnd() + length);\n        }\n\n                return length;\n    }
521	public static DVConstraint createDateConstraint(int comparisonOperator, String expr1, String expr2, String dateFormat) {\n		if (expr1 == null) {\n			throw new IllegalArgumentException("expr1 must be supplied");\n		}\n		OperatorType.validateSecondArg(comparisonOperator, expr2);\n		SimpleDateFormat df = null;\n		if (dateFormat != null) {\n		    df = new SimpleDateFormat(dateFormat, LocaleUtil.getUserLocale());\n		    df.setTimeZone(LocaleUtil.getUserTimeZone());\n		}\n		\n				String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertDate(expr1, df) : null;\n				String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertDate(expr2, df) : null;\n		return new DVConstraint(ValidationType.DATE, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
522	public int aggregateDrawingRecords(DrawingManager2 drawingManager, boolean createIfMissing) {\n        int loc = findFirstRecordLocBySid(DrawingRecord.sid);\n        boolean noDrawingRecordsFound = (loc == -1);\n        if (noDrawingRecordsFound) {\n            if(!createIfMissing) {\n                                return -1;\n            }\n\n            EscherAggregate aggregate = new EscherAggregate(true);\n            loc = findFirstRecordLocBySid(EscherAggregate.sid);\n            if (loc == -1) {\n                loc = findFirstRecordLocBySid( WindowTwoRecord.sid );\n            } else {\n                getRecords().remove(loc);\n            }\n            getRecords().add( loc, aggregate );\n            return loc;\n        }\n        List<RecordBase> records = getRecords();\n\n        EscherAggregate.createAggregate(records, loc);\n\n        return loc;\n    }
523	public void postSign(final DOMSignContext xmlSignContext, final String signatureValue)\n    throws MarshalException {\n        LOG.log(POILogger.DEBUG, "postSign");\n\n        final Document document = (Document)xmlSignContext.getParent();\n\n        \n        String signatureId = signatureConfig.getPackageSignatureId();\n        if (!signatureId.equals(document.getDocumentElement().getAttribute("Id"))) {\n            throw new RuntimeException("ds:Signature not found for @Id: " + signatureId);\n        }\n\n        \n        final Element signatureNode = getDsigElement(document, "SignatureValue"); \n        if (signatureNode == null) {\n            throw new RuntimeException("preSign has to be called before postSign");\n        }\n        signatureNode.setTextContent(signatureValue);\n\n        \n        for (SignatureFacet signatureFacet : signatureConfig.getSignatureFacets()) {\n            signatureFacet.postSign(document);\n        }\n\n        writeDocument(document);\n    }
524	private void compareNumberOfSheets(Locator loc1, Locator loc2) {\n        int num1 = loc1.workbook.getNumberOfSheets();\n        int num2 = loc2.workbook.getNumberOfSheets();\n        if (num1 != num2) {\n            String str = String.format(Locale.ROOT, "%s\nworkbook1 [%d] != workbook2 [%d]",\n                "Number of Sheets do not match ::",\n                num1, num2\n            );\n\n            listOfDifferences.add(str);\n            \n        }\n    }
525	public static void main(final String[] args)\n            throws UnsupportedEncodingException, IOException {\n        String originalFileName = null;\n        String copyFileName = null;\n\n        \n        if (args.length == 1) {\n            originalFileName = args[0];\n            File f = TempFile.createTempFile("CopyOfPOIFileSystem-", ".ole2");\n            f.deleteOnExit();\n            copyFileName = f.getAbsolutePath();\n        } else if (args.length == 2) {\n            originalFileName = args[0];\n            copyFileName = args[1];\n        } else {\n            System.err.println("Usage: " + CopyCompare.class.getName() +\n                    "originPOIFS [copyPOIFS]");\n            System.exit(1);\n        }\n\n        \n        final POIFSReader r = new POIFSReader();\n        final CopyFile cf = new CopyFile(copyFileName);\n        r.registerListener(cf);\n        r.setNotifyEmptyDirectories(true);\n\n        r.read(new File(originalFileName));\n\n        \n        cf.close();\n\n        \n        try (POIFSFileSystem opfs = new POIFSFileSystem(new File(originalFileName));\n             POIFSFileSystem cpfs = new POIFSFileSystem(new File(copyFileName))) {\n            final DirectoryEntry oRoot = opfs.getRoot();\n            final DirectoryEntry cRoot = cpfs.getRoot();\n            System.out.println(EntryUtils.areDirectoriesIdentical(oRoot, cRoot) ? "Equal" : "Not equal");\n        }\n    }
526	public void drawBorders(CellRangeAddress range, BorderStyle borderType,\n            BorderExtent extent) {\n        switch (extent) {\n        case NONE:\n            removeBorders(range);\n            break;\n        case ALL:\n            drawHorizontalBorders(range, borderType, BorderExtent.ALL);\n            drawVerticalBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case INSIDE:\n            drawHorizontalBorders(range, borderType, BorderExtent.INSIDE);\n            drawVerticalBorders(range, borderType, BorderExtent.INSIDE);\n            break;\n        case OUTSIDE:\n            drawOutsideBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case TOP:\n            drawTopBorder(range, borderType);\n            break;\n        case BOTTOM:\n            drawBottomBorder(range, borderType);\n            break;\n        case LEFT:\n            drawLeftBorder(range, borderType);\n            break;\n        case RIGHT:\n            drawRightBorder(range, borderType);\n            break;\n        case HORIZONTAL:\n            drawHorizontalBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case INSIDE_HORIZONTAL:\n            drawHorizontalBorders(range, borderType, BorderExtent.INSIDE);\n            break;\n        case OUTSIDE_HORIZONTAL:\n            drawOutsideBorders(range, borderType, BorderExtent.HORIZONTAL);\n            break;\n        case VERTICAL:\n            drawVerticalBorders(range, borderType, BorderExtent.ALL);\n            break;\n        case INSIDE_VERTICAL:\n            drawVerticalBorders(range, borderType, BorderExtent.INSIDE);\n            break;\n        case OUTSIDE_VERTICAL:\n            drawOutsideBorders(range, borderType, BorderExtent.VERTICAL);\n            break;\n        }\n    }
527	public static Document process( File xlsFile ) throws Exception\n    {\n        final HSSFWorkbook workbook = AbstractExcelUtils.loadXls( xlsFile );\n        try {\n            ExcelToFoConverter excelToHtmlConverter = new ExcelToFoConverter(\n                    XMLHelper.getDocumentBuilderFactory().newDocumentBuilder()\n                            .newDocument() );\n            excelToHtmlConverter.processWorkbook( workbook );\n            return excelToHtmlConverter.getDocument();\n        } finally {\n            workbook.close();\n        }\n    }
528	public void resize(double scaleX, double scaleY){\n        XSSFClientAnchor anchor = getClientAnchor();\n        XSSFClientAnchor pref = getPreferredSize(scaleX,scaleY);\n        if (anchor == null || pref == null) {\n            logger.log(POILogger.WARN, "picture is not anchored via client anchor - ignoring resize call");\n            return;\n        }\n\n        int row2 = anchor.getRow1() + (pref.getRow2() - pref.getRow1());\n        int col2 = anchor.getCol1() + (pref.getCol2() - pref.getCol1());\n\n        anchor.setCol2(col2);\n                anchor.setDx2(pref.getDx2());\n\n        anchor.setRow2(row2);\n                anchor.setDy2(pref.getDy2());\n    }
529	public void newFileLink() {\n        _range = new CellRangeAddress(0, 0, 0, 0);\n        _guid = STD_MONIKER;\n        _linkOpts = HLINK_URL | HLINK_LABEL;\n        _fileOpts = 0;\n        setLabel("");\n        _moniker = FILE_MONIKER;\n        setAddress(null);\n        setShortFilename("");\n        _uninterpretedTail = FILE_TAIL;\n    }
530	protected static CTGroupShape prototype() {\n        if (prototype == null) {\n            CTGroupShape shape = CTGroupShape.Factory.newInstance();\n\n            CTGroupShapeNonVisual nv = shape.addNewNvGrpSpPr();\n            CTNonVisualDrawingProps nvpr = nv.addNewCNvPr();\n            nvpr.setId(0);\n            nvpr.setName("Group 0");\n            nv.addNewCNvGrpSpPr();\n            CTGroupShapeProperties sp = shape.addNewGrpSpPr();\n            CTGroupTransform2D t2d = sp.addNewXfrm();\n            CTPositiveSize2D p1 = t2d.addNewExt();\n            p1.setCx(0);\n            p1.setCy(0);\n            CTPoint2D p2 = t2d.addNewOff();\n            p2.setX(0);\n            p2.setY(0);\n            CTPositiveSize2D p3 = t2d.addNewChExt();\n            p3.setCx(0);\n            p3.setCy(0);\n            CTPoint2D p4 = t2d.addNewChOff();\n            p4.setX(0);\n            p4.setY(0);\n\n            prototype = shape;\n        }\n        return prototype;\n    }
531	public XSSFShapeGroup createGroup(XSSFChildAnchor anchor) {\n        CTGroupShape ctShape = ctGroup.addNewGrpSp();\n        ctShape.set(prototype());\n\n        XSSFShapeGroup shape = new XSSFShapeGroup(getDrawing(), ctShape);\n        shape.parent = this;\n        shape.anchor = anchor;\n\n        \n        CTGroupTransform2D xfrm = shape.getCTGroupShape().getGrpSpPr().getXfrm();\n        CTTransform2D t2 = anchor.getCTTransform2D();\n        xfrm.setOff(t2.getOff());\n        xfrm.setExt(t2.getExt());\n                xfrm.setChExt(t2.getExt());\n        xfrm.setFlipH(t2.getFlipH());\n        xfrm.setFlipV(t2.getFlipV());\n\n        return shape;\n    }
532	public Record cloneViaReserialise() {\n                        byte[] b = serialize();\n        RecordInputStream rinp = new RecordInputStream(new ByteArrayInputStream(b));\n        rinp.nextRecord();\n\n        Record[] r = RecordFactory.createRecord(rinp);\n        if(r.length != 1) {\n            throw new IllegalStateException("Re-serialised a record to clone it, but got " + r.length + " records back!");\n        }\n        return r[0];\n    }
533	public POIFSFileSystem getSummaryEntries(DirectoryNode root, String encryptedStream)\n    throws IOException, GeneralSecurityException {\n        DocumentNode es = (DocumentNode) root.getEntry(encryptedStream);\n        DocumentInputStream dis = root.createDocumentInputStream(es);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        IOUtils.copy(dis, bos);\n        dis.close();\n        CryptoAPIDocumentInputStream sbis = new CryptoAPIDocumentInputStream(this, bos.toByteArray());\n        LittleEndianInputStream leis = new LittleEndianInputStream(sbis);\n        POIFSFileSystem fsOut = null;\n        try {\n            int streamDescriptorArrayOffset = (int) leis.readUInt();\n             leis.readUInt();\n            long skipN = streamDescriptorArrayOffset - 8L;\n            if (sbis.skip(skipN) < skipN) {\n                throw new EOFException("buffer underrun");\n            }\n            sbis.setBlock(0);\n            int encryptedStreamDescriptorCount = (int) leis.readUInt();\n            StreamDescriptorEntry entries[] = new StreamDescriptorEntry[encryptedStreamDescriptorCount];\n            for (int i = 0; i < encryptedStreamDescriptorCount; i++) {\n                StreamDescriptorEntry entry = new StreamDescriptorEntry();\n                entries[i] = entry;\n                entry.streamOffset = (int) leis.readUInt();\n                entry.streamSize = (int) leis.readUInt();\n                entry.block = leis.readUShort();\n                int nameSize = leis.readUByte();\n                entry.flags = leis.readUByte();\n                                entry.reserved2 = leis.readInt();\n                entry.streamName = StringUtil.readUnicodeLE(leis, nameSize);\n                leis.readShort();\n                assert(entry.streamName.length() == nameSize);\n            }\n\n            fsOut = new POIFSFileSystem();             for (StreamDescriptorEntry entry : entries) {\n                sbis.seek(entry.streamOffset);\n                sbis.setBlock(entry.block);\n                InputStream is = new BoundedInputStream(sbis, entry.streamSize);\n                fsOut.createDocument(is, entry.streamName);\n                is.close();\n            }\n        } catch (Exception e) {\n            IOUtils.closeQuietly(fsOut);\n            if (e instanceof GeneralSecurityException) {\n                throw (GeneralSecurityException)e;\n            } else if (e instanceof IOException) {\n                throw (IOException)e;\n            } else {\n                throw new IOException("summary entries can't be read", e);\n            }\n        } finally {\n            IOUtils.closeQuietly(leis);\n            IOUtils.closeQuietly(sbis);\n        }\n        return fsOut;\n    }
534	public String toString()\n    {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append("[SHARED FORMULA (").append(HexDump.intToHex(sid)).append("]\n");\n        buffer.append("    .range      = ").append(getRange()).append("\n");\n        buffer.append("    .reserved    = ").append(HexDump.shortToHex(field_5_reserved)).append("\n");\n\n        Ptg[] ptgs = field_7_parsed_expr.getTokens();\n        for (int k = 0; k < ptgs.length; k++ ) {\n           buffer.append("Formula[").append(k).append("]");\n           Ptg ptg = ptgs[k];\n           buffer.append(ptg).append(ptg.getRVAType()).append("\n");\n        }\n\n        buffer.append("[/SHARED FORMULA]\n");\n        return buffer.toString();\n    }
535	private synchronized String generateTempFileName(File directory) {\n		File tmpFilename;\n		do {\n			tmpFilename = new File(directory.getAbsoluteFile() + File.separator\n					+ "OpenXML4J" + System.nanoTime());\n		} while (tmpFilename.exists());\n		return FileHelper.getFilename(tmpFilename.getAbsoluteFile());\n	}
536	@SuppressWarnings("WeakerAccess")\n    protected static PaintStyle selectPaint(XSLFFillProperties fp, final CTSchemeColor phClr, final PackagePart parentPart, final XSLFTheme theme, boolean hasPlaceholder) {\n        if (fp == null || fp.isSetNoFill()) {\n            return null;\n        } else if (fp.isSetSolidFill()) {\n            return selectPaint(fp.getSolidFill(), phClr, theme);\n        } else if (fp.isSetBlipFill()) {\n            return selectPaint(fp.getBlipFill(), parentPart);\n        } else if (fp.isSetGradFill()) {\n            return selectPaint(fp.getGradFill(), phClr, theme);\n        } else if (fp.isSetMatrixStyle()) {\n            return selectPaint(fp.getMatrixStyle(), theme, fp.isLineStyle(), hasPlaceholder);\n        } else {\n            return null;\n        }\n    }
537	public static CFRule12Record createColorScale(HSSFSheet sheet) {\n        int numPoints = 3;\n        ExtendedColor[] colors = new ExtendedColor[numPoints];\n        ColorGradientThreshold[] ts = new ColorGradientThreshold[numPoints];\n        for (int i=0; i<ts.length; i++) {\n            ts[i] = new ColorGradientThreshold();\n            colors[i] = new ExtendedColor();\n        }\n        \n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_COLOR_SCALE, \n                                              ComparisonOperator.NO_COMPARISON);\n        ColorGradientFormatting cgf = r.createColorGradientFormatting();\n        cgf.setNumControlPoints(numPoints);\n        cgf.setThresholds(ts);\n        cgf.setColors(colors);\n        return r;\n    }
538	public StylesTable getStylesTable() throws IOException, InvalidFormatException {\n        ArrayList<PackagePart> parts = pkg.getPartsByContentType(XSSFRelation.STYLES.getContentType());\n        if (parts.size() == 0) return null;\n\n                StylesTable styles = new StylesTable(parts.get(0));\n        parts = pkg.getPartsByContentType(XSSFRelation.THEME.getContentType());\n        if (parts.size() != 0) {\n            styles.setTheme(new ThemesTable(parts.get(0)));\n        }\n        return styles;\n    }
539	public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IOException {\n                        for (String workbookName : WORKBOOK_DIR_ENTRY_NAMES) {\n            if (poifsDir.hasEntry(workbookName)) {\n                if (getPreferEventExtractor()) {\n                    return new EventBasedExcelExtractor(poifsDir);\n                }\n                return new ExcelExtractor(poifsDir);\n            }\n        }\n        if (poifsDir.hasEntry(OLD_WORKBOOK_DIR_ENTRY_NAME)) {\n            throw new OldExcelFormatException("Old Excel Spreadsheet format (1-95) "\n                    + "found. Please call OldExcelExtractor directly for basic text extraction");\n        }\n        \n                Class<?> cls = getScratchpadClass();\n        try {\n            Method m = cls.getDeclaredMethod("createExtractor", DirectoryNode.class);\n            POITextExtractor ext = (POITextExtractor)m.invoke(null, poifsDir);\n            if (ext != null) return ext;\n        } catch (IllegalArgumentException iae) {\n            throw iae;\n        } catch (Exception e) {\n            throw new IllegalArgumentException("Error creating Scratchpad Extractor", e);\n        }\n\n        throw new IllegalArgumentException("No supported documents found in the OLE2 stream");\n    }
540	private void collectValues(ValueEval operand, DoubleList temp) throws EvaluationException {\n        if (operand instanceof ThreeDEval) {\n            ThreeDEval ae = (ThreeDEval) operand;\n            for (int sIx=ae.getFirstSheetIndex(); sIx <= ae.getLastSheetIndex(); sIx++) {\n                int width = ae.getWidth();\n                int height = ae.getHeight();\n                for (int rrIx=0; rrIx<height; rrIx++) {\n                    for (int rcIx=0; rcIx<width; rcIx++) {\n                        ValueEval ve = ae.getValue(sIx, rrIx, rcIx);\n                        if(!isSubtotalCounted() && ae.isSubTotal(rrIx, rcIx)) continue;\n                        collectValue(ve, true, temp);\n                    }\n                }\n            }\n            return;\n        }\n		if (operand instanceof TwoDEval) {\n			TwoDEval ae = (TwoDEval) operand;\n			int width = ae.getWidth();\n			int height = ae.getHeight();\n			for (int rrIx=0; rrIx<height; rrIx++) {\n				for (int rcIx=0; rcIx<width; rcIx++) {\n					ValueEval ve = ae.getValue(rrIx, rcIx);\n                    if(!isSubtotalCounted() && ae.isSubTotal(rrIx, rcIx)) continue;\n                    collectValue(ve, true, temp);\n				}\n			}\n			return;\n		}\n		if (operand instanceof RefEval) {\n			RefEval re = (RefEval) operand;\n			for (int sIx = re.getFirstSheetIndex(); sIx <= re.getLastSheetIndex(); sIx++) {\n			    collectValue(re.getInnerValueEval(sIx), true, temp);\n			}\n			return;\n		}\n		collectValue(operand, false, temp);\n	}
541	private static double[] RGB2HSL(Color color)\n    {\n        \n        float[] rgb = color.getRGBColorComponents( null );\n        double r = rgb[0];\n        double g = rgb[1];\n        double b = rgb[2];\n\n        \n        double min = Math.min(r, Math.min(g, b));\n        double max = Math.max(r, Math.max(g, b));\n\n        \n        double h = 0;\n\n        if (max == min) {\n            h = 0;\n        } else if (max == r) {\n            h = ((60d * (g - b) / (max - min)) + 360d) % 360d;\n        } else if (max == g) {\n            h = (60d * (b - r) / (max - min)) + 120d;\n        } else if (max == b) {\n            h = (60d * (r - g) / (max - min)) + 240d;\n        }\n\n        \n        double l = (max + min) / 2d;\n\n        \n        final double s;\n\n        if (max == min) {\n            s = 0;\n        } else if (l <= .5d) {\n            s = (max - min) / (max + min);\n        } else {\n            s = (max - min) / (2d - max - min);\n        }\n\n        return new double[] {h, s * 100, l * 100};\n    }
542	public void save(File targetFile) throws IOException {\n		if (targetFile == null) {\n			throw new IllegalArgumentException("targetFile");\n		}\n\n		this.throwExceptionIfReadOnly();\n		\n				if(targetFile.exists() && \n		        targetFile.getAbsolutePath().equals(this.originalPackagePath)) {\n		    throw new InvalidOperationException(\n		            "You can't call save(File) to save to the currently open " +\n		            "file. To save to the current file, please just call close()"\n		    );\n		}\n		\n				FileOutputStream fos = null;\n		try {\n			fos = new FileOutputStream(targetFile);\n			this.save(fos);\n		} finally {\n			if (fos != null) {\n                fos.close();\n            }\n		}\n	}
543	private void onWorkbookCreate() {\n        workbook = CTWorkbook.Factory.newInstance();\n\n                CTWorkbookPr workbookPr = workbook.addNewWorkbookPr();\n        workbookPr.setDate1904(false);\n\n        setBookViewsIfMissing();\n        workbook.addNewSheets();\n\n        POIXMLProperties.ExtendedProperties expProps = getProperties().getExtendedProperties();\n        expProps.getUnderlyingProperties().setApplication(DOCUMENT_CREATOR);\n\n        sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, this.xssfFactory);\n        stylesSource = (StylesTable)createRelationship(XSSFRelation.STYLES, this.xssfFactory);\n        stylesSource.setWorkbook(this);\n\n        namedRanges = new ArrayList<>();\n        namedRangesByName = new ArrayListValuedHashMap<>();\n        sheets = new ArrayList<>();\n        pivotTables = new ArrayList<>();\n    }
544	protected static void fixLineEndings(List<HSLFTextParagraph> paragraphs) {\n        HSLFTextRun lastRun = null;\n        for (HSLFTextParagraph p : paragraphs) {\n            if (lastRun != null && !lastRun.getRawText().endsWith("\r")) {\n                lastRun.setText(lastRun.getRawText() + "\r");\n            }\n            List<HSLFTextRun> ltr = p.getTextRuns();\n            if (ltr.isEmpty()) {\n                throw new HSLFException("paragraph without textruns found");\n            }\n            lastRun = ltr.get(ltr.size() - 1);\n            assert (lastRun.getRawText() != null);\n        }\n    }
545	public static CFRule12Record create(HSSFSheet sheet, ExtendedColor color) {\n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_DATA_BAR, \n                                              ComparisonOperator.NO_COMPARISON);\n        DataBarFormatting dbf = r.createDataBarFormatting();\n        dbf.setColor(color);\n        dbf.setPercentMin((byte)0);\n        dbf.setPercentMax((byte)100);\n        \n        DataBarThreshold min = new DataBarThreshold();\n        min.setType(RangeType.MIN.id);\n        dbf.setThresholdMin(min);\n        \n        DataBarThreshold max = new DataBarThreshold();\n        max.setType(RangeType.MAX.id);\n        dbf.setThresholdMax(max);\n        \n        return r;\n    }
546	static void evaluateRules(Workbook wb, String sheetName) {\n        final WorkbookEvaluatorProvider wbEvalProv = (WorkbookEvaluatorProvider) wb.getCreationHelper().createFormulaEvaluator();\n        final ConditionalFormattingEvaluator cfEval = new ConditionalFormattingEvaluator(wb, wbEvalProv);\n                cfEval.clearAllCachedValues();\n        \n        final Sheet sheet = wb.getSheet(sheetName);\n        for (Row r : sheet) {\n            for (Cell c : r) {\n                final List<EvaluationConditionalFormatRule> rules = cfEval.getConditionalFormattingForCell(c);\n                                if (rules == null || rules.isEmpty()) continue;\n                final CellReference ref = ConditionalFormattingEvaluator.getRef(c);\n                if (rules.isEmpty()) continue;\n\n                System.out.println("\n"\n                  + ref.formatAsString()\n                  + " has conditional formatting.");\n\n                for (EvaluationConditionalFormatRule rule : rules) {\n                    ConditionalFormattingRule cf = rule.getRule();\n\n                    StringBuilder b = new StringBuilder();\n                    b.append("\tRule ")\n                     .append(rule.getFormattingIndex())\n                     .append(": ");\n                    \n                                        if (cf.getColorScaleFormatting() != null) {\n                        b.append("\n\t\tcolor scale (caller must calculate bucket)");\n                    }\n                                        if (cf.getDataBarFormatting() != null) {\n                        b.append("\n\t\tdata bar (caller must calculate bucket)");\n                    }\n                                        if (cf.getMultiStateFormatting() != null) {\n                        b.append("\n\t\ticon set (caller must calculate icon bucket)");\n                    }\n                                        if (cf.getPatternFormatting() != null) {\n                        final PatternFormatting fill = cf.getPatternFormatting();\n                        b.append("\n\t\tfill pattern ")\n                         .append(fill.getFillPattern())\n                         .append(" color index ")\n                         .append(fill.getFillBackgroundColor());\n                    }\n                                        if (cf.getFontFormatting() != null) {\n                        final FontFormatting ff = cf.getFontFormatting();\n                        b.append("\n\t\tfont format ")\n                         .append("color index ")\n                         .append(ff.getFontColorIndex());\n                        if (ff.isBold()) b.append(" bold");\n                        if (ff.isItalic()) b.append(" italic");\n                        if (ff.isStruckout()) b.append(" strikeout");\n                        b.append(" underline index ")\n                         .append(ff.getUnderlineType());\n                    }\n                    \n                    System.out.println(b);\n                }\n            }\n        }\n    }
547	private void isCellFontFamilyMatches(Locator loc1, Locator loc2) {\n                if (!(loc1.cell instanceof XSSFCell)) return;\n        String family1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getFontName();\n        String family2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getFontName();\n        if (!family1.equals(family2)) {\n            addMessage(loc1, loc2, "Cell Font Family does not Match ::", family1, family2);\n        }\n    }
548	public static boolean matchesPngHeader(byte[] data, int offset) {\n        if (data == null || data.length - offset < PNG_FILE_HEADER.length) {\n            return false;\n        }\n\n        for (int i = 0; i < PNG_FILE_HEADER.length; i++) {\n            if (PNG_FILE_HEADER[i] != data[i + offset]) {\n                return false;\n            }\n        }\n\n        return true;\n    }
549	HSSFCell createCellFromRecord(CellValueRecordInterface cell) {\n        HSSFCell hcell = new HSSFCell(book, sheet, cell);\n\n        addCell(hcell);\n        int colIx = cell.getColumn();\n        if (row.isEmpty()) {\n            row.setFirstCol(colIx);\n            row.setLastCol(colIx + 1);\n        } else {\n            if (colIx < row.getFirstCol()) {\n                row.setFirstCol(colIx);\n            } else if (colIx > row.getLastCol()) {\n                row.setLastCol(colIx + 1);\n            } \n        }\n                return hcell;\n    }
550	public void confirmSignature() throws XMLSignatureException, MarshalException {\n        final Document document = DocumentHelper.createDocument();\n        final DOMSignContext xmlSignContext = createXMLSignContext(document);\n\n                final DOMSignedInfo signedInfo = preSign(xmlSignContext);\n\n                final String signatureValue = signDigest(xmlSignContext, signedInfo);\n\n                postSign(xmlSignContext, signatureValue);\n    }
551	private static int indexOf(byte[] data, int offset, byte[] pattern) {\n        int[] failure = computeFailure(pattern);\n\n        int j = 0;\n        if (data.length == 0) {\n            return -1;\n        }\n\n        for (int i = offset; i < data.length; i++) {\n            while (j > 0 && pattern[j] != data[i]) {\n                j = failure[j - 1];\n            }\n            if (pattern[j] == data[i]) { j++; }\n            if (j == pattern.length) {\n                return i - pattern.length + 1;\n            }\n        }\n        return -1;\n    }
552	private int getBodyElementSpecificPos(int pos, List<? extends IBodyElement> list) {\n                if (list.size() == 0) {\n            return -1;\n        }\n\n        if (pos >= 0 && pos < bodyElements.size()) {\n                        IBodyElement needle = bodyElements.get(pos);\n            if (needle.getElementType() != list.get(0).getElementType()) {\n                                return -1;\n            }\n\n                        int startPos = Math.min(pos, list.size() - 1);\n            for (int i = startPos; i >= 0; i--) {\n                if (list.get(i) == needle) {\n                    return i;\n                }\n            }\n        }\n\n                return -1;\n    }
553	private void writePropertySet(String name, PropertySet set, POIFSFileSystem outFS) throws IOException {\n        try {\n            PropertySet mSet = new PropertySet(set);\n            ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n\n            mSet.write(bOut);\n            byte[] data = bOut.toByteArray();\n            ByteArrayInputStream bIn = new ByteArrayInputStream(data);\n\n                        outFS.createOrUpdateDocument(bIn, name);\n\n            logger.log(POILogger.INFO, "Wrote property set " + name + " of size " + data.length);\n        } catch(org.apache.poi.hpsf.WritingNotSupportedException wnse) {\n            logger.log( POILogger.ERROR, "Couldn't write property set with name " + name + " as not supported by HPSF yet");\n        }\n    }
554	private static double getColumnWidthForRow(\n            Row row, int column, int defaultCharWidth, DataFormatter formatter, boolean useMergedCells) {\n        if( row == null ) {\n            return -1;\n        }\n\n        Cell cell = row.getCell(column);\n\n        if (cell == null) {\n            return -1;\n        }\n\n        return getCellWidth(cell, defaultCharWidth, formatter, useMergedCells);\n    }
555	public void writeOut(OutputStream out) throws IOException {\n		\n				ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		for (Record r : _children) r.writeOut(baos);\n		byte[] data = baos.toByteArray();\n\n				_escherRecord.setData(data);\n	}
556	private static int lookupIndexOfExactValue(LookupValueComparer lookupComparer, ValueVector vector) {\n\n				int size = vector.getSize();\n		for (int i = 0; i < size; i++) {\n			if(lookupComparer.compareTo(vector.getItem(i)).isEqual()) {\n				return i;\n			}\n		}\n		return -1;\n	}
557	public boolean removeAbstractNum(BigInteger abstractNumID) {\n        if (abstractNumID.byteValue() < abstractNums.size()) {\n            ctNumbering.removeAbstractNum(abstractNumID.byteValue());\n            abstractNums.remove(abstractNumID.byteValue());\n            return true;\n        }\n        return false;\n    }
558	public XWPFRun insertNewRun(int pos) {\n        if (pos >= 0 && pos <= runs.size()) {\n                                                int rPos = 0;\n            for (int i = 0; i < pos; i++) {\n                XWPFRun currRun = runs.get(i);\n                if (!(currRun instanceof XWPFHyperlinkRun\n                        || currRun instanceof XWPFFieldRun)) {\n                    rPos++;\n                }\n            }\n\n            CTR ctRun = paragraph.insertNewR(rPos);\n            XWPFRun newRun = new XWPFRun(ctRun, (IRunBody) this);\n\n                                    int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != -1) {\n                    iPos = oldAt;\n                }\n            }\n            iruns.add(iPos, newRun);\n\n                        runs.add(pos, newRun);\n\n            return newRun;\n        }\n\n        return null;\n    }
559	static void shadeAlt(Sheet sheet) {\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("MOD(ROW(),2)");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.LIGHT_GREEN.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:Z100")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.createRow(0).createCell(1).setCellValue("Shade Alternating Rows");\n        sheet.createRow(1).createCell(1).setCellValue("Condition: Formula Is  =MOD(ROW(),2)   (Light Green Fill)");\n    }
560	public void removeTable(XSSFTable t) {\n        long id = t.getCTTable().getId();\n        Map.Entry<String, XSSFTable> toDelete = null;\n\n        for (Map.Entry<String, XSSFTable> entry : tables.entrySet()) {\n            if (entry.getValue().getCTTable().getId() == id) toDelete = entry;\n        }\n        if (toDelete != null) {\n            removeRelation(getRelationById(toDelete.getKey()), true);\n            tables.remove(toDelete.getKey());\n            toDelete.getValue().onTableDelete();\n        }\n    }
561	public void removeCustomProperties() {\n        if (getSectionCount() < 2) {\n            throw new HPSFRuntimeException("Illegal internal format of Document SummaryInformation stream: second section is missing.");\n        }\n\n        List<Section> l = new LinkedList<>(getSections());\n        clearSections();\n        int idx = 0;\n        for (Section s : l) {\n            if (idx++ != 1) {\n                addSection(s);\n            }\n        }\n    }
562	public int write(final OutputStream out, final int codepage)\n    throws IOException, WritingNotSupportedException {\n        int length = 0;\n        long variantType = getType();\n\n        \n\n        if (variantType == Variant.VT_LPSTR && codepage != CodePageUtil.CP_UTF16) {\n            String csStr = CodePageUtil.codepageToEncoding(codepage > 0 ? codepage : Property.DEFAULT_CODEPAGE);\n            if (!Charset.forName(csStr).newEncoder().canEncode((String)value)) {\n                variantType = Variant.VT_LPWSTR;\n            }\n        }\n\n        LittleEndian.putUInt(variantType, out);\n        length += LittleEndianConsts.INT_SIZE;\n        length += VariantSupport.write(out, variantType, getValue(), codepage);\n        return length;\n    }
563	private NotImplementedException addExceptionInfo(NotImplementedException inner, int sheetIndex, int rowIndex, int columnIndex) {\n\n        try {\n            String sheetName = _workbook.getSheetName(sheetIndex);\n            CellReference cr = new CellReference(sheetName, rowIndex, columnIndex, false, false);\n            String msg =  "Error evaluating cell " + cr.formatAsString();\n            return new NotImplementedException(msg, inner);\n        } catch (Exception e) {\n                        LOG.log(POILogger.ERROR, "Can't add exception info", e);\n            return inner;         }\n    }
564	private Workbook loadWorkbook() {\n        if (excelFileName == null) {\n            throw new BuildException("fileName attribute must be set!", getLocation());\n        }\n\n        try {\n            try (FileInputStream fis = new FileInputStream(excelFileName)) {\n                workbook = WorkbookFactory.create(fis);\n            }\n        } catch(Exception e) {\n            throw new BuildException("Cannot load file " + excelFileName\n                    + ". Make sure the path and file permissions are correct.", e);\n        }\n\n        return workbook;\n    }
565	public ArrayList<PackagePart> getPartsByRelationshipType(\n			String relationshipType) {\n		if (relationshipType == null) {\n			throw new IllegalArgumentException("relationshipType");\n		}\n		ArrayList<PackagePart> retArr = new ArrayList<>();\n		for (PackageRelationship rel : getRelationshipsByType(relationshipType)) {\n			PackagePart part = getPart(rel);\n			if (part != null) {\n			    retArr.add(part);\n			}\n		}\n		Collections.sort(retArr);\n		return retArr;\n	}
566	public static Cell translateUnicodeValues(Cell cell) {\n\n        String s = cell.getRichStringCellValue().getString();\n        boolean foundUnicode = false;\n        String lowerCaseStr = s.toLowerCase(Locale.ROOT);\n\n        for (UnicodeMapping entry : unicodeMappings) {\n            String key = entry.entityName;\n            if (lowerCaseStr.contains(key)) {\n                s = s.replaceAll(key, entry.resolvedValue);\n                foundUnicode = true;\n            }\n        }\n        if (foundUnicode) {\n            cell.setCellValue(cell.getRow().getSheet().getWorkbook().getCreationHelper()\n                    .createRichTextString(s));\n        }\n        return cell;\n    }
567	public int buildTextPropList(int containsField, byte[] data, int dataOffset) {\n		int bytesPassed = 0;\n\n						for(TextProp tp : getPotentialProperties()) {\n			\n						if((containsField & tp.getMask()) != 0) {\n                if(dataOffset+bytesPassed >= data.length) {\n                                                            maskSpecial |= tp.getMask();\n                    return bytesPassed;\n                }\n\n								TextProp prop = tp.clone();\n				int val = 0;\n				if (prop instanceof HSLFTabStopPropCollection) {\n                    ((HSLFTabStopPropCollection)prop).parseProperty(data, dataOffset+bytesPassed);\n                } else if (prop.getSize() == 2) {\n					val = LittleEndian.getShort(data,dataOffset+bytesPassed);\n				} else if(prop.getSize() == 4) {\n					val = LittleEndian.getInt(data,dataOffset+bytesPassed);\n				} else if (prop.getSize() == 0) {\n                                        maskSpecial |= tp.getMask();\n                    continue;\n                }\n				\n				if (prop instanceof BitMaskTextProp) {\n				    ((BitMaskTextProp)prop).setValueWithMask(val, containsField);\n				} else if (!(prop instanceof HSLFTabStopPropCollection)) {\n				    prop.setValue(val);\n				}\n				bytesPassed += prop.getSize();\n				addProp(prop);\n			}\n		}\n\n				return bytesPassed;\n	}
568	private void updateFormula(XSSFCell cell, String oldName, String newName) {\n        CTCellFormula f = cell.getCTCell().getF();\n        if (f != null) {\n            String formula = f.getStringValue();\n            if (formula != null && formula.length() > 0) {\n                int sheetIndex = _wb.getSheetIndex(cell.getSheet());\n                Ptg[] ptgs = FormulaParser.parse(formula, _fpwb, FormulaType.CELL, sheetIndex, cell.getRowIndex());\n                for (Ptg ptg : ptgs) {\n                    updatePtg(ptg, oldName, newName);\n                }\n                String updatedFormula = FormulaRenderer.toFormulaString(_fpwb, ptgs);\n                if (!formula.equals(updatedFormula)) f.setStringValue(updatedFormula);\n            }\n        }\n    }
569	protected String getCellFormula(XSSFEvaluationWorkbook fpb) {\n        CellType cellType = getCellType();\n        if(cellType != CellType.FORMULA) {\n            throw typeMismatch(CellType.FORMULA, cellType, false);\n        }\n\n        CTCellFormula f = _cell.getF();\n        if (isPartOfArrayFormulaGroup()) {\n            \n            if (f == null || f.getStringValue().isEmpty()) {\n                XSSFCell cell = getSheet().getFirstCellInArrayFormula(this);\n                return cell.getCellFormula(fpb);\n            }\n        }\n        if (f.getT() == STCellFormulaType.SHARED) {\n            return convertSharedFormula((int)f.getSi(), fpb == null ? XSSFEvaluationWorkbook.create(getSheet().getWorkbook()) : fpb);\n        }\n        return f.getStringValue();\n    }
570	static void preserveSpaces(XmlString xs) {\n        String text = xs.getStringValue();\n        if (text != null && (text.startsWith(" ") || text.endsWith(" "))) {\n            XmlCursor c = xs.newCursor();\n            c.toNextToken();\n            c.insertAttributeWithValue(new QName("http://www.w3.org/XML/1998/namespace", "space"), "preserve");\n            c.dispose();\n        }\n    }
571	public XDDFTextRun appendRegularRun(String text) {\n        CTRegularTextRun r = _p.addNewR();\n        r.setT(text);\n        CTTextCharacterProperties rPr = r.addNewRPr();\n        rPr.setLang(LocaleUtil.getUserLocale().toLanguageTag());\n        XDDFTextRun run = new XDDFTextRun(r, this);\n        _runs.add(run);\n        return run;\n    }
572	public void restoreProperties(int index) {\n        if (index == 0) {\n            return;\n        }\n        int stackIndex = index;\n        if (stackIndex < 0) {\n            int curIdx = propStack.indexOf(prop);\n            if (curIdx == -1) {\n                                curIdx = propStack.size();\n            }\n            stackIndex = curIdx + index;\n        }\n        if (stackIndex == -1) {\n                        stackIndex = propStack.size()-1;\n        }\n        prop = propStack.get(stackIndex);\n    }
573	public HSSFComment createComment(HSSFAnchor anchor) {\n        HSSFComment shape = new HSSFComment(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
574	protected List<PropertyValue> writeProperties(OutputStream out) throws IOException {\n        List<PropertyValue> variableLengthProperties = new ArrayList<>();\n        for (Entry<MAPIProperty, PropertyValue> entry : properties.entrySet()) {\n            MAPIProperty property = entry.getKey();\n            PropertyValue value = entry.getValue();\n            if (value == null) {\n                continue;\n            }\n            if (property.id < 0) {\n                continue;\n            }\n                          	                    long tag = Long.parseLong(getFileName(property, value.getActualType()), 16);\n            LittleEndian.putUInt(tag, out);\n            LittleEndian.putUInt(value.getFlags(), out); \n            MAPIType type = getTypeMapping(value.getActualType());\n            if (type.isFixedLength()) {\n                                writeFixedLengthValueHeader(out, property, type, value);\n            } else {\n                                writeVariableLengthValueHeader(out, property, type, value);\n                variableLengthProperties.add(value);\n            }\n        }\n        return variableLengthProperties;\n    }
575	public static String createSafeSheetName(final String nameProposal, char replaceChar) {\n        if (nameProposal == null) {\n            return "null";\n        }\n        if (nameProposal.length() < 1) {\n            return "empty";\n        }\n        final int length = Math.min(31, nameProposal.length());\n        final String shortenname = nameProposal.substring(0, length);\n        final StringBuilder result = new StringBuilder(shortenname);\n        for (int i=0; i<length; i++) {\n            char ch = result.charAt(i);\n            switch (ch) {\n                case '\u0000':\n                case '\u0003':\n                case ':':\n                case '/':\n                case '\\':\n                case '?':\n                case '*':\n                case ']':\n                case '[':\n                    result.setCharAt(i, replaceChar);\n                    break;\n                case '\'':\n                    if (i==0 || i==length-1) {\n                        result.setCharAt(i, replaceChar);\n                    }\n                    break;\n                default:\n                                }\n        }\n        return result.toString();\n    }
576	private RuntimeException expected(String s) {\n        String msg;\n\n        if (look == '=' && _formulaString.substring(0, _pointer-1).trim().length() < 1) {\n            msg = "The specified formula '" + _formulaString\n                + "' starts with an equals sign which is not allowed.";\n        } else {\n            msg = new StringBuilder("Parse error near char ")\n                .append(_pointer-1)                 .append(" '")\n                .appendCodePoint(look)\n                .append("'")\n                .append(" in specified formula '")\n                .append(_formulaString)\n                .append("'. Expected ")\n                .append(s)\n                .toString();\n        }\n        return new FormulaParseException(msg);\n    }
577	public Date calculateWorkdays(double start, int workdays, double[] holidays) {\n		Date startDate = DateUtil.getJavaDate(start);\n		int direction = workdays < 0 ? -1 : 1;\n		Calendar endDate = LocaleUtil.getLocaleCalendar();\n		endDate.setTime(startDate);\n		double excelEndDate = DateUtil.getExcelDate(endDate.getTime());\n		while (workdays != 0) {\n			endDate.add(Calendar.DAY_OF_YEAR, direction);\n			excelEndDate += direction;\n			if (endDate.get(Calendar.DAY_OF_WEEK) != Calendar.SATURDAY\n					&& endDate.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY\n					&& !isHoliday(excelEndDate,	holidays)) {\n				workdays -= direction;\n			}\n		}\n		return endDate.getTime();\n	}
578	@Beta\n    @Internal\n    public void copyCellFrom(Cell srcCell, CellCopyPolicy policy) {\n                if (policy.isCopyCellValue()) {\n            if (srcCell != null) {\n                CellType copyCellType = srcCell.getCellType();\n                if (copyCellType == CellType.FORMULA && !policy.isCopyCellFormula()) {\n                                                            copyCellType = srcCell.getCachedFormulaResultType();\n                }\n                switch (copyCellType) {\n                    case NUMERIC:\n                                                if (DateUtil.isCellDateFormatted(srcCell)) {\n                            setCellValue(srcCell.getDateCellValue());\n                        }\n                        else {\n                            setCellValue(srcCell.getNumericCellValue());\n                        }\n                        break;\n                    case STRING:\n                        setCellValue(srcCell.getStringCellValue());\n                        break;\n                    case FORMULA:\n                        setCellFormula(srcCell.getCellFormula());\n                        break;\n                    case BLANK:\n                        setBlank();\n                        break;\n                    case BOOLEAN:\n                        setCellValue(srcCell.getBooleanCellValue());\n                        break;\n                    case ERROR:\n                        setCellErrorValue(srcCell.getErrorCellValue());\n                        break;\n\n                    default:\n                        throw new IllegalArgumentException("Invalid cell type " + srcCell.getCellType());\n                }\n            } else {                 setBlank();\n            }\n        }\n        \n                if (policy.isCopyCellStyle()) {\n            setCellStyle(srcCell == null ? null : srcCell.getCellStyle());\n        }\n        \n        final Hyperlink srcHyperlink = (srcCell == null) ? null : srcCell.getHyperlink();\n\n        if (policy.isMergeHyperlink()) {\n                        if (srcHyperlink != null) {\n                setHyperlink(new XSSFHyperlink(srcHyperlink));\n            }\n        } else if (policy.isCopyHyperlink()) {\n                                    setHyperlink(srcHyperlink == null ? null : new XSSFHyperlink(srcHyperlink));\n        }\n    }
579	public static Color HSL2RGB(double h, double s, double l, double alpha) {\n                        s = Math.max(0, Math.min(100, s));\n        l = Math.max(0, Math.min(100, l));\n\n        if (alpha <0.0f || alpha > 1.0f) {\n            String message = "Color parameter outside of expected range - Alpha: " + alpha;\n            throw new IllegalArgumentException( message );\n        }\n\n        \n        h = h % 360.0f;\n        h /= 360f;\n        s /= 100f;\n        l /= 100f;\n\n        double q = (l < 0.5d)\n            ? l * (1d + s)\n            : (l + s) - (s * l);\n\n        double p = 2d * l - q;\n\n        double r = Math.max(0, HUE2RGB(p, q, h + (1.0d / 3.0d)));\n        double g = Math.max(0, HUE2RGB(p, q, h));\n        double b = Math.max(0, HUE2RGB(p, q, h - (1.0d / 3.0d)));\n\n        r = Math.min(r, 1.0d);\n        g = Math.min(g, 1.0d);\n        b = Math.min(b, 1.0d);\n\n        return new Color((float)r, (float)g, (float)b, (float)alpha);\n    }
580	public void addChild(final Property property)\n        throws IOException\n    {\n        String name = property.getName();\n\n        if (_children_names.contains(name))\n        {\n            throw new IOException("Duplicate name \"" + name + "\"");\n        }\n        _children_names.add(name);\n        _children.add(property);\n    }
581	private SheetIdentifier parseSheetRange(String bookname, NameIdentifier sheet1Name) {\n        GetChar();\n        SheetIdentifier sheet2 = parseSheetName();\n        if (sheet2 != null) {\n           return new SheetRangeIdentifier(bookname, sheet1Name, sheet2.getSheetIdentifier());\n        }\n        return null;\n    }
582	private XSSFPivotTable createPivotTable(CellReference position, Sheet sourceSheet, PivotTableReferenceConfigurator refConfig) {\n\n        XSSFPivotTable pivotTable = createPivotTable();\n                pivotTable.setDefaultPivotTableDefinition();\n\n                pivotTable.createSourceReferences(position, sourceSheet, refConfig);\n\n                pivotTable.getPivotCacheDefinition().createCacheFields(sourceSheet);\n        pivotTable.createDefaultDataColumns();\n\n        return pivotTable;\n    }
583	public static HSLFSoundData[] find(Document document){\n        ArrayList<HSLFSoundData> lst = new ArrayList<>();\n        Record[] ch = document.getChildRecords();\n        for (int i = 0; i < ch.length; i++) {\n            if(ch[i].getRecordType() == RecordTypes.SoundCollection.typeID){\n                RecordContainer col = (RecordContainer)ch[i];\n                Record[] sr = col.getChildRecords();\n                for (int j = 0; j < sr.length; j++) {\n                    if(sr[j] instanceof Sound){\n                        lst.add(new HSLFSoundData((Sound)sr[j]));\n                    }\n                }\n            }\n\n        }\n        return lst.toArray(new HSLFSoundData[lst.size()]);\n    }
584	public static DVConstraint createTimeConstraint(int comparisonOperator, String expr1, String expr2) {\n		if (expr1 == null) {\n			throw new IllegalArgumentException("expr1 must be supplied");\n		}\n		OperatorType.validateSecondArg(comparisonOperator, expr1);\n		\n				String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertTime(expr1) : null;\n				String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertTime(expr2) : null;\n		return new DVConstraint(ValidationType.TIME, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
585	public static String mapMsCodepointString(String string) {\n        if (string == null || string.isEmpty()) return string;\n        initMsCodepointMap();\n\n        StringBuilder sb = new StringBuilder();\n        final int length = string.length();\n        for (int offset = 0; offset < length; ) {\n            Integer msCodepoint = string.codePointAt(offset);\n            Integer uniCodepoint = msCodepointToUnicode.get(msCodepoint);\n            sb.appendCodePoint(uniCodepoint == null ? msCodepoint : uniCodepoint);\n            offset += Character.charCount(msCodepoint);\n        }\n\n        return sb.toString();\n    }
586	protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {\n       boolean firstInStore = false;\n       if (_mini_stream.getStartBlock() == POIFSConstants.END_OF_CHAIN) {\n           firstInStore = true;\n       }\n       \n              if (! firstInStore) {\n           try {\n              return getBlockAt(offset);\n           } catch(IndexOutOfBoundsException e) {}\n       }\n       \n                     \n              int newBigBlock = _filesystem.getFreeBlock();\n       _filesystem.createBlockIfNeeded(newBigBlock);\n       \n              if (firstInStore) {\n           _filesystem._get_property_table().getRoot().setStartBlock(newBigBlock);\n           _mini_stream = new POIFSStream(_filesystem, newBigBlock);\n       } else {\n                      ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\n           int block = _mini_stream.getStartBlock();\n           while(true) {\n              loopDetector.claim(block);\n              int next = _filesystem.getNextBlock(block);\n              if(next == POIFSConstants.END_OF_CHAIN) {\n                 break;\n              }\n              block = next;\n           }\n           _filesystem.setNextBlock(block, newBigBlock);\n       }\n       \n              _filesystem.setNextBlock(newBigBlock, POIFSConstants.END_OF_CHAIN);\n\n              return createBlockIfNeeded(offset);\n    }
587	public XWPFNumbering createNumbering() {\n        if (numbering == null) {\n            NumberingDocument numberingDoc = NumberingDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.NUMBERING;\n            int i = getRelationIndex(relation);\n\n            XWPFNumbering wrapper = (XWPFNumbering) createRelationship(relation, XWPFFactory.getInstance(), i);\n            wrapper.setNumbering(numberingDoc.addNewNumbering());\n            numbering = wrapper;\n        }\n\n        return numbering;\n    }
588	private void processGlyphs(Graphics2D graphics, DrawFontManager dfm, List<AttributedStringData> attList, final int beginIndex, TextRun run, String runText) {\n                List<FontGroupRange> ttrList = FontGroup.getFontGroupRanges(runText);\n        int rangeBegin = 0;\n        for (FontGroupRange ttr : ttrList) {\n            FontInfo fiRun = run.getFontInfo(ttr.getFontGroup());\n            if (fiRun == null) {\n                                fiRun = run.getFontInfo(FontGroup.LATIN);\n            }\n            FontInfo fiMapped = dfm.getMappedFont(graphics, fiRun);\n            FontInfo fiFallback = dfm.getFallbackFont(graphics, fiRun);\n            assert(fiFallback != null);\n            if (fiMapped == null) {\n                fiMapped = dfm.getMappedFont(graphics, new DrawFontInfo(paragraph.getDefaultFontFamily()));\n            }\n            if (fiMapped == null) {\n                fiMapped = fiFallback;\n            }\n\n            Font fontMapped = dfm.createAWTFont(graphics, fiMapped, 10, run.isBold(), run.isItalic());\n            Font fontFallback = dfm.createAWTFont(graphics, fiFallback, 10, run.isBold(), run.isItalic());\n\n                        final int rangeLen = ttr.getLength();\n            int partEnd = rangeBegin;\n            while (partEnd<rangeBegin+rangeLen) {\n                                int partBegin = partEnd;\n                partEnd = nextPart(fontMapped, runText, partBegin, rangeBegin+rangeLen, true);\n\n                                                                \n                if (partBegin < partEnd) {\n                                        attList.add(new AttributedStringData(TextAttribute.FAMILY, fontMapped.getFontName(Locale.ROOT), beginIndex+partBegin, beginIndex+partEnd));\n                    if (LOG.check(POILogger.DEBUG)) {\n                        LOG.log(POILogger.DEBUG, "mapped: ",fontMapped.getFontName(Locale.ROOT)," ",(beginIndex+partBegin)," ",(beginIndex+partEnd)," - ",runText.substring(beginIndex+partBegin, beginIndex+partEnd));\n                    }\n                }\n\n                                partBegin = partEnd;\n                partEnd = nextPart(fontMapped, runText, partBegin, rangeBegin+rangeLen, false);\n                \n                if (partBegin < partEnd) {\n                                        attList.add(new AttributedStringData(TextAttribute.FAMILY, fontFallback.getFontName(Locale.ROOT), beginIndex+partBegin, beginIndex+partEnd));\n                    if (LOG.check(POILogger.DEBUG)) {\n                        LOG.log(POILogger.DEBUG, "fallback: ",fontFallback.getFontName(Locale.ROOT)," ",(beginIndex+partBegin)," ",(beginIndex+partEnd)," - ",runText.substring(beginIndex+partBegin, beginIndex+partEnd));\n                    }\n                }\n            }\n            \n            rangeBegin += rangeLen;\n        }\n    }
589	public static BATBlock createEmptyBATBlock(final POIFSBigBlockSize bigBlockSize, boolean isXBAT) {\n       BATBlock block = new BATBlock(bigBlockSize);\n       if(isXBAT) {\n           final int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();\n           block._values[ _entries_per_xbat_block ] = POIFSConstants.END_OF_CHAIN;\n       }\n       return block;\n    }
590	public boolean trackColumn(int column) {\n        untrackedColumns.remove(column);\n        if (!maxColumnWidths.containsKey(column)) {\n            maxColumnWidths.put(column, new ColumnWidthPair());\n            return true;\n        }\n        return false;\n    }
591	public void applyBorders(Sheet sheet) {\n        Workbook wb = sheet.getWorkbook();\n        for (Map.Entry<CellAddress, Map<String, Object>> entry : _propertyTemplate\n                .entrySet()) {\n            CellAddress cellAddress = entry.getKey();\n            if (cellAddress.getRow() < wb.getSpreadsheetVersion().getMaxRows()\n                    && cellAddress.getColumn() < wb.getSpreadsheetVersion()\n                            .getMaxColumns()) {\n                Map<String, Object> properties = entry.getValue();\n                Row row = CellUtil.getRow(cellAddress.getRow(), sheet);\n                Cell cell = CellUtil.getCell(row, cellAddress.getColumn());\n                CellUtil.setCellStyleProperties(cell, properties);\n            }\n        }\n    }
592	public XWPFHeader createHeader(HeaderFooterType type) {\n        XWPFHeaderFooterPolicy hfPolicy = createHeaderFooterPolicy();\n                if (type == HeaderFooterType.FIRST) {\n            CTSectPr ctSectPr = getSection();\n            if (!ctSectPr.isSetTitlePg()) {\n                CTOnOff titlePg = ctSectPr.addNewTitlePg();\n                titlePg.setVal(STOnOff.ON);\n            }\n                                }\n        return hfPolicy.createHeader(STHdrFtr.Enum.forInt(type.toInt()));\n    }
593	private void readCoreContents() throws IOException {\n              bigBlockSize = _header.getBigBlockSize();\n       \n                     ChainLoopDetector loopDetector = getChainLoopDetector();\n       \n              for(int fatAt : _header.getBATArray()) {\n          readBAT(fatAt, loopDetector);\n       }\n       \n              int remainingFATs = _header.getBATCount() - _header.getBATArray().length;\n       \n              BATBlock xfat; \n       int nextAt = _header.getXBATIndex();\n       for(int i=0; i<_header.getXBATCount(); i++) {\n          loopDetector.claim(nextAt);\n          ByteBuffer fatData = getBlockAt(nextAt);\n          xfat = BATBlock.createBATBlock(bigBlockSize, fatData);\n          xfat.setOurBlockIndex(nextAt);\n          nextAt = xfat.getValueAt(bigBlockSize.getXBATEntriesPerBlock());\n          _xbat_blocks.add(xfat);\n          \n                    int xbatFATs = Math.min(remainingFATs, bigBlockSize.getXBATEntriesPerBlock());\n          for(int j=0; j<xbatFATs; j++) {\n             int fatAt = xfat.getValueAt(j);\n             if(fatAt == POIFSConstants.UNUSED_BLOCK || fatAt == POIFSConstants.END_OF_CHAIN) break;\n             readBAT(fatAt, loopDetector);\n          }\n          remainingFATs -= xbatFATs;\n       }\n       \n                     _property_table = new PropertyTable(_header, this);\n       \n              BATBlock sfat;\n       List<BATBlock> sbats = new ArrayList<>();\n       _mini_store     = new POIFSMiniStore(this, _property_table.getRoot(), sbats, _header);\n       nextAt = _header.getSBATStart();\n       for(int i=0; i<_header.getSBATCount() && nextAt != POIFSConstants.END_OF_CHAIN; i++) {\n          loopDetector.claim(nextAt);\n          ByteBuffer fatData = getBlockAt(nextAt);\n          sfat = BATBlock.createBATBlock(bigBlockSize, fatData);\n          sfat.setOurBlockIndex(nextAt);\n          sbats.add(sfat);\n          nextAt = getNextBlock(nextAt);  \n       }\n    }
594	public static CellRangeAddress[][] buildMergedRangesMap( Sheet sheet ) {\n        CellRangeAddress[][] mergedRanges = new CellRangeAddress[1][];\n        for ( final CellRangeAddress cellRangeAddress : sheet.getMergedRegions() ) {\n            final int requiredHeight = cellRangeAddress.getLastRow() + 1;\n            if ( mergedRanges.length < requiredHeight ) {\n                CellRangeAddress[][] newArray = new CellRangeAddress[requiredHeight][];\n                System.arraycopy( mergedRanges, 0, newArray, 0,\n                        mergedRanges.length );\n                mergedRanges = newArray;\n            }\n\n            for ( int r = cellRangeAddress.getFirstRow(); r <= cellRangeAddress\n                    .getLastRow(); r++ ) {\n                final int requiredWidth = cellRangeAddress.getLastColumn() + 1;\n\n                CellRangeAddress[] rowMerged = mergedRanges[r];\n                if ( rowMerged == null ) {\n                    rowMerged = new CellRangeAddress[requiredWidth];\n                    mergedRanges[r] = rowMerged;\n                } else {\n                    final int rowMergedLength = rowMerged.length;\n                    if ( rowMergedLength < requiredWidth )\n                    {\n                        final CellRangeAddress[] newRow = new CellRangeAddress[requiredWidth];\n                        System.arraycopy( rowMerged, 0, newRow, 0,\n                                rowMergedLength );\n\n                        mergedRanges[r] = newRow;\n                        rowMerged = newRow;\n                    }\n                }\n\n                Arrays.fill( rowMerged, cellRangeAddress.getFirstColumn(),\n                        cellRangeAddress.getLastColumn() + 1, cellRangeAddress );\n            }\n        }\n        return mergedRanges;\n    }
595	public int addConditionalFormatting(CellRangeAddress[] regions, HSSFConditionalFormattingRule[] cfRules) {\n        if (regions == null) {\n            throw new IllegalArgumentException("regions must not be null");\n        }\n        for(CellRangeAddress range : regions) range.validate(SpreadsheetVersion.EXCEL97);\n\n        if (cfRules == null) {\n            throw new IllegalArgumentException("cfRules must not be null");\n        }\n        if (cfRules.length == 0) {\n            throw new IllegalArgumentException("cfRules must not be empty");\n        }\n        if (cfRules.length > 3) {\n            throw new IllegalArgumentException("Number of rules must not exceed 3");\n        }\n\n        CFRuleBase[] rules = new CFRuleBase[cfRules.length];\n        for (int i = 0; i != cfRules.length; i++) {\n            rules[i] = cfRules[i].getCfRuleRecord();\n        }\n        CFRecordsAggregate cfra = new CFRecordsAggregate(regions, rules);\n        return _conditionalFormattingTable.add(cfra);\n    }
596	public HSSFTextbox createTextbox(HSSFClientAnchor anchor) {\n        HSSFTextbox shape = new HSSFTextbox(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
597	private void attemptMergeColInfoRecords(int colInfoIx) {\n		int nRecords = records.size();\n		if (colInfoIx < 0 || colInfoIx >= nRecords) {\n			throw new IllegalArgumentException("colInfoIx " + colInfoIx\n					+ " is out of range (0.." + (nRecords-1) + ")");\n		}\n		ColumnInfoRecord currentCol = getColInfo(colInfoIx);\n		int nextIx = colInfoIx+1;\n		if (nextIx < nRecords) {\n			if (mergeColInfoRecords(currentCol, getColInfo(nextIx))) {\n    			records.remove(nextIx);\n			}\n		}\n		if (colInfoIx > 0) {\n			if (mergeColInfoRecords(getColInfo(colInfoIx - 1), currentCol)) {\n    			records.remove(colInfoIx);\n    		}\n		}\n	}
598	private static VerticalAlignment getVerticalAlignment(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        VerticalAlignment align;\n        if (value instanceof VerticalAlignment) {\n            align = (VerticalAlignment) value;\n        }\n                else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map used a Short value for "\n                        + name + ". Should use VerticalAlignment enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            align = VerticalAlignment.forInt(code);\n        }\n        else if (value == null) {\n            align = VerticalAlignment.BOTTOM;\n        }\n        else {\n            throw new RuntimeException("Unexpected vertical alignment style class. Must be VerticalAlignment or Short (deprecated).");\n        }\n        return align;\n    }
599	public static TNEFAttribute create(InputStream inp) throws IOException {\n      int id   = LittleEndian.readUShort(inp);\n      int type = LittleEndian.readUShort(inp);\n      \n            if(id == TNEFProperty.ID_MAPIPROPERTIES.id ||\n            id == TNEFProperty.ID_ATTACHMENT.id) {\n         return new TNEFMAPIAttribute(id, type, inp);\n      }\n      if(type == TNEFProperty.TYPE_STRING ||\n           type == TNEFProperty.TYPE_TEXT) {\n         return new TNEFStringAttribute(id, type, inp);\n      }\n      if(type == TNEFProperty.TYPE_DATE) {\n         return new TNEFDateAttribute(id, type, inp);\n      }\n      return new TNEFAttribute(id, type, inp); \n   }
600	public double drawParagraphs(Graphics2D graphics, double x, double y) {\n        DrawFactory fact = DrawFactory.getInstance(graphics);\n\n        double y0 = y;\n        Iterator<? extends TextParagraph<?,?,? extends TextRun>> paragraphs = getShape().iterator();\n        \n        boolean isFirstLine = true;\n        for (int autoNbrIdx=0; paragraphs.hasNext(); autoNbrIdx++){\n            TextParagraph<?,?,? extends TextRun> p = paragraphs.next();\n            DrawTextParagraph dp = fact.getDrawable(p);\n            BulletStyle bs = p.getBulletStyle();\n            if (bs == null || bs.getAutoNumberingScheme() == null) {\n                autoNbrIdx = -1;\n            } else {\n                Integer startAt = bs.getAutoNumberingStartAt();\n                if (startAt == null) startAt = 1;\n                                if (startAt > autoNbrIdx) autoNbrIdx = startAt;\n            }\n            dp.setAutoNumberingIdx(autoNbrIdx);\n            dp.breakText(graphics);\n\n            if (isFirstLine) {\n                y += dp.getFirstLineLeading();\n            } else {\n                                Double spaceBefore = p.getSpaceBefore();\n                if (spaceBefore == null) spaceBefore = 0d;\n                if(spaceBefore > 0) {\n                                                            y += spaceBefore*0.01*dp.getFirstLineHeight();\n                } else {\n                                        y += -spaceBefore;\n                }\n            }\n            isFirstLine = false;\n            \n            dp.setPosition(x, y);\n            dp.draw(graphics);\n            y += dp.getY();\n\n            if (paragraphs.hasNext()) {\n                Double spaceAfter = p.getSpaceAfter();\n                if (spaceAfter == null) spaceAfter = 0d;\n                if(spaceAfter > 0) {\n                                                            y += spaceAfter*0.01*dp.getLastLineHeight();\n                } else {\n                                        y += -spaceAfter;\n                }\n            }\n        }\n        return y - y0;\n    }
601	public XWPFTableRow insertNewTableRow(int pos) {\n        if (pos >= 0 && pos <= tableRows.size()) {\n            CTRow row = ctTbl.insertNewTr(pos);\n            XWPFTableRow tableRow = new XWPFTableRow(row, this);\n            tableRows.add(pos, tableRow);\n            return tableRow;\n        }\n        return null;\n    }
602	private String parseAsSpecialQuantifier(){\n        if ( look != '[') {\n            return null;\n        }\n        GetChar();\n        if( look != '#') {\n            return null;\n        }\n        GetChar();\n        String name = parseAsName();\n        if ( name.equals("This")) {\n            name = name + ' ' + parseAsName();\n        }\n        Match(']');\n        return name;\n    }
603	public void demonstrateMethodCalls(String outputFilename) throws IOException {\n        try (HSSFWorkbook workbook = new HSSFWorkbook()) {\n            HSSFSheet sheet = workbook.createSheet("In Cell Lists");\n            HSSFRow row = sheet.createRow(0);\n\n                                    HSSFCell cell = row.createCell(0);\n            this.bulletedItemInCell(workbook, "List Item", cell);\n\n                                    row = sheet.createRow(1);\n            cell = row.createCell(0);\n            ArrayList<String> listItems = new ArrayList<>();\n            listItems.add("List Item One.");\n            listItems.add("List Item Two.");\n            listItems.add("List Item Three.");\n            listItems.add("List Item Four.");\n            this.listInCell(workbook, listItems, cell);\n                                    row.setHeight((short) 1100);\n            sheet.setColumnWidth(0, 9500);\n\n                                                row = sheet.createRow(2);\n            cell = row.createCell(0);\n            listItems.add("List Item Five.");\n            listItems.add("List Item Six.");\n            this.numberedListInCell(workbook, listItems, cell, 1, 2);\n            row.setHeight((short) 1550);\n\n                                                row = sheet.createRow(3);\n            cell = row.createCell(0);\n            listItems.add("List Item Seven.");\n            listItems.add("List Item Eight.");\n            listItems.add("List Item Nine.");\n            listItems.add("List Item Ten.");\n            this.bulletedListInCell(workbook, listItems, cell);\n            row.setHeight((short) 2550);\n\n                                                                                                                        row = sheet.createRow(4);\n            cell = row.createCell(0);\n            ArrayList<MultiLevelListItem> multiLevelListItems = new ArrayList<>();\n            listItems = new ArrayList<>();\n            listItems.add("ML List Item One - Sub Item One.");\n            listItems.add("ML List Item One - Sub Item Two.");\n            listItems.add("ML List Item One - Sub Item Three.");\n            listItems.add("ML List Item One - Sub Item Four.");\n            multiLevelListItems.add(new MultiLevelListItem("List Item One.", listItems));\n                                                multiLevelListItems.add(new MultiLevelListItem("List Item Two.", null));\n            multiLevelListItems.add(new MultiLevelListItem("List Item Three.", null));\n            listItems = new ArrayList<>();\n            listItems.add("ML List Item Four - Sub Item One.");\n            listItems.add("ML List Item Four - Sub Item Two.");\n            listItems.add("ML List Item Four - Sub Item Three.");\n            multiLevelListItems.add(new MultiLevelListItem("List Item Four.", listItems));\n            this.multiLevelListInCell(workbook, multiLevelListItems, cell);\n            row.setHeight((short) 2800);\n\n                                                row = sheet.createRow(5);\n            cell = row.createCell(0);\n            this.multiLevelNumberedListInCell(workbook, multiLevelListItems,\n                    cell, 1, 1, 1, 2);\n            row.setHeight((short) 2800);\n\n                                                row = sheet.createRow(6);\n            cell = row.createCell(0);\n            this.multiLevelBulletedListInCell(workbook, multiLevelListItems, cell);\n            row.setHeight((short) 2800);\n\n                        try (FileOutputStream fos = new FileOutputStream(new File(outputFilename))) {\n                workbook.write(fos);\n            }\n        } catch (IOException ioEx) {\n            System.out.println("Caught a: " + ioEx.getClass().getName());\n            System.out.println("Message: " + ioEx.getMessage());\n            System.out.println("Stacktrace follows...........");\n            ioEx.printStackTrace(System.out);\n        }\n    }
604	public static ErrorEval valueOf(int errorCode) {\n        FormulaError error = FormulaError.forInt(errorCode);\n        ErrorEval eval = evals.get(error);\n        if (eval != null) {\n            return eval;\n        } else {\n            throw new RuntimeException("Unhandled error type for code " + errorCode);\n        }\n    }
605	public String getTextRecursively() {\n\n        StringBuilder text = new StringBuilder(64);\n        for (int i = 0; i < bodyElements.size(); i++) {\n            boolean isLast = (i == bodyElements.size() - 1);\n            appendBodyElementText(text, bodyElements.get(i), isLast);\n        }\n\n        return text.toString();\n    }
606	public static ValueEval getSingleValue(ValueEval arg, int srcCellRow, int srcCellCol)\n            throws EvaluationException {\n        final ValueEval result;\n        if (arg instanceof RefEval) {\n            result = chooseSingleElementFromRef((RefEval) arg);\n        } else if (arg instanceof AreaEval) {\n            result = chooseSingleElementFromArea((AreaEval) arg, srcCellRow, srcCellCol);\n        } else {\n            result = arg;\n        }\n        if (result instanceof ErrorEval) {\n            throw new EvaluationException((ErrorEval) result);\n        }\n        return result;\n    }
607	private boolean isCursorInFtn(XmlCursor cursor) {\n        XmlCursor verify = cursor.newCursor();\n        verify.toParent();\n        if (verify.getObject() == this.ctFtnEdn) {\n            return true;\n        }\n        return false;\n    }
608	protected void cacheProperties() {\n        if (origSize == null || checksum == null) {\n            byte data[] = getData();\n            checksum = IOUtils.calculateChecksum(data);\n            \n            PictureType pt = getType();\n            if (pt == null) {\n                origSize = new Dimension(1,1);\n                return;\n            }\n            \n            switch (pt) {\n            case EMF:\n                origSize = new ImageHeaderEMF(data, 0).getSize();\n                break;\n            case WMF:\n                                                origSize = new ImageHeaderWMF(data, 0).getSize();\n                break;\n            case PICT:\n                origSize = new ImageHeaderPICT(data, 0).getSize();\n                break;\n            default:\n                origSize = new ImageHeaderBitmap(data, 0).getSize();\n                break;\n            }\n        }\n    }
609	public void setBorderBottom(Borders border) {\n        CTPBdr ct = getCTPBrd(true);\n        CTBorder pr = ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom();\n        if (border.getValue() == Borders.NONE.getValue()) {\n            ct.unsetBottom();\n        } else {\n            pr.setVal(STBorder.Enum.forInt(border.getValue()));\n        }\n    }
610	private CTHdrFtr buildHdrFtr(XWPFParagraph[] paragraphs, XWPFHeaderFooter wrapper) {\n        CTHdrFtr ftr = wrapper._getHdrFtr();\n        if (paragraphs != null) {\n            for (int i = 0; i < paragraphs.length; i++) {\n                 ftr.addNewP();\n                ftr.setPArray(i, paragraphs[i].getCTP());\n            }\n        }\n        return ftr;\n    }
611	public void setParentSize(int size) {\n        assert(size > 0);\n        int covered = 0;\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TextSpecInfoRun runs[] = getTextSpecInfoRuns();\n        assert(runs.length > 0);\n        for (int i=0; i<runs.length && covered < size; i++) {\n            TextSpecInfoRun run = runs[i];\n            if (covered + run.getLength() > size || i == runs.length-1) {\n                run.setLength(size-covered);\n            }\n            covered += run.getLength();\n            try {\n                run.writeOut(bos);\n            } catch (IOException e) {\n                throw new HSLFException(e);\n            }\n        }\n        _data = bos.toByteArray();\n\n                LittleEndian.putInt(_header, 4, _data.length);\n    }
612	private ClientAnchorDetail fitImageToColumns(Sheet sheet, int colNumber,\n            double reqImageWidthMM, int resizeBehaviour) {\n\n        double colWidthMM;\n        double colCoordinatesPerMM;\n        int pictureWidthCoordinates;\n        ClientAnchorDetail colClientAnchorDetail = null;\n\n                colWidthMM = ConvertImageUnits.widthUnits2Millimetres(\n                (short)sheet.getColumnWidth(colNumber));\n\n                                                if(colWidthMM < reqImageWidthMM) {\n\n                        if((resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                                                sheet.setColumnWidth(colNumber,\n                        ConvertImageUnits.millimetres2WidthUnits(reqImageWidthMM));\n                                                                                if(sheet instanceof HSSFSheet) {\n                    colWidthMM = reqImageWidthMM;\n                    colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                        colWidthMM;\n                    pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n\n                }\n                else {\n                    pictureWidthCoordinates = (int)reqImageWidthMM * AddDimensionedImage.EMU_PER_MM;\n                }\n                colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                        colNumber, pictureWidthCoordinates);\n            }\n                                                else if ((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                     (resizeBehaviour == AddDimensionedImage.EXPAND_ROW)) {\n                colClientAnchorDetail = this.calculateColumnLocation(sheet,\n                        colNumber, reqImageWidthMM);\n            }\n        }\n                else {\n            if(sheet instanceof HSSFSheet) {\n                                colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                                pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n            }\n            else {\n                pictureWidthCoordinates = (int)reqImageWidthMM *\n                        AddDimensionedImage.EMU_PER_MM;\n            }\n            colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                    colNumber, pictureWidthCoordinates);\n        }\n        return(colClientAnchorDetail);\n    }
613	public InputStream getContents(PackagePart corePart) throws IOException, InvalidFormatException {\n        PackageRelationshipCollection prc =\n                corePart.getRelationshipsByType(getRelation());\n        Iterator<PackageRelationship> it = prc.iterator();\n        if(it.hasNext()) {\n            PackageRelationship rel = it.next();\n            PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n            PackagePart part = corePart.getPackage().getPart(relName);\n            return part.getInputStream();\n        }\n        log.log(POILogger.WARN, "No part " + getDefaultFileName() + " found");\n        return null;\n    }
614	@Beta\n    public void addReportFilter(int columnIndex) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n                CTLocation location = pivotTableDefinition.getLocation();\n        AreaReference destination = new AreaReference(location.getRef(), SpreadsheetVersion.EXCEL2007);\n        if (destination.getFirstCell().getRow() < 2) {\n            AreaReference newDestination = new AreaReference(new CellReference(2, destination.getFirstCell().getCol()), new CellReference(\n                    3, destination.getFirstCell().getCol()+1), SpreadsheetVersion.EXCEL2007);\n            location.setRef(newDestination.formatAsString());\n       }\n\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_PAGE);\n        pivotField.setShowAll(false);\n        for(int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTPageFields pageFields;\n        if (pivotTableDefinition.getPageFields()!= null) {\n            pageFields = pivotTableDefinition.getPageFields();\n                        pivotTableDefinition.setMultipleFieldFilters(true);\n        } else {\n            pageFields = pivotTableDefinition.addNewPageFields();\n        }\n        CTPageField pageField = pageFields.addNewPageField();\n        pageField.setHier(-1);\n        pageField.setFld(columnIndex);\n\n        pageFields.setCount(pageFields.sizeOfPageFieldArray());\n        pivotTableDefinition.getLocation().setColPageCount(pageFields.getCount());\n    }
615	private void initCharacterRuns() {\n		if (!_charRangeFound) {\n			int[] point = findRange(_characters, _start, _end);\n			_charStart = point[0];\n			_charEnd = point[1];\n			_charRangeFound = true;\n		}\n	}
616	public static double npv(double r, double[] cfs) {\n        double npv = 0;\n        double r1 = r + 1;\n        double trate = r1;\n        for (int i=0, iSize=cfs.length; i<iSize; i++) {\n            npv += cfs[i] / trate;\n            trate *= r1;\n        }\n        return npv;\n    }
617	@SuppressWarnings("unused")\n    public void mergeCells(int firstRow, int lastRow, int firstCol, int lastCol) {\n\n    	if(firstRow > lastRow) {\n    		throw new IllegalArgumentException(\n    			"Cannot merge, first row > last row : "\n    			+ firstRow + " > " + lastRow\n    		);\n    	}\n\n    	if(firstCol > lastCol) {\n    		throw new IllegalArgumentException(\n    			"Cannot merge, first column > last column : "\n    			+ firstCol + " > " + lastCol\n    		);\n    	}\n\n    	int rowSpan = (lastRow - firstRow) + 1;\n    	boolean mergeRowRequired = rowSpan > 1;\n\n    	int colSpan = (lastCol - firstCol) + 1;\n    	boolean mergeColumnRequired = colSpan > 1;\n\n    	for(int i = firstRow; i <= lastRow; i++) {\n\n    		XSLFTableRow row = _rows.get(i);\n\n    		for(int colPos = firstCol; colPos <= lastCol; colPos++) {\n\n    			XSLFTableCell cell = row.getCells().get(colPos);\n\n    			if(mergeRowRequired) {\n	    			if(i == firstRow) {\n	    				cell.setRowSpan(rowSpan);\n	    			} else {\n	    				cell.setVMerge();\n	    			}\n    			}\n    			if(mergeColumnRequired) {\n    				if(colPos == firstCol) {\n    					cell.setGridSpan(colSpan);\n    				} else {\n    					cell.setHMerge();\n    				}\n    			}\n    		}\n    	}\n    }
618	@SuppressWarnings("resource")\n    protected static List<HSLFHyperlink> find(List<HSLFTextParagraph> paragraphs){\n        List<HSLFHyperlink> lst = new ArrayList<>();\n        if (paragraphs == null || paragraphs.isEmpty()) return lst;\n\n        HSLFTextParagraph firstPara = paragraphs.get(0);\n\n        HSLFSlideShow ppt = firstPara.getSheet().getSlideShow();\n                ExObjList exobj = ppt.getDocumentRecord().getExObjList(false);\n        if (exobj != null) {\n            Record[] records = firstPara.getRecords();\n            find(Arrays.asList(records), exobj, lst);\n        }\n\n        return lst;\n    }
619	public void serialize(ContinuableRecordOutput out) {\n        int numberOfRichTextRuns = 0;\n        int extendedDataSize = 0;\n        if (isRichText() && field_4_format_runs != null) {\n            numberOfRichTextRuns = field_4_format_runs.size();\n        }\n        if (isExtendedText() && field_5_ext_rst != null) {\n            extendedDataSize = 4 + field_5_ext_rst.getDataSize();\n        }\n       \n                        out.writeString(field_3_string, numberOfRichTextRuns, extendedDataSize);\n\n        if (numberOfRichTextRuns > 0) {\n\n                    for (int i=0;i<numberOfRichTextRuns;i++) {\n              if (out.getAvailableSpace() < 4) {\n                  out.writeContinue();\n              }\n              FormatRun r = field_4_format_runs.get(i);\n              r.serialize(out);\n          }\n        }\n\n        if (extendedDataSize > 0 && field_5_ext_rst != null) {\n           field_5_ext_rst.serialize(out);\n        }\n    }
620	public XWPFTable insertNewTbl(XmlCursor cursor) {\n        if (isCursorInFtn(cursor)) {\n            String uri = CTTbl.type.getName().getNamespaceURI();\n            String localPart = "tbl";\n            cursor.beginElement(localPart, uri);\n            cursor.toParent();\n            CTTbl t = (CTTbl) cursor.getObject();\n            XWPFTable newT = new XWPFTable(t, this);\n            cursor.removeXmlContents();\n            XmlObject o = null;\n            while (!(o instanceof CTTbl) && (cursor.toPrevSibling())) {\n                o = cursor.getObject();\n            }\n            if (!(o instanceof CTTbl)) {\n                tables.add(0, newT);\n            } else {\n                int pos = tables.indexOf(getTable((CTTbl) o)) + 1;\n                tables.add(pos, newT);\n            }\n            int i = 0;\n            cursor = t.newCursor();\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (o instanceof CTP || o instanceof CTTbl)\n                    i++;\n            }\n            bodyElements.add(i, newT);\n            XmlCursor c2 = t.newCursor();\n            cursor.toCursor(c2);\n            cursor.toEndToken();\n            c2.dispose();\n            return newT;\n        }\n        return null;\n    }
621	public static void xmlBeans(int numCols) {\n        int i = 0, cnt = 0;\n        printMemoryUsage("before");\n\n        CTWorksheet sh = CTWorksheet.Factory.newInstance();\n        CTSheetData data = sh.addNewSheetData();\n        try {\n            for (i = 0; ; i++) {\n                CTRow row = data.addNewRow();\n                row.setR(i);\n                for (int j = 0; j < numCols; j++) {\n                    CTCell cell = row.addNewC();\n                    cell.setT(STCellType.N);\n                    cell.setV(String.valueOf(j));\n                    cnt++;\n                }\n            }\n        } catch (OutOfMemoryError er) {\n            System.out.println("Failed at row=" + i + ", objects: " + cnt);\n        } catch (final Exception e) {\n            System.out.println("Unable to reach an OutOfMemoryError");\n            System.out.println(e.getClass().getName() + ": " + e.getMessage());\n        }\n        printMemoryUsage("after");\n    }
622	public NameXPtg getNameXPtg(String name, int sheetRefIndex) {\n                for (int i = 0; i < _externalBookBlocks.length; i++) {\n            int definedNameIndex = _externalBookBlocks[i].getIndexOfName(name);\n            if (definedNameIndex < 0) {\n                continue;\n            }\n\n                        int thisSheetRefIndex = findRefIndexFromExtBookIndex(i);\n            if (thisSheetRefIndex >= 0) {\n                                if (sheetRefIndex == -1 || thisSheetRefIndex == sheetRefIndex) {\n                    return new NameXPtg(thisSheetRefIndex, definedNameIndex);\n                }\n            }\n        }\n        return null;\n    }
623	private Map<Integer, Integer> computeWidths(Sheet sheet) {\n        Map<Integer, Integer> ret = new TreeMap<>();\n        int tableWidth = 0;\n\n        ensureColumnBounds(sheet);\n        \n                int lastRowNum = sheet.getLastRowNum();\n        int headerCharCount = String.valueOf(lastRowNum).length();\n        int headerColWidth = widthToPixels((headerCharCount + 1) * 256);\n        ret.put(IDX_HEADER_COL_WIDTH, headerColWidth);\n        tableWidth += headerColWidth;\n\n        for (int i = firstColumn; i < endColumn; i++) {\n            int colWidth = widthToPixels(sheet.getColumnWidth(i));\n            ret.put(i, colWidth);\n            tableWidth += colWidth;\n        }\n        \n        ret.put(IDX_TABLE_WIDTH, tableWidth);\n        return ret ;\n    }
624	private int calcSize() throws WritingNotSupportedException, IOException {\n        sectionBytes.reset();\n        write(sectionBytes);\n        padSectionBytes();\n        return sectionBytes.size();\n    }
625	private static PrintSetupRecord createPrintSetup() {\n        PrintSetupRecord retval = new PrintSetupRecord();\n\n        retval.setPaperSize(( short ) 1);\n        retval.setScale(( short ) 100);\n        retval.setPageStart(( short ) 1);\n        retval.setFitWidth(( short ) 1);\n        retval.setFitHeight(( short ) 1);\n        retval.setOptions(( short ) 2);\n        retval.setHResolution(( short ) 300);\n        retval.setVResolution(( short ) 300);\n        retval.setHeaderMargin( 0.5);\n        retval.setFooterMargin( 0.5);\n        retval.setCopies(( short ) 1);\n        return retval;\n    }
626	private static void hexDumpAligned(Writer w, byte[] data, int dumpLen, int globalOffset,\n			boolean zeroAlignEachRecord) {\n		int baseDataOffset = 0;\n\n				int globalStart = globalOffset + baseDataOffset;\n		int globalEnd = globalOffset + baseDataOffset + dumpLen;\n		int startDelta = globalStart % DUMP_LINE_LEN;\n		int endDelta = globalEnd % DUMP_LINE_LEN;\n		if (zeroAlignEachRecord) {\n			endDelta -= startDelta;\n			if (endDelta < 0) {\n				endDelta += DUMP_LINE_LEN;\n			}\n			startDelta = 0;\n		}\n		int startLineAddr;\n		int endLineAddr;\n		if (zeroAlignEachRecord) {\n			endLineAddr = globalEnd - endDelta - (globalStart - startDelta);\n			startLineAddr = 0;\n		} else {\n			startLineAddr = globalStart - startDelta;\n			endLineAddr = globalEnd - endDelta;\n		}\n\n		int lineDataOffset = baseDataOffset - startDelta;\n		int lineAddr = startLineAddr;\n\n				if (startLineAddr == endLineAddr) {\n			hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, endDelta);\n			return;\n		}\n		hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, DUMP_LINE_LEN);\n\n				while (true) {\n			lineAddr += DUMP_LINE_LEN;\n			lineDataOffset += DUMP_LINE_LEN;\n			if (lineAddr >= endLineAddr) {\n				break;\n			}\n			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, DUMP_LINE_LEN);\n		}\n\n\n				if (endDelta != 0) {\n			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, endDelta);\n		}\n	}
627	public Set<CellPosition> getPosition(int rowInd, int colInd) {\n	    Set<CellPosition> positions = EnumSet.noneOf(CellPosition.class);\n	    if (rowInd > getFirstRow() && rowInd < getLastRow() && colInd > getFirstColumn() && colInd < getLastColumn()) {\n	        positions.add(CellPosition.INSIDE);\n	        return positions; 	    }\n	    	    if (rowInd == getFirstRow()) positions.add(CellPosition.TOP);\n	    if (rowInd == getLastRow()) positions.add(CellPosition.BOTTOM);\n	    if (colInd == getFirstColumn()) positions.add(CellPosition.LEFT);\n	    if (colInd == getLastColumn()) positions.add(CellPosition.RIGHT);\n	    \n	    return positions;\n	}
628	public static String getBlipType(byte b) {\n        switch (b) {\n            case BT_ERROR:   return " ERROR";\n            case BT_UNKNOWN: return " UNKNOWN";\n            case BT_EMF:     return " EMF";\n            case BT_WMF:     return " WMF";\n            case BT_PICT:    return " PICT";\n            case BT_JPEG:    return " JPEG";\n            case BT_PNG:     return " PNG";\n            case BT_DIB:     return " DIB";\n        }\n        if ( b < 32 ) {\n            return " NotKnown";\n        }\n        return " Client";\n    }
629	protected int calculateNonWeekendHolidays(double start, double end, double[] holidays) {\n        int nonWeekendHolidays = 0;\n        double startDay = start < end ? start : end;\n        double endDay = end > start ? end : start;\n        for (double holiday : holidays) {\n            if (isInARange(startDay, endDay, holiday)) {\n                if (!isWeekend(holiday)) {\n                    nonWeekendHolidays++;\n                }\n            }\n        }\n        return start <= end ? nonWeekendHolidays : -nonWeekendHolidays;\n    }
630	public void remove( Object record ) {\n	   	   int i = 0;\n	   for (Record r : records) {\n	       if (r == record) {\n	           remove(i);\n	           break;\n	       }\n	       i++;\n	   }\n	}
631	private static int[] computeFailure(byte[] pattern) {\n        int[] failure = new int[pattern.length];\n\n        int j = 0;\n        for (int i = 1; i < pattern.length; i++) {\n            while (j > 0 && pattern[j] != pattern[i]) {\n                j = failure[j - 1];\n            }\n            if (pattern[j] == pattern[i]) {\n                j++;\n            }\n            failure[i] = j;\n        }\n\n        return failure;\n    }
632	@Beta\n    protected void createSourceReferences(CellReference position, Sheet sourceSheet, PivotTableReferenceConfigurator refConfig){\n        \n                AreaReference destination = new AreaReference(position, new CellReference(\n                position.getRow()+1, position.getCol()+1), SpreadsheetVersion.EXCEL2007);\n\n        CTLocation location;\n        if(pivotTableDefinition.getLocation() == null) {\n            location = pivotTableDefinition.addNewLocation();\n            location.setFirstDataCol(1);\n            location.setFirstDataRow(1);\n            location.setFirstHeaderRow(1);\n        } else {\n            location = pivotTableDefinition.getLocation();\n        }\n        location.setRef(destination.formatAsString());\n        pivotTableDefinition.setLocation(location);\n\n                CTPivotCacheDefinition cacheDef = getPivotCacheDefinition().getCTPivotCacheDefinition();\n        CTCacheSource cacheSource = cacheDef.addNewCacheSource();\n        cacheSource.setType(STSourceType.WORKSHEET);\n        CTWorksheetSource worksheetSource = cacheSource.addNewWorksheetSource();\n        worksheetSource.setSheet(sourceSheet.getSheetName());\n        setDataSheet(sourceSheet);\n\n        refConfig.configureReference(worksheetSource);\n        if (worksheetSource.getName() == null && worksheetSource.getRef() == null) throw new IllegalArgumentException("Pivot table source area reference or name must be specified.");\n    }
633	@SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})\n    public synchronized int appendRootLevelRecord(Record newRecord) {\n        int addedAt = -1;\n        Record[] r = new Record[_records.length + 1];\n        boolean added = false;\n        for (int i = (_records.length - 1); i >= 0; i--) {\n            if (added) {\n                                r[i] = _records[i];\n            } else {\n                r[(i + 1)] = _records[i];\n                if (_records[i] instanceof PersistPtrHolder) {\n                    r[i] = newRecord;\n                    added = true;\n                    addedAt = i;\n                }\n            }\n        }\n        _records = r;\n        return addedAt;\n    }
634	public void addFootnoteReference(XWPFAbstractFootnoteEndnote footnote) {\n        XWPFRun run = createRun();\n        CTR ctRun = run.getCTR();\n        ctRun.addNewRPr().addNewRStyle().setVal("FootnoteReference");\n        if (footnote instanceof XWPFEndnote) {\n            ctRun.addNewEndnoteReference().setId(footnote.getId());\n        } else {\n            ctRun.addNewFootnoteReference().setId(footnote.getId());\n        }\n    }
635	public void setAllBorders(Object... args) {\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = { BorderEdge.top, BorderEdge.left, null, null };\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[2] = (col == cols - 1) ? BorderEdge.right : null;\n                edges[3] = (row == rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
636	private short applyUserCellStyle(HSSFCellStyle style){\n        if(style.getUserStyleName() == null) {\n            throw new IllegalArgumentException("Expected user-defined style");\n        }\n\n        InternalWorkbook iwb = _book.getWorkbook();\n        short userXf = -1;\n        int numfmt = iwb.getNumExFormats();\n        for(short i = 0; i < numfmt; i++){\n            ExtendedFormatRecord xf = iwb.getExFormatAt(i);\n            if(xf.getXFType() == ExtendedFormatRecord.XF_CELL && xf.getParentIndex() == style.getIndex() ){\n                userXf = i;\n                break;\n            }\n        }\n        short styleIndex;\n        if (userXf == -1){\n            ExtendedFormatRecord xfr = iwb.createCellXF();\n            xfr.cloneStyleFrom(iwb.getExFormatAt(style.getIndex()));\n            xfr.setIndentionOptions((short)0);\n            xfr.setXFType(ExtendedFormatRecord.XF_CELL);\n            xfr.setParentIndex(style.getIndex());\n            styleIndex = (short)numfmt;\n        } else {\n            styleIndex = userXf;\n        }\n\n        return styleIndex;\n    }
637	public static long calculateChecksum(InputStream stream) throws IOException {\n        Checksum sum = new CRC32();\n\n        byte[] buf = new byte[4096];\n        int count;\n        while ((count = stream.read(buf)) != -1) {\n            if (count > 0) {\n                sum.update(buf, 0, count);\n            }\n        }\n        return sum.getValue();\n    }
638	private static void copyProperties(PackageProperties src, PackageProperties tgt) {\n        tgt.setCategoryProperty(src.getCategoryProperty());\n        tgt.setContentStatusProperty(src.getContentStatusProperty());\n        tgt.setContentTypeProperty(src.getContentTypeProperty());\n        tgt.setCreatorProperty(src.getCreatorProperty());\n        tgt.setDescriptionProperty(src.getDescriptionProperty());\n        tgt.setIdentifierProperty(src.getIdentifierProperty());\n        tgt.setKeywordsProperty(src.getKeywordsProperty());\n        tgt.setLanguageProperty(src.getLanguageProperty());\n        tgt.setRevisionProperty(src.getRevisionProperty());\n        tgt.setSubjectProperty(src.getSubjectProperty());\n        tgt.setTitleProperty(src.getTitleProperty());\n        tgt.setVersionProperty(src.getVersionProperty());\n    }
639	public XWPFTable createTable(int rows, int cols) {\n        XWPFTable table = new XWPFTable(headerFooter.addNewTbl(), this, rows, cols);\n        tables.add(table);\n        bodyElements.add(table);\n        return table;\n    }
640	private static boolean fullfillsConditions(AreaEval db, int row, AreaEval cdb)\n            throws EvaluationException {\n                                final int height = cdb.getHeight();\n        for(int conditionRow = 1; conditionRow < height; ++conditionRow) {\n            boolean matches = true;\n            final int width = cdb.getWidth();\n            for(int column = 0; column < width; ++column) {                                                 boolean columnCondition = true;\n                ValueEval condition;\n                \n                                condition = resolveReference(cdb, conditionRow, column);\n                \n                                if(condition instanceof BlankEval)\n                    continue;\n                                ValueEval targetHeader = resolveReference(cdb, 0, column);\n\n                if(!(targetHeader instanceof StringValueEval)) {\n                    throw new EvaluationException(ErrorEval.VALUE_INVALID);\n                }\n                \n                if (getColumnForName(targetHeader, db) == -1)\n                                        columnCondition = false;\n\n                if(columnCondition) {                                         ValueEval value = resolveReference(db, row, getColumnForName(targetHeader, db));\n                    if(!testNormalCondition(value, condition)) {\n                        matches = false;\n                        break;\n                    }\n                } else {                                         if(OperandResolver.coerceValueToString(condition).isEmpty()) {\n                        throw new EvaluationException(ErrorEval.VALUE_INVALID);\n                    }\n                    throw new NotImplementedException(\n                            "D* function with formula conditions");\n                }\n            }\n            if (matches) {\n                return true;\n            }\n        }\n        return false;\n    }
641	private void compareNumberOfRowsInSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n\n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n            \n            int num1 = loc1.sheet.getPhysicalNumberOfRows();\n            int num2 = loc2.sheet.getPhysicalNumberOfRows();\n\n            if (num1 != num2) {\n                String str = String.format(Locale.ROOT, "%s\nworkbook1 -> %s [%d] != workbook2 -> %s [%d]",\n                    "Number Of Rows does not Match ::",\n                    loc1.sheet.getSheetName(), num1,\n                    loc2.sheet.getSheetName(), num2\n                );\n                listOfDifferences.add(str);\n            }\n        }\n\n    }
642	public XWPFTable createTable() {\n        XWPFTable table = new XWPFTable(ctDocument.getBody().addNewTbl(), this);\n        bodyElements.add(table);\n        tables.add(table);\n        return table;\n    }
643	public static boolean hasExactSharedBorder(CellRangeAddress crA, CellRangeAddress crB) {\n        int oFirstRow = crB.getFirstRow();\n        int oLastRow  = crB.getLastRow();\n        int oFirstCol = crB.getFirstColumn();\n        int oLastCol  = crB.getLastColumn();\n\n        if (crA.getFirstRow() > 0 && crA.getFirstRow()-1 == oLastRow || \n                oFirstRow > 0 && oFirstRow-1 == crA.getLastRow()) {\n                                    return crA.getFirstColumn() == oFirstCol && crA.getLastColumn() == oLastCol;\n        }\n\n        if (crA.getFirstColumn()>0 && crA.getFirstColumn() - 1 == oLastCol ||\n                oFirstCol>0 && crA.getLastColumn() == oFirstCol -1) {\n                                    return crA.getFirstRow() == oFirstRow && crA.getLastRow() == oLastRow;\n        }\n        return false;\n    }
644	protected static Map<Short, Constructor<? extends EscherRecord>> recordsToMap(Class<?>[] recClasses) {\n        Map<Short, Constructor<? extends EscherRecord>> result = new HashMap<>();\n        final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n\n        for (Class<?> recClass : recClasses) {\n            @SuppressWarnings("unchecked")\n            Class<? extends EscherRecord> recCls = (Class<? extends EscherRecord>) recClass;\n            short sid;\n            try {\n                sid = recCls.getField("RECORD_ID").getShort(null);\n            } catch (IllegalArgumentException e) {\n                throw new RuntimeException(e);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(e);\n            } catch (NoSuchFieldException e) {\n                throw new RuntimeException(e);\n            }\n            Constructor<? extends EscherRecord> constructor;\n            try {\n                constructor = recCls.getConstructor(EMPTY_CLASS_ARRAY);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(e);\n            }\n            result.put(Short.valueOf(sid), constructor);\n        }\n        return result;\n    }
645	private void transformNode(ParseNode node, byte desiredOperandClass,\n			boolean callerForceArrayFlag) {\n		Ptg token = node.getToken();\n		ParseNode[] children = node.getChildren();\n		boolean isSimpleValueFunc = isSimpleValueFunction(token);\n\n		if (isSimpleValueFunc) {\n			boolean localForceArray = desiredOperandClass == Ptg.CLASS_ARRAY;\n			for (int i = 0; i < children.length; i++) {\n				transformNode(children[i], desiredOperandClass, localForceArray);\n			}\n			setSimpleValueFuncClass((AbstractFunctionPtg) token, desiredOperandClass, callerForceArrayFlag);\n			return;\n		}\n\n		if (isSingleArgSum(token)) {\n									token = FuncVarPtg.SUM;\n								}\n		if (token instanceof ValueOperatorPtg || token instanceof ControlPtg\n				|| token instanceof MemFuncPtg\n				|| token instanceof MemAreaPtg\n				|| token instanceof UnionPtg\n				|| token instanceof IntersectionPtg) {\n						\n												byte localDesiredOperandClass = desiredOperandClass == Ptg.CLASS_REF ? Ptg.CLASS_VALUE : desiredOperandClass;\n			for (int i = 0; i < children.length; i++) {\n				transformNode(children[i], localDesiredOperandClass, callerForceArrayFlag);\n			}\n			return;\n		}\n		if (token instanceof AbstractFunctionPtg) {\n			transformFunctionNode((AbstractFunctionPtg) token, children, desiredOperandClass, callerForceArrayFlag);\n			return;\n		}\n		if (children.length > 0) {\n			if (token == RangePtg.instance) {\n								return;\n			}\n			throw new IllegalStateException("Node should not have any children");\n		}\n\n		if (token.isBaseToken()) {\n						return;\n		}\n		token.setClass(transformClass(token.getPtgClass(), desiredOperandClass, callerForceArrayFlag));\n	}
646	protected void matchVariableSizedPropertiesToChunks() {\n                        Map<Integer, Chunk> chunks = new HashMap<>();\n        for (Chunk chunk : parentGroup.getChunks()) {\n            chunks.put(chunk.getChunkId(), chunk);\n        }\n\n                for (PropertyValue val : properties.values()) {\n            if (val instanceof ChunkBasedPropertyValue) {\n                ChunkBasedPropertyValue cVal = (ChunkBasedPropertyValue) val;\n                Chunk chunk = chunks.get(cVal.getProperty().id);\n                                \n                \n                if (chunk != null) {\n                    cVal.setValue(chunk);\n                } else {\n                    logger.log(POILogger.WARN, "No chunk found matching Property " + cVal);\n                }\n            }\n        }\n    }
647	private Ptg columnCopyRefPtg(RefPtgBase rptg) {\n        final int refColumn = rptg.getColumn();\n        if (rptg.isColRelative()) {\n                        final int destColumnIndex = _firstMovedIndex + _amountToMove;\n            if (destColumnIndex < 0 || _version.getLastColumnIndex() < destColumnIndex) {\n                return createDeletedRef(rptg);\n            }\n\n                        final int newColumnIndex = refColumn + _amountToMove;\n            if(newColumnIndex < 0 || _version.getLastColumnIndex() < newColumnIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            rptg.setColumn(newColumnIndex);\n            return rptg;\n        }\n        return null;\n    }
648	@Beta\n    public void addColLabel(int columnIndex, String valueFormat) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        final int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_COL);\n        pivotField.setShowAll(false);\n        if (valueFormat != null && !valueFormat.trim().isEmpty()) {\n            DataFormat df = parentSheet.getWorkbook().createDataFormat();\n            pivotField.setNumFmtId(df.getFormat(valueFormat));\n        }\n        for (int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTColFields colFields;\n        if(pivotTableDefinition.getColFields() != null) {\n            colFields = pivotTableDefinition.getColFields();\n        } else {\n            colFields = pivotTableDefinition.addNewColFields();\n        }\n\n        colFields.addNewField().setX(columnIndex);\n        colFields.setCount(colFields.sizeOfFieldArray());\n    }
649	public static POITextExtractor createExtractor(OPCPackage pkg) throws IOException, OpenXML4JException, XmlException {\n        try {\n                        PackageRelationshipCollection core;\n            core = pkg.getRelationshipsByType(CORE_DOCUMENT_REL);\n              \n                        if (core.size() == 0) {\n                                core = pkg.getRelationshipsByType(STRICT_DOCUMENT_REL);\n            }\n            if (core.size() == 0) {\n                                core = pkg.getRelationshipsByType(VISIO_DOCUMENT_REL);\n                if (core.size() == 1)\n                    return new XDGFVisioExtractor(pkg);\n            }\n              \n                        if (core.size() != 1) {\n                throw new IllegalArgumentException("Invalid OOXML Package received - expected 1 core document, found " + core.size());\n            }\n     \n                        final PackagePart corePart = pkg.getPart(core.getRelationship(0));\n            final String contentType = corePart.getContentType();\n     \n                        for (XSSFRelation rel : XSSFExcelExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    if (getPreferEventExtractor()) {\n                        return new XSSFEventBasedExcelExtractor(pkg);\n                    }\n                    return new XSSFExcelExtractor(pkg);\n                }\n            }\n     \n                        for (XWPFRelation rel : XWPFWordExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    return new XWPFWordExtractor(pkg);\n                }\n            }\n     \n                        for (XSLFRelation rel : XSLFPowerPointExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    return new SlideShowExtractor<>(new XMLSlideShow(pkg));\n                }\n            }\n     \n                        if (XSLFRelation.THEME_MANAGER.getContentType().equals(contentType)) {\n                return new SlideShowExtractor<>(new XMLSlideShow(pkg));\n            }\n\n                        for (XSSFRelation rel : XSSFBEventBasedExcelExtractor.SUPPORTED_TYPES) {\n                if (rel.getContentType().equals(contentType)) {\n                    return new XSSFBEventBasedExcelExtractor(pkg);\n                }\n            }\n\n            throw new IllegalArgumentException("No supported documents found in the OOXML package (found "+contentType+")");\n\n        } catch (IOException | Error | RuntimeException | XmlException | OpenXML4JException e) {                                     pkg.revert();\n            throw e;\n        }\n    }
650	@Beta\n    public AreaReference getPivotArea(Workbook wb) throws IllegalArgumentException {\n        final CTWorksheetSource wsSource = ctPivotCacheDefinition.getCacheSource().getWorksheetSource();\n        \n        final String ref = wsSource.getRef();\n        final String name = wsSource.getName();\n        \n        if (ref == null && name == null) {\n            throw new IllegalArgumentException("Pivot cache must reference an area, named range, or table.");\n        }\n        \n                if (ref != null) {\n            return new AreaReference(ref, SpreadsheetVersion.EXCEL2007);\n        }\n        \n        assert (name != null);\n        \n                final Name range = wb.getName(name);\n        if (range != null) {\n            return new AreaReference(range.getRefersToFormula(), SpreadsheetVersion.EXCEL2007);\n        }\n        \n                        final XSSFSheet sheet = (XSSFSheet) wb.getSheet(wsSource.getSheet());\n        for (XSSFTable table : sheet.getTables()) {\n                        if (name.equals(table.getName())) {\n                return new AreaReference(table.getStartCellReference(), table.getEndCellReference(),\n                        SpreadsheetVersion.EXCEL2007);\n            }\n        }\n        \n        throw new IllegalArgumentException("Name '" + name + "' was not found.");\n    }
651	public static void main(String[] args) throws Exception {\n        try (HSLFSlideShow ppt = new HSLFSlideShow()) {\n                        Object[] def = new Object[]{\n                    Color.yellow, 40,\n                    Color.green, 60,\n                    Color.gray, 30,\n                    Color.red, 80,\n            };\n\n            HSLFSlide slide = ppt.createSlide();\n\n            HSLFGroupShape group = new HSLFGroupShape();\n                        Rectangle bounds = new Rectangle(200, 100, 350, 300);\n            group.setAnchor(bounds);\n            group.setInteriorAnchor(new Rectangle(0, 0, 100, 100));\n            slide.addShape(group);\n            Graphics2D graphics = new PPGraphics2D(group);\n\n                        int x = 10, y = 10;\n            graphics.setFont(new Font("Arial", Font.BOLD, 10));\n            for (int i = 0, idx = 1; i < def.length; i += 2, idx++) {\n                graphics.setColor(Color.black);\n                int width = ((Integer) def[i + 1]).intValue();\n                graphics.drawString("Q" + idx, x - 5, y + 10);\n                graphics.drawString(width + "%", x + width + 3, y + 10);\n                graphics.setColor((Color) def[i]);\n                graphics.fill(new Rectangle(x, y, width, 10));\n                y += 15;\n            }\n            graphics.setColor(Color.black);\n            graphics.setFont(new Font("Arial", Font.BOLD, 14));\n            graphics.draw(group.getInteriorAnchor());\n            graphics.drawString("Performance", x + 30, y + 10);\n\n            try (FileOutputStream out = new FileOutputStream("hslf-graphics.ppt")) {\n                ppt.write(out);\n            }\n        }\n    }
652	private static String getFormulaFromTextExpression(String textExpr) {\n		if (textExpr == null) {\n			return null;\n		}\n		if (textExpr.length() < 1) {\n			throw new IllegalArgumentException("Empty string is not a valid formula/value expression");\n		}\n		if (textExpr.charAt(0) == '=') {\n			return textExpr.substring(1);\n		}\n		return null;\n	}
653	public void createBarChart( HSSFWorkbook workbook, HSSFSheet parentSheet )\n	{\n\n		List<Record> records = new ArrayList<>();\n		records.add( createMSDrawingObjectRecord() );\n		records.add( createOBJRecord() );\n		records.add( createBOFRecord() );\n		records.add(new HeaderRecord(""));\n		records.add(new FooterRecord(""));\n		records.add( createHCenterRecord() );\n		records.add( createVCenterRecord() );\n		records.add( createPrintSetupRecord() );\n				records.add( createFontBasisRecord1() );\n		records.add( createFontBasisRecord2() );\n		records.add(new ProtectRecord(false));\n		records.add( createUnitsRecord() );\n		records.add( createChartRecord( 0, 0, 30434904, 19031616 ) );\n		records.add( createBeginRecord() );\n		records.add( createSCLRecord( (short) 1, (short) 1 ) );\n		records.add( createPlotGrowthRecord( 65536, 65536 ) );\n		records.add( createFrameRecord1() );\n		records.add( createBeginRecord() );\n		records.add( createLineFormatRecord(true) );\n		records.add( createAreaFormatRecord1() );\n		records.add( createEndRecord() );\n		records.add( createSeriesRecord() );\n		records.add( createBeginRecord() );\n		records.add( createTitleLinkedDataRecord() );\n		records.add( createValuesLinkedDataRecord() );\n		records.add( createCategoriesLinkedDataRecord() );\n		records.add( createDataFormatRecord() );\n								records.add( createSeriesToChartGroupRecord() );\n		records.add( createEndRecord() );\n		records.add( createSheetPropsRecord() );\n		records.add( createDefaultTextRecord( DefaultDataLabelTextPropertiesRecord.CATEGORY_DATA_TYPE_ALL_TEXT_CHARACTERISTIC ) );\n		records.add( createAllTextRecord() );\n		records.add( createBeginRecord() );\n				records.add( createFontIndexRecord( 5 ) );\n		records.add( createDirectLinkRecord() );\n		records.add( createEndRecord() );\n		records.add( createDefaultTextRecord( (short) 3 ) ); 		records.add( createUnknownTextRecord() );\n		records.add( createBeginRecord() );\n		records.add( createFontIndexRecord( (short) 6 ) );\n		records.add( createDirectLinkRecord() );\n		records.add( createEndRecord() );\n\n		records.add( createAxisUsedRecord( (short) 1 ) );\n		createAxisRecords( records );\n\n		records.add( createEndRecord() );\n		records.add( createDimensionsRecord() );\n		records.add( createSeriesIndexRecord(2) );\n		records.add( createSeriesIndexRecord(1) );\n		records.add( createSeriesIndexRecord(3) );\n		records.add(EOFRecord.instance);\n\n\n\n		parentSheet.insertChartRecords( records );\n		workbook.insertChartRecord();\n	}
654	public Chunk createChunk(byte[] data, int offset) {\n				ChunkHeader header =\n			ChunkHeader.createChunkHeader(version, data, offset);\n				if(header.getLength() < 0) {\n			throw new IllegalArgumentException("Found a chunk with a negative length, which isn't allowed");\n		}\n\n				int endOfDataPos = offset + header.getLength() + header.getSizeInBytes();\n\n						if(endOfDataPos > data.length) {\n			logger.log(POILogger.WARN,\n				"Header called for " + header.getLength() +" bytes, but that would take us past the end of the data!");\n\n			endOfDataPos = data.length;\n			header.setLength(data.length - offset - header.getSizeInBytes());\n\n			if(header.hasTrailer()) {\n				header.setLength(header.getLength() - 8);\n				endOfDataPos  -= 8;\n			}\n			if(header.hasSeparator()) {\n                header.setLength(header.getLength() - 4);\n				endOfDataPos  -= 4;\n			}\n		}\n\n\n				ChunkTrailer trailer = null;\n		ChunkSeparator separator = null;\n		if(header.hasTrailer()) {\n			if(endOfDataPos <= data.length-8) {\n				trailer = new ChunkTrailer(\n					data, endOfDataPos);\n				endOfDataPos += 8;\n			} else {\n				logger.log(POILogger.ERROR, "Header claims a length to " + endOfDataPos + " there's then no space for the trailer in the data (" + data.length + ")");\n			}\n		}\n		if(header.hasSeparator()) {\n			if(endOfDataPos <= data.length-4) {\n				separator = new ChunkSeparator(\n						data, endOfDataPos);\n			} else {\n				logger.log(POILogger.ERROR, "Header claims a length to " + endOfDataPos + " there's then no space for the separator in the data (" + data.length + ")");\n			}\n		}\n\n				byte[] contents = IOUtils.safelyAllocate(header.getLength(), MAX_RECORD_LENGTH);\n		System.arraycopy(data, offset+header.getSizeInBytes(), contents, 0, contents.length);\n		Chunk chunk = new Chunk(header, trailer, separator, contents);\n\n				CommandDefinition[] defs = chunkCommandDefinitions.get(Integer.valueOf(header.getType()));\n		if (defs == null) {\n		    defs = new CommandDefinition[0];\n		}\n		chunk.commandDefinitions = defs;\n\n				chunk.processCommands();\n\n				return chunk;\n	}
655	public void setVBAProject(InputStream vbaProjectStream) throws IOException {\n        if (!isMacroEnabled()) {\n            setWorkbookType(XSSFWorkbookType.XLSM);\n        }\n\n        PackagePartName ppName;\n        try {\n            ppName = PackagingURIHelper.createPartName(XSSFRelation.VBA_MACROS.getDefaultFileName());\n        } catch (InvalidFormatException e) {\n            throw new POIXMLException(e);\n        }\n        OPCPackage opc = getPackage();\n        OutputStream outputStream;\n        if (!opc.containPart(ppName)) {\n            POIXMLDocumentPart relationship = createRelationship(XSSFRelation.VBA_MACROS, this.xssfFactory);\n            outputStream = relationship.getPackagePart().getOutputStream();\n        } else {\n            PackagePart part = opc.getPart(ppName);\n            outputStream = part.getOutputStream();\n        }\n        try {\n            IOUtils.copy(vbaProjectStream, outputStream);\n        } finally {\n            IOUtils.closeQuietly(outputStream);\n        }\n    }
656	public void nextRecord() throws RecordFormatException {\n		if (_nextSid == INVALID_SID_VALUE) {\n			throw new IllegalStateException("EOF - next record not available");\n		}\n		if (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {\n			throw new IllegalStateException("Cannot call nextRecord() without checking hasNextRecord() first");\n		}\n		_currentSid = _nextSid;\n		_currentDataOffset = 0;\n		_currentDataLength = _bhi.readDataSize();\n		if (_currentDataLength > MAX_RECORD_DATA_SIZE) {\n			throw new RecordFormatException("The content of an excel record cannot exceed "\n					+ MAX_RECORD_DATA_SIZE + " bytes");\n		}\n	}
657	static void expiry(Sheet sheet) {\n        CellStyle style = sheet.getWorkbook().createCellStyle();\n        style.setDataFormat((short)BuiltinFormats.getBuiltinFormat("d-mmm"));\n\n        sheet.createRow(0).createCell(0).setCellValue("Date");\n        sheet.createRow(1).createCell(0).setCellFormula("TODAY()+29");\n        sheet.createRow(2).createCell(0).setCellFormula("A2+1");\n        sheet.createRow(3).createCell(0).setCellFormula("A3+1");\n\n        for(int rownum = 1; rownum <= 3; rownum++) {\n            sheet.getRow(rownum).getCell(0).setCellStyle(style);\n        }\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("AND(A2-TODAY()>=0,A2-TODAY()<=30)");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontStyle(false, true);\n        font.setFontColorIndex(IndexedColors.BLUE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A4")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(0).createCell(1).setCellValue("Dates within the next 30 days are highlighted");\n    }
658	public void setInsideBorders(Object... args) {\n        if (args.length == 0) return;\n\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = new BorderEdge[2];\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[0] = (col > 0 && col < cols - 1) ? BorderEdge.right : null;\n                edges[1] = (row > 0 && row < rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
659	public XWPFTableRow createRow() {\n        int sizeCol = ctTbl.sizeOfTrArray() > 0 ? ctTbl.getTrArray(0)\n                .sizeOfTcArray() : 0;\n        XWPFTableRow tabRow = new XWPFTableRow(ctTbl.addNewTr(), this);\n        addColumn(tabRow, sizeCol);\n        tableRows.add(tabRow);\n        return tabRow;\n    }
660	@Beta\n    public void addColumnLabel(DataConsolidateFunction function, int columnIndex, String valueFieldName, String valueFormat) {\n        checkColumnIndex(columnIndex);\n\n        addDataColumn(columnIndex, true);\n        addDataField(function, columnIndex, valueFieldName, valueFormat);\n\n                if (pivotTableDefinition.getDataFields().getCount() == 2) {\n            CTColFields colFields;\n            if(pivotTableDefinition.getColFields() != null) {\n                colFields = pivotTableDefinition.getColFields();\n            } else {\n                colFields = pivotTableDefinition.addNewColFields();\n            }\n            colFields.addNewField().setX(-2);\n            colFields.setCount(colFields.sizeOfFieldArray());\n        }\n    }
661	public ExtSSTRecord createExtSSTRecord(int sstOffset) {\n        if (bucketAbsoluteOffsets == null || bucketRelativeOffsets == null) {\n            throw new IllegalStateException("SST record has not yet been serialized.");\n        }\n\n        ExtSSTRecord extSST = new ExtSSTRecord();\n        extSST.setNumStringsPerBucket((short)8);\n        int[] absoluteOffsets = bucketAbsoluteOffsets.clone();\n        int[] relativeOffsets = bucketRelativeOffsets.clone();\n        for ( int i = 0; i < absoluteOffsets.length; i++ ) {\n            absoluteOffsets[i] += sstOffset;\n        }\n        extSST.setBucketOffsets(absoluteOffsets, relativeOffsets);\n        return extSST;\n    }
662	public InputStream openResourceAsStream(String sampleFileName) {\n\n        if (_sampleDataIsAvaliableOnClassPath) {\n            InputStream result = sampleFileName == null ? null :\n                    openClasspathResource(sampleFileName);\n            if(result == null) {\n                throw new RuntimeException("specified test sample file '" + sampleFileName\n                        + "' not found on the classpath");\n            }\n                        return new NonSeekableInputStream(result);\n        }\n        if (_resolvedDataDir == null) {\n            throw new RuntimeException("Must set system property '"\n                    + TEST_PROPERTY\n                    + "' properly before running tests");\n        }\n\n        File f = getFile(sampleFileName);\n        try {\n            return new FileInputStream(f);\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }
663	private boolean isCellTypeMatches(Locator loc1, Locator loc2) {\n        CellType type1 = loc1.cell.getCellType();\n        CellType type2 = loc2.cell.getCellType();\n        if (type1 == type2) return true;\n        addMessage(loc1, loc2,\n            "Cell Data-Type does not Match in :: ",\n            type1.name(), type2.name()\n        );\n        return false;\n    }
664	static void inList(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Codes");\n        sheet.createRow(1).createCell(0).setCellValue("AA");\n        sheet.createRow(2).createCell(0).setCellValue("BB");\n        sheet.createRow(3).createCell(0).setCellValue("GG");\n        sheet.createRow(4).createCell(0).setCellValue("AA");\n        sheet.createRow(5).createCell(0).setCellValue("FF");\n        sheet.createRow(6).createCell(0).setCellValue("XX");\n        sheet.createRow(7).createCell(0).setCellValue("CC");\n\n        sheet.getRow(0).createCell(2).setCellValue("Valid");\n        sheet.getRow(1).createCell(2).setCellValue("AA");\n        sheet.getRow(2).createCell(2).setCellValue("BB");\n        sheet.getRow(3).createCell(2).setCellValue("CC");\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n                ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("COUNTIF($C$2:$C$4,A2)");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.LIGHT_BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A8")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(3).setCellValue("<== Use Excel conditional formatting to highlight items that are in a list on the worksheet");\n    }
665	public String formatRawCellContents(double value, int formatIndex, String formatString, boolean use1904Windowing) {\n        localeChangedObservable.checkForLocaleChange();\n        \n                if(DateUtil.isADateFormat(formatIndex,formatString)) {\n            if(DateUtil.isValidExcelDate(value)) {\n                Format dateFormat = getFormat(value, formatIndex, formatString);\n                if(dateFormat instanceof ExcelStyleDateFormatter) {\n                                        ((ExcelStyleDateFormatter)dateFormat).setDateToBeFormatted(value);\n                }\n                Date d = DateUtil.getJavaDate(value, use1904Windowing);\n                return performDateFormatting(d, dateFormat);\n            }\n                        if (emulateCSV) {\n                return invalidDateTimeString;\n            }\n        }\n        \n                Format numberFormat = getFormat(value, formatIndex, formatString);\n        if (numberFormat == null) {\n            return String.valueOf(value);\n        }\n        \n                                                String result;\n        final String textValue = NumberToTextConverter.toText(value);\n        if (textValue.indexOf('E') > -1) {\n            result = numberFormat.format(Double.valueOf(value));\n        }\n        else {\n            result = numberFormat.format(new BigDecimal(textValue));\n        }\n                if (result.indexOf('E') > -1 && !result.contains("E-")) {\n            result = result.replaceFirst("E", "E+");\n        }\n        return result;\n    }
666	public CellFormatResult apply(Object value) {\n        boolean applies = applies(value);\n        String text;\n        Color textColor;\n        if (applies) {\n            text = format.format(value);\n            textColor = color;\n        } else {\n            text = format.simpleFormat(value);\n            textColor = null;\n        }\n        return new CellFormatResult(applies, text, textColor);\n    }
667	protected static void setCertID\n        (CertIDType certId, SignatureConfig signatureConfig, boolean issuerNameNoReverseOrder, X509Certificate certificate) {\n        X509IssuerSerialType issuerSerial = certId.addNewIssuerSerial();\n        String issuerName;\n        if (issuerNameNoReverseOrder) {\n            \n                                    issuerName = certificate.getIssuerDN().getName().replace(",", ", ");\n        } else {\n            issuerName = certificate.getIssuerX500Principal().toString();\n        }\n        issuerSerial.setX509IssuerName(issuerName);\n        issuerSerial.setX509SerialNumber(certificate.getSerialNumber());\n\n        byte[] encodedCertificate;\n        try {\n            encodedCertificate = certificate.getEncoded();\n        } catch (CertificateEncodingException e) {\n            throw new RuntimeException("certificate encoding error: "\n                    + e.getMessage(), e);\n        }\n        DigestAlgAndValueType certDigest = certId.addNewCertDigest(); \n        setDigestAlgAndValue(certDigest, encodedCertificate, signatureConfig.getXadesDigestAlgo());\n    }
668	public XWPFFootnotes createFootnotes() {\n        if (footnotes == null) {\n            FootnotesDocument footnotesDoc = FootnotesDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.FOOTNOTE;\n            int i = getRelationIndex(relation);\n\n            XWPFFootnotes wrapper = (XWPFFootnotes) createRelationship(relation, XWPFFactory.getInstance(), i);\n            wrapper.setFootnotes(footnotesDoc.addNewFootnotes());\n            wrapper.setIdManager(this.footnoteIdManager);\n            footnotes = wrapper;\n        }\n\n        return footnotes;\n    }
669	private static I_MatchPredicate createGeneralMatchPredicate(StringEval stringEval) {\n        String value = stringEval.getStringValue();\n        CmpOp operator = CmpOp.getOperator(value);\n        value = value.substring(operator.getLength());\n\n        Boolean booleanVal = parseBoolean(value);\n        if(booleanVal != null) {\n            return new BooleanMatcher(booleanVal.booleanValue(), operator);\n        }\n\n        Double doubleVal = OperandResolver.parseDouble(value);\n        if(doubleVal != null) {\n            return new NumberMatcher(doubleVal.doubleValue(), operator);\n        }\n        ErrorEval ee = parseError(value);\n        if (ee != null) {\n            return new ErrorMatcher(ee.getErrorCode(), operator);\n        }\n\n                return new StringMatcher(value, operator);\n    }
670	public String getText() {\n        try {\n            WordToTextConverter wordToTextConverter = new WordToTextConverter();\n\n            HeaderStories hs = new HeaderStories(doc);\n\n            if (hs.getFirstHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getFirstHeaderSubrange());\n            if (hs.getEvenHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getEvenHeaderSubrange());\n            if (hs.getOddHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getOddHeaderSubrange());\n\n            wordToTextConverter.processDocument(doc);\n            wordToTextConverter.processDocumentPart(doc,\n                    doc.getMainTextboxRange());\n\n            if (hs.getFirstFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getFirstFooterSubrange());\n            if (hs.getEvenFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getEvenFooterSubrange());\n            if (hs.getOddFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getOddFooterSubrange());\n\n            return wordToTextConverter.getText();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch ( Exception exc ) {\n            throw new RuntimeException( exc );\n        }\n    }
671	private static String translateBuiltInName(byte name)\n	{\n		switch (name)\n		{\n			case NameRecord.BUILTIN_AUTO_ACTIVATE :     return "Auto_Activate";\n			case NameRecord.BUILTIN_AUTO_CLOSE :        return "Auto_Close";\n			case NameRecord.BUILTIN_AUTO_DEACTIVATE :   return "Auto_Deactivate";\n			case NameRecord.BUILTIN_AUTO_OPEN :         return "Auto_Open";\n			case NameRecord.BUILTIN_CONSOLIDATE_AREA :  return "Consolidate_Area";\n			case NameRecord.BUILTIN_CRITERIA :          return "Criteria";\n			case NameRecord.BUILTIN_DATABASE :          return "Database";\n			case NameRecord.BUILTIN_DATA_FORM :         return "Data_Form";\n			case NameRecord.BUILTIN_PRINT_AREA :        return "Print_Area";\n			case NameRecord.BUILTIN_PRINT_TITLE :       return "Print_Titles";\n			case NameRecord.BUILTIN_RECORDER :          return "Recorder";\n			case NameRecord.BUILTIN_SHEET_TITLE :       return "Sheet_Title";\n			case NameRecord.BUILTIN_FILTER_DB  :        return "_FilterDatabase";\n\n		}\n\n		return "Unknown";\n	}
672	private String convertSharedFormula(int si, XSSFEvaluationWorkbook fpb){\n        XSSFSheet sheet = getSheet();\n\n        CTCellFormula f = sheet.getSharedFormula(si);\n        if(f == null) {\n            throw new IllegalStateException(\n                    "Master cell of a shared formula with sid="+si+" was not found");\n        }\n\n        String sharedFormula = f.getStringValue();\n                String sharedFormulaRange = f.getRef();\n\n        CellRangeAddress ref = CellRangeAddress.valueOf(sharedFormulaRange);\n\n        int sheetIndex = sheet.getWorkbook().getSheetIndex(sheet);\n        SharedFormula sf = new SharedFormula(SpreadsheetVersion.EXCEL2007);\n\n        Ptg[] ptgs = FormulaParser.parse(sharedFormula, fpb, FormulaType.CELL, sheetIndex, getRowIndex());\n        Ptg[] fmla = sf.convertSharedFormulas(ptgs,\n                getRowIndex() - ref.getFirstRow(), getColumnIndex() - ref.getFirstColumn());\n        return FormulaRenderer.toFormulaString(fpb, fmla);\n    }
673	public XWPFTable createTable(int rows, int cols) {\n        XWPFTable table = new XWPFTable(ctDocument.getBody().addNewTbl(), this, rows, cols);\n        bodyElements.add(table);\n        tables.add(table);\n        return table;\n    }
674	private void findEscherChildren(DefaultEscherRecordFactory erf, byte[] source, int startPos, int lenToGo, List<EscherRecord> found) {\n\n		int escherBytes = LittleEndian.getInt( source, startPos + 4 ) + 8;\n\n				EscherRecord r = erf.createRecord(source,startPos);\n				r.fillFields( source, startPos, erf );\n				found.add(r);\n\n				int size = r.getRecordSize();\n		if(size < 8) {\n			logger.log(POILogger.WARN, "Hit short DDF record at " + startPos + " - " + size);\n		}\n\n		\n		if(size != escherBytes){\n			logger.log(POILogger.WARN, "Record length=" + escherBytes + " but getRecordSize() returned " + r.getRecordSize() + "; record: " + r.getClass());\n			size = escherBytes;\n		}\n		startPos += size;\n		lenToGo -= size;\n		if(lenToGo >= 8) {\n			findEscherChildren(erf, source, startPos, lenToGo, found);\n		}\n	}
675	@SuppressWarnings("unchecked")\n    public T getShape() {\n        byte metroBytes[] = getMetroBytes();\n        if (metroBytes == null) {\n            return null;\n        }\n        \n                ClassLoader cl = getClass().getClassLoader();\n        try {\n            Class<?> ms = cl.loadClass("org.apache.poi.xslf.usermodel.XSLFMetroShape");\n            Method m = ms.getMethod("parseShape", byte[].class);\n            return (T)m.invoke(null, new Object[]{metroBytes});\n        } catch (Exception e) {\n            LOGGER.log(POILogger.ERROR, "can't process metro blob, check if all dependencies for POI OOXML are in the classpath.", e);\n            return null;\n        }\n    }
676	static HSLFHyperlink createHyperlink(HSLFSimpleShape shape) {\n                ExHyperlink exHyper = new ExHyperlink();\n        int linkId = shape.getSheet().getSlideShow().addToObjListAtom(exHyper);\n        ExHyperlinkAtom obj = exHyper.getExHyperlinkAtom();\n        obj.setNumber(linkId);\n        InteractiveInfo info = new InteractiveInfo();\n        info.getInteractiveInfoAtom().setHyperlinkID(linkId);\n        HSLFEscherClientDataRecord cldata = shape.getClientData(true);\n        cldata.addChild(info);\n        HSLFHyperlink hyper = new HSLFHyperlink(exHyper, info);\n        hyper.linkToNextSlide();\n        shape.setHyperlink(hyper);\n        return hyper;\n    }
677	public void write(POIFSStream stream) throws IOException {\n       OutputStream os = stream.getOutputStream();\n       for(Property property : _properties) {\n          if(property != null) {\n             property.writeData(os);\n          }\n       }\n       os.close();\n       \n              if(getStartBlock() != stream.getStartBlock()) {\n          setStartBlock(stream.getStartBlock());\n       }\n    }
678	public int getNumBorderColors(CellAddress cell) {\n        Map<String, Object> cellProperties = _propertyTemplate.get(cell);\n        if (cellProperties == null) {\n            return 0;\n        }\n\n        int count = 0;\n        for (String property : cellProperties.keySet()) {\n            if (property.equals(CellUtil.TOP_BORDER_COLOR))\n                count += 1;\n            if (property.equals(CellUtil.BOTTOM_BORDER_COLOR))\n                count += 1;\n            if (property.equals(CellUtil.LEFT_BORDER_COLOR))\n                count += 1;\n            if (property.equals(CellUtil.RIGHT_BORDER_COLOR))\n                count += 1;\n        }\n        return count;\n    }
679	private void addName(String functionName) {\n        final Name name = _book.createName();\n        name.setFunction(true);\n        name.setNameName(functionName);\n        name.setSheetIndex(_sheetIndex);\n    }
680	public static POIFSFileSystem verifyAndBuildPOIFS(InputStream istream) throws IOException {\n        InputStream is = FileMagic.prepareToCheckMagic(istream);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        if (fm != FileMagic.OLE2) {\n            throw new IllegalArgumentException("The document is really a "+fm+" file");\n        }\n\n        return new POIFSFileSystem(is);\n    }
681	public Borders getBorderBetween() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getBetween();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
682	private static int dateDiff(long startDateMS, long endDateMS) {\n		long msDiff = endDateMS - startDateMS;\n\n				int remainderHours = (int) ((msDiff % MS_PER_DAY) / MS_PER_HOUR);\n		switch (remainderHours) {\n			case 0:  				break;\n			case 1:  			case 23: 							default:\n				throw new RuntimeException("Unexpected date diff between " + startDateMS + " and " + endDateMS);\n\n		}\n		return (int) (0.5 + ((double)msDiff / MS_PER_DAY));\n	}
683	public static void main(String[] args) throws IOException {\n        Workbook wb;\n\n        if(args.length > 0 && args[0].equals("-xls")) {\n            wb = new HSSFWorkbook();\n        } else {\n            wb = new XSSFWorkbook();\n        }\n\n        sameCell(wb.createSheet("Same Cell"));\n        multiCell(wb.createSheet("MultiCell"));\n        overlapping(wb.createSheet("Overlapping"));\n        errors(wb.createSheet("Errors"));\n        hideDupplicates(wb.createSheet("Hide Dups"));\n        formatDuplicates(wb.createSheet("Duplicates"));\n        inList(wb.createSheet("In List"));\n        expiry(wb.createSheet("Expiry"));\n        shadeAlt(wb.createSheet("Shade Alt"));\n        shadeBands(wb.createSheet("Shade Bands"));\n        iconSets(wb.createSheet("Icon Sets"));\n        colourScales(wb.createSheet("Colour Scales"));\n        dataBars(wb.createSheet("Data Bars"));\n\n                evaluateRules(wb, "Overlapping");\n        \n                String file = "cf-poi.xls";\n        if(wb instanceof XSSFWorkbook) {\n            file += "x";\n        }\n        FileOutputStream out = new FileOutputStream(file);\n        wb.write(out);\n        out.close();\n        System.out.println("Generated: " + file);\n        wb.close();\n    }
684	private void isCellUnderLineMatches(Locator loc1, Locator loc2) {\n                if (!(loc1.cell instanceof XSSFCell)) return;\n        byte b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getUnderline();\n        byte b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getUnderline();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 == 1 ? "" : "NOT ")+"UNDERLINE",\n                (b2 == 1 ? "" : "NOT ")+"UNDERLINE"\n            );\n        }\n    }
685	public static void optimiseFonts(HSSFWorkbook workbook) {\n						short[] newPos = \n			new short[workbook.getWorkbook().getNumberOfFontRecords()+1];\n		boolean[] zapRecords = new boolean[newPos.length];\n		for(int i=0; i<newPos.length; i++) {\n			newPos[i] = (short)i;\n			zapRecords[i] = false;\n		}\n		\n						FontRecord[] frecs = new FontRecord[newPos.length]; \n		for(int i=0; i<newPos.length; i++) {\n						if(i == 4) continue;\n			\n			frecs[i] = workbook.getWorkbook().getFontRecordAt(i);\n		}\n		\n												for(int i=5; i<newPos.length; i++) {\n									int earlierDuplicate = -1;\n			for(int j=0; j<i && earlierDuplicate == -1; j++) {\n				if(j == 4) continue;\n				\n				FontRecord frCheck = workbook.getWorkbook().getFontRecordAt(j);\n				if(frCheck.sameProperties(frecs[i])) {\n					earlierDuplicate = j;\n				}\n			}\n			\n						if(earlierDuplicate != -1) {\n				newPos[i] = (short)earlierDuplicate;\n				zapRecords[i] = true;\n			}\n		}\n		\n										for(int i=5; i<newPos.length; i++) {\n									short preDeletePos = newPos[i];\n			short newPosition = preDeletePos;\n			for(int j=0; j<preDeletePos; j++) {\n				if(zapRecords[j]) newPosition--;\n			}\n			\n						newPos[i] = newPosition;\n		}\n		\n				for(int i=5; i<newPos.length; i++) {\n			if(zapRecords[i]) {\n				workbook.getWorkbook().removeFontRecord(\n						frecs[i]\n				);\n			}\n		}\n		\n						workbook.resetFontCache();\n		\n						for(int i=0; i<workbook.getWorkbook().getNumExFormats(); i++) {\n			ExtendedFormatRecord xfr = workbook.getWorkbook().getExFormatAt(i);\n			xfr.setFontIndex(\n					newPos[ xfr.getFontIndex() ]\n			);\n		}\n		\n										HashSet<UnicodeString> doneUnicodeStrings = new HashSet<>();\n		for(int sheetNum=0; sheetNum<workbook.getNumberOfSheets(); sheetNum++) {\n			HSSFSheet s = workbook.getSheetAt(sheetNum);\n			for (Row row : s) {\n			   for (Cell cell : row) {\n					if(cell.getCellType() == CellType.STRING) {\n						HSSFRichTextString rtr = (HSSFRichTextString)cell.getRichStringCellValue();\n						UnicodeString u = rtr.getRawUnicodeString();\n						\n												if(! doneUnicodeStrings.contains(u)) {\n														for(short i=5; i<newPos.length; i++) {\n								if(i != newPos[i]) {\n									u.swapFontUse(i, newPos[i]);\n								}\n							}\n							\n														doneUnicodeStrings.add(u);\n						}\n					}\n				}\n			}\n		}\n	}
686	private ParseNode additiveExpression() {\n        ParseNode result = Term();\n        while (true) {\n            SkipWhite();\n            Ptg operator;\n            switch(look) {\n                case '+':\n                    Match('+');\n                    operator = AddPtg.instance;\n                    break;\n                case '-':\n                    Match('-');\n                    operator = SubtractPtg.instance;\n                    break;\n                default:\n                    return result;             }\n            ParseNode other = Term();\n            result = new ParseNode(operator, result, other);\n        }\n    }
687	protected byte[] getDocumentEntryBytes(String name, int encryptionOffset, int len) throws IOException {\n        DirectoryNode dir = getDirectory();\n        DocumentEntry documentProps = (DocumentEntry)dir.getEntry(name);\n        DocumentInputStream dis = dir.createDocumentInputStream(documentProps);\n        EncryptionInfo ei = (encryptionOffset > -1) ? getEncryptionInfo() : null;\n        int streamSize = documentProps.getSize();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(Math.min(streamSize,len));\n\n        InputStream is = dis;\n        try {\n            if (ei != null) {\n                try {\n                    Decryptor dec = ei.getDecryptor();\n                    is = dec.getDataStream(dis, streamSize, 0);\n                    if (encryptionOffset > 0) {\n                        ChunkedCipherInputStream cis = (ChunkedCipherInputStream)is;\n                        byte plain[] = IOUtils.safelyAllocate(encryptionOffset, MAX_RECORD_LENGTH);\n                        cis.readPlain(plain, 0, encryptionOffset);\n                        bos.write(plain);\n                    }\n                } catch (GeneralSecurityException e) {\n                    throw new IOException(e.getMessage(), e);\n                }\n            }\n                                    if (len < Integer.MAX_VALUE) {\n                is = new BoundedInputStream(is, len);\n            }\n            IOUtils.copy(is, bos);\n            return bos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(dis);\n        }\n    }
688	void buildShapeTree() {\n        EscherContainerRecord dgContainer = _boundAggregate.getEscherContainer();\n        if (dgContainer == null) {\n            return;\n        }\n        EscherContainerRecord spgrConrainer = dgContainer.getChildContainers().get(0);\n        List<EscherContainerRecord> spgrChildren = spgrConrainer.getChildContainers();\n\n        for (int i = 0; i < spgrChildren.size(); i++) {\n            EscherContainerRecord spContainer = spgrChildren.get(i);\n            if (i != 0) {\n                HSSFShapeFactory.createShapeTree(spContainer, _boundAggregate, this, _sheet.getWorkbook().getDirectory());\n            }\n        }\n    }
689	protected static void storeText(List<HSLFTextParagraph> paragraphs) {\n        fixLineEndings(paragraphs);\n        updateTextAtom(paragraphs);\n        updateStyles(paragraphs);\n        updateHyperlinks(paragraphs);\n        refreshRecords(paragraphs);\n\n        for (HSLFTextParagraph p : paragraphs) {\n            p._dirty = false;\n        }\n    }
690	public void writeOut(byte headerA, byte headerB, long type, Record[] children, OutputStream out) throws IOException {\n				if(out instanceof MutableByteArrayOutputStream) {\n			MutableByteArrayOutputStream mout =\n				(MutableByteArrayOutputStream)out;\n\n						int oldSize = mout.getBytesWritten();\n\n						mout.write(new byte[] {headerA,headerB});\n			byte[] typeB = new byte[2];\n			LittleEndian.putShort(typeB, 0, (short)type);\n			mout.write(typeB);\n			mout.write(new byte[4]);\n\n						for (Record aChildren : children) {\n				aChildren.writeOut(mout);\n			}\n\n												int length = mout.getBytesWritten() - oldSize - 8;\n			byte[] size = new byte[4];\n			LittleEndian.putInt(size,0,length);\n			mout.overwrite(size, oldSize+4);\n		} else {\n						\n						ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n						baos.write(new byte[] {headerA,headerB});\n			byte[] typeB = new byte[2];\n			LittleEndian.putShort(typeB,0,(short)type);\n			baos.write(typeB);\n			baos.write(new byte[] {0,0,0,0});\n\n						for (Record aChildren : children) {\n				aChildren.writeOut(baos);\n			}\n\n						byte[] toWrite = baos.toByteArray();\n\n												LittleEndian.putInt(toWrite,4,(toWrite.length-8));\n\n						out.write(toWrite);\n		}\n	}
691	public FontRecord createNewFont() {\n        FontRecord rec = createFont();\n\n        records.add(records.getFontpos()+1, rec);\n        records.setFontpos( records.getFontpos() + 1 );\n        numfonts++;\n        return rec;\n    }
692	public void createNotesMaster() {\n        RelationPart rp = createRelationship\n                (XSLFRelation.NOTES_MASTER, XSLFFactory.getInstance(), 1, false);\n        _notesMaster = rp.getDocumentPart();\n\n        CTNotesMasterIdList notesMasterIdList = _presentation.addNewNotesMasterIdLst();\n        CTNotesMasterIdListEntry notesMasterId = notesMasterIdList.addNewNotesMasterId();\n        notesMasterId.setId(rp.getRelationship().getId());\n\n        Integer themeIndex = 1;\n                List<Integer> themeIndexList = new ArrayList<>();\n        for (POIXMLDocumentPart p : getRelations()) {\n            if (p instanceof XSLFTheme) {\n                themeIndexList.add(XSLFRelation.THEME.getFileNameIndex(p));\n            }\n        }\n\n        if (!themeIndexList.isEmpty()) {\n            Boolean found = false;\n            for (Integer i = 1; i <= themeIndexList.size(); i++) {\n                if (!themeIndexList.contains(i)) {\n                    found = true;\n                    themeIndex = i;\n                }\n            }\n            if (!found) {\n                themeIndex = themeIndexList.size() + 1;\n            }\n        }\n\n        XSLFTheme theme = (XSLFTheme) createRelationship\n                (XSLFRelation.THEME, XSLFFactory.getInstance(), themeIndex);\n        theme.importTheme(getSlides().get(0).getTheme());\n\n        _notesMaster.addRelation(null, XSLFRelation.THEME, theme);\n    }
693	private ParseNode function(String name) {\n        Ptg nameToken = null;\n        if(!AbstractFunctionPtg.isBuiltInFunctionName(name)) {\n                        \n            if (_book == null) {\n                                throw new IllegalStateException("Need book to evaluate name '" + name + "'");\n            }\n                        EvaluationName hName = _book.getName(name, _sheetIndex);\n            if (hName != null) {\n                if (!hName.isFunctionName()) {\n                    throw new FormulaParseException("Attempt to use name '" + name\n                            + "' as a function, but defined name in workbook does not refer to a function");\n                }\n    \n                                                nameToken = hName.createPtg();\n            } else {\n                                nameToken = _book.getNameXPtg(name, null);\n                if (nameToken == null) {\n                                        if (log.check(POILogger.WARN)) {\n                        log.log(POILogger.WARN,\n                                "FormulaParser.function: Name '" + name + "' is completely unknown in the current workbook.");\n                    }\n                                        switch (_book.getSpreadsheetVersion()) {\n                        case EXCEL97:\n                                                        addName(name);\n                            hName = _book.getName(name, _sheetIndex);\n                            nameToken = hName.createPtg();\n                            break;\n                        case EXCEL2007:\n                                                        nameToken = new NameXPxg(name);\n                            break;\n                        default:\n                            throw new IllegalStateException("Unexpected spreadsheet version: " + _book.getSpreadsheetVersion().name());\n                    }\n                }\n            }\n        }\n\n        Match('(');\n        ParseNode[] args = Arguments();\n        Match(')');\n\n        return getFunction(name, nameToken, args);\n    }
694	private static int findInsertPosForNewCondFormatTable(List<RecordBase> records) {\n\n		for (int i = records.size() - 2; i >= 0; i--) { 			Object rb = records.get(i);\n			if (rb instanceof MergedCellsTable) {\n				return i + 1;\n			}\n			if (rb instanceof DataValidityTable) {\n				continue;\n			}\n\n			Record rec = (Record) rb;\n			switch (rec.getSid()) {\n				case WindowTwoRecord.sid:\n				case SCLRecord.sid:\n				case PaneRecord.sid:\n				case SelectionRecord.sid:\n				case UnknownRecord.STANDARDWIDTH_0099:\n								case UnknownRecord.LABELRANGES_015F:\n				case UnknownRecord.PHONETICPR_00EF:\n										return i + 1;\n											}\n		}\n		throw new RuntimeException("Did not find Window2 record");\n	}
695	public void clearRect(int x, int y, int width, int height) {\n        Paint paint = getPaint();\n        setColor(getBackground());\n        fillRect(x, y, width, height);\n        setPaint(paint);\n    }
696	PackagePart createPart(PackagePartName partName, String contentType,\n			boolean loadRelationships) {\n		throwExceptionIfReadOnly();\n		if (partName == null) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		if (contentType == null || contentType.isEmpty()) {\n			throw new IllegalArgumentException("contentType");\n		}\n\n				if (partList.containsKey(partName)\n				&& !partList.get(partName).isDeleted()) {\n			throw new PartAlreadyExistsException(\n					"A part with the name '" + partName.getName() + "'" +\n					" already exists : Packages shall not contain equivalent part names and package" +\n					" implementers shall neither create nor recognize packages with equivalent part names. [M1.12]");\n		}\n\n		\n\n																if (contentType.equals(ContentTypes.CORE_PROPERTIES_PART)) {\n			if (this.packageProperties != null) {\n				throw new InvalidOperationException(\n						"OPC Compliance error [M4.1]: you try to add more than one core properties relationship in the package !");\n			}\n		}\n\n		\n\n		PackagePart part = this.createPartImpl(partName, contentType,\n				loadRelationships);\n		this.contentTypeManager.addContentType(partName, contentType);\n		this.partList.put(partName, part);\n		this.isDirty = true;\n		return part;\n	}
697	public static PackagePartName createPartName(String partName,\n			PackagePart relativePart) throws InvalidFormatException {\n		URI newPartNameURI;\n		try {\n			newPartNameURI = resolvePartUri(\n					relativePart.getPartName().getURI(), new URI(partName));\n		} catch (URISyntaxException e) {\n			throw new InvalidFormatException(e.getMessage());\n		}\n		return createPartName(newPartNameURI);\n	}
698	public void cloneStyleFrom(ExtendedFormatRecord source) {\n        field_1_font_index           = source.field_1_font_index;\n        field_2_format_index         = source.field_2_format_index;\n        field_3_cell_options         = source.field_3_cell_options;\n        field_4_alignment_options    = source.field_4_alignment_options;\n        field_5_indention_options    = source.field_5_indention_options;\n        field_6_border_options       = source.field_6_border_options;\n        field_7_palette_options      = source.field_7_palette_options;\n        field_8_adtl_palette_options = source.field_8_adtl_palette_options;\n        field_9_fill_palette_options = source.field_9_fill_palette_options;\n    }
699	public static Cipher getCipher(Key key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode, String padding) {\n        int keySizeInBytes = key.getEncoded().length;\n        if (padding == null) padding = "NoPadding";\n        \n        try {\n                        if (Cipher.getMaxAllowedKeyLength(cipherAlgorithm.jceId) < keySizeInBytes*8) {\n                throw new EncryptedDocumentException("Export Restrictions in place - please install JCE Unlimited Strength Jurisdiction Policy files");\n            }\n\n            Cipher cipher;\n            if (cipherAlgorithm == CipherAlgorithm.rc4) {\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId);\n            } else if (cipherAlgorithm.needsBouncyCastle) {\n                registerBouncyCastle();\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding, "BC");\n            } else {\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding);\n            }\n            \n            if (vec == null) {\n                cipher.init(cipherMode, key);\n            } else {\n                AlgorithmParameterSpec aps;\n                if (cipherAlgorithm == CipherAlgorithm.rc2) {\n                    aps = new RC2ParameterSpec(key.getEncoded().length*8, vec);\n                } else {\n                    aps = new IvParameterSpec(vec);\n                }\n                cipher.init(cipherMode, key, aps);\n            }\n            return cipher;\n        } catch (GeneralSecurityException e) {\n            throw new EncryptedDocumentException(e);\n        }\n    }
700	public XSLFChart createChart(XSLFSlide slide) {\n        int chartIdx = findNextAvailableFileNameIndex(XSLFRelation.CHART, _charts.size() + 1);\n        XSLFChart chart = (XSLFChart) createRelationship(XSLFRelation.CHART, XSLFFactory.getInstance(), chartIdx, true).getDocumentPart();\n        slide.addRelation(null, XSLFRelation.CHART, chart);\n        chart.setChartIndex(chartIdx);\n        _charts.add(chart);\n        return chart;\n    }
701	private void create(){\n		EscherContainerRecord dgContainer = new EscherContainerRecord();\n		dgContainer.setRecordId( EscherContainerRecord.DG_CONTAINER );\n		dgContainer.setOptions((short)15);\n\n		dg = new EscherDgRecord();\n		dg.setOptions((short)16);\n		dg.setNumShapes(1);\n		dgContainer.addChildRecord(dg);\n\n		EscherContainerRecord spgrContainer = new EscherContainerRecord();\n		spgrContainer.setOptions((short)15);\n		spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);\n\n		EscherContainerRecord spContainer = new EscherContainerRecord();\n		spContainer.setOptions((short)15);\n		spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n\n		EscherSpgrRecord spgr = new EscherSpgrRecord();\n		spgr.setOptions((short)1);\n		spContainer.addChildRecord(spgr);\n\n		EscherSpRecord sp = new EscherSpRecord();\n		sp.setOptions((short)((ShapeType.NOT_PRIMITIVE.nativeId << 4) + 2));\n		sp.setFlags(EscherSpRecord.FLAG_PATRIARCH | EscherSpRecord.FLAG_GROUP);\n		spContainer.addChildRecord(sp);\n		spgrContainer.addChildRecord(spContainer);\n		dgContainer.addChildRecord(spgrContainer);\n\n		spContainer = new EscherContainerRecord();\n		spContainer.setOptions((short)15);\n		spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n		sp = new EscherSpRecord();\n		sp.setOptions((short)((ShapeType.RECT.nativeId << 4) + 2));\n		sp.setFlags(EscherSpRecord.FLAG_BACKGROUND | EscherSpRecord.FLAG_HASSHAPETYPE);\n		spContainer.addChildRecord(sp);\n\n		EscherOptRecord opt = new EscherOptRecord();\n		opt.setRecordId(EscherOptRecord.RECORD_ID);\n		opt.addEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, 134217728));\n		opt.addEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLBACKCOLOR, 134217733));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.FILL__RECTRIGHT, 10064750));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.FILL__RECTBOTTOM, 7778750));\n		opt.addEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, 1179666));\n		opt.addEscherProperty(new EscherBoolProperty(EscherProperties.LINESTYLE__NOLINEDRAWDASH, 524288));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.SHAPE__BLACKANDWHITESETTINGS, 9));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.SHAPE__BACKGROUNDSHAPE, 65537));\n		spContainer.addChildRecord(opt);\n\n		dgContainer.addChildRecord(spContainer);\n		\n		childRecords.add(dgContainer);\n	}
702	@Internal\n    public static void copyNodeRecursively( Entry entry, DirectoryEntry target )\n    throws IOException {\n        if ( entry.isDirectoryEntry() ) {\n        	DirectoryEntry dirEntry = (DirectoryEntry)entry;\n            DirectoryEntry newTarget = target.createDirectory( entry.getName() );\n            newTarget.setStorageClsid( dirEntry.getStorageClsid() );\n            Iterator<Entry> entries = dirEntry.getEntries();\n\n            while ( entries.hasNext() ) {\n                copyNodeRecursively( entries.next(), newTarget );\n            }\n        } else {\n            DocumentEntry dentry = (DocumentEntry) entry;\n            DocumentInputStream dstream = new DocumentInputStream( dentry );\n            target.createDocument( dentry.getName(), dstream );\n            dstream.close();\n        }\n    }
703	public static NumberRecord convertToNumberRecord(RKRecord rk) {\n        NumberRecord num = new NumberRecord();\n\n        num.setColumn(rk.getColumn());\n        num.setRow(rk.getRow());\n        num.setXFIndex(rk.getXFIndex());\n        num.setValue(rk.getRKNumber());\n        return num;\n    }
704	public static int serializePtgs(Ptg[] ptgs, byte[] array, int offset) {\n		LittleEndianByteArrayOutputStream out = new LittleEndianByteArrayOutputStream(array, offset); 		\n		List<Ptg> arrayPtgs = null;\n\n		for (Ptg ptg : ptgs) {\n			ptg.write(out);\n			if (ptg instanceof ArrayPtg) {\n				if (arrayPtgs == null) {\n					arrayPtgs = new ArrayList<>(5);\n				}\n				arrayPtgs.add(ptg);\n			}\n		}\n		if (arrayPtgs != null) {\n			for (Ptg arrayPtg : arrayPtgs) {\n				ArrayPtg p = (ArrayPtg) arrayPtg;\n				p.writeTokenValueBytes(out);\n			}\n		}\n		return out.getWriteIndex() - offset;\n	}
705	static void writeDataRow(HSSFSheet sheet, int rowIx, double v0, double v1, int expRes) {\n        HSSFRow row = sheet.createRow(rowIx);\n\n        int rowNum = rowIx + 1;\n\n\n        row.createCell(0).setCellValue(formatDoubleAsHex(v0));\n        row.createCell(1).setCellValue(formatDoubleAsHex(v1));\n        row.createCell(2).setCellValue(v0);\n        row.createCell(3).setCellValue(v1);\n        row.createCell(4).setCellValue(expRes < 0 ? "LT" : expRes > 0 ? "GT" : "EQ");\n        row.createCell(5).setCellFormula("C" + rowNum + "<" + "D" + rowNum);\n        row.createCell(6).setCellFormula("C" + rowNum + "=" + "D" + rowNum);\n        row.createCell(7).setCellFormula("C" + rowNum + ">" + "D" + rowNum);\n                String frm = "if(or(" +\n            "and(E#='LT', F#      , G#=FALSE, H#=FALSE)," +\n            "and(E#='EQ', F#=FALSE, G#      , H#=FALSE)," +\n            "and(E#='GT', F#=FALSE, G#=FALSE, H#      )" +\n            "), 'OK', 'error')"    ;\n        row.createCell(8).setCellFormula(frm.replaceAll("#", String.valueOf(rowNum)).replace('\'', '"'));\n    }
706	public void writeData(final OutputStream stream) throws IOException {\n            new IntegerField(_bat_count_offset,      _bat_count, _data);\n      new IntegerField(_property_start_offset, _property_start, _data);\n      new IntegerField(_sbat_start_offset,     _sbat_start, _data);\n      new IntegerField(_sbat_block_count_offset, _sbat_count, _data);\n      new IntegerField(_xbat_start_offset,      _xbat_start, _data);\n      new IntegerField(_xbat_count_offset,      _xbat_count, _data);\n      \n            stream.write(_data, 0, 512);\n      \n            for(int i=POIFSConstants.SMALLER_BIG_BLOCK_SIZE; i<bigBlockSize.getBigBlockSize(); i++) {\n         stream.write(0);\n      }\n   }
707	private void collectIfPtgs(TokenCollector temp) {\n\n				getChildren()[0].collectPtgs(temp);\n\n				int ifAttrIndex = temp.createPlaceholder();\n\n				getChildren()[1].collectPtgs(temp);\n\n				int skipAfterTrueParamIndex = temp.createPlaceholder();\n		int trueParamSize = temp.sumTokenSizes(ifAttrIndex+1, skipAfterTrueParamIndex);\n\n		AttrPtg attrIf = AttrPtg.createIf(trueParamSize + 4); \n		if (getChildren().length > 2) {\n			\n						getChildren()[2].collectPtgs(temp);\n\n			int skipAfterFalseParamIndex = temp.createPlaceholder();\n\n			int falseParamSize =  temp.sumTokenSizes(skipAfterTrueParamIndex+1, skipAfterFalseParamIndex);\n\n			AttrPtg attrSkipAfterTrue = AttrPtg.createSkip(falseParamSize + 4 + 4 - 1); 			AttrPtg attrSkipAfterFalse = AttrPtg.createSkip(4 - 1); \n			temp.setPlaceholder(ifAttrIndex, attrIf);\n			temp.setPlaceholder(skipAfterTrueParamIndex, attrSkipAfterTrue);\n			temp.setPlaceholder(skipAfterFalseParamIndex, attrSkipAfterFalse);\n		} else {\n						AttrPtg attrSkipAfterTrue = AttrPtg.createSkip(4 - 1); \n			temp.setPlaceholder(ifAttrIndex, attrIf);\n			temp.setPlaceholder(skipAfterTrueParamIndex, attrSkipAfterTrue);\n		}\n		temp.add(_token);\n	}
708	public static boolean isEndOfRowBlock(int sid) {\n		switch(sid) {\n			case ViewDefinitionRecord.sid:\n							case DrawingRecord.sid:\n			case DrawingSelectionRecord.sid:\n			case ObjRecord.sid:\n			case TextObjectRecord.sid:\n            case ColumnInfoRecord.sid:             case GutsRecord.sid:   			case WindowOneRecord.sid:\n							case WindowTwoRecord.sid:\n				return true;\n\n			case DVALRecord.sid:\n				return true;\n			case EOFRecord.sid:\n								throw new RuntimeException("Found EOFRecord before WindowTwoRecord was encountered");\n		}\n		return PageSettingsBlock.isComponentRecord(sid);\n	}
709	public static void arrayMoveWithin(Object[] array, int moveFrom, int moveTo, int numToMove) {\n    	    	if(numToMove <= 0) { return; }\n    	if(moveFrom == moveTo) { return; }\n    	\n    	    	if(moveFrom < 0 || moveFrom >= array.length) {\n    		throw new IllegalArgumentException("The moveFrom must be a valid array index");\n    	}\n    	if(moveTo < 0 || moveTo >= array.length) {\n    		throw new IllegalArgumentException("The moveTo must be a valid array index");\n    	}\n    	if(moveFrom+numToMove > array.length) {\n    		throw new IllegalArgumentException("Asked to move more entries than the array has");\n    	}\n    	if(moveTo+numToMove > array.length) {\n    		throw new IllegalArgumentException("Asked to move to a position that doesn't have enough space");\n    	}\n    	\n    	    	Object[] toMove = new Object[numToMove];\n    	System.arraycopy(array, moveFrom, toMove, 0, numToMove);\n    	\n    	    	Object[] toShift;\n    	int shiftTo;\n    	if(moveFrom > moveTo) {\n    		    		    		toShift = new Object[(moveFrom-moveTo)];\n    		System.arraycopy(array, moveTo, toShift, 0, toShift.length);\n    		shiftTo = moveTo + numToMove;\n    	} else {\n    		    		    		toShift = new Object[(moveTo-moveFrom)];\n    		System.arraycopy(array, moveFrom+numToMove, toShift, 0, toShift.length);\n    		shiftTo = moveFrom;\n    	}\n    	\n    	    	System.arraycopy(toMove, 0, array, moveTo, toMove.length);\n    	\n    	    	System.arraycopy(toShift, 0, array, shiftTo, toShift.length);\n    	\n    	\n    	    }
710	public void writeOut(OutputStream out) throws IOException {\n												int size = 8 + 20 + 4 + (3 * lastEditUser.length());\n		_contents = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n\n				System.arraycopy(atomHeader,0,_contents,0,4);	\n				int atomSize = 20+4+lastEditUser.length();\n		LittleEndian.putInt(_contents,4,atomSize);\n\n				LittleEndian.putInt(_contents,8,20);\n\n				System.arraycopy((isEncrypted ? encHeaderToken : headerToken),0,_contents,12,4);\n\n				LittleEndian.putInt(_contents,16,(int)currentEditOffset);\n\n						byte[] asciiUN = IOUtils.safelyAllocate(lastEditUser.length(), MAX_RECORD_LENGTH);\n		StringUtil.putCompressedUnicode(lastEditUser,asciiUN,0);\n		\n				LittleEndian.putShort(_contents,20,(short)asciiUN.length);\n		\n				LittleEndian.putShort(_contents,22,(short)docFinalVersion);\n		_contents[24] = docMajorNo;\n		_contents[25] = docMinorNo;\n\n				_contents[26] = 0;\n		_contents[27] = 0;\n\n				System.arraycopy(asciiUN,0,_contents,28,asciiUN.length);\n\n				LittleEndian.putInt(_contents,28+asciiUN.length,(int)releaseVersion);\n\n				byte [] ucUN = IOUtils.safelyAllocate(lastEditUser.length()*2, MAX_RECORD_LENGTH);\n		StringUtil.putUnicodeLE(lastEditUser,ucUN,0);\n		System.arraycopy(ucUN,0,_contents,28+asciiUN.length+4,ucUN.length);\n\n				out.write(_contents);\n	}
711	private static CellRefParts separateRefParts(String reference) {\n        int plingPos = reference.lastIndexOf(SHEET_NAME_DELIMITER);\n        final String sheetName = parseSheetName(reference, plingPos);\n        String cell = reference.substring(plingPos+1).toUpperCase(Locale.ROOT);\n        Matcher matcher = CELL_REF_PATTERN.matcher(cell);\n        if (!matcher.matches()) {\n            throw new IllegalArgumentException("Invalid CellReference: " + reference);\n        }\n        String col = matcher.group(1);\n        String row = matcher.group(2);\n\n        return new CellRefParts(sheetName, row, col);\n    }
712	private void setPropertiesFromSheet(InternalSheet sheet) {\n        RowRecord row = sheet.getNextRow();\n\n        while (row != null) {\n            createRowFromRecord(row);\n\n            row = sheet.getNextRow();\n        }\n\n        Iterator<CellValueRecordInterface> iter = sheet.getCellValueIterator();\n        long timestart = System.currentTimeMillis();\n\n        if (log.check( POILogger.DEBUG )) {\n            log.log(DEBUG, "Time at start of cell creating in HSSF sheet = ",\n                    Long.valueOf(timestart));\n        }\n        HSSFRow lastrow = null;\n\n                while (iter.hasNext()) {\n            CellValueRecordInterface cval = iter.next();\n\n            long cellstart = System.currentTimeMillis();\n            HSSFRow hrow = lastrow;\n\n            if (hrow == null || hrow.getRowNum() != cval.getRow()) {\n                hrow = getRow(cval.getRow());\n                lastrow = hrow;\n                if (hrow == null) {\n                    "Unexpected missing row when some rows already present"\n\n                                        RowRecord rowRec = new RowRecord(cval.getRow());\n                    sheet.addRow(rowRec);\n                    hrow = createRowFromRecord(rowRec);\n                }\n            }\n            if (log.check( POILogger.DEBUG )) {\n                if (cval instanceof Record) {\n                log.log( DEBUG, "record id = " + Integer.toHexString( ( (Record) cval ).getSid() ) );\n                } else {\n                    log.log( DEBUG, "record = " + cval );\n                }\n            }\n            hrow.createCellFromRecord( cval );\n            if (log.check( POILogger.DEBUG )) {\n                log.log( DEBUG, "record took ",\n                    Long.valueOf( System.currentTimeMillis() - cellstart ) );\n            }\n\n        }\n        if (log.check( POILogger.DEBUG )) {\n            log.log(DEBUG, "total sheet cell creation took ",\n                Long.valueOf(System.currentTimeMillis() - timestart));\n    }\n    }
713	private void appendHeaderFooter( String text, StringBuffer out ) {\n        if ( text == null || text.length() == 0 )\n            return;\n\n        text = text.replace( '\r', '\n' );\n        if ( !text.endsWith( "\n" ))\n        {\n            out.append( text );\n            out.append( '\n' );\n            return;\n        }\n        if ( text.endsWith( "\n\n" ))\n        {\n            out.append( text.substring( 0, text.length() - 1 ));\n            return;\n        }\n        out.append( text );\n    }
714	@SuppressWarnings("WeakerAccess")\n    protected PropertySet getPropertySet(String setName, EncryptionInfo encryptionInfo) throws IOException {\n        DirectoryNode dirNode = directory;\n        \n        POIFSFileSystem encPoifs = null;\n        String step = "getting";\n        try {\n            if (encryptionInfo != null && encryptionInfo.isDocPropsEncrypted()) {\n                step = "getting encrypted";\n                String encryptedStream = getEncryptedPropertyStreamName();\n                if (!dirNode.hasEntry(encryptedStream)) {\n                    throw new EncryptedDocumentException("can't find encrypted property stream '"+encryptedStream+"'");\n                }\n                CryptoAPIDecryptor dec = (CryptoAPIDecryptor)encryptionInfo.getDecryptor();\n                encPoifs = dec.getSummaryEntries(dirNode, encryptedStream);\n                dirNode = encPoifs.getRoot();\n            }\n            \n                        if (dirNode == null || !dirNode.hasEntry(setName)) {\n                return null;\n            }\n    \n                        step = "getting";\n            try (DocumentInputStream dis = dirNode.createDocumentInputStream(dirNode.getEntry(setName))) {\n                                step = "creating";\n                return PropertySetFactory.create(dis);\n            }\n        } catch (IOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new IOException("Error "+step+" property set with name " + setName, e);\n        } finally {\n            IOUtils.closeQuietly(encPoifs);\n        }\n    }
715	public ExcelAntEvaluationResult evaluateCell(String cellName, double expectedValue,\n            double precision) {\n\n        ExcelAntEvaluationResult evalResults = null;\n\n        Cell cell = getCell(cellName);\n\n        FormulaEvaluator evaluator = getEvaluator(excelFileName);\n\n\n        CellValue resultOfEval = evaluator.evaluate(cell);\n\n        if (resultOfEval.getErrorValue() == 0) {\n                        double result = resultOfEval.getNumberValue();\n            double delta = Math.abs(result - expectedValue);\n            if (delta > precision) {\n                evalResults = new ExcelAntEvaluationResult(false, false,\n                        resultOfEval.getNumberValue(),\n                        "Results was out of range based on precision " + " of "\n                                + precision + ".  Delta was actually " + delta, delta, cellName);\n            } else {\n                evalResults = new ExcelAntEvaluationResult(false, true,\n                        resultOfEval.getNumberValue(),\n                        "Evaluation passed without error within in range.", delta, cellName);\n            }\n        } else {\n            String errorMeaning = null;\n            try {\n                errorMeaning = FormulaError.forInt(resultOfEval.getErrorValue()).getString();\n            } catch(IllegalArgumentException iae) {\n                errorMeaning =  "unknown error code: " +\n                                Byte.toString(resultOfEval.getErrorValue());\n            }\n\n            evalResults = new ExcelAntEvaluationResult(true, false,\n                    resultOfEval.getNumberValue(),\n                    "Evaluation failed due to an evaluation error of "\n                            + resultOfEval.getErrorValue()\n                            + " which is "\n                            + errorMeaning, 0, cellName);\n        }\n\n        return evalResults;\n    }
716	@Beta\n    private void addDataField(DataConsolidateFunction function, int columnIndex, String valueFieldName, String valueFormat) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        \n        CTDataFields dataFields;\n        if(pivotTableDefinition.getDataFields() != null) {\n            dataFields = pivotTableDefinition.getDataFields();\n        } else {\n            dataFields = pivotTableDefinition.addNewDataFields();\n        }\n        CTDataField dataField = dataFields.addNewDataField();\n        dataField.setSubtotal(STDataConsolidateFunction.Enum.forInt(function.getValue()));\n        Cell cell = getDataSheet().getRow(pivotArea.getFirstCell().getRow())\n                .getCell(pivotArea.getFirstCell().getCol() + columnIndex);\n        cell.setCellType(CellType.STRING);\n        dataField.setName(valueFieldName);\n        dataField.setFld(columnIndex);\n        if (valueFormat != null && !valueFormat.trim().isEmpty()) {\n            DataFormat df = parentSheet.getWorkbook().createDataFormat();\n            dataField.setNumFmtId(df.getFormat(valueFormat));\n        }\n        dataFields.setCount(dataFields.sizeOfDataFieldArray());\n    }
717	public float getAnchorHeightInPoints(HSSFSheet sheet) {\n        int y1 = getDy1();\n        int y2 = getDy2();\n        int row1 = Math.min(getRow1(), getRow2());\n        int row2 = Math.max(getRow1(), getRow2());\n\n        float points = 0;\n        if (row1 == row2) {\n            points = ((y2 - y1) / 256.0f) * getRowHeightInPoints(sheet, row2);\n        } else {\n            points += ((256.0f - y1) / 256.0f) * getRowHeightInPoints(sheet, row1);\n            for (int i = row1 + 1; i < row2; i++) {\n                points += getRowHeightInPoints(sheet, i);\n            }\n            points += (y2 / 256.0f) * getRowHeightInPoints(sheet, row2);\n        }\n\n        return points;\n    }
718	protected void onDocumentWrite(){\n        CTCell[] cArray = new CTCell[_cells.size()];\n        int i = 0;\n        for (XSSFCell xssfCell : _cells.values()) {\n            cArray[i] = (CTCell) xssfCell.getCTCell().copy();\n            \n                                                                        xssfCell.setCTCell(cArray[i]);\n            i++;\n        }\n\n        _row.setCArray(cArray);\n    }
719	private void findMostRecentCoreRecords() {\n				Map<Integer,Integer> mostRecentByBytes = new HashMap<>();\n		for (Record record : _hslfSlideShow.getRecords()) {\n			if (record instanceof PersistPtrHolder) {\n				PersistPtrHolder pph = (PersistPtrHolder) record;\n\n												int[] ids = pph.getKnownSlideIDs();\n				for (int id : ids) {\n					mostRecentByBytes.remove(id);\n				}\n\n								Map<Integer,Integer> thisSetOfLocations = pph.getSlideLocationsLookup();\n				for (int id : ids) {\n					mostRecentByBytes.put(id, thisSetOfLocations.get(id));\n				}\n			}\n		}\n\n						_mostRecentCoreRecords = new Record[mostRecentByBytes.size()];\n\n						_sheetIdToCoreRecordsLookup = new HashMap<>();\n		Integer[] allIDs = mostRecentByBytes.keySet().toArray(new Integer[0]);\n		Arrays.sort(allIDs);\n		for (int i = 0; i < allIDs.length; i++) {\n			_sheetIdToCoreRecordsLookup.put(allIDs[i], i);\n		}\n\n		Map<Integer,Integer> mostRecentByBytesRev = new HashMap<>(mostRecentByBytes.size());\n		for (Map.Entry<Integer,Integer> me : mostRecentByBytes.entrySet()) {\n		    mostRecentByBytesRev.put(me.getValue(), me.getKey());\n		}\n\n				for (Record record : _hslfSlideShow.getRecords()) {\n			if (!(record instanceof PositionDependentRecord)) {\n                continue;\n            }\n\n			PositionDependentRecord pdr = (PositionDependentRecord) record;\n			int recordAt = pdr.getLastOnDiskOffset();\n\n			Integer thisID = mostRecentByBytesRev.get(recordAt);\n\n			if (thisID == null) {\n                continue;\n            }\n\n						int storeAt = _sheetIdToCoreRecordsLookup.get(thisID);\n\n						if (pdr instanceof PositionDependentRecordContainer) {\n				PositionDependentRecordContainer pdrc = (PositionDependentRecordContainer) record;\n				pdrc.setSheetId(thisID);\n			}\n\n						_mostRecentCoreRecords[storeAt] = record;\n		}\n\n				for (Record record : _mostRecentCoreRecords) {\n						if (record != null) {\n								if (record.getRecordType() == RecordTypes.Document.typeID) {\n					_documentRecord = (Document) record;\n					_fonts = _documentRecord.getEnvironment().getFontCollection();\n				}\n			} \n		}\n	}
720	protected static String toDebugFriendlyString(byte[] value) {\n        if (value == null) {\n            return "(Null Byte Array)";\n        }\n\n        StringBuffer text = new StringBuffer();\n        text.append("Bytes len=").append(value.length);\n        text.append(" [");\n\n        int limit = Math.min(value.length, 16);\n        if (value.length > 16) {\n            limit = 12;\n        }\n        for (int i = 0; i < limit; i++) {\n            if (i > 0) {\n                text.append(',');\n            }\n            text.append(value[i]);\n        }\n        if (value.length > 16) {\n            text.append(",....");\n        }\n        text.append("]");\n        return text.toString();\n    }
721	private void outputUncompressed(byte b, OutputStream res) throws IOException {\n		nextMask += (1<<maskBitsSet);\n	maskBitsSet++;\n\n		buffer[bufferLen] = b;\n	bufferLen++;\n	dict[(posOut&4095)] = b;\n	posOut++;\n\n		if(maskBitsSet == 8) {\n		output8Codes(res);\n	}\n}
722	public String getSignatureMethodUri() {\n        switch (getDigestAlgo()) {\n        case sha1:   return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1;\n        case sha224: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA224;\n        case sha256: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA256;\n        case sha384: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA384;\n        case sha512: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA512;\n        case ripemd160: return XMLSignature.ALGO_ID_SIGNATURE_RSA_RIPEMD160;\n        default: throw new EncryptedDocumentException("Hash algorithm "\n            +getDigestAlgo()+" not supported for signing.");\n        }\n    }
723	public void display(PrintWriter w, int indent)\n    {\n        for (int i = 0; i < indent * 4; i++) {\n            w.print(' ');\n        }\n        w.println(getRecordName());\n    }
724	public void writeOut(OutputStream o, boolean isMasterStyle) throws IOException {\n	    if (!isMasterStyle) {\n	        	        	        StyleTextPropAtom.writeLittleEndian(charactersCovered,o);\n	    }\n\n				if (textPropType == TextPropType.paragraph && indentLevel > -1) {\n			StyleTextPropAtom.writeLittleEndian(indentLevel, o);\n		}\n\n				int mask = maskSpecial;\n		for (TextProp textProp : textProps.values()) {\n            mask |= textProp.getWriteMask();\n        }\n		StyleTextPropAtom.writeLittleEndian(mask,o);\n\n				for (TextProp textProp : getTextPropList()) {\n            int val = textProp.getValue();\n            if (textProp instanceof BitMaskTextProp && textProp.getWriteMask() == 0) {\n                                continue;\n            } else if (textProp.getSize() == 2) {\n                StyleTextPropAtom.writeLittleEndian((short)val,o);\n            } else if (textProp.getSize() == 4) {\n                StyleTextPropAtom.writeLittleEndian(val,o);\n            } else if (textProp instanceof HSLFTabStopPropCollection) {\n                ((HSLFTabStopPropCollection)textProp).writeProperty(o);\n            }\n		}\n	}
725	public void dumpDrawingGroupRecords(boolean fat) {\n        DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );\n        if (r == null) {\n            return;\n        }\n        r.decode();\n        List<EscherRecord> escherRecords = r.getEscherRecords();\n        PrintWriter w = new PrintWriter(new OutputStreamWriter(System.out, Charset.defaultCharset()));\n        for (EscherRecord escherRecord : escherRecords) {\n            if (fat) {\n                System.out.println(escherRecord);\n            } else {\n                escherRecord.display(w, 0);\n            }\n        }\n        w.flush();\n    }
726	public Borders getBorderLeft() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getLeft();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
727	private static double getCellWidth(int defaultCharWidth, int colspan,\n            CellStyle style, double minWidth, AttributedString str) {\n        TextLayout layout = new TextLayout(str.getIterator(), fontRenderContext);\n        final Rectangle2D bounds;\n        if(style.getRotation() != 0){\n            \n            AffineTransform trans = new AffineTransform();\n            trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n            trans.concatenate(\n            AffineTransform.getScaleInstance(1, fontHeightMultiple)\n            );\n            bounds = layout.getOutline(trans).getBounds();\n        } else {\n            bounds = layout.getBounds();\n        }\n                final double frameWidth = bounds.getX() + bounds.getWidth();\n        return Math.max(minWidth, ((frameWidth / colspan) / defaultCharWidth) + style.getIndention());\n    }
728	protected void writeProperties(POIFSFileSystem outFS, List<String> writtenEntries) throws IOException {\n        final EncryptionInfo ei = getEncryptionInfo();\n        final boolean encryptProps = (ei != null && ei.isDocPropsEncrypted());\n        try (POIFSFileSystem tmpFS = new POIFSFileSystem()) {\n            final POIFSFileSystem fs = (encryptProps) ? tmpFS : outFS;\n\n            writePropertySet(SummaryInformation.DEFAULT_STREAM_NAME, getSummaryInformation(), fs, writtenEntries);\n            writePropertySet(DocumentSummaryInformation.DEFAULT_STREAM_NAME, getDocumentSummaryInformation(), fs, writtenEntries);\n\n            if (!encryptProps) {\n                return;\n            }\n\n                        writePropertySet(DocumentSummaryInformation.DEFAULT_STREAM_NAME, newDocumentSummaryInformation(), outFS);\n\n                        if (outFS.getRoot().hasEntry(SummaryInformation.DEFAULT_STREAM_NAME)) {\n                outFS.getRoot().getEntry(SummaryInformation.DEFAULT_STREAM_NAME).delete();\n            }\n            Encryptor encGen = ei.getEncryptor();\n            if (!(encGen instanceof CryptoAPIEncryptor)) {\n                throw new EncryptedDocumentException(\n                    "Using " + ei.getEncryptionMode() + " encryption. Only CryptoAPI encryption supports encrypted property sets!");\n            }\n            CryptoAPIEncryptor enc = (CryptoAPIEncryptor) encGen;\n            try {\n                enc.setSummaryEntries(outFS.getRoot(), getEncryptedPropertyStreamName(), fs);\n            } catch (GeneralSecurityException e) {\n                throw new IOException(e);\n            }\n        }\n    }
729	public int addChildAfter(Record newChild, Record after) {\n				int loc = findChildLocation(after);\n		if(loc == -1) {\n			throw new IllegalArgumentException("Asked to add a new child after another record, but that record wasn't one of our children!");\n		}\n\n				addChildAt(newChild, loc+1);\n		return loc+1;\n	}
730	public static void main(String[] args) throws IOException\n    {\n                        try (FileInputStream fin = new FileInputStream(args[0])) {\n                        try (POIFSFileSystem poifs = new POIFSFileSystem(fin)) {\n                                try (InputStream din = poifs.createDocumentInputStream("Workbook")) {\n                                        HSSFRequest req = new HSSFRequest();\n                                        req.addListenerForAllRecords(new EventExample());\n                                        HSSFEventFactory factory = new HSSFEventFactory();\n                                        factory.processEvents(req, din);\n                }\n            }\n        }\n        System.out.println("done.");\n    }
731	public void writeToFS(POIFSFileSystem fs) throws IOException {\n				ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		writeOut(baos);\n		ByteArrayInputStream bais = \n			new ByteArrayInputStream(baos.toByteArray());\n\n				fs.createOrUpdateDocument(bais,"Current User");\n	}
732	boolean hasLeadingTrailingSpaces(String str) {\n        if (str != null && str.length() > 0) {\n            char firstChar = str.charAt(0);\n            char lastChar  = str.charAt(str.length() - 1);\n            return Character.isWhitespace(firstChar) || Character.isWhitespace(lastChar) ;\n        }\n        return false;\n    }
733	public void numberedListInCell(HSSFWorkbook workbook,\n                                   ArrayList<String> listItems,\n                                   HSSFCell cell,\n                                   int startingValue,\n                                   int increment) {\n        StringBuilder buffer = new StringBuilder();\n        int itemNumber = startingValue;\n                        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n                        for(String listItem : listItems) {\n            buffer.append(itemNumber).append(". ");\n            buffer.append(listItem);\n            buffer.append("\n");\n            itemNumber += increment;\n        }\n                        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
734	void setType(CellType type)\n    {\n        switch(type)\n        {\n            case NUMERIC:\n            {\n                _value = new NumericValue();\n                break;\n            }\n            case STRING:\n            {\n                PlainStringValue sval = new PlainStringValue();\n                if(_value != null){\n                                        String str = convertCellValueToString();\n                    sval.setValue(str);\n                }\n                _value = sval;\n                break;\n            }\n            case FORMULA:\n            {\n                _value = new NumericFormulaValue();\n                break;\n            }\n            case BLANK:\n            {\n                _value = new BlankValue();\n                break;\n            }\n            case BOOLEAN:\n            {\n                BooleanValue bval = new BooleanValue();\n                if(_value != null){\n                                        boolean val = convertCellValueToBoolean();\n                    bval.setValue(val);\n                }\n                _value = bval;\n                break;\n            }\n            case ERROR:\n            {\n                _value = new ErrorValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException("Illegal type " + type);\n            }\n        }\n    }
735	private ParseNode powerFactor() {\n        ParseNode result = percentFactor();\n        while(true) {\n            SkipWhite();\n            if(look != '^') {\n                return result;\n            }\n            Match('^');\n            ParseNode other = percentFactor();\n            result = new ParseNode(PowerPtg.instance, result, other);\n        }\n    }
736	public boolean changeName(Property property, String newName)\n    {\n        boolean result;\n        String  oldName = property.getName();\n\n        property.setName(newName);\n        String cleanNewName = property.getName();\n\n        if (_children_names.contains(cleanNewName))\n        {\n\n                        property.setName(oldName);\n            result = false;\n        }\n        else\n        {\n            _children_names.add(cleanNewName);\n            _children_names.remove(oldName);\n            result = true;\n        }\n        return result;\n    }
737	public void setRunType(int type) {\n        getEscherTextboxWrapper();\n        if (_txtbox == null) {\n            return;\n        }\n        List<HSLFTextParagraph> paras = HSLFTextParagraph.findTextParagraphs(_txtbox, getSheet());\n        if (!paras.isEmpty()) {\n            paras.get(0).setRunType(type);\n        }\n    }
738	public void findChildren(byte[] documentData) {\n				childStreams = new Stream[childPointers.length];\n		for(int i=0; i<childPointers.length; i++) {\n			Pointer ptr = childPointers[i];\n			childStreams[i] = Stream.createStream(ptr, documentData, chunkFactory, pointerFactory);\n\n						if(childStreams[i] instanceof ChunkStream) {\n				ChunkStream child = (ChunkStream)childStreams[i];\n				child.findChunks();\n			}\n\n						if(childStreams[i] instanceof PointerContainingStream) {\n				PointerContainingStream child =\n					(PointerContainingStream)childStreams[i];\n				child.findChildren(documentData);\n			}\n		}\n	}
