1	public void markAsClaimed(Picture picture) {\n        claimed.add(picture);\n    }
2	public BigInteger getIdOfAbstractNum(XWPFAbstractNum abstractNum) {\n        CTAbstractNum copy = (CTAbstractNum) abstractNum.getCTAbstractNum().copy();\n        XWPFAbstractNum newAbstractNum = new XWPFAbstractNum(copy, this);\n        int i;\n        for (i = 0; i < abstractNums.size(); i++) {\n            newAbstractNum.getCTAbstractNum().setAbstractNumId(BigInteger.valueOf(i));\n            newAbstractNum.setNumbering(this);\n            if (newAbstractNum.getCTAbstractNum().valueEquals(abstractNums.get(i).getCTAbstractNum())) {\n                return newAbstractNum.getCTAbstractNum().getAbstractNumId();\n            }\n        }\n        return null;\n    }
3	public SharedStringsTable getSharedStringsTable() throws IOException, InvalidFormatException {\n        ArrayList<PackagePart> parts = pkg.getPartsByContentType(XSSFRelation.SHARED_STRINGS.getContentType());\n        return parts.size() == 0 ? null : new SharedStringsTable(parts.get(0));\n    }
4	private static void putAll(final Map<String, Object> src, Map<String, Object> dest) {\n        for (final String key : src.keySet()) {\n            if (shortValues.contains(key)) {\n                dest.put(key, getShort(src, key));\n            } else if (booleanValues.contains(key)) {\n                dest.put(key, getBoolean(src, key));\n            } else if (borderTypeValues.contains(key)) {\n                dest.put(key, getBorderStyle(src, key));\n            } else if (ALIGNMENT.equals(key)) {\n                dest.put(key, getHorizontalAlignment(src, key));\n            } else if (VERTICAL_ALIGNMENT.equals(key)) {\n                dest.put(key, getVerticalAlignment(src, key));\n            } else if (FILL_PATTERN.equals(key)) {\n                dest.put(key, getFillPattern(src, key));\n            } else {\n                if (log.check(POILogger.INFO)) {\n                    log.log(POILogger.INFO, "Ignoring unrecognized CellUtil format properties key: " + key);\n                }\n            }\n        }\n    }
5	public void clearSections() {\n        sections.clear();\n    }
6	public void bulletedItemInCell(HSSFWorkbook workbook, String listItem, HSSFCell cell) {\n        // A format String must be built to ensure that the contents of the\n        // cell appear as a bulleted item.\n        HSSFDataFormat format = workbook.createDataFormat();\n        String formatString = InCellLists.BULLET_CHARACTER + " @";\n        int formatIndex = format.getFormat(formatString);\n\n        // Construct an HSSFCellStyle and set it's data formt to use the\n        // object created above.\n        HSSFCellStyle bulletStyle = workbook.createCellStyle();\n        bulletStyle.setDataFormat((short)formatIndex);\n\n        // Set the cells contents and style.\n        cell.setCellValue(new HSSFRichTextString(listItem));\n        cell.setCellStyle(bulletStyle);\n    }
7	public void addObjectTableEntry(HwmfObjectTableEntry entry) {\n        ListIterator<HwmfObjectTableEntry> oIter = objectTable.listIterator();\n        while (oIter.hasNext()) {\n            HwmfObjectTableEntry tableEntry = oIter.next();\n            if (tableEntry == null) {\n                oIter.set(entry);\n                return;\n            }\n        }\n        objectTable.add(entry);\n    }
8	public ValueEval evaluate(ValueEval[] args, OperationEvaluationContext ec) {\n        if (args.length < 2 || args.length > 3) {\n            return ErrorEval.VALUE_INVALID;\n        }\n\n        int srcCellRow = ec.getRowIndex();\n        int srcCellCol = ec.getColumnIndex();\n\n        double start;\n        int days;\n        double[] holidays;\n        try {\n            start = this.evaluator.evaluateDateArg(args[0], srcCellRow, srcCellCol);\n            days = (int) Math.floor(this.evaluator.evaluateNumberArg(args[1], srcCellRow, srcCellCol));\n            ValueEval holidaysCell = args.length == 3 ? args[2] : null;\n            holidays = this.evaluator.evaluateDatesArg(holidaysCell, srcCellRow, srcCellCol);\n            return new NumberEval(DateUtil.getExcelDate(WorkdayCalculator.instance.calculateWorkdays(start, days, holidays)));\n        } catch (EvaluationException e) {\n            return ErrorEval.VALUE_INVALID;\n        }\n    }
9	public PackagePart getPart(PackagePartName partName) {\n		throwExceptionIfWriteOnly();\n\n		if (partName == null) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		// If the partlist is null, then we parse the package.\n		if (partList == null) {\n			try {\n				getParts();\n			} catch (InvalidFormatException e) {\n				return null;\n			}\n		}\n\n		return partList.get(partName);\n	}
10	public static boolean isInternalDateFormat(int format) {\n            switch(format) {\n                // Internal Date Formats as described on page 427 in\n                // Microsoft Excel Dev's Kit...\n                case 0x0e:\n                case 0x0f:\n                case 0x10:\n                case 0x11:\n                case 0x12:\n                case 0x13:\n                case 0x14:\n                case 0x15:\n                case 0x16:\n                case 0x2d:\n                case 0x2e:\n                case 0x2f:\n                    return true;\n            }\n       return false;\n    }
11	public boolean hasUnlimitedVarags() {\n		return FUNCTION_MAX_PARAMS == _maxParams;\n	}
12	public boolean equals(Object other)\n  {\n    if (other == this) return true;\n    if (!(other instanceof SavedByEntry)) return false;\n    SavedByEntry that = (SavedByEntry) other;\n    return that.userName.equals(userName) &&\n           that.saveLocation.equals(saveLocation);\n  }
13	protected static void processChunks(DirectoryNode node, ChunkGroup grouping) {\n      for(Entry entry : node) {\n         if(entry instanceof DocumentNode) {\n            process(entry, grouping);\n         } else if(entry instanceof DirectoryNode) {\n             if(entry.getName().endsWith(Types.DIRECTORY.asFileEnding())) {\n                 process(entry, grouping);\n             }\n         }\n      }\n   }
14	private void rowToCSV(Row row) {\n        Cell cell;\n        int lastCellNum;\n        ArrayList<String> csvLine = new ArrayList<>();\n\n        // Check to ensure that a row was recovered from the sheet as it is\n        // possible that one or more rows between other populated rows could be\n        // missing - blank. If the row does contain cells then...\n        if(row != null) {\n\n            // Get the index for the right most cell on the row and then\n            // step along the row from left to right recovering the contents\n            // of each cell, converting that into a formatted String and\n            // then storing the String into the csvLine ArrayList.\n            lastCellNum = row.getLastCellNum();\n            for(int i = 0; i <= lastCellNum; i++) {\n                cell = row.getCell(i);\n                if(cell == null) {\n                    csvLine.add("");\n                }\n                else {\n                    if(cell.getCellType() != CellType.FORMULA) {\n                        csvLine.add(this.formatter.formatCellValue(cell));\n                    }\n                    else {\n                        csvLine.add(this.formatter.formatCellValue(cell, this.evaluator));\n                    }\n                }\n            }\n            // Make a note of the index number of the right most cell. This value\n            // will later be used to ensure that the matrix of data in the CSV file\n            // is square.\n            if(lastCellNum > this.maxRowWidth) {\n                this.maxRowWidth = lastCellNum;\n            }\n        }\n        this.csvData.add(csvLine);\n    }
15	private static int binarySearch( List<PlexOfField> list,\n            int startIndex, int endIndex, int requiredStartOffset )\n    {\n        checkIndexForBinarySearch( list.size(), startIndex, endIndex );\n\n        int low = startIndex, mid = -1, high = endIndex - 1, result = 0;\n        while ( low <= high )\n        {\n            mid = ( low + high ) >>> 1;\n            int midStart = list.get( mid ).getFcStart();\n\n            if ( midStart == requiredStartOffset )\n            {\n                return mid;\n            }\n            else if ( midStart < requiredStartOffset )\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid - 1;\n            }\n        }\n        if ( mid < 0 )\n        {\n            int insertPoint = endIndex;\n            for ( int index = startIndex; index < endIndex; index++ )\n            {\n                if ( requiredStartOffset < list.get( index ).getFcStart() )\n                {\n                    insertPoint = index;\n                }\n            }\n            return -insertPoint - 1;\n        }\n        return -mid - ( result >= 0 ? 1 : 2 );\n    }
16	public String getSignificantDecimalDigitsLastDigitRounded() {\n		long wp = _wholePart + 5; // rounds last digit\n		StringBuilder sb = new StringBuilder(24);\n		sb.append(wp);\n		sb.setCharAt(sb.length()-1, '0');\n		return sb.toString();\n	}
17	private static void put(Map<String, Object> properties, String name, Object value) {\n        properties.put(name, value);\n    }
18	public void updateOtherRecordReferences(Map<Integer,Integer> oldToNewReferencesLookup) {\n	}
19	static void errors(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue(84);\n        sheet.createRow(1).createCell(0).setCellValue(0);\n        sheet.createRow(2).createCell(0).setCellFormula("ROUND(A1/A2,0)");\n        sheet.createRow(3).createCell(0).setCellValue(0);\n        sheet.createRow(4).createCell(0).setCellFormula("ROUND(A6/A4,0)");\n        sheet.createRow(5).createCell(0).setCellValue(41);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =ISERROR(C2)   (White Font)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("ISERROR(A1)");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontColorIndex(IndexedColors.WHITE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(1).setCellValue("<== The error in this cell is hidden. Condition: Formula Is   =ISERROR(C2)   (White Font)");\n        sheet.getRow(4).createCell(1).setCellValue("<== The error in this cell is hidden. Condition: Formula Is   =ISERROR(C2)   (White Font)");\n    }
20	@Internal\n    public boolean isFHtmlNotPeriod()\n    {\n        return fHtmlNotPeriod.isSet(field_1_grfhic);\n    }
21	public XWPFHeader createHeader(Enum type, XWPFParagraph[] pars) {\n        XWPFHeader header = getHeader(type);\n\n        if (header == null) {\n            HdrDocument hdrDoc = HdrDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.HEADER;\n            int i = getRelationIndex(relation);\n\n            XWPFHeader wrapper = (XWPFHeader) doc.createRelationship(relation,\n                    XWPFFactory.getInstance(), i);\n            wrapper.setXWPFDocument(doc);\n\n            CTHdrFtr hdr = buildHdr(type, wrapper, pars);\n            wrapper.setHeaderFooter(hdr);\n            hdrDoc.setHdr(hdr);\n            assignHeader(wrapper, type);\n            header = wrapper;\n        }\n\n        return header;\n    }
22	public void clear()\n    {\n        _limit = 0;\n    }
23	public void setPlotOnlyVisibleCells(boolean only) {\n        if (!chart.isSetPlotVisOnly()) {\n            chart.setPlotVisOnly(CTBoolean.Factory.newInstance());\n        }\n        chart.getPlotVisOnly().setVal(only);\n    }
24	public static int countMatches(CharSequence haystack, char needle) {\n        if (haystack == null) return 0;\n        int count = 0;\n        final int length = haystack.length();\n        for (int i = 0; i < length; i++) {\n            if (haystack.charAt(i) == needle) {\n                count++;\n            }\n        }\n        return count;\n    }
25	public int getFillsColourRGB() { return fillsColourRGB; }
26	public List<Cell> getMatchingCells(EvaluationConditionalFormatRule rule) {\n        final List<Cell> cells = new ArrayList<>();\n        final Sheet sheet = rule.getSheet();\n        \n        for (CellRangeAddress region : rule.getRegions()) {\n            for (int r = region.getFirstRow(); r <= region.getLastRow(); r++) {\n                final Row row = sheet.getRow(r);\n                if (row == null) {\n                    continue; // no cells to check\n                }\n                for (int c = region.getFirstColumn(); c <= region.getLastColumn(); c++) {\n                    final Cell cell = row.getCell(c);\n                    if (cell == null) {\n                        continue;\n                    }\n                    \n                    List<EvaluationConditionalFormatRule> cellRules = getConditionalFormattingForCell(cell);\n                    if (cellRules.contains(rule)) {\n                        cells.add(cell);\n                    }\n                }\n            }\n        }\n        return Collections.unmodifiableList(cells);\n    }
27	private static BufferedImage readImage(final InputStream data, final String contentType) throws IOException {\n        IOException lastException = null;\n        BufferedImage img = null;\n\n        final ByteArrayInputStream bis;\n        if (data instanceof ByteArrayInputStream) {\n            bis = (ByteArrayInputStream)data;\n        } else {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(0x3FFFF);\n            IOUtils.copy(data, bos);\n            bis = new ByteArrayInputStream(bos.toByteArray());\n        }\n\n\n        // currently don't use FileCacheImageInputStream,\n        // because of the risk of filling the file handles (see #59166)\n        ImageInputStream iis = new MemoryCacheImageInputStream(bis);\n        try {\n            Iterator<ImageReader> iter = ImageIO.getImageReaders(iis);\n            while (img==null && iter.hasNext()) {\n                ImageReader reader = iter.next();\n                ImageReadParam param = reader.getDefaultReadParam();\n                // 0:default mode, 1:fallback mode\n                for (int mode=0; img==null && mode<3; mode++) {\n                    lastException = null;\n                    if (mode > 0) {\n                        bis.reset();\n                        iis.close();\n                        iis = new MemoryCacheImageInputStream(bis);\n                    }\n\n                    try {\n                    \n                        switch (mode) {\n                            case 0:\n                                reader.setInput(iis, false, true);\n                                img = reader.read(0, param);\n                                break;\n                            case 1: {\n                                // try to load picture in gray scale mode\n                                // fallback mode for invalid image band metadata\n                                // see http://stackoverflow.com/questions/10416378\n                                Iterator<ImageTypeSpecifier> imageTypes = reader.getImageTypes(0);\n                                while (imageTypes.hasNext()) {\n                                    ImageTypeSpecifier imageTypeSpecifier = imageTypes.next();\n                                    int bufferedImageType = imageTypeSpecifier.getBufferedImageType();\n                                    if (bufferedImageType == BufferedImage.TYPE_BYTE_GRAY) {\n                                        param.setDestinationType(imageTypeSpecifier);\n                                        break;\n                                    }\n                                }\n                                reader.setInput(iis, false, true);\n                                img = reader.read(0, param);\n                                break;\n                            }\n                            case 2: {\n                                // try to load truncated pictures by supplying a BufferedImage\n                                // and use the processed data up till the point of error\n                                reader.setInput(iis, false, true);\n                                int height = reader.getHeight(0);\n                                int width = reader.getWidth(0);\n                                \n                                Iterator<ImageTypeSpecifier> imageTypes = reader.getImageTypes(0);\n                                if (imageTypes.hasNext()) {\n                                    ImageTypeSpecifier imageTypeSpecifier = imageTypes.next();\n                                    img = imageTypeSpecifier.createBufferedImage(width, height);\n                                    param.setDestination(img);\n                                } else {\n                                    lastException = new IOException("unable to load even a truncated version of the image.");\n                                    break;\n                                }\n\n                                try {\n                                    reader.read(0, param);\n                                } finally {\n                                    if (img.getType() != BufferedImage.TYPE_INT_ARGB) {\n                                        int y = findTruncatedBlackBox(img, width, height);\n                                        if (y < height) {\n                                            BufferedImage argbImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n                                            Graphics2D g = argbImg.createGraphics();\n                                            g.clipRect(0, 0, width, y);\n                                            g.drawImage(img, 0, 0, null);\n                                            g.dispose();\n                                            img.flush();\n                                            img = argbImg;\n                                        }\n                                    }\n                                }                                \n                                break;\n                            }\n                        }\n                    \n                    } catch (IOException e) {\n                        if (mode < 2) {\n                            lastException = e;\n                        }\n                    } catch (RuntimeException e) {\n                        if (mode < 2) {\n                            lastException = new IOException("ImageIO runtime exception - "+(mode==0 ? "normal" : "fallback"), e);\n                        }\n                    }\n                }\n                reader.dispose();\n            }\n        } finally {\n            iis.close();\n        }\n        \n        // If you don't have an image at the end of all readers\n        if (img == null) {\n            if (lastException != null) {\n                // rethrow exception - be aware that the exception source can be in\n                // multiple locations above ...\n                throw lastException;\n            }\n            LOG.log(POILogger.WARN, "Content-type: "+contentType+" is not support. Image ignored.");\n            return null;\n        }\n\n        // add alpha channel\n        if (img.getType() != BufferedImage.TYPE_INT_ARGB) {\n            BufferedImage argbImg = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_ARGB);\n            Graphics g = argbImg.getGraphics();\n            g.drawImage(img, 0, 0, null);\n            g.dispose();\n            return argbImg;\n        }\n        \n        return img;\n    }
28	private static boolean needsMemFunc(ParseNode root) {\n        Ptg token = root.getToken();\n        if (token instanceof AbstractFunctionPtg) {\n            return true;\n        }\n        if (token instanceof ExternSheetReferenceToken) { // 3D refs\n            return true;\n        }\n        if (token instanceof NamePtg || token instanceof NameXPtg) { // 3D refs\n            return true;\n        }\n\n        if (token instanceof OperationPtg || token instanceof ParenthesisPtg) {\n            // expect RangePtg, but perhaps also UnionPtg, IntersectionPtg etc\n            for(ParseNode child : root.getChildren()) {\n                if (needsMemFunc(child)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (token instanceof OperandPtg) {\n            return false;\n        }\n        if (token instanceof OperationPtg) {\n            return true;\n        }\n\n        return false;\n    }
29	public void removeItem(int sheetId, String ref){\n        //sheet Id of a sheet the cell belongs to\n        int id = -1;\n        CTCalcCell[] c = chain.getCArray();\n\n        for (int i = 0; i < c.length; i++){\n            //If sheet Id  is omitted, it is assumed to be the same as the value of the previous cell.\n            if(c[i].isSetI()) id = c[i].getI();\n\n            if(id == sheetId && c[i].getR().equals(ref)){\n                if(c[i].isSetI() && i < c.length - 1 && !c[i+1].isSetI()) {\n                    c[i+1].setI(id);\n                }\n                chain.removeC(i);\n                break;\n            }\n        }\n    }
30	public static int getEncodedSizeWithoutArrayData(Ptg[] ptgs) {\n		int result = 0;\n		for (Ptg ptg : ptgs) {\n			if (ptg instanceof ArrayPtg) {\n				result += ArrayPtg.PLAIN_TOKEN_SIZE;\n			} else {\n				result += ptg.getSize();\n			}\n		}\n		return result;\n	}
31	public PackageRelationshipCollection getRelationshipsByType(\n            String relationshipType) throws InvalidFormatException {\n        _container.throwExceptionIfWriteOnly();\n\n        return getRelationshipsCore(relationshipType);\n    }
32	//http://en.wikipedia.org/wiki/Future_value\n	static public double fv(double r, int nper, double pmt, double pv, int type) {\n        return -(pv * Math.pow(1 + r, nper) + pmt * (1+r*type) * (Math.pow(1 + r, nper) - 1) / r);\n	}
33	public static Cell createCell(Row row, int column, String value) {\n        return createCell(row, column, value, null);\n    }
34	private static double invokeInternal(Function target, ValueEval[] args, int srcCellRow, int srcCellCol)\n				throws NumericEvalEx {\n		ValueEval evalResult;\n		try {\n			evalResult = target.evaluate(args, srcCellRow, (short)srcCellCol);\n		} catch (NotImplementedException e) {\n			throw new NumericEvalEx("Not implemented:" + e.getMessage());\n		}\n\n		if(evalResult == null) {\n			throw new NumericEvalEx("Result object was null");\n		}\n		if(evalResult instanceof ErrorEval) {\n			ErrorEval ee = (ErrorEval) evalResult;\n			throw new NumericEvalEx(formatErrorMessage(ee));\n		}\n		if(!(evalResult instanceof NumericValueEval)) {\n			throw new NumericEvalEx("Result object type (" + evalResult.getClass().getName()\n					+ ") is invalid.  Expected implementor of ("\n					+ NumericValueEval.class.getName() + ")");\n		}\n\n		NumericValueEval result = (NumericValueEval) evalResult;\n		return result.getNumberValue();\n	}
35	protected final void onSave(Set<PackagePart> alreadySaved) throws IOException {\n        //if part is already committed then return\n        if (this.isCommited) {\n            return;\n        }\n\n        // this usually clears out previous content in the part...\n        prepareForCommit();\n\n        commit();\n        alreadySaved.add(this.getPackagePart());\n        for (RelationPart rp : relations.values()) {\n            POIXMLDocumentPart p = rp.getDocumentPart();\n            if (!alreadySaved.contains(p.getPackagePart())) {\n                p.onSave(alreadySaved);\n            }\n        }\n    }
36	public int getIndentationHanging() {\n        CTInd indentation = getCTInd(false);\n        return (indentation != null && indentation.isSetHanging()) ? indentation.getHanging().intValue() : -1;\n    }
37	/* package */ static I_MatchPredicate createCriteriaPredicate(ValueEval arg, int srcRowIndex, int srcColumnIndex) {\n\n        ValueEval evaluatedCriteriaArg = evaluateCriteriaArg(arg, srcRowIndex, srcColumnIndex);\n\n        if(evaluatedCriteriaArg instanceof NumberEval) {\n            return new NumberMatcher(((NumberEval)evaluatedCriteriaArg).getNumberValue(), CmpOp.OP_NONE);\n        }\n        if(evaluatedCriteriaArg instanceof BoolEval) {\n            return new BooleanMatcher(((BoolEval)evaluatedCriteriaArg).getBooleanValue(), CmpOp.OP_NONE);\n        }\n\n        if(evaluatedCriteriaArg instanceof StringEval) {\n            return createGeneralMatchPredicate((StringEval)evaluatedCriteriaArg);\n        }\n        if(evaluatedCriteriaArg instanceof ErrorEval) {\n            return new ErrorMatcher(((ErrorEval)evaluatedCriteriaArg).getErrorCode(), CmpOp.OP_NONE);\n        }\n        if(evaluatedCriteriaArg == BlankEval.instance) {\n            return null;\n        }\n        throw new RuntimeException("Unexpected type for criteria ("\n                + evaluatedCriteriaArg.getClass().getName() + ")");\n    }
38	public int getPropertySize() {\n        return 6;\n    }
39	public int getFcPlcfbkl()\n    {\n        return _fieldHandler.getFieldOffset( FIBFieldHandler.PLCFBKL );\n    }
40	public void setGuardState(boolean guardState) {\n        this.guardState = guardState;\n    }
41	public TextSegment searchText(String searched, PositionInParagraph startPos) {\n        int startRun = startPos.getRun(),\n            startText = startPos.getText(),\n            startChar = startPos.getChar();\n        int beginRunPos = 0, candCharPos = 0;\n        boolean newList = false;\n        \n        CTR[] rArray = paragraph.getRArray();\n        for (int runPos = startRun; runPos < rArray.length; runPos++) {\n            int beginTextPos = 0, beginCharPos = 0, textPos = 0, charPos = 0;\n            CTR ctRun = rArray[runPos];\n            XmlCursor c = ctRun.newCursor();\n            c.selectPath("./*");\n            try {\n                while (c.toNextSelection()) {\n                    XmlObject o = c.getObject();\n                    if (o instanceof CTText) {\n                        if (textPos >= startText) {\n                            String candidate = ((CTText) o).getStringValue();\n                            if (runPos == startRun) {\n                                charPos = startChar;\n                            } else {\n                                charPos = 0;\n                            }\n    \n                            for (; charPos < candidate.length(); charPos++) {\n                                if ((candidate.charAt(charPos) == searched.charAt(0)) && (candCharPos == 0)) {\n                                    beginTextPos = textPos;\n                                    beginCharPos = charPos;\n                                    beginRunPos = runPos;\n                                    newList = true;\n                                }\n                                if (candidate.charAt(charPos) == searched.charAt(candCharPos)) {\n                                    if (candCharPos + 1 < searched.length()) {\n                                        candCharPos++;\n                                    } else if (newList) {\n                                        TextSegment segment = new TextSegment();\n                                        segment.setBeginRun(beginRunPos);\n                                        segment.setBeginText(beginTextPos);\n                                        segment.setBeginChar(beginCharPos);\n                                        segment.setEndRun(runPos);\n                                        segment.setEndText(textPos);\n                                        segment.setEndChar(charPos);\n                                        return segment;\n                                    }\n                                } else {\n                                    candCharPos = 0;\n                                }\n                            }\n                        }\n                        textPos++;\n                    } else if (o instanceof CTProofErr) {\n                        c.removeXml();\n                    } else if (o instanceof CTRPr) {\n                        //do nothing\n                    } else {\n                        candCharPos = 0;\n                    }\n                }\n            } finally {\n                c.dispose();\n            }\n        }\n        return null;\n    }
42	private static String normalizePartName(URI partName, String baseUri) throws XMLSignatureException {\n        String pn = partName.toASCIIString();\n        if (!pn.startsWith(baseUri)) {\n            pn = baseUri + pn;\n        }\n        try {\n            pn = new URI(pn).normalize().getPath().replace('\\', '/');\n            LOG.log(POILogger.DEBUG, "part name: " + pn);\n        } catch (URISyntaxException e) {\n            throw new XMLSignatureException(e);\n        }\n        return pn;\n    }
43	protected ByteBuffer getBlockAt(final int offset) {\n       // Which big block is this?\n       int byteOffset = offset * POIFSConstants.SMALL_BLOCK_SIZE;\n       int bigBlockNumber = byteOffset / _filesystem.getBigBlockSize();\n       int bigBlockOffset = byteOffset % _filesystem.getBigBlockSize();\n       \n       // Now locate the data block for it\n       Iterator<ByteBuffer> it = _mini_stream.getBlockIterator();\n       for(int i=0; i<bigBlockNumber; i++) {\n          it.next();\n       }\n       ByteBuffer dataBlock = it.next();\n       if(dataBlock == null) {\n          throw new IndexOutOfBoundsException("Big block " + bigBlockNumber + " outside stream");\n       }\n\n       // Position ourselves, and take a slice \n       dataBlock.position(\n             dataBlock.position() + bigBlockOffset\n       );\n       ByteBuffer miniBuffer = dataBlock.slice();\n       miniBuffer.limit(POIFSConstants.SMALL_BLOCK_SIZE);\n       return miniBuffer;\n    }
44	public String toXml(String tab) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(tab).append("<").append(getRecordName()).append(">\n");\n        for (EscherRecord escherRecord : getEscherRecords()) {\n            builder.append(escherRecord.toXml(tab + "\t"));\n        }\n        builder.append(tab).append("</").append(getRecordName()).append(">\n");\n        return builder.toString();\n    }
45	public DirectoryEntry createDirectory(final String name)\n        throws IOException\n    {\n        return getRoot().createDirectory(name);\n    }
46	private void write(POIFSFileSystem fs) throws IOException {\n        // For tracking what we've written out, used if we're\n        //  going to be preserving nodes\n        List<String> excepts = new ArrayList<>(1);\n\n        // Write out the Workbook stream\n        fs.createDocument(new ByteArrayInputStream(getBytes()), "Workbook");\n\n        // Write out our HPFS properties, if we have them\n        writeProperties(fs, excepts);\n        \n        if (preserveNodes) {\n            // Don't write out the old Workbook, we'll be doing our new one\n            // If the file had an "incorrect" name for the workbook stream,\n            // don't write the old one as we'll use the correct name shortly\n            excepts.addAll(Arrays.asList(WORKBOOK_DIR_ENTRY_NAMES));\n\n            // summary information has been already written via writeProperties and might go in a\n            // different stream, if the file is cryptoapi encrypted\n            excepts.addAll(Arrays.asList(\n                DocumentSummaryInformation.DEFAULT_STREAM_NAME,\n                SummaryInformation.DEFAULT_STREAM_NAME,\n                getEncryptedPropertyStreamName()\n            ));\n\n            // Copy over all the other nodes to our new poifs\n            EntryUtils.copyNodes(\n                    new FilteringDirectoryNode(getDirectory(), excepts)\n                    , new FilteringDirectoryNode(fs.getRoot(), excepts)\n                    );\n\n            // YK: preserve StorageClsid, it is important for embedded workbooks,\n            // see Bugzilla 47920\n            fs.getRoot().setStorageClsid(getDirectory().getStorageClsid());\n        }\n    }
47	public int getKeySize() {\n        return keyBits;\n    }
48	public void dump(Writer outWriter) throws IOException {\n        this.out = outWriter;\n\n        int padding = 0;\n        write(out, "<Presentation>" + CR, padding);\n        padding++;\n        if (pictstream != null){\n            write(out, "<Pictures>" + CR, padding);\n            dumpPictures(pictstream, padding);\n            write(out, "</Pictures>" + CR, padding);\n        }\n        //dump the structure of the powerpoint document\n        write(out, "<PowerPointDocument>" + CR, padding);\n        padding++;\n        dump(docstream, 0, docstream.length, padding);\n        padding--;\n        write(out, "</PowerPointDocument>" + CR, padding);\n        padding--;\n        write(out, "</Presentation>", padding);\n    }
49	public boolean areFieldsStripped() {\n		return stripFields;\n	}
50	private CellCacheEntry[] getSensitiveInputCells() {\n		int nItems = _sensitiveInputCells.size();\n		if (nItems < 1) {\n			return CellCacheEntry.EMPTY_ARRAY;\n		}\n		CellCacheEntry[] result = new CellCacheEntry[nItems];\n		_sensitiveInputCells.toArray(result);\n		return result;\n	}
51	private static GridsetRecord createGridset() {\n        GridsetRecord retval = new GridsetRecord();\n\n        retval.setGridset(true);\n        return retval;\n    }
52	protected void writeNodeData(DirectoryEntry directory, List<PropertyValue> values) throws IOException {\n        for (PropertyValue value : values) {\n            byte[] bytes = value.getRawValue();\n            String nodeName = VARIABLE_LENGTH_PROPERTY_PREFIX + getFileName(value.getProperty(), value.getActualType());\n            directory.createDocument(nodeName, new ByteArrayInputStream(bytes));\n        }\n    }
53	public void manufactureStrings( int stringCount, RecordInputStream in )\n    {\n      for (int i=0;i<stringCount;i++) {\n         // Extract exactly the count of strings from the SST record.\n         UnicodeString str;\n         if(in.available() == 0 && ! in.hasNextRecord()) {\n        	 logger.log( POILogger.ERROR, "Ran out of data before creating all the strings! String at index " + i + "");\n            str = new UnicodeString("");\n         } else {\n            str = new UnicodeString(in);\n         }\n         addToStringTable( strings, str );\n      }\n    }
54	public void shiftRowBreaks(int startingRow, int endingRow, int count) {\n        shiftBreaks(getRowBreaksRecord(), startingRow, endingRow, count);\n    }
55	public boolean equals(Object o)\n    {\n        if (!(o instanceof UnicodeString)) {\n            return false;\n        }\n        UnicodeString other = (UnicodeString) o;\n\n        //OK lets do this in stages to return a quickly, first check the actual string\n        if (field_1_charCount != other.field_1_charCount\n            || field_2_optionflags != other.field_2_optionflags\n            || !field_3_string.equals(other.field_3_string)) {\n            return false;\n        }\n\n        //OK string appears to be equal but now lets compare formatting runs\n        if (field_4_format_runs == null) {\n            // Strings are equal, and there are not formatting runs.\n            return (other.field_4_format_runs == null);\n        } else if (other.field_4_format_runs == null) {\n            // Strings are equal, but one or the other has formatting runs\n            return false;\n        }\n\n        //Strings are equal, so now compare formatting runs.\n        int size = field_4_format_runs.size();\n        if (size != other.field_4_format_runs.size()) {\n          return false;\n        }\n\n        for (int i=0;i<size;i++) {\n          FormatRun run1 = field_4_format_runs.get(i);\n          FormatRun run2 = other.field_4_format_runs.get(i);\n\n          if (!run1.equals(run2)) {\n            return false;\n          }\n        }\n\n        // Well the format runs are equal as well!, better check the ExtRst data\n        if (field_5_ext_rst == null) {\n            return (other.field_5_ext_rst == null);\n        } else if (other.field_5_ext_rst == null) {\n            return false;\n        }\n            \n       return field_5_ext_rst.equals(other.field_5_ext_rst);\n    }
56	public static Cipher getCipher(SecretKey key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode) {\n        return getCipher(key, cipherAlgorithm, chain, vec, cipherMode, null);\n    }
57	public X509Certificate getSigner() {\n        // The first certificate is presumably the signer.\n        return certChain.isEmpty() ? null : certChain.get(0);\n    }
58	public static boolean isLogUnsupportedTypes() {\n        return logUnsupportedTypes;\n    }
59	boolean getPropertyBooleanValue(final int id) throws NoSingleSectionException {\n        return getFirstSection().getPropertyBooleanValue(id);\n    }
60	UnicodeString getUnicodeString() {\n      return cloneStringIfRequired();\n    }
61	private ParseNode  Term() {\n        ParseNode result = powerFactor();\n        while(true) {\n            SkipWhite();\n            Ptg operator;\n            switch(look) {\n                case '*':\n                    Match('*');\n                    operator = MultiplyPtg.instance;\n                    break;\n                case '/':\n                    Match('/');\n                    operator = DividePtg.instance;\n                    break;\n                default:\n                    return result; // finished with Term\n            }\n            ParseNode other = powerFactor();\n            result = new ParseNode(operator, result, other);\n        }\n    }
62	void free() throws IOException {\n       _stream.free();\n       _property.setStartBlock(POIFSConstants.END_OF_CHAIN);\n   }
63	public void createDrawingGroup() {\n        if (drawingManager == null) {\n            EscherContainerRecord dggContainer = new EscherContainerRecord();\n            EscherDggRecord dgg = new EscherDggRecord();\n            EscherOptRecord opt = new EscherOptRecord();\n            EscherSplitMenuColorsRecord splitMenuColors = new EscherSplitMenuColorsRecord();\n\n            dggContainer.setRecordId((short) 0xF000);\n            dggContainer.setOptions((short) 0x000F);\n            dgg.setRecordId(EscherDggRecord.RECORD_ID);\n            dgg.setOptions((short)0x0000);\n            dgg.setShapeIdMax(1024);\n            dgg.setNumShapesSaved(0);\n            dgg.setDrawingsSaved(0);\n            dgg.setFileIdClusters(new EscherDggRecord.FileIdCluster[] {} );\n            drawingManager = new DrawingManager2(dgg);\n            EscherContainerRecord bstoreContainer = null;\n            if (!escherBSERecords.isEmpty())\n            {\n                bstoreContainer = new EscherContainerRecord();\n                bstoreContainer.setRecordId( EscherContainerRecord.BSTORE_CONTAINER );\n                bstoreContainer.setOptions( (short) ( (escherBSERecords.size() << 4) | 0xF ) );\n                for (EscherRecord escherRecord : escherBSERecords) {\n                    bstoreContainer.addChildRecord( escherRecord );\n                }\n            }\n            opt.setRecordId((short) 0xF00B);\n            opt.setOptions((short) 0x0033);\n            opt.addEscherProperty( new EscherBoolProperty(EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE, 524296) );\n            opt.addEscherProperty( new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, 0x08000041) );\n            opt.addEscherProperty( new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, 134217792) );\n            splitMenuColors.setRecordId((short) 0xF11E);\n            splitMenuColors.setOptions((short) 0x0040);\n            splitMenuColors.setColor1(0x0800000D);\n            splitMenuColors.setColor2(0x0800000C);\n            splitMenuColors.setColor3(0x08000017);\n            splitMenuColors.setColor4(0x100000F7);\n\n            dggContainer.addChildRecord(dgg);\n            if (bstoreContainer != null) {\n                dggContainer.addChildRecord( bstoreContainer );\n            }\n            dggContainer.addChildRecord(opt);\n            dggContainer.addChildRecord(splitMenuColors);\n\n            int dgLoc = findFirstRecordLocBySid(DrawingGroupRecord.sid);\n            if (dgLoc == -1) {\n                DrawingGroupRecord drawingGroup = new DrawingGroupRecord();\n                drawingGroup.addEscherRecord(dggContainer);\n                int loc = findFirstRecordLocBySid(CountryRecord.sid);\n\n                getRecords().add(loc+1, drawingGroup);\n            } else {\n                DrawingGroupRecord drawingGroup = new DrawingGroupRecord();\n                drawingGroup.addEscherRecord(dggContainer);\n                getRecords().set(dgLoc, drawingGroup);\n            }\n\n        }\n    }
64	public void evaluateAll() {\n        // Have the evaluation done, with exceptions\n        evaluateAllFormulaCells(wb, false);\n    }
65	public static boolean copyStream(InputStream inStream, OutputStream outStream) {\n		try {\n			byte[] buffer = new byte[1024];\n			int bytesRead;\n			while ((bytesRead = inStream.read(buffer)) >= 0) {\n				outStream.write(buffer, 0, bytesRead);\n			}\n		} catch (Exception e) {\n			return false;\n		}\n		return true;\n	}
66	public String getText() {\n       String text;\n       try {\n           TextListener tl = triggerExtraction();\n\n           text = tl._text.toString();\n           if(! text.endsWith("\n")) {\n               text = text + "\n";\n           }\n       } catch(IOException e) {\n           throw new RuntimeException(e);\n       }\n\n       return text;\n   }
67	public static byte[] createXorArray1(String password) {\n        if (password.length() > 15) {\n            password = password.substring(0, 15);\n        }\n        byte passBytes[] = password.getBytes(Charset.forName("ASCII"));\n        \n        // this code is based on the libre office implementation.\n        // The MS-OFFCRYPTO misses some infos about the various rotation sizes \n        byte obfuscationArray[] = new byte[16];\n        System.arraycopy(passBytes, 0, obfuscationArray, 0, passBytes.length);\n        System.arraycopy(PAD_ARRAY, 0, obfuscationArray, passBytes.length, PAD_ARRAY.length-passBytes.length+1);\n        \n        int xorKey = createXorKey1(password);\n        \n        // rotation of key values is application dependent - Excel = 2 / Word = 7 \n        int nRotateSize = 2;\n        \n        byte baseKeyLE[] = { (byte)(xorKey & 0xFF), (byte)((xorKey >>> 8) & 0xFF) };\n        for (int i=0; i<obfuscationArray.length; i++) {\n            obfuscationArray[i] ^= baseKeyLE[i&1];\n            obfuscationArray[i] = rotateLeft(obfuscationArray[i], nRotateSize);\n        }\n        \n        return obfuscationArray;\n    }
68	public int getOurBlockIndex() {\n       return ourBlockIndex;\n    }
69	public static boolean isCellInternalDateFormatted(Cell cell) {\n        if (cell == null) return false;\n        boolean bDate = false;\n\n        double d = cell.getNumericCellValue();\n        if ( DateUtil.isValidExcelDate(d) ) {\n            CellStyle style = cell.getCellStyle();\n            int i = style.getDataFormat();\n            bDate = isInternalDateFormat(i);\n        }\n        return bDate;\n    }
70	@SuppressWarnings("WeakerAccess")\n    public int getShade(){\n        return getPercentageValue("shade");\n    }
71	public static String stripFields( String text )\n    {\n        return Range.stripFields( text );\n    }
72	private static StringBuilder buildInitSB(byte[] text, PieceDescriptor pd) {\n        if (StringUtil.BIG5.equals(pd.getCharset())) {\n            return new StringBuilder(CodePageUtil.cp950ToString(text, 0, text.length));\n        }\n\n        String str = new String(text, 0, text.length, (pd.isUnicode()) ? StringUtil.UTF16LE : pd.getCharset());\n        return new StringBuilder(str);\n    }
73	static void unCompressPAPOperation (ParagraphProperties newPAP, SprmOperation sprm)\n  {\n    switch (sprm.getOperation())\n    {\n      case 0:\n        newPAP.setIstd (sprm.getOperand());\n        break;\n      case 0x1:\n\n        // Used only for piece table grpprl's not for PAPX\n//        int istdFirst = LittleEndian.getShort (varParam, 2);\n//        int istdLast = LittleEndian.getShort (varParam, 4);\n//        if ((newPAP.getIstd () > istdFirst) || (newPAP.getIstd () <= istdLast))\n//        {\n//          permuteIstd (newPAP, varParam, opSize);\n//        }\n        break;\n      case 0x2:\n        if (newPAP.getIstd () <= 9 || newPAP.getIstd () >= 1)\n        {\n          byte paramTmp = (byte) sprm.getOperand();\n          newPAP.setIstd (newPAP.getIstd () + paramTmp);\n          newPAP.setLvl ((byte) (newPAP.getLvl () + paramTmp));\n\n          if (((paramTmp >> 7) & 0x01) == 1)\n          {\n            newPAP.setIstd (Math.max (newPAP.getIstd (), 1));\n          }\n          else\n          {\n            newPAP.setIstd (Math.min (newPAP.getIstd (), 9));\n          }\n\n        }\n        break;\n      case 0x3:\n        // Physical justification of the paragraph\n        newPAP.setJc ((byte) sprm.getOperand());\n        break;\n      case 0x4:\n        newPAP.setFSideBySide (sprm.getOperand() != 0);\n        break;\n      case 0x5:\n        newPAP.setFKeep (sprm.getOperand() != 0);\n        break;\n      case 0x6:\n        newPAP.setFKeepFollow (sprm.getOperand() != 0);\n        break;\n      case 0x7:\n        newPAP.setFPageBreakBefore (sprm.getOperand() != 0);\n        break;\n      case 0x8:\n        newPAP.setBrcl ((byte) sprm.getOperand());\n        break;\n      case 0x9:\n        newPAP.setBrcp ((byte) sprm.getOperand());\n        break;\n      case 0xa:\n        newPAP.setIlvl ((byte) sprm.getOperand());\n        break;\n        case 0xb:\n            /* sprmPIlfo -- 0x460B */\n            newPAP.setIlfo( sprm.getOperandShortSigned() );\n            break;\n      case 0xc:\n        newPAP.setFNoLnn (sprm.getOperand() != 0);\n        break;\n      case 0xd:\n        /**handle tabs . variable parameter. seperate processing needed*/\n        handleTabs(newPAP, sprm);\n        break;\n      case 0xe:\n        newPAP.setDxaRight (sprm.getOperand());\n        break;\n      case 0xf:\n        newPAP.setDxaLeft (sprm.getOperand());\n        break;\n      case 0x10:\n\n        // sprmPNest is only stored in grpprls linked to a piece table.\n        newPAP.setDxaLeft (newPAP.getDxaLeft () + sprm.getOperand());\n        newPAP.setDxaLeft (Math.max (0, newPAP.getDxaLeft ()));\n        break;\n      case 0x11:\n        newPAP.setDxaLeft1 (sprm.getOperand());\n        break;\n      case 0x12:\n        newPAP.setLspd(new LineSpacingDescriptor(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x13:\n        newPAP.setDyaBefore (sprm.getOperand());\n        break;\n      case 0x14:\n        newPAP.setDyaAfter (sprm.getOperand());\n        break;\n      case 0x15:\n        // fast saved only\n        //applySprmPChgTabs (newPAP, varParam, opSize);\n        break;\n        case 0x16:\n            // sprmPFInTable -- 0x2416\n            newPAP.setFInTable( sprm.getOperand()  != 0);\n            break;\n      case 0x17:\n        newPAP.setFTtp ( sprm.getOperand() != 0);\n        break;\n      case 0x18:\n        newPAP.setDxaAbs (sprm.getOperand());\n        break;\n      case 0x19:\n        newPAP.setDyaAbs (sprm.getOperand());\n        break;\n      case 0x1a:\n        newPAP.setDxaWidth (sprm.getOperand());\n        break;\n      case 0x1b:\n        byte param = (byte)sprm.getOperand();\n        /** @todo handle paragraph postioning*/\n        byte pcVert = (byte) ((param & 0x0c) >> 2);\n        byte pcHorz = (byte) (param & 0x03);\n        if (pcVert != 3)\n        {\n          newPAP.setPcVert (pcVert);\n        }\n        if (pcHorz != 3)\n        {\n          newPAP.setPcHorz (pcHorz);\n        }\n        break;\n\n        // BrcXXX1 is older Version. Brc is used\n        // case 0x1c:\n        // newPAP.setBrcTop1((short)param);\n        // break;\n        // case 0x1d:\n        // newPAP.setBrcLeft1((short)param);\n        // break;\n        // case 0x1e:\n        // newPAP.setBrcBottom1((short)param);\n        // break;\n        // case 0x1f:\n        // newPAP.setBrcRight1((short)param);\n        // break;\n        // case 0x20:\n        // newPAP.setBrcBetween1((short)param);\n        // break;\n        // case 0x21:\n        // newPAP.setBrcBar1((byte)param);\n        // break;\n\n      case 0x22:\n        newPAP.setDxaFromText (sprm.getOperand());\n        break;\n      case 0x23:\n        newPAP.setWr((byte)sprm.getOperand());\n        break;\n      case 0x24:\n        newPAP.setBrcTop(new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x25:\n        newPAP.setBrcLeft(new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x26:\n        newPAP.setBrcBottom (new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x27:\n        newPAP.setBrcRight (new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x28:\n        newPAP.setBrcBetween (new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x29:\n        newPAP.setBrcBar (new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x2a:\n        newPAP.setFNoAutoHyph (sprm.getOperand() != 0);\n        break;\n      case 0x2b:\n        newPAP.setDyaHeight (sprm.getOperand());\n        break;\n      case 0x2c:\n        newPAP.setDcs (new DropCapSpecifier((short)sprm.getOperand()));\n        break;\n        case 0x2d:\n            newPAP.setShd( new ShadingDescriptor80( (short) sprm.getOperand() )\n                    .toShadingDescriptor() );\n            break;\n      case 0x2e:\n        newPAP.setDyaFromText (sprm.getOperand());\n        break;\n      case 0x2f:\n        newPAP.setDxaFromText (sprm.getOperand());\n        break;\n      case 0x30:\n        newPAP.setFLocked (sprm.getOperand() != 0);\n        break;\n      case 0x31:\n        newPAP.setFWidowControl (sprm.getOperand() != 0);\n        break;\n      case 0x33:\n        newPAP.setFKinsoku (sprm.getOperand() != 0);\n        break;\n      case 0x34:\n        newPAP.setFWordWrap (sprm.getOperand() != 0);\n        break;\n      case 0x35:\n        newPAP.setFOverflowPunct (sprm.getOperand() != 0);\n        break;\n      case 0x36:\n        newPAP.setFTopLinePunct (sprm.getOperand() != 0);\n        break;\n      case 0x37:\n        newPAP.setFAutoSpaceDE (sprm.getOperand() != 0);\n        break;\n      case 0x38:\n        newPAP.setFAutoSpaceDN (sprm.getOperand() != 0);\n        break;\n      case 0x39:\n        newPAP.setWAlignFont (sprm.getOperand());\n        break;\n      case 0x3a:\n        newPAP.setFontAlign ((short) sprm.getOperand());\n        break;\n      case 0x3b:\n        //obsolete\n        break;\n      case 0x3e:\n      {\n        byte[] buf = new byte[sprm.size() - 3];\n        System.arraycopy(buf, 0, sprm.getGrpprl(), sprm.getGrpprlOffset(),\n                         buf.length);\n        newPAP.setAnld(buf);\n        break;\n      }\n      case 0x3f:\n        //don't really need this. spec is confusing regarding this\n        //sprm\n          byte[] varParam = sprm.getGrpprl();\n          int offset = sprm.getGrpprlOffset();\n          newPAP.setFPropRMark (varParam[offset]  != 0 );\n          newPAP.setIbstPropRMark (LittleEndian.getShort (varParam, offset + 1));\n          newPAP.setDttmPropRMark (new DateAndTime(varParam, offset + 3));\n        break;\n      case 0x40:\n        // This condition commented out, as Word seems to set outline levels even for \n        //  paragraph with other styles than Heading 1..9, even though specification \n        //  does not say so. See bug 49820 for discussion.\n        //if (newPAP.getIstd () < 1 && newPAP.getIstd () > 9)\n        {\n          newPAP.setLvl ((byte) sprm.getOperand());\n        }\n        break;\n      case 0x41:\n        // sprmPFBiDi \n        newPAP.setFBiDi(sprm.getOperand() != 0);\n        break;\n      case 0x43:\n\n        //pap.fNumRMIns\n        newPAP.setFNumRMIns (sprm.getOperand() != 0);\n        break;\n      case 0x44:\n\n        //undocumented\n        break;\n      case 0x45:\n        if (sprm.getSizeCode() == 6)\n        {\n          byte[] buf = new byte[sprm.size() - 3];\n          System.arraycopy(buf, 0, sprm.getGrpprl(), sprm.getGrpprlOffset(), buf.length);\n          newPAP.setNumrm (buf);\n        }\n        else\n        {\n          /**@todo handle large PAPX from data stream*/\n        }\n        break;\n\n      case 0x47:\n        newPAP.setFUsePgsuSettings (sprm.getOperand() != 0);\n        break;\n      case 0x48:\n        newPAP.setFAdjustRight (sprm.getOperand() != 0);\n        break;\n        case 0x49:\n            // sprmPItap -- 0x6649\n            newPAP.setItap( sprm.getOperand() );\n            break;\n        case 0x4a:\n            // sprmPDtap -- 0x664a\n            newPAP.setItap( (byte) ( newPAP.getItap() + sprm.getOperand() ) );\n            break;\n        case 0x4b:\n            // sprmPFInnerTableCell -- 0x244b\n            newPAP.setFInnerTableCell( sprm.getOperand()  != 0);\n            break;\n        case 0x4c:\n            // sprmPFInnerTtp -- 0x244c\n            newPAP.setFTtpEmbedded( sprm.getOperand()  != 0);\n            break;\n        case 0x4d:\n            // sprmPShd -- 0xc64d\n            ShadingDescriptor shadingDescriptor = new ShadingDescriptor(\n                    sprm.getGrpprl(), 3 );\n            newPAP.setShading( shadingDescriptor );\n            break;\n        case 0x5d:\n            // sprmPDxaRight -- 0x845d\n            newPAP.setDxaRight( sprm.getOperand() );\n            break;\n        case 0x5e:\n            // sprmPDxaLeft -- 0x845e\n            newPAP.setDxaLeft( sprm.getOperand() );\n            break;\n        case 0x60:\n            // sprmPDxaLeft1 -- 0x8460\n            newPAP.setDxaLeft1( sprm.getOperand() );\n            break;\n      case 0x61:\n        // sprmPJc \n        newPAP.setJustificationLogical((byte) sprm.getOperand());\n        break;\n      case 0x67:\n          // sprmPRsid -- 0x6467 \n          newPAP.setRsid( sprm.getOperand() );\n          break;\n        default:\n            logger.log( POILogger.DEBUG, "Unknown PAP sprm ignored: " + sprm );\n            break;\n        }\n  }
74	private void addModified() {\n        setElementTextContent(KEYWORD_MODIFIED, namespaceDcTerms, propsPart.getModifiedProperty(),\n                propsPart.getModifiedPropertyString(), "dcterms:W3CDTF");\n    }
75	public static String toExternalString(String rawText, int runType) {\n        // PowerPoint seems to store files with \r as the line break\n        // The messes things up on everything but a Mac, so translate\n        // them to \n\n        String text = rawText.replace('\r', '\n');\n\n        switch (runType) {\n        // 0xB acts like cariage return in page titles and like blank in the\n        // others\n        case -1:\n        case org.apache.poi.hslf.record.TextHeaderAtom.TITLE_TYPE:\n        case org.apache.poi.hslf.record.TextHeaderAtom.CENTER_TITLE_TYPE:\n            text = text.replace((char) 0x0B, '\n');\n            break;\n        default:\n            text = text.replace((char) 0x0B, ' ');\n            break;\n        }\n\n        return text;\n    }
76	private boolean processRecord(Record record) {\n		if (!isSidIncluded(record.getSid())) {\n			return true;\n		}\n		return _listener.processRecord(record);\n	}
77	protected void readProperties() {\n        if (initialized) {\n            return;\n        }\n        DocumentSummaryInformation dsi = readPropertySet(DocumentSummaryInformation.class, DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n        if (dsi != null) {\n            dsInf = dsi;\n        }\n        SummaryInformation si = readPropertySet(SummaryInformation.class, SummaryInformation.DEFAULT_STREAM_NAME);\n        if (si != null) {\n            sInf = si;\n        }\n\n        // Mark the fact that we've now loaded up the properties\n        initialized = true;\n    }
78	public boolean isError() {\n		return _isError;\n	}
79	public static String getLocaleFromLCID(int lcid) {\n        int languageId = lcid & 0xFFFF;\n        switch (languageId) {\n        case 0x0001: return "ar";\n        case 0x0002: return "bg";\n        case 0x0003: return "ca";\n        case 0x0004: return "zh-Hans";\n        case 0x0005: return "cs";\n        case 0x0006: return "da";\n        case 0x0007: return "de";\n        case 0x0008: return "el";\n        case 0x0009: return "en";\n        case 0x000a: return "es";\n        case 0x000b: return "fi";\n        case 0x000c: return "fr";\n        case 0x000d: return "he";\n        case 0x000e: return "hu";\n        case 0x000f: return "is";\n        case 0x0010: return "it";\n        case 0x0011: return "ja";\n        case 0x0012: return "ko";\n        case 0x0013: return "nl";\n        case 0x0014: return "no";\n        case 0x0015: return "pl";\n        case 0x0016: return "pt";\n        case 0x0017: return "rm";\n        case 0x0018: return "ro";\n        case 0x0019: return "ru";\n        case 0x001a: return "bs, hr, or sr";\n        case 0x001b: return "sk";\n        case 0x001c: return "sq";\n        case 0x001d: return "sv";\n        case 0x001e: return "th";\n        case 0x001f: return "tr";\n        case 0x0020: return "ur";\n        case 0x0021: return "id";\n        case 0x0022: return "uk";\n        case 0x0023: return "be";\n        case 0x0024: return "sl";\n        case 0x0025: return "et";\n        case 0x0026: return "lv";\n        case 0x0027: return "lt";\n        case 0x0028: return "tg";\n        case 0x0029: return "fa";\n        case 0x002a: return "vi";\n        case 0x002b: return "hy";\n        case 0x002c: return "az";\n        case 0x002d: return "eu";\n        case 0x002e: return "dsb or hsb";\n        case 0x002f: return "mk";\n        case 0x0030: return "st"; // reserved\n        case 0x0031: return "ts"; // reserved\n        case 0x0032: return "tn";\n        case 0x0033: return "ve"; // reserved\n        case 0x0034: return "xh";\n        case 0x0035: return "zu";\n        case 0x0036: return "af";\n        case 0x0037: return "ka";\n        case 0x0038: return "fo";\n        case 0x0039: return "hi";\n        case 0x003a: return "mt";\n        case 0x003b: return "se";\n        case 0x003c: return "ga";\n        case 0x003d: return "yi"; // reserved\n        case 0x003e: return "ms";\n        case 0x003f: return "kk";\n        case 0x0040: return "ky";\n        case 0x0041: return "sw";\n        case 0x0042: return "tk";\n        case 0x0043: return "uz";\n        case 0x0044: return "tt";\n        case 0x0045: return "bn";\n        case 0x0046: return "pa";\n        case 0x0047: return "gu";\n        case 0x0048: return "or";\n        case 0x0049: return "ta";\n        case 0x004a: return "te";\n        case 0x004b: return "kn";\n        case 0x004c: return "ml";\n        case 0x004d: return "as";\n        case 0x004e: return "mr";\n        case 0x004f: return "sa";\n        case 0x0050: return "mn";\n        case 0x0051: return "bo";\n        case 0x0052: return "cy";\n        case 0x0053: return "km";\n        case 0x0054: return "lo";\n        case 0x0055: return "my"; // reserved\n        case 0x0056: return "gl";\n        case 0x0057: return "kok";\n        case 0x0058: return "mni"; // reserved\n        case 0x0059: return "sd";\n        case 0x005a: return "syr";\n        case 0x005b: return "si";\n        case 0x005c: return "chr";\n        case 0x005d: return "iu";\n        case 0x005e: return "am";\n        case 0x005f: return "tzm";\n        case 0x0060: return "ks"; // reserved\n        case 0x0061: return "ne";\n        case 0x0062: return "fy";\n        case 0x0063: return "ps";\n        case 0x0064: return "fil";\n        case 0x0065: return "dv";\n        case 0x0066: return "bin"; // reserved\n        case 0x0067: return "ff";\n        case 0x0068: return "ha";\n        case 0x0069: return "ibb"; // reserved\n        case 0x006a: return "yo";\n        case 0x006b: return "quz";\n        case 0x006c: return "nso";\n        case 0x006d: return "ba";\n        case 0x006e: return "lb";\n        case 0x006f: return "kl";\n        case 0x0070: return "ig";\n        case 0x0071: return "kr"; // reserved\n        case 0x0072: return "om"; // reserved\n        case 0x0073: return "ti";\n        case 0x0074: return "gn"; // reserved\n        case 0x0075: return "haw";\n        case 0x0076: return "la"; // reserved\n        case 0x0077: return "so"; // reserved\n        case 0x0078: return "ii";\n        case 0x0079: return "pap"; // reserved\n        case 0x007a: return "arn";\n        case 0x007b: return "invalid"; // Neither defined nor reserved\n        case 0x007c: return "moh";\n        case 0x007d: return "invalid"; // Neither defined nor reserved\n        case 0x007e: return "br";\n        case 0x007f: return "invalid"; // Reserved or invariant locale behavior\n        case 0x0080: return "ug";\n        case 0x0081: return "mi";\n        case 0x0082: return "oc";\n        case 0x0083: return "co";\n        case 0x0084: return "gsw";\n        case 0x0085: return "sah";\n        case 0x0086: return "qut";\n        case 0x0087: return "rw";\n        case 0x0088: return "wo";\n        case 0x0089: return "invalid"; // Neither defined nor reserved\n        case 0x008a: return "invalid"; // Neither defined nor reserved\n        case 0x008b: return "invalid"; // Neither defined nor reserved\n        case 0x008c: return "prs";\n        case 0x008d: return "invalid"; // Neither defined nor reserved\n        case 0x008e: return "invalid"; // Neither defined nor reserved\n        case 0x008f: return "invalid"; // Neither defined nor reserved\n        case 0x0090: return "invalid"; // Neither defined nor reserved\n        case 0x0091: return "gd";\n        case 0x0092: return "ku";\n        case 0x0093: return "quc"; // reserved\n        case 0x0401: return "ar-SA";\n        case 0x0402: return "bg-BG";\n        case 0x0403: return "ca-ES";\n        case 0x0404: return "zh-TW";\n        case 0x0405: return "cs-CZ";\n        case 0x0406: return "da-DK";\n        case 0x0407: return "de-DE";\n        case 0x0408: return "el-GR";\n        case 0x0409: return "en-US";\n        case 0x040a: return "es-ES_tradnl";\n        case 0x040b: return "fi-FI";\n        case 0x040c: return "fr-FR";\n        case 0x040d: return "he-IL";\n        case 0x040e: return "hu-HU";\n        case 0x040f: return "is-IS";\n        case 0x0410: return "it-IT";\n        case 0x0411: return "ja-JP";\n        case 0x0412: return "ko-KR";\n        case 0x0413: return "nl-NL";\n        case 0x0414: return "nb-NO";\n        case 0x0415: return "pl-PL";\n        case 0x0416: return "pt-BR";\n        case 0x0417: return "rm-CH";\n        case 0x0418: return "ro-RO";\n        case 0x0419: return "ru-RU";\n        case 0x041a: return "hr-HR";\n        case 0x041b: return "sk-SK";\n        case 0x041c: return "sq-AL";\n        case 0x041d: return "sv-SE";\n        case 0x041e: return "th-TH";\n        case 0x041f: return "tr-TR";\n        case 0x0420: return "ur-PK";\n        case 0x0421: return "id-ID";\n        case 0x0422: return "uk-UA";\n        case 0x0423: return "be-BY";\n        case 0x0424: return "sl-SI";\n        case 0x0425: return "et-EE";\n        case 0x0426: return "lv-LV";\n        case 0x0427: return "lt-LT";\n        case 0x0428: return "tg-Cyrl-TJ";\n        case 0x0429: return "fa-IR";\n        case 0x042a: return "vi-VN";\n        case 0x042b: return "hy-AM";\n        case 0x042c: return "az-Latn-AZ";\n        case 0x042d: return "eu-ES";\n        case 0x042e: return "hsb-DE";\n        case 0x042f: return "mk-MK";\n        case 0x0430: return "st-ZA"; // reserved\n        case 0x0431: return "ts-ZA"; // reserved\n        case 0x0432: return "tn-ZA";\n        case 0x0433: return "ve-ZA"; // reserved\n        case 0x0434: return "xh-ZA";\n        case 0x0435: return "zu-ZA";\n        case 0x0436: return "af-ZA";\n        case 0x0437: return "ka-GE";\n        case 0x0438: return "fo-FO";\n        case 0x0439: return "hi-IN";\n        case 0x043a: return "mt-MT";\n        case 0x043b: return "se-NO";\n        case 0x043d: return "yi-Hebr"; // reserved\n        case 0x043e: return "ms-MY";\n        case 0x043f: return "kk-KZ";\n        case 0x0440: return "ky-KG";\n        case 0x0441: return "sw-KE";\n        case 0x0442: return "tk-TM";\n        case 0x0443: return "uz-Latn-UZ";\n        case 0x0444: return "tt-RU";\n        case 0x0445: return "bn-IN";\n        case 0x0446: return "pa-IN";\n        case 0x0447: return "gu-IN";\n        case 0x0448: return "or-IN";\n        case 0x0449: return "ta-IN";\n        case 0x044a: return "te-IN";\n        case 0x044b: return "kn-IN";\n        case 0x044c: return "ml-IN";\n        case 0x044d: return "as-IN";\n        case 0x044e: return "mr-IN";\n        case 0x044f: return "sa-IN";\n        case 0x0450: return "mn-MN";\n        case 0x0451: return "bo-CN";\n        case 0x0452: return "cy-GB";\n        case 0x0453: return "km-KH";\n        case 0x0454: return "lo-LA";\n        case 0x0455: return "my-MM"; // reserved\n        case 0x0456: return "gl-ES";\n        case 0x0457: return "kok-IN";\n        case 0x0458: return "mni-IN"; // reserved\n        case 0x0459: return "sd-Deva-IN"; // reserved\n        case 0x045a: return "syr-SY";\n        case 0x045b: return "si-LK";\n        case 0x045c: return "chr-Cher-US";\n        case 0x045d: return "iu-Cans-CA";\n        case 0x045e: return "am-ET";\n        case 0x045f: return "tzm-Arab-MA"; // reserved\n        case 0x0460: return "ks-Arab"; // reserved\n        case 0x0461: return "ne-NP";\n        case 0x0462: return "fy-NL";\n        case 0x0463: return "ps-AF";\n        case 0x0464: return "fil-PH";\n        case 0x0465: return "dv-MV";\n        case 0x0466: return "bin-NG"; // reserved\n        case 0x0467: return "fuv-NG"; // reserved\n        case 0x0468: return "ha-Latn-NG";\n        case 0x0469: return "ibb-NG"; // reserved\n        case 0x046a: return "yo-NG";\n        case 0x046b: return "quz-BO";\n        case 0x046c: return "nso-ZA";\n        case 0x046d: return "ba-RU";\n        case 0x046e: return "lb-LU";\n        case 0x046f: return "kl-GL";\n        case 0x0470: return "ig-NG";\n        case 0x0471: return "kr-NG"; // reserved\n        case 0x0472: return "om-Ethi-ET"; // reserved\n        case 0x0473: return "ti-ET";\n        case 0x0474: return "gn-PY"; // reserved\n        case 0x0475: return "haw-US";\n        case 0x0476: return "la-Latn"; // reserved\n        case 0x0477: return "so-SO"; // reserved\n        case 0x0478: return "ii-CN";\n        case 0x0479: return "pap-x029"; // reserved\n        case 0x047a: return "arn-CL";\n        case 0x047c: return "moh-CA";\n        case 0x047e: return "br-FR";\n        case 0x0480: return "ug-CN";\n        case 0x0481: return "mi-NZ";\n        case 0x0482: return "oc-FR";\n        case 0x0483: return "co-FR";\n        case 0x0484: return "gsw-FR";\n        case 0x0485: return "sah-RU";\n        case 0x0486: return "qut-GT";\n        case 0x0487: return "rw-RW";\n        case 0x0488: return "wo-SN";\n        case 0x048c: return "prs-AF";\n        case 0x048d: return "plt-MG"; // reserved\n        case 0x048e: return "zh-yue-HK"; // reserved\n        case 0x048f: return "tdd-Tale-CN"; // reserved\n        case 0x0490: return "khb-Talu-CN"; // reserved\n        case 0x0491: return "gd-GB";\n        case 0x0492: return "ku-Arab-IQ";\n        case 0x0493: return "quc-CO"; // reserved\n        case 0x0501: return "qps-ploc";\n        case 0x05fe: return "qps-ploca";\n        case 0x0801: return "ar-IQ";\n        case 0x0803: return "ca-ES-valencia";\n        case 0x0804: return "zh-CN";\n        case 0x0807: return "de-CH";\n        case 0x0809: return "en-GB";\n        case 0x080a: return "es-MX";\n        case 0x080c: return "fr-BE";\n        case 0x0810: return "it-CH";\n        case 0x0811: return "ja-Ploc-JP"; // reserved\n        case 0x0813: return "nl-BE";\n        case 0x0814: return "nn-NO";\n        case 0x0816: return "pt-PT";\n        case 0x0818: return "ro-MO"; // reserved\n        case 0x0819: return "ru-MO"; // reserved\n        case 0x081a: return "sr-Latn-CS";\n        case 0x081d: return "sv-FI";\n        case 0x0820: return "ur-IN"; // reserved\n        case 0x0827: return "invalid"; // Neither defined nor reserved\n        case 0x082c: return "az-Cyrl-AZ";\n        case 0x082e: return "dsb-DE";\n        case 0x0832: return "tn-BW";\n        case 0x083b: return "se-SE";\n        case 0x083c: return "ga-IE";\n        case 0x083e: return "ms-BN";\n        case 0x0843: return "uz-Cyrl-UZ";\n        case 0x0845: return "bn-BD";\n        case 0x0846: return "pa-Arab-PK";\n        case 0x0849: return "ta-LK";\n        case 0x0850: return "mn-Mong-CN";\n        case 0x0851: return "bo-BT"; // reserved\n        case 0x0859: return "sd-Arab-PK";\n        case 0x085d: return "iu-Latn-CA";\n        case 0x085f: return "tzm-Latn-DZ";\n        case 0x0860: return "ks-Deva"; // reserved\n        case 0x0861: return "ne-IN"; // reserved\n        case 0x0867: return "ff-Latn-SN";\n        case 0x086b: return "quz-EC";\n        case 0x0873: return "ti-ER";\n        case 0x09ff: return "qps-plocm";\n        case 0x0c01: return "ar-EG";\n        case 0x0c04: return "zh-HK";\n        case 0x0c07: return "de-AT";\n        case 0x0c09: return "en-AU";\n        case 0x0c0a: return "es-ES";\n        case 0x0c0c: return "fr-CA";\n        case 0x0c1a: return "sr-Cyrl-CS";\n        case 0x0c3b: return "se-FI";\n        case 0x0c5f: return "tmz-MA"; // reserved\n        case 0x0c6b: return "quz-PE";\n        case 0x1001: return "ar-LY";\n        case 0x1004: return "zh-SG";\n        case 0x1007: return "de-LU";\n        case 0x1009: return "en-CA";\n        case 0x100a: return "es-GT";\n        case 0x100c: return "fr-CH";\n        case 0x101a: return "hr-BA";\n        case 0x103b: return "smj-NO";\n        case 0x1401: return "ar-DZ";\n        case 0x1404: return "zh-MO";\n        case 0x1407: return "de-LI";\n        case 0x1409: return "en-NZ";\n        case 0x140a: return "es-CR";\n        case 0x140c: return "fr-LU";\n        case 0x141a: return "bs-Latn-BA";\n        case 0x143b: return "smj-SE";\n        case 0x1801: return "ar-MA";\n        case 0x1809: return "en-IE";\n        case 0x180a: return "es-PA";\n        case 0x180c: return "fr-MC";\n        case 0x181a: return "sr-Latn-BA";\n        case 0x183b: return "sma-NO";\n        case 0x1c01: return "ar-TN";\n        case 0x1c09: return "en-ZA";\n        case 0x1c0a: return "es-DO";\n        case 0x1c0c: return "invalid"; // Neither defined nor reserved\n        case 0x1c1a: return "sr-Cyrl-BA";\n        case 0x1c3b: return "sma-SE";\n        case 0x2001: return "ar-OM";\n        case 0x2008: return "invalid"; // Neither defined nor reserved\n        case 0x2009: return "en-JM";\n        case 0x200a: return "es-VE";\n        case 0x200c: return "fr-RE"; // reserved\n        case 0x201a: return "bs-Cyrl-BA";\n        case 0x203b: return "sms-FI";\n        case 0x2401: return "ar-YE";\n        case 0x2409: return "en-029";\n        case 0x240a: return "es-CO";\n        case 0x240c: return "fr-CG"; // reserved\n        case 0x241a: return "sr-Latn-RS";\n        case 0x243b: return "smn-FI";\n        case 0x2801: return "ar-SY";\n        case 0x2809: return "en-BZ";\n        case 0x280a: return "es-PE";\n        case 0x280c: return "fr-SN"; // reserved\n        case 0x281a: return "sr-Cyrl-RS";\n        case 0x2c01: return "ar-JO";\n        case 0x2c09: return "en-TT";\n        case 0x2c0a: return "es-AR";\n        case 0x2c0c: return "fr-CM"; // reserved\n        case 0x2c1a: return "sr-Latn-ME";\n        case 0x3001: return "ar-LB";\n        case 0x3009: return "en-ZW";\n        case 0x300a: return "es-EC";\n        case 0x300c: return "fr-CI"; // reserved\n        case 0x301a: return "sr-Cyrl-ME";\n        case 0x3401: return "ar-KW";\n        case 0x3409: return "en-PH";\n        case 0x340a: return "es-CL";\n        case 0x340c: return "fr-ML"; // reserved\n        case 0x3801: return "ar-AE";\n        case 0x3809: return "en-ID"; // reserved\n        case 0x380a: return "es-UY";\n        case 0x380c: return "fr-MA"; // reserved\n        case 0x3c01: return "ar-BH";\n        case 0x3c09: return "en-HK"; // reserved\n        case 0x3c0a: return "es-PY";\n        case 0x3c0c: return "fr-HT"; // reserved\n        case 0x4001: return "ar-QA";\n        case 0x4009: return "en-IN";\n        case 0x400a: return "es-BO";\n        case 0x4401: return "ar-Ploc-SA"; // reserved\n        case 0x4409: return "en-MY";\n        case 0x440a: return "es-SV";\n        case 0x4801: return "ar-145"; // reserved\n        case 0x4809: return "en-SG";\n        case 0x480a: return "es-HN";\n        case 0x4c09: return "en-AE"; // reserved\n        case 0x4c0a: return "es-NI";\n        case 0x5009: return "en-BH"; // reserved\n        case 0x500a: return "es-PR";\n        case 0x5409: return "en-EG"; // reserved\n        case 0x540a: return "es-US";\n        case 0x5809: return "en-JO"; // reserved\n        case 0x5c09: return "en-KW"; // reserved\n        case 0x6009: return "en-TR"; // reserved\n        case 0x6409: return "en-YE"; // reserved\n        case 0x641a: return "bs-Cyrl";\n        case 0x681a: return "bs-Latn";\n        case 0x6c1a: return "sr-Cyrl";\n        case 0x701a: return "sr-Latn";\n        case 0x703b: return "smn";\n        case 0x742c: return "az-Cyrl";\n        case 0x743b: return "sms";\n        case 0x7804: return "zh";\n        case 0x7814: return "nn";\n        case 0x781a: return "bs";\n        case 0x782c: return "az-Latn";\n        case 0x783b: return "sma";\n        case 0x7843: return "uz-Cyrl";\n        case 0x7850: return "mn-Cyrl";\n        case 0x785d: return "iu-Cans";\n        case 0x7c04: return "zh-Hant";\n        case 0x7c14: return "nb";\n        case 0x7c1a: return "sr";\n        case 0x7c28: return "tg-Cyrl";\n        case 0x7c2e: return "dsb";\n        case 0x7c3b: return "smj";\n        case 0x7c43: return "uz-Latn";\n        case 0x7c46: return "pa-Arab";\n        case 0x7c50: return "mn-Mong";\n        case 0x7c59: return "sd-Arab";\n        case 0x7c5c: return "chr-Cher";\n        case 0x7c5d: return "iu-Latn";\n        case 0x7c5f: return "tzm-Latn";\n        case 0x7c67: return "ff-Latn";\n        case 0x7c68: return "ha-Latn";\n        case 0x7c92: return "ku-Arab";\n        default: return "invalid";\n        }\n    }
80	public void insertSST() {\n        LOG.log(DEBUG, "creating new SST via insertSST!");\n\n        sst = new SSTRecord();\n        records.add(records.size() - 1, createExtendedSST());\n        records.add(records.size() - 2, sst);\n    }
81	public boolean isFLastRow()\n    {\n        return fLastRow.isSet( field_2_tlp_flags );\n\n    }
82	private int drawDashDotDot(Graphics g,int x, int y, int thickness,\n                              boolean horizontal,\n                              boolean rightBottom) {\n\n      for (int t=0; t < thickness; t++) {\n         if (!rightBottom) {\n            t = 0 - t; //add negative thickness so we go the other way\n                       //then we'll decrement instead of increment.\n         }\n         if (horizontal) {\n            g.drawLine(x,y+t,x+5,y+t);\n            g.drawLine(x+8,y+t,x+10,y+t);\n            g.drawLine(x+13,y+t,x+15,y+t);\n         } else {\n            g.drawLine(x+t,y,x+t,y+5);\n            g.drawLine(x+t,y+8,x+t,y+10);\n            g.drawLine(x+t,y+13,x+t,y+15);\n         }\n      }\n      return 18;\n   }
83	public String format(Object value) {\n        StringBuffer sb = new StringBuffer();\n        formatValue(sb, value);\n        return sb.toString();\n    }
84	private static CellType determineType(CellValueRecordInterface cval) {\n        if (cval instanceof FormulaRecordAggregate) {\n            return CellType.FORMULA;\n        }\n        // all others are plain BIFF records\n        Record record = ( Record ) cval;\n        switch (record.getSid()) {\n\n            case NumberRecord.sid :   return CellType.NUMERIC;\n            case BlankRecord.sid :    return CellType.BLANK;\n            case LabelSSTRecord.sid : return CellType.STRING;\n            case BoolErrRecord.sid :\n                BoolErrRecord boolErrRecord = ( BoolErrRecord ) record;\n\n                return boolErrRecord.isBoolean()\n                         ? CellType.BOOLEAN\n                         : CellType.ERROR;\n        }\n        throw new RuntimeException("Bad cell value rec (" + cval.getClass().getName() + ")");\n    }
85	public static long copy(InputStream inp, OutputStream out) throws IOException {\n        final byte[] buff = new byte[4096];\n        long totalCount = 0;\n        for (int count; (count = inp.read(buff)) != -1; totalCount += count) {\n            if (count > 0) {\n                out.write(buff, 0, count);\n            }\n        }\n        return totalCount;\n    }
86	protected void initAll() {\n		initCharacterRuns();\n		initParagraphs();\n		initSections();\n	}
87	public void clear() {\n        for (Property p : getProperties()) {\n            removeProperty(p.getID());\n        }\n    }
88	int getLinkOptions(){\n        return _linkOpts;\n    }
89	public Record[] getChildRecords() { return null; }
90	private static IterationRecord createIteration() {\n        return new IterationRecord(false);\n    }
91	public int getPageCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_PAGECOUNT);\n    }
92	private void addCell(HSSFCell cell) {\n\n        int column=cell.getColumnIndex();\n        // re-allocate cells array as required.\n        if(column>=cells.length) {\n            HSSFCell[] oldCells=cells;\n            // New size based on the same logic as ArrayList\n            int newSize=oldCells.length*3/2+1;\n            if(newSize<column+1) {\n                newSize=column+INITIAL_CAPACITY;\n            }\n            cells=new HSSFCell[newSize];\n            System.arraycopy(oldCells,0,cells,0,oldCells.length);\n        }\n        cells[column]=cell;\n\n        // fix up firstCol and lastCol indexes\n        if (row.isEmpty() || column < row.getFirstCol()) {\n            row.setFirstCol((short)column);\n        }\n\n        if (row.isEmpty() || column >= row.getLastCol()) {\n            row.setLastCol((short) (column+1)); // +1 -> for one past the last index\n        }\n    }
93	public void addSlidePersistAtom(SlidePersistAtom spa) {\n		// Add the new SlidePersistAtom at the end\n		appendChildRecord(spa);\n\n		SlideAtomsSet newSAS = new SlideAtomsSet(spa, new Record[0]);\n\n		// Update our SlideAtomsSets with this\n		SlideAtomsSet[] sas = new SlideAtomsSet[slideAtomsSets.length+1];\n		System.arraycopy(slideAtomsSets, 0, sas, 0, slideAtomsSets.length);\n		sas[sas.length-1] = newSAS;\n		slideAtomsSets = sas;\n	}
94	public static TwoDEval resolveTableArrayArg(ValueEval eval) throws EvaluationException {\n		if (eval instanceof TwoDEval) {\n			return (TwoDEval) eval;\n		}\n\n		if(eval instanceof RefEval) {\n			RefEval refEval = (RefEval) eval;\n			// Make this cell ref look like a 1x1 area ref.\n\n			// It doesn't matter if eval is a 2D or 3D ref, because that detail is never asked of AreaEval.\n			return refEval.offset(0, 0, 0, 0);\n		}\n		throw EvaluationException.invalidValue();\n	}
95	public void writeData(OutputStream stream)\n        throws IOException\n    {\n        stream.write(_raw_data);\n    }
96	public void removeContentStatus() {\n        remove1stProperty(PropertyIDMap.PID_CONTENTSTATUS);\n    }
97	public void setOutsideBorders(Object... args){\n        if (args.length == 0) return;\n\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = new BorderEdge[4];\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[0] = (col == 0) ? BorderEdge.left : null;\n                edges[1] = (col == cols - 1) ? BorderEdge.right : null;\n                edges[2] = (row == 0) ? BorderEdge.top : null;\n                edges[3] = (row == rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
98	public static synchronized XMLReader newXMLReader() throws SAXException, ParserConfigurationException {\n        XMLReader xmlReader = saxFactory.newSAXParser().getXMLReader();\n        xmlReader.setEntityResolver(IGNORING_ENTITY_RESOLVER);\n        trySetSAXFeature(xmlReader, XMLConstants.FEATURE_SECURE_PROCESSING);\n        trySetXercesSecurityManager(xmlReader);\n        return xmlReader;\n    }
99	public static byte[] getByteArray( byte[] data, int offset, int size )\n    {\n        byte[] copy = new byte[size];\n        System.arraycopy( data, offset, copy, 0, size );\n\n        return copy;\n    }
100	public static void copyNodes(POIFSFileSystem source, POIFSFileSystem target, List<String> excepts )\n    throws IOException {\n        copyNodes(\n              new FilteringDirectoryNode(source.getRoot(), excepts),\n              new FilteringDirectoryNode(target.getRoot(), excepts)\n        );\n    }
101	public void clearAllCachedResultValues() {\n        _cache.clear();\n        _sheetIndexesBySheet.clear();\n        _workbook.clearAllCachedResultValues();\n    }
102	public static String xorHashPassword(String password) {\n        int hashedPassword = createXorVerifier2(password);\n        return String.format(Locale.ROOT, "%1$08X", hashedPassword);\n    }
103	public void replaceText(String pPlaceHolder, String pValue) {\n		while (true) {\n			String text = text();\n			int offset = text.indexOf(pPlaceHolder);\n			if (offset >= 0) {\n				replaceText(pPlaceHolder, pValue, offset);\n			} else {\n				break;\n			}\n		}\n	}
104	private void adjustForInsert(int length) {\n		_end += length;\n\n		reset();\n		Range parent = _parent.get();\n		if (parent != null) {\n			parent.adjustForInsert(length);\n		}\n	}
105	public void preSerialize(){\n        // Ensure we have enough tab IDs\n        // Can be a few short if new sheets were added\n        if(records.getTabpos() > 0) {\n            TabIdRecord tir = ( TabIdRecord ) records.get(records.getTabpos());\n            if(tir._tabids.length < boundsheets.size()) {\n                fixTabIdRecord();\n            }\n        }\n    }
106	public Path2D.Double getBoundsAsPath() {\n\n        Double w = getWidth();\n        Double h = getHeight();\n\n        Path2D.Double bounds = new Path2D.Double();\n        bounds.moveTo(0, 0);\n        bounds.lineTo(w, 0);\n        bounds.lineTo(w, h);\n        bounds.lineTo(0, h);\n        bounds.lineTo(0, 0);\n\n        return bounds;\n    }
107	public int serialize(int offset, byte[] data) {\n        // Determine buffer size\n        List <EscherRecord>records = getEscherRecords();\n        int size = getEscherRecordSize(records);\n        byte[] buffer = new byte[size];\n\n        // Serialize escher records into one big data structure and keep note of ending offsets.\n        final List <Integer>spEndingOffsets = new ArrayList<>();\n        final List <EscherRecord> shapes = new ArrayList<>();\n        int pos = 0;\n        for (Object record : records) {\n            EscherRecord e = (EscherRecord) record;\n            pos += e.serialize(pos, buffer, new EscherSerializationListener() {\n                public void beforeRecordSerialize(int offset, short recordId, EscherRecord record) {\n                }\n\n                public void afterRecordSerialize(int offset, short recordId, int size, EscherRecord record) {\n                    if (recordId == EscherClientDataRecord.RECORD_ID || recordId == EscherTextboxRecord.RECORD_ID) {\n                        spEndingOffsets.add(offset);\n                        shapes.add(record);\n                    }\n                }\n            });\n        }\n        shapes.add(0, null);\n        spEndingOffsets.add(0, 0);\n\n        // Split escher records into separate MSODRAWING and OBJ, TXO records.  (We don't break on\n        // the first one because it's the patriach).\n        pos = offset;\n        int writtenEscherBytes = 0;\n        int i;\n        for (i = 1; i < shapes.size(); i++) {\n            int endOffset = spEndingOffsets.get(i) - 1;\n            int startOffset;\n            if (i == 1)\n                startOffset = 0;\n            else\n                startOffset = spEndingOffsets.get(i - 1);\n\n            byte[] drawingData = new byte[endOffset - startOffset + 1];\n            System.arraycopy(buffer, startOffset, drawingData, 0, drawingData.length);\n            pos += writeDataIntoDrawingRecord(drawingData, writtenEscherBytes, pos, data, i);\n\n            writtenEscherBytes += drawingData.length;\n\n            // Write the matching OBJ record\n            Record obj = shapeToObj.get(shapes.get(i));\n            pos += obj.serialize(pos, data);\n\n            if (i == shapes.size() - 1 && endOffset < buffer.length - 1) {\n                drawingData = new byte[buffer.length - endOffset - 1];\n                System.arraycopy(buffer, endOffset + 1, drawingData, 0, drawingData.length);\n                pos += writeDataIntoDrawingRecord(drawingData, writtenEscherBytes, pos, data, i);\n            }\n        }\n        if ((pos - offset) < buffer.length - 1) {\n            byte[] drawingData = new byte[buffer.length - (pos - offset)];\n            System.arraycopy(buffer, (pos - offset), drawingData, 0, drawingData.length);\n            pos += writeDataIntoDrawingRecord(drawingData, writtenEscherBytes, pos, data, i);\n        }\n\n        for (NoteRecord noteRecord : tailRec.values()) {\n            pos += noteRecord.serialize(pos, data);\n        }\n        int bytesWritten = pos - offset;\n        if (bytesWritten != getRecordSize())\n            throw new RecordFormatException(bytesWritten + " bytes written but getRecordSize() reports " + getRecordSize());\n        return bytesWritten;\n    }
108	public void parseSheet(Map<String, XSSFSheet> shIdMap, CTSheet ctSheet) {\n        XSSFSheet sh = shIdMap.get(ctSheet.getId());\n        if(sh == null) {\n            logger.log(POILogger.WARN, "Sheet with name " + ctSheet.getName() + " and r:id " + ctSheet.getId()+ " was defined, but didn't exist in package, skipping");\n            return;\n        }\n        sh.sheet = ctSheet;\n        sh.onDocumentRead();\n        sheets.add(sh);\n    }
109	public static OPCPackage openPackage(String path) throws IOException {\n        try {\n            return OPCPackage.open(path);\n        } catch (InvalidFormatException e) {\n            throw new IOException(e.toString(), e);\n        }\n    }
110	public void setCbMac( int cbMac )\n    {\n        _fibRgLw.setCbMac( cbMac );\n    }
111	public Observable getLocaleChangedObservable() {\n        return localeChangedObservable;\n    }
112	private void isCellFontSizeMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        short size1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getFontHeightInPoints();\n        short size2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getFontHeightInPoints();\n        if (size1 != size2) {\n            addMessage(loc1, loc2,\n                "Cell Font Size does not Match ::",\n                Short.toString(size1),\n                Short.toString(size2)\n            );\n        }\n    }
113	public void setMainSpRecordId(int shapeId) {\n        EscherContainerRecord dgContainer = getEscherContainer();\n        EscherContainerRecord spgrConatiner = dgContainer.getChildById(EscherContainerRecord.SPGR_CONTAINER);\n        EscherContainerRecord spContainer = (EscherContainerRecord) spgrConatiner.getChild(0);\n        EscherSpRecord sp = spContainer.getChildById(EscherSpRecord.RECORD_ID);\n        sp.setShapeId(shapeId);\n    }
114	protected void addRun(CTR run) {\n        int pos;\n        pos = paragraph.sizeOfRArray();\n        paragraph.addNewR();\n        paragraph.setRArray(pos, run);\n    }
115	@Internal\n    public boolean isFVertMerge()\n    {\n        return fVertMerge.isSet(field_1_rgf);\n    }
116	public void addTab() {\n        run.addNewTab();\n    }
117	protected int getUIndex() {\n        return this._cellXfId;\n    }
118	public void setDisplayName(String name) {\n        ctTable.setDisplayName(name);\n    }
119	private void parseContentTypesFile(InputStream in)\n            throws InvalidFormatException {\n        try {\n            Document xmlContentTypetDoc = DocumentHelper.readDocument(in);\n\n            // Default content types\n            NodeList defaultTypes = xmlContentTypetDoc.getDocumentElement().getElementsByTagNameNS(TYPES_NAMESPACE_URI, DEFAULT_TAG_NAME);\n            int defaultTypeCount = defaultTypes.getLength();\n            for (int i = 0; i < defaultTypeCount; i++) {\n                Element element = (Element) defaultTypes.item(i);\n                String extension = element.getAttribute(EXTENSION_ATTRIBUTE_NAME);\n                String contentType = element.getAttribute(CONTENT_TYPE_ATTRIBUTE_NAME);\n                addDefaultContentType(extension, contentType);\n            }\n\n            // Overriden content types\n            NodeList overrideTypes = xmlContentTypetDoc.getDocumentElement().getElementsByTagNameNS(TYPES_NAMESPACE_URI, OVERRIDE_TAG_NAME);\n            int overrideTypeCount = overrideTypes.getLength();\n            for (int i = 0; i < overrideTypeCount; i++) {\n                Element element = (Element) overrideTypes.item(i);\n                URI uri = new URI(element.getAttribute(PART_NAME_ATTRIBUTE_NAME));\n                PackagePartName partName = PackagingURIHelper.createPartName(uri);\n                String contentType = element.getAttribute(CONTENT_TYPE_ATTRIBUTE_NAME);\n                addOverrideContentType(partName, contentType);\n            }\n        } catch (URISyntaxException | IOException | SAXException e) {\n            throw new InvalidFormatException(e.getMessage());\n        }\n    }
120	public void untrackAllColumnsForAutoSizing()\n    {\n        _autoSizeColumnTracker.untrackAllColumns();\n    }
121	private static CTDrawing newDrawing(){\n        return CTDrawing.Factory.newInstance();\n    }
122	public void setMovieIndex(int idx){\n        ExObjRefAtom oe = getClientDataRecord(RecordTypes.ExObjRefAtom.typeID);\n        oe.setExObjIdRef(idx);\n\n        AnimationInfo an = getClientDataRecord(RecordTypes.AnimationInfo.typeID);\n        if(an != null) {\n            AnimationInfoAtom ai = an.getAnimationInfoAtom();\n            ai.setDimColor(0x07000000);\n            ai.setFlag(AnimationInfoAtom.Automatic, true);\n            ai.setFlag(AnimationInfoAtom.Play, true);\n            ai.setFlag(AnimationInfoAtom.Synchronous, true);\n            ai.setOrderID(idx + 1);\n        }\n    }
123	@SuppressWarnings({"unchecked", "WeakerAccess"})\n    protected <T extends XmlObject> T selectProperty(Class<T> resultClass, String xquery) {\n        XmlObject[] rs = getXmlObject().selectPath(xquery);\n        if (rs.length == 0) return null;\n        return (resultClass.isInstance(rs[0])) ? (T)rs[0] : null;\n    }
124	public static double fixedPointToDouble(int fixedPoint) {\n        int i = (fixedPoint >> 16);\n        int f = fixedPoint & 0xFFFF;\n        return (i + f/65536d);\n    }
125	public static PropertySet create(final InputStream stream)\n    throws NoPropertySetStreamException, MarkUnsupportedException, UnsupportedEncodingException, IOException {\n        stream.mark(PropertySet.OFFSET_HEADER+ClassID.LENGTH+1);\n        LittleEndianInputStream leis = new LittleEndianInputStream(stream);\n        int byteOrder =  leis.readUShort();\n        int format = leis.readUShort();\n        /*int osVersion = (int)*/leis.readUInt();\n        byte[] clsIdBuf = new byte[ClassID.LENGTH];\n        leis.readFully(clsIdBuf);\n        int sectionCount = (int)leis.readUInt();\n        \n        if (byteOrder != PropertySet.BYTE_ORDER_ASSERTION ||\n            format != PropertySet.FORMAT_ASSERTION ||\n            sectionCount < 0) {\n            throw new NoPropertySetStreamException();\n        }\n        \n        if (sectionCount > 0) {\n            leis.readFully(clsIdBuf);\n        }\n        stream.reset();\n        \n        ClassID clsId = new ClassID(clsIdBuf, 0);\n        if (sectionCount > 0 && PropertySet.matchesSummary(clsId, SummaryInformation.FORMAT_ID)) {\n            return new SummaryInformation(stream);\n        } else if (sectionCount > 0 && PropertySet.matchesSummary(clsId, DocumentSummaryInformation.FORMAT_ID)) {\n            return new DocumentSummaryInformation(stream);\n        } else {\n            return new PropertySet(stream);\n        }\n    }
126	public int getBackgroundColourRGB() { return backgroundColourRGB; }
127	public static double getCellWidth(Cell cell, int defaultCharWidth, DataFormatter formatter, boolean useMergedCells) {\n        Sheet sheet = cell.getSheet();\n        Workbook wb = sheet.getWorkbook();\n        Row row = cell.getRow();\n        int column = cell.getColumnIndex();\n\n        // FIXME: this looks very similar to getCellWithMerges below. Consider consolidating.\n        // We should only be checking merged regions if useMergedCells is true. Why are we doing this for-loop?\n        int colspan = 1;\n        for (CellRangeAddress region : sheet.getMergedRegions()) {\n            if (region.isInRange(row.getRowNum(), column)) {\n                if (!useMergedCells) {\n                    // If we're not using merged cells, skip this one and move on to the next.\n                    return -1;\n                }\n                cell = row.getCell(region.getFirstColumn());\n                colspan = 1 + region.getLastColumn() - region.getFirstColumn();\n            }\n        }\n\n        CellStyle style = cell.getCellStyle();\n        CellType cellType = cell.getCellType();\n\n        // for formula cells we compute the cell width for the cached formula result\n        if (cellType == CellType.FORMULA)\n            cellType = cell.getCachedFormulaResultType();\n\n        Font font = wb.getFontAt(style.getFontIndexAsInt());\n\n        double width = -1;\n        if (cellType == CellType.STRING) {\n            RichTextString rt = cell.getRichStringCellValue();\n            String[] lines = rt.getString().split("\\n");\n            for (String line : lines) {\n                String txt = line + defaultChar;\n\n                AttributedString str = new AttributedString(txt);\n                copyAttributes(font, str, 0, txt.length());\n\n                /*if (rt.numFormattingRuns() > 0) {\n                    // TODO: support rich text fragments\n                }*/\n\n                width = getCellWidth(defaultCharWidth, colspan, style, width, str);\n            }\n        } else {\n            String sval = null;\n            if (cellType == CellType.NUMERIC) {\n                // Try to get it formatted to look the same as excel\n                try {\n                    sval = formatter.formatCellValue(cell, dummyEvaluator);\n                } catch (Exception e) {\n                    sval = String.valueOf(cell.getNumericCellValue());\n                }\n            } else if (cellType == CellType.BOOLEAN) {\n                sval = String.valueOf(cell.getBooleanCellValue()).toUpperCase(Locale.ROOT);\n            }\n            if(sval != null) {\n                String txt = sval + defaultChar;\n                AttributedString str = new AttributedString(txt);\n                copyAttributes(font, str, 0, txt.length());\n\n                width = getCellWidth(defaultCharWidth, colspan, style, width, str);\n            }\n        }\n        return width;\n    }
128	private static boolean shouldCountFeb29(SimpleDate start, SimpleDate end) {\n		if (isLeapYear(start.year)) {\n	        if (start.year == end.year) {\n	            // note - dates may not actually span Feb-29, but it gets counted anyway in this case\n	            return true;\n	        }\n\n	        switch (start.month) {\n				case SimpleDate.JANUARY:\n				case SimpleDate.FEBRUARY:\n					return true;\n			}\n			return false;\n		}\n		\n		if (isLeapYear(end.year)) {\n			switch (end.month) {\n				case SimpleDate.JANUARY:\n					return false;\n				case SimpleDate.FEBRUARY:\n					break;\n				default:\n					return true;\n			}\n			return end.day == LONG_FEB_LEN;\n		}\n		return false;\n	}
129	@Internal\n    public byte getPcHorz()\n    {\n        return ( byte )pcHorz.getValue(field_13_widthAndFitsFlags);\n    }
130	public HSSFIconMultiStateFormatting createMultiStateFormatting() {\n        return getMultiStateFormatting(true);\n    }
131	public short getIx() {\n	   return field_2_ixals;\n	}
132	@Internal\n    public boolean isFFitText()\n    {\n        return fFitText.isSet(field_1_grpfChp);\n    }
133	public DOMSignContext createXMLSignContext(final Document document) {\n        return new DOMSignContext(signatureConfig.getKey(), document);\n    }
134	private String dumpBytes(byte[] data, int offset, int len) {\n		StringBuffer ret = new StringBuffer();\n		for(int i=0; i<len; i++) {\n			int j = i + offset;\n			int b = data[j];\n			if(b < 0) { b += 256; }\n\n			String bs = Integer.toHexString(b);\n			if(bs.length() == 1)\n				ret.append('0');\n			ret.append(bs);\n			ret.append(' ');\n		}\n		return ret.toString();\n	}
135	@Internal\n    public byte getILvl()\n    {\n        return ( byte )iLvl.getValue(field_2_flags);\n    }
136	public void preSerialize() {\n        for (RecordBase r: getRecords()) {\n            if (r instanceof EscherAggregate) {\n                // Trigger flattening of user model and corresponding update of dgg record.\n                r.getRecordSize();\n            }\n        }\n    }
137	public void setDateValue(String cellName, Date date) {\n        Cell cell = getCell(cellName);\n        cell.setCellValue(date);\n    }
138	private static CountryRecord createCountry() {\n        CountryRecord retval = new CountryRecord();\n\n        retval.setDefaultCountry(( short ) 1);\n\n        // from Russia with love ;)\n        if ( "ru_RU".equals( LocaleUtil.getUserLocale().toString() ) ) {\n            retval.setCurrentCountry(( short ) 7);\n        } else {\n            retval.setCurrentCountry(( short ) 1);\n        }\n\n        return retval;\n    }
139	private void checkForEmptyCellComments(EmptyCellCommentsCheckType type) {\n       if (commentCellRefs != null && !commentCellRefs.isEmpty()) {\n           // If we've reached the end of the sheet data, output any\n           //  comments we haven't yet already handled\n           if (type == EmptyCellCommentsCheckType.END_OF_SHEET_DATA) {\n               while (!commentCellRefs.isEmpty()) {\n                   outputEmptyCellComment(commentCellRefs.remove());\n               }\n               return;\n           }\n\n           // At the end of a row, handle any comments for "missing" rows before us\n           if (this.cellRef == null) {\n               if (type == EmptyCellCommentsCheckType.END_OF_ROW) {\n                   while (!commentCellRefs.isEmpty()) {\n                       if (commentCellRefs.peek().getRow() == rowNum) {\n                           outputEmptyCellComment(commentCellRefs.remove());\n                       } else {\n                           return;\n                       }\n                   }\n                   return;\n               } else {\n                   throw new IllegalStateException("Cell ref should be null only if there are only empty cells in the row; rowNum: " + rowNum);\n               }\n           }\n\n           CellAddress nextCommentCellRef;\n           do {\n               CellAddress cellRef = new CellAddress(this.cellRef);\n               CellAddress peekCellRef = commentCellRefs.peek();\n               if (type == EmptyCellCommentsCheckType.CELL && cellRef.equals(peekCellRef)) {\n                   // remove the comment cell ref from the list if we're about to handle it alongside the cell content\n                   commentCellRefs.remove();\n                   return;\n               } else {\n                   // fill in any gaps if there are empty cells with comment mixed in with non-empty cells\n                   int comparison = peekCellRef.compareTo(cellRef);\n                   if (comparison > 0 && type == EmptyCellCommentsCheckType.END_OF_ROW && peekCellRef.getRow() <= rowNum) {\n                       nextCommentCellRef = commentCellRefs.remove();\n                       outputEmptyCellComment(nextCommentCellRef);\n                   } else if (comparison < 0 && type == EmptyCellCommentsCheckType.CELL && peekCellRef.getRow() <= rowNum) {\n                       nextCommentCellRef = commentCellRefs.remove();\n                       outputEmptyCellComment(nextCommentCellRef);\n                   } else {\n                       nextCommentCellRef = null;\n                   }\n               }\n           } while (nextCommentCellRef != null && !commentCellRefs.isEmpty());\n       }\n   }
140	public void read(final InputStream stream) throws IOException {\n        try (POIFSFileSystem poifs = new POIFSFileSystem(stream)) {\n            read(poifs);\n        }\n    }
141	/*package*/ ValueEval evaluateNameFormula(Ptg[] ptgs, OperationEvaluationContext ec) {\n    if (ptgs.length == 1) {\n      return getEvalForPtg(ptgs[0], ec);\n    }\n      return evaluateFormula(ec, ptgs);\n    }
142	public void formatValue(StringBuffer toAppendTo, Object value) {\n        if (value instanceof Number) {\n            double val = ((Number) value).doubleValue();\n            if (val == 0) {\n                toAppendTo.append('0');\n                return;\n            }\n\n            String fmt;\n            double exp = Math.log10(Math.abs(val));\n            boolean stripZeros = true;\n            if (exp > 10 || exp < -9)\n                fmt = "%1.5E";\n            else if ((long) val != val)\n                fmt = "%1.9f";\n            else {\n                fmt = "%1.0f";\n                stripZeros = false;\n            }\n\n            Formatter formatter = new Formatter(toAppendTo, locale);\n            try {\n                formatter.format(locale, fmt, value);\n            } finally {\n                formatter.close();\n            }\n            if (stripZeros) {\n                // strip off trailing zeros\n                int removeFrom;\n                if (fmt.endsWith("E"))\n                    removeFrom = toAppendTo.lastIndexOf("E") - 1;\n                else\n                    removeFrom = toAppendTo.length() - 1;\n                while (toAppendTo.charAt(removeFrom) == '0') {\n                    toAppendTo.deleteCharAt(removeFrom--);\n                }\n                if (toAppendTo.charAt(removeFrom) == '.') {\n                    toAppendTo.deleteCharAt(removeFrom--);\n                }\n            }\n        } else if (value instanceof Boolean) {\n            toAppendTo.append(value.toString().toUpperCase(Locale.ROOT));\n        } else {\n            toAppendTo.append(value);\n        }\n    }
143	public boolean getSubValue(int idx) {\n		return subPropMatches[idx] && ((super.getValue() & subPropMasks[idx]) != 0);\n	}
144	protected void init(){\n        //type of the text\n        int type = getTextType();\n\n        int head;\n        int pos = 0;\n\n        //number of indentation levels\n        short levels = LittleEndian.getShort(_data, 0);\n        pos += LittleEndian.SHORT_SIZE;\n\n        paragraphStyles = new ArrayList<>(levels);\n        charStyles = new ArrayList<>(levels);\n\n        for(short i = 0; i < levels; i++) {\n            TextPropCollection prprops = new TextPropCollection(0, TextPropType.paragraph);\n            if (type >= TextHeaderAtom.CENTRE_BODY_TYPE) {\n                // Fetch the 2 byte value, that is safe to ignore for some types of text\n                short indentLevel = LittleEndian.getShort(_data, pos);\n                prprops.setIndentLevel(indentLevel);\n                pos += LittleEndian.SHORT_SIZE;\n            } else {\n                prprops.setIndentLevel((short)-1);\n            }\n\n            head = LittleEndian.getInt(_data, pos);\n            pos += LittleEndian.INT_SIZE;\n            \n            pos += prprops.buildTextPropList( head, _data, pos);\n            paragraphStyles.add(prprops);\n\n            head = LittleEndian.getInt(_data, pos);\n            pos += LittleEndian.INT_SIZE;\n            TextPropCollection chprops = new TextPropCollection(0, TextPropType.character);\n            pos += chprops.buildTextPropList( head, _data, pos);\n            charStyles.add(chprops);\n        }\n    }
145	public void registerListener(final POIFSReaderListener listener, final String name) {\n        registerListener(listener, null, name);\n    }
146	public static Record createRecordForType(long type, byte[] b, int start, int len) {\n		// We use the RecordTypes class to provide us with the right\n		//  class to use for a given type\n		// A spot of reflection gets us the (byte[],int,int) constructor\n		// From there, we instanciate the class\n		// Any special record handling occurs once we have the class\n		RecordConstructor c = RecordTypes.forTypeID((short)type).recordConstructor;\n		if (c == null) {\n			// How odd. RecordTypes normally substitutes in\n			//  a default handler class if it has heard of the record\n			//  type but there's no support for it. Explicitly request\n			//  that now\n			c = RecordTypes.UnknownRecordPlaceholder.recordConstructor;\n		}\n\n		final Record toReturn;\n		try {\n			toReturn = c.apply(b, start, len);\n		} catch(RuntimeException e) {\n			// Handle case of a corrupt last record, whose claimed length\n			//  would take us passed the end of the file\n			if(start + len > b.length ) {\n				logger.log(POILogger.WARN, "Warning: Skipping record of type " + type + " at position " + start + " which claims to be longer than the file! (" + len + " vs " + (b.length-start) + ")");\n				return null;\n			}\n\n			throw new HSLFException("Couldn't instantiate the class for type with id " + type + " on class " + c + " : " + e, e);\n		}\n\n		// Handling for special kinds of records follow\n\n		// If it's a position aware record, tell it where it is\n		if(toReturn instanceof PositionDependentRecord) {\n			PositionDependentRecord pdr = (PositionDependentRecord)toReturn;\n			pdr.setLastOnDiskOffset(start);\n		}\n\n		// Return the created record\n		return toReturn;\n	}
147	public List<EscherRecord> getChildRecords() { return Collections.emptyList(); }
148	public void setNEdn(final int field_64_nedn) {\n        this.field_64_nedn = field_64_nedn;\n    }
149	private HSSFRow createRowFromRecord(RowRecord row) {\n        HSSFRow hrow = new HSSFRow(_workbook, this, row);\n\n        addRow(hrow, false);\n        return hrow;\n    }
150	protected HSLFEscherClientDataRecord getClientData(boolean create) {\n        HSLFEscherClientDataRecord clientData = getEscherChild(EscherClientDataRecord.RECORD_ID);\n        if (clientData == null && create) {\n            clientData = new HSLFEscherClientDataRecord();\n            clientData.setOptions((short)15);\n            clientData.setRecordId(EscherClientDataRecord.RECORD_ID);\n            getSpContainer().addChildBefore(clientData, EscherTextboxRecord.RECORD_ID);\n        }\n        return clientData;\n    }
151	PropertyTable _get_property_table() {\n      return _property_table;\n    }
152	private void addContentType() {\n        setElementTextContent(KEYWORD_CONTENT_TYPE, namespaceCoreProperties, propsPart.getContentTypeProperty());\n	}
153	public int getNumPointers(int offset, byte[] data) {\n        // V5 stores it as a 16 bit number at the offset\n        return LittleEndian.getShort(data, offset);\n    }
154	public static void main(final String args[]) throws IOException {\n      if (args.length == 0) {\n         System.err.println("Must specify at least one file to view");\n         System.exit(1);\n      }\n\n      boolean withSizes = false;\n      boolean newPOIFS = true;\n      for (String arg : args) {\n         if (arg.equalsIgnoreCase("-size") || arg.equalsIgnoreCase("-sizes")) {\n            withSizes = true;\n         } else if (arg.equalsIgnoreCase("-old") || arg.equalsIgnoreCase("-old-poifs")) {\n            newPOIFS = false;\n         } else {\n            if (newPOIFS) {\n               viewFile(arg, withSizes);\n            } else {\n               viewFileOld(arg, withSizes);\n            }\n         }\n      }\n   }
155	private static void refreshRecords(List<HSLFTextParagraph> paragraphs) {\n        TextHeaderAtom headerAtom = paragraphs.get(0)._headerAtom;\n        RecordContainer _txtbox = headerAtom.getParentRecord();\n        if (_txtbox instanceof EscherTextboxWrapper) {\n            try {\n                _txtbox.writeOut(null);\n            } catch (IOException e) {\n                throw new HSLFException("failed dummy write", e);\n            }\n        }\n    }
156	public void setNFtn(final int field_62_nftn) {\n        this.field_62_nftn = field_62_nftn;\n    }
157	protected final int getNextPartNumber(POIXMLRelation descriptor, int minIdx) {\n        OPCPackage pkg = packagePart.getPackage();\n\n        try {\n            String name = descriptor.getDefaultFileName();\n            if (name.equals(descriptor.getFileName(9999))) {\n                // Non-index based, check if default is free\n                PackagePartName ppName = PackagingURIHelper.createPartName(name);\n                if (pkg.containPart(ppName)) {\n                    // Default name already taken, not index based, nothing free\n                    return -1;\n                } else {\n                    // Default name free\n                    return 0;\n                }\n            }\n\n            // Default to searching from 1, unless they asked for 0+\n            int idx = (minIdx < 0) ? 1 : minIdx;\n            int maxIdx = minIdx + pkg.getParts().size();\n            while (idx <= maxIdx) {\n                name = descriptor.getFileName(idx);\n                PackagePartName ppName = PackagingURIHelper.createPartName(name);\n                if (!pkg.containPart(ppName)) {\n                    return idx;\n                }\n                idx++;\n            }\n        } catch (InvalidFormatException e) {\n            // Give a general wrapped exception for the problem\n            throw new POIXMLException(e);\n        }\n        return -1;\n    }
158	public int getSize() { return sizeOfDataBlock; }
159	private boolean implicitlyTrackColumn(int column) {\n        if (!untrackedColumns.contains(column)) {\n            trackColumn(column);\n            return true;\n        }\n        return false;\n    }
160	public void addSection(final Section section) {\n        sections.add(section);\n    }
161	private ClientAnchorDetail fitImageToRows(Sheet sheet, int rowNumber,\n            double reqImageHeightMM, int resizeBehaviour) {\n        Row row;\n        double rowHeightMM;\n        double rowCoordinatesPerMM;\n        int pictureHeightCoordinates;\n        ClientAnchorDetail rowClientAnchorDetail = null;\n\n        // Get the row and it's height\n        row = sheet.getRow(rowNumber);\n        if(row == null) {\n            // Create row if it does not exist.\n            row = sheet.createRow(rowNumber);\n        }\n\n        // Get the row's height in millimetres\n        rowHeightMM = row.getHeightInPoints() / ConvertImageUnits.POINTS_PER_MILLIMETRE;\n\n        // Check that the row's height will accomodate the image at the required\n        // dimensions. If the height of the row is LESS than the required height\n        // of the image, decide how the application should respond - resize the\n        // row or overlay the image across a series of rows.\n        if(rowHeightMM < reqImageHeightMM) {\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_ROW) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                row.setHeightInPoints((float)(reqImageHeightMM *\n                        ConvertImageUnits.POINTS_PER_MILLIMETRE));\n                if(sheet instanceof HSSFSheet) {                    \n                    rowHeightMM = reqImageHeightMM;\n                    rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                        rowHeightMM;\n                    pictureHeightCoordinates = (int)(reqImageHeightMM *\n                            rowCoordinatesPerMM);\n                }\n                else {\n                    pictureHeightCoordinates = (int)(reqImageHeightMM *\n                            AddDimensionedImage.EMU_PER_MM);\n                }\n                rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n            }\n            // If the user has chosen to overlay both rows and columns or just\n            // to expand ONLY the size of the columns, then calculate how to lay\n            // the image out ver one or more rows.\n            else if((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                    (resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN)) {\n                rowClientAnchorDetail = this.calculateRowLocation(sheet,\n                        rowNumber, reqImageHeightMM);\n            }\n        }\n        // Else, if the image is smaller than the space available\n        else {\n            if(sheet instanceof HSSFSheet) {\n                rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n                pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n            }\n            else {\n                pictureHeightCoordinates = (int)(reqImageHeightMM *\n                        AddDimensionedImage.EMU_PER_MM);\n            }\n            rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n        }\n        return(rowClientAnchorDetail);\n    }
162	protected int getNextBlock(final int offset) {\n       BATBlockAndIndex bai = getBATBlockAndIndex(offset);\n       return bai.getBlock().getValueAt( bai.getIndex() );\n    }
163	public void removeProperty(final Property property) {\n        _properties.remove(property);\n    }
164	int getSat(){\n        return getPercentageValue("sat");\n    }
165	public boolean intersects(CellRangeAddressBase other) {\n		return this._firstRow <= other._lastRow &&\n				this._firstCol <= other._lastCol &&\n				other._firstRow <= this._lastRow &&\n				other._firstCol <= this._lastCol;\n	}
166	@Internal\n    public boolean isFVertRestart()\n    {\n        return fVertRestart.isSet(field_1_rgf);\n    }
167	public XWPFTableCell createCell() {\n        XWPFTableCell tableCell = new XWPFTableCell(ctRow.addNewTc(), this, table.getBody());\n        tableCells.add(tableCell);\n        return tableCell;\n    }
168	private void appendSpecificTypes(Element root,\n            Entry<PackagePartName, String> entry) {\n        Element specificType = root.getOwnerDocument().createElementNS(TYPES_NAMESPACE_URI, OVERRIDE_TAG_NAME);\n        specificType.setAttribute(PART_NAME_ATTRIBUTE_NAME, entry.getKey().getName());\n        specificType.setAttribute(CONTENT_TYPE_ATTRIBUTE_NAME, entry.getValue());\n        root.appendChild(specificType);\n    }
169	public static void writeLittleEndian(int i,OutputStream o) throws IOException {\n		byte[] bi = new byte[4];\n		LittleEndian.putInt(bi,0,i);\n		o.write(bi);\n	}
170	public static double sumsq(double[] values) {\n        double sumsq = 0;\n        for (int i=0, iSize=values.length; i<iSize; i++) {\n            sumsq += values[i]*values[i];\n        }\n        return sumsq;\n    }
171	@Internal\n    public int putCellXf(CTXf cellXf) {\n        xfs.add(cellXf);\n        return xfs.size();\n    }
172	private InputStream getXLSFromURL(String urlstring) throws MalformedURLException, IOException {\n    URL url = new URL(urlstring);\n    URLConnection uc = url.openConnection();\n    String field = uc.getHeaderField(0);\n    for (int i=0;field != null; i++) {\n      System.out.println(field);\n      field = uc.getHeaderField(i);\n  }\n      return new BufferedInputStream(uc.getInputStream());\n  }
173	public void registerListener(final POIFSReaderListener listener) {\n        if (listener == null) {\n            throw new NullPointerException();\n        }\n        if (registryClosed) {\n            throw new IllegalStateException();\n        }\n        registry.registerListener(listener);\n    }
174	public void addRow(XWPFTableRow row) {\n        ctTbl.addNewTr();\n        ctTbl.setTrArray(getNumberOfRows() - 1, row.getCtRow());\n        tableRows.add(row);\n    }
175	public boolean isFHasSep()\n    {\n        return fHasSep.isSet( field_2_flt );\n\n    }
176	public void parseRelationshipsPart(PackagePart relPart)\n            throws InvalidFormatException {\n        try {\n            logger.log(POILogger.DEBUG, "Parsing relationship: " + relPart.getPartName());\n            Document xmlRelationshipsDoc = DocumentHelper.readDocument(relPart.getInputStream());\n\n            // Browse default types\n            Element root = xmlRelationshipsDoc.getDocumentElement();\n\n            // Check OPC compliance M4.1 rule\n            boolean fCorePropertiesRelationship = false;\n\n            NodeList nodeList = root.getElementsByTagNameNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIP_TAG_NAME);\n            int nodeCount = nodeList.getLength();\n            for (int i = 0; i < nodeCount; i++) {\n                Element element = (Element)nodeList.item(i);\n                // Relationship ID\n                String id = element.getAttribute(PackageRelationship.ID_ATTRIBUTE_NAME);\n                // Relationship type\n                String type = element.getAttribute(PackageRelationship.TYPE_ATTRIBUTE_NAME);\n\n                /* Check OPC Compliance */\n                // Check Rule M4.1\n                if (type.equals(PackageRelationshipTypes.CORE_PROPERTIES))\n                    if (!fCorePropertiesRelationship)\n                        fCorePropertiesRelationship = true;\n                    else\n                        throw new InvalidFormatException(\n                                "OPC Compliance error [M4.1]: there is more than one core properties relationship in the package !");\n\n                /* End OPC Compliance */\n\n                // TargetMode (default value "Internal")\n                Attr targetModeAttr = element.getAttributeNode(PackageRelationship.TARGET_MODE_ATTRIBUTE_NAME);\n                TargetMode targetMode = TargetMode.INTERNAL;\n                if (targetModeAttr != null) {\n                    targetMode = targetModeAttr.getValue().toLowerCase(Locale.ROOT)\n                            .equals("internal") ? TargetMode.INTERNAL\n                            : TargetMode.EXTERNAL;\n                }\n\n                // Target converted in URI\n                URI target = PackagingURIHelper.toURI("http://invalid.uri"); // dummy url\n                String value = element.getAttribute(PackageRelationship.TARGET_ATTRIBUTE_NAME);\n                try {\n                    // when parsing of the given uri fails, we can either\n                    // ignore this relationship, which leads to IllegalStateException\n                    // later on, or use a dummy value and thus enable processing of the\n                    // package\n                    target = PackagingURIHelper.toURI(value);\n                } catch (URISyntaxException e) {\n                    logger.log(POILogger.ERROR, "Cannot convert " + value\n                            + " in a valid relationship URI-> dummy-URI used", e);\n                }\n                addRelationship(target, targetMode, type, id);\n            }\n        } catch (Exception e) {\n            logger.log(POILogger.ERROR, e);\n            throw new InvalidFormatException(e.getMessage());\n        }\n    }
177	@SuppressWarnings("WeakerAccess")\n    public void setBulletAutoNumber(AutoNumberingScheme scheme, int startAt) {\n        if(startAt < 1) throw new IllegalArgumentException("Start Number must be greater or equal that 1") ;\n        CTTextParagraphProperties pr = _p.isSetPPr() ? _p.getPPr() : _p.addNewPPr();\n        CTTextAutonumberBullet lst = pr.isSetBuAutoNum() ? pr.getBuAutoNum() : pr.addNewBuAutoNum();\n        lst.setType(STTextAutonumberScheme.Enum.forInt(scheme.ooxmlId));\n        lst.setStartAt(startAt);\n    }
178	public List<XSSFTableColumn> getColumns() {\n        if (tableColumns == null) {\n           List<XSSFTableColumn> columns = new ArrayList<>();\n            CTTableColumns ctTableColumns = ctTable.getTableColumns();\n            if (ctTableColumns != null) {\n                for (CTTableColumn column : ctTableColumns.getTableColumnList()) {\n                    XSSFTableColumn tableColumn = new XSSFTableColumn(this, column);\n                    columns.add(tableColumn);\n                }\n            }\n            tableColumns = Collections.unmodifiableList(columns);\n        }\n        return tableColumns;\n    }
179	public void removeMarshaller(String contentType) {\n		try {\n            partMarshallers.remove(new ContentType(contentType));\n        } catch (InvalidFormatException e) {\n            throw new RuntimeException(e);\n        }\n	}
180	static void hideDupplicates(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("City");\n        sheet.createRow(1).createCell(0).setCellValue("Boston");\n        sheet.createRow(2).createCell(0).setCellValue("Boston");\n        sheet.createRow(3).createCell(0).setCellValue("Chicago");\n        sheet.createRow(4).createCell(0).setCellValue("Chicago");\n        sheet.createRow(5).createCell(0).setCellValue("New York");\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =A2=A1   (White Font)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("A2=A1");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontColorIndex(IndexedColors.WHITE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(1).createCell(1).setCellValue("<== the second (and subsequent) " +\n                "occurences of each region name will have white font colour.  " +\n                "Condition: Formula Is   =A2=A1   (White Font)");\n    }
181	public void readFrom(InputStream is) throws IOException {\n        try {\n            doc = StyleSheetDocument.Factory.parse(is, DEFAULT_XML_OPTIONS);\n\n            CTStylesheet styleSheet = doc.getStyleSheet();\n\n            // Grab all the different bits we care about\n            \n            // keep this first, as some constructors below want it\n            IndexedColorMap customColors = CustomIndexedColorMap.fromColors(styleSheet.getColors());\n            if (customColors != null) indexedColors = customColors;\n            \n            CTNumFmts ctfmts = styleSheet.getNumFmts();\n            if( ctfmts != null){\n                for (CTNumFmt nfmt : ctfmts.getNumFmtArray()) {\n                    short formatId = (short)nfmt.getNumFmtId();\n                    numberFormats.put(formatId, nfmt.getFormatCode());\n                }\n            }\n\n            CTFonts ctfonts = styleSheet.getFonts();\n            if(ctfonts != null){\n                int idx = 0;\n                for (CTFont font : ctfonts.getFontArray()) {\n                    // Create the font and save it. Themes Table supplied later\n                    XSSFFont f = new XSSFFont(font, idx, indexedColors);\n                    fonts.add(f);\n                    idx++;\n                }\n            }\n            CTFills ctfills = styleSheet.getFills();\n            if(ctfills != null){\n                for (CTFill fill : ctfills.getFillArray()) {\n                    fills.add(new XSSFCellFill(fill, indexedColors));\n                }\n            }\n\n            CTBorders ctborders = styleSheet.getBorders();\n            if(ctborders != null) {\n                for (CTBorder border : ctborders.getBorderArray()) {\n                    borders.add(new XSSFCellBorder(border, indexedColors));\n                }\n            }\n\n            CTCellXfs cellXfs = styleSheet.getCellXfs();\n            if(cellXfs != null) xfs.addAll(Arrays.asList(cellXfs.getXfArray()));\n\n            CTCellStyleXfs cellStyleXfs = styleSheet.getCellStyleXfs();\n            if(cellStyleXfs != null) styleXfs.addAll(Arrays.asList(cellStyleXfs.getXfArray()));\n\n            CTDxfs styleDxfs = styleSheet.getDxfs();\n            if(styleDxfs != null) dxfs.addAll(Arrays.asList(styleDxfs.getDxfArray()));\n\n            CTTableStyles ctTableStyles = styleSheet.getTableStyles();\n            if (ctTableStyles != null) {\n                int idx = 0;\n                for (CTTableStyle style : Arrays.asList(ctTableStyles.getTableStyleArray())) {\n                    tableStyles.put(style.getName(), new XSSFTableStyle(idx, styleDxfs, style, indexedColors));\n                    idx++;\n                }\n            }\n            \n        } catch (XmlException e) {\n            throw new IOException(e.getLocalizedMessage());\n        }\n    }
182	public boolean isPlotVisibleOnly() {\n        return plotVisibleOnly.isSet(field_1_flags);\n    }
183	public boolean isAutoTextBackground()\n    {\n        return autoTextBackground.isSet(field_10_options);\n    }
184	@Internal\n    public short getIPriority()\n    {\n        return ( short )iPriority.getValue(field_3_info3);\n    }
185	public int getPostNumPointersSkip() {\n        return getPostNumPointersSkipV6();\n    }
186	public static String getFromCompressedUnicode(\n            final byte[] string,\n            final int offset,\n            final int len) {\n        int len_to_use = Math.min(len, string.length - offset);\n        return new String(string, offset, len_to_use, ISO_8859_1);\n    }
187	public short getAltLangId(){\n        return altLangId;\n    }
188	@SuppressWarnings("WeakerAccess")\n    public String getMajorFont(){\n        return _theme.getThemeElements().getFontScheme().getMajorFont().getLatin().getTypeface();\n    }
189	public String getValue() {\n        return _cell.getV();\n    }
190	public void setNameText(String newName) {\n     field_6_name_text = newName;\n  }
191	@SuppressWarnings("WeakerAccess")\n    public void setLineTailWidth(DecorationSize style) {\n        CTLineProperties ln = getLn(this, true);\n        if (ln == null) {\n            return;\n        }\n        \n        CTLineEndProperties lnEnd = ln.isSetTailEnd() ? ln.getTailEnd() : ln.addNewTailEnd();\n        if (style == null) {\n            if (lnEnd.isSetW()) {\n                lnEnd.unsetW();\n            }\n        } else {\n            lnEnd.setW(STLineEndWidth.Enum.forInt(style.ooxmlId));\n        }\n    }
192	public static List<String> inspectViewable(final Object viewable,\n                                       final boolean drilldown,\n                                       final int indentLevel,\n                                       final String indentString)\n    {\n        List<String> objects = new ArrayList<>();\n\n        if (viewable instanceof POIFSViewable)\n        {\n            POIFSViewable inspected = ( POIFSViewable ) viewable;\n\n            objects.add(indent(indentLevel, indentString,\n                               inspected.getShortDescription()));\n            if (drilldown)\n            {\n                if (inspected.preferArray())\n                {\n                    Object[] data = inspected.getViewableArray();\n\n                    for (int j = 0; j < data.length; j++)\n                    {\n                        objects.addAll(inspectViewable(data[ j ], drilldown,\n                                                       indentLevel + 1,\n                                                       indentString));\n                    }\n                }\n                else\n                {\n                    Iterator<Object> iter = inspected.getViewableIterator();\n\n                    while (iter.hasNext())\n                    {\n                        objects.addAll(inspectViewable(iter.next(),\n                                                       drilldown,\n                                                       indentLevel + 1,\n                                                       indentString));\n                    }\n                }\n            }\n        }\n        else\n        {\n            objects.add(indent(indentLevel, indentString,\n                               viewable.toString()));\n        }\n        return objects;\n    }
193	private CellType getBaseCellType(boolean blankCells) {\n        switch (_cell.getT().intValue()) {\n            case STCellType.INT_B:\n                return CellType.BOOLEAN;\n            case STCellType.INT_N:\n                if (!_cell.isSetV() && blankCells) {\n                    // ooxml does have a separate cell type of 'blank'.  A blank cell gets encoded as\n                    // (either not present or) a numeric cell with no value set.\n                    // The formula evaluator (and perhaps other clients of this interface) needs to\n                    // distinguish blank values which sometimes get translated into zero and sometimes\n                    // empty string, depending on context\n                    return CellType.BLANK;\n                }\n                return CellType.NUMERIC;\n            case STCellType.INT_E:\n                return CellType.ERROR;\n            case STCellType.INT_S: // String is in shared strings\n            case STCellType.INT_INLINE_STR: // String is inline in cell\n            case STCellType.INT_STR:\n                 return CellType.STRING;\n            default:\n                throw new IllegalStateException("Illegal cell type: " + this._cell.getT());\n        }\n    }
194	public void updateFormulasAfterCellShift(FormulaShifter shifter, int externSheetIndex) {\n        getRowsAggregate().updateFormulasAfterRowShift(shifter, externSheetIndex);\n        if (condFormatting != null) {\n            getConditionalFormattingTable().updateFormulasAfterCellShift(shifter, externSheetIndex);\n        }\n        // TODO - adjust data validations\n    }
195	protected static int absoluteDay(Calendar cal, boolean use1904windowing)\n    {\n        return cal.get(Calendar.DAY_OF_YEAR)\n               + daysInPriorYears(cal.get(Calendar.YEAR), use1904windowing);\n    }
196	public ExControl getExControl(){\n        int idx = getControlIndex();\n        Document doc = getSheet().getSlideShow().getDocumentRecord();\n        ExObjList lst = (ExObjList)doc.findFirstOfType(RecordTypes.ExObjList.typeID);\n        if (lst == null) {\n            return null;\n        }\n        \n        for (Record ch : lst.getChildRecords()) {\n            if(ch instanceof ExControl){\n                ExControl c = (ExControl)ch;\n                if(c.getExOleObjAtom().getObjID() == idx){\n                    return c;\n                }\n            }\n        }\n        return null;\n    }
197	public void processChildRecords() {\n    	convertRawBytesToEscherRecords();\n    }
198	@Beta\n    public void copyRows(List<? extends Row> srcRows, int destStartRow, CellCopyPolicy policy) {\n        if (srcRows == null || srcRows.size() == 0) {\n            throw new IllegalArgumentException("No rows to copy");\n        }\n        final Row srcStartRow = srcRows.get(0);\n        final Row srcEndRow = srcRows.get(srcRows.size() - 1);\n\n        if (srcStartRow == null) {\n            throw new IllegalArgumentException("copyRows: First row cannot be null");\n        }\n\n        final int srcStartRowNum = srcStartRow.getRowNum();\n        final int srcEndRowNum = srcEndRow.getRowNum();\n\n        // check row numbers to make sure they are continuous and increasing (monotonic)\n        // and srcRows does not contain null rows\n        final int size = srcRows.size();\n        for (int index=1; index < size; index++) {\n            final Row curRow = srcRows.get(index);\n            if (curRow == null) {\n                throw new IllegalArgumentException("srcRows may not contain null rows. Found null row at index " + index + ".");\n                //} else if (curRow.getRowNum() != prevRow.getRowNum() + 1) {\n                //    throw new IllegalArgumentException("srcRows must contain continuously increasing row numbers. " +\n                //            "Got srcRows[" + (index-1) + "]=Row " + prevRow.getRowNum() + ", srcRows[" + index + "]=Row " + curRow.getRowNum() + ".");\n                // FIXME: assumes row objects belong to non-null sheets and sheets belong to non-null workbooks.\n            } else if (srcStartRow.getSheet().getWorkbook() != curRow.getSheet().getWorkbook()) {\n                throw new IllegalArgumentException("All rows in srcRows must belong to the same sheet in the same workbook." +\n                        "Expected all rows from same workbook (" + srcStartRow.getSheet().getWorkbook() + "). " +\n                        "Got srcRows[" + index + "] from different workbook (" + curRow.getSheet().getWorkbook() + ").");\n            } else if (srcStartRow.getSheet() != curRow.getSheet()) {\n                throw new IllegalArgumentException("All rows in srcRows must belong to the same sheet. " +\n                        "Expected all rows from " + srcStartRow.getSheet().getSheetName() + ". " +\n                        "Got srcRows[" + index + "] from " + curRow.getSheet().getSheetName());\n            }\n        }\n\n        // FIXME: is special behavior needed if srcRows and destRows belong to the same sheets and the regions overlap?\n\n        final CellCopyPolicy options = new CellCopyPolicy(policy);\n        // avoid O(N^2) performance scanning through all regions for each row\n        // merged regions will be copied after all the rows have been copied\n        options.setCopyMergedRegions(false);\n\n        // FIXME: if srcRows contains gaps or null values, clear out those rows that will be overwritten\n        // how will this work with merging (copy just values, leave cell styles in place?)\n\n        int r = destStartRow;\n        for (Row srcRow : srcRows) {\n            int destRowNum;\n            if (policy.isCondenseRows()) {\n                destRowNum = r++;\n            } else {\n                final int shift = (srcRow.getRowNum() - srcStartRowNum);\n                destRowNum = destStartRow + shift;\n            }\n            //removeRow(destRowNum); //this probably clears all external formula references to destRow, causing unwanted #REF! errors\n            final XSSFRow destRow = createRow(destRowNum);\n            destRow.copyRowFrom(srcRow, options);\n        }\n\n        // ======================\n        // Only do additional copy operations here that cannot be done with Row.copyFromRow(Row, options)\n        // reasons: operation needs to interact with multiple rows or sheets\n\n        // Copy merged regions that are contained within the copy region\n        if (policy.isCopyMergedRegions()) {\n            // FIXME: is this something that rowShifter could be doing?\n            final int shift = destStartRow - srcStartRowNum;\n            for (CellRangeAddress srcRegion : srcStartRow.getSheet().getMergedRegions()) {\n                if (srcStartRowNum <= srcRegion.getFirstRow() && srcRegion.getLastRow() <= srcEndRowNum) {\n                    // srcRegion is fully inside the copied rows\n                    final CellRangeAddress destRegion = srcRegion.copy();\n                    destRegion.setFirstRow(destRegion.getFirstRow() + shift);\n                    destRegion.setLastRow(destRegion.getLastRow() + shift);\n                    addMergedRegion(destRegion);\n                }\n            }\n        }\n    }
199	public byte[] compress(InputStream src) throws IOException {\n      ByteArrayOutputStream res = new ByteArrayOutputStream();\n      compress(src,res);\n      return res.toByteArray();\n   }
200	public void removeFontRecord(FontRecord rec) {\n        records.remove(rec); // this updates FontPos for us\n        numfonts--;\n    }
201	public boolean isContainerRecord() {\n        return getVersion() == (short)0x000f;\n    }
202	private static DefaultColWidthRecord createDefaultColWidth() {\n        DefaultColWidthRecord retval = new DefaultColWidthRecord();\n        retval.setColWidth(DefaultColWidthRecord.DEFAULT_COLUMN_WIDTH);\n        return retval;\n    }
203	/* package */ static HSLFHyperlink createHyperlink(HSLFTextRun run) {\n        // TODO: check if a hyperlink already exists\n        ExHyperlink exHyper = new ExHyperlink();\n        int linkId = run.getTextParagraph().getSheet().getSlideShow().addToObjListAtom(exHyper);\n        ExHyperlinkAtom obj = exHyper.getExHyperlinkAtom();\n        obj.setNumber(linkId);\n        InteractiveInfo info = new InteractiveInfo();\n        info.getInteractiveInfoAtom().setHyperlinkID(linkId);\n        // don't add the hyperlink now to text paragraph records\n        // this will be done, when the paragraph is saved\n        HSLFHyperlink hyper = new HSLFHyperlink(exHyper, info);\n        hyper.linkToNextSlide();\n        \n        TxInteractiveInfoAtom txinfo = new TxInteractiveInfoAtom();\n        int startIdx = run.getTextParagraph().getStartIdxOfTextRun(run);\n        int endIdx = startIdx + run.getLength();\n        txinfo.setStartIndex(startIdx);\n        txinfo.setEndIndex(endIdx);\n        hyper.setTextRunInfo(txinfo);\n        \n        run.setHyperlink(hyper);\n        return hyper;\n    }
204	public static byte fromInt(int b) {\n      if(b < 128) return (byte)b;\n      return (byte)(b - 256);\n   }
205	public int getBlockSize() {\n        return blockSize;\n    }
206	public void addSlideLookup(int slideID, int posOnDisk) {\n        if (_slideLocations.containsKey(slideID)) {\n            throw new CorruptPowerPointFileException("A record with persistId "+slideID+" already exists.");\n        }\n\n        _slideLocations.put(slideID, posOnDisk);\n    }
207	@SuppressWarnings("WeakerAccess")\n    public void mergeCells(int firstCol, int lastCol)\n    {\n        if (firstCol >= lastCol) {\n            throw new IllegalArgumentException(\n                "Cannot merge, first column >= last column : "\n                + firstCol + " >= " + lastCol\n            );\n        }\n\n        final int colSpan = (lastCol - firstCol) + 1;\n\n        _cells.get(firstCol).setGridSpan(colSpan);\n        for (final XSLFTableCell cell : _cells.subList(firstCol+1, lastCol+1)) {\n            cell.setHMerge();\n        }\n    }
208	@Internal\n    public boolean isFWarichuNoOpenBracket()\n    {\n        return fWarichuNoOpenBracket.isSet(field_30_copt);\n    }
209	public XWPFTable getTable(CTTbl ctTable) {\n        for (XWPFTable table : tables) {\n            if (table == null)\n                return null;\n            if (table.getCTTbl().equals(ctTable))\n                return table;\n        }\n        return null;\n    }
210	public void setWorkbook(XSSFWorkbook workbook) {\n        this.workbook = workbook;\n    }
211	public XWPFRun createRun() {\n        XWPFRun xwpfRun = new XWPFRun(paragraph.addNewR(), (IRunBody)this);\n        runs.add(xwpfRun);\n        iruns.add(xwpfRun);\n        return xwpfRun;\n    }
212	public byte getCh()\n    {\n        return (byte) ch.getValue( field_1_chHolder );\n\n    }
213	public HSLFFontInfo getFontInfo(String typeface) {\n        return fonts.get(typeface);\n    }
214	public static String getBiffName(int sid) {\n        // Note to POI developers:\n        // Make sure you delete the corresponding entry from\n        // this method any time a new Record subclass is created.\n        switch (sid) {\n            case PRINTSIZE_0033: return "PRINTSIZE";\n            case PLS_004D: return "PLS";\n            case 0x0050: return "DCON"; // Data Consolidation Information\n            case 0x007F: return "IMDATA";\n            case SHEETPR_0081: return "SHEETPR";\n            case SORT_0090: return "SORT"; // Sorting Options\n            case 0x0094: return "LHRECORD"; // .WK? File Conversion Information\n            case STANDARDWIDTH_0099: return "STANDARDWIDTH"; //Standard Column Width\n            case SCL_00A0: return "SCL"; // Window Zoom Magnification\n            case 0x00AE: return "SCENMAN"; // Scenario Output Data\n\n            case 0x00B2: return "SXVI";        // (pivot table) View Item\n            case 0x00B4: return "SXIVD";       // (pivot table) Row/Column Field IDs\n            case 0x00B5: return "SXLI";        // (pivot table) Line Item Array\n\n            case 0x00D3: return "OBPROJ";\n            case 0x00DC: return "PARAMQRY";\n            case 0x00DE: return "OLESIZE";\n            case BITMAP_00E9: return "BITMAP";\n            case PHONETICPR_00EF: return "PHONETICPR";\n            case 0x00F1: return "SXEX";        // PivotTable View Extended Information\n\n            case LABELRANGES_015F: return "LABELRANGES";\n            case 0x01BA: return "CODENAME";\n            case 0x01A9: return "USERBVIEW";\n            case 0x01AD: return "QSI";\n\n            case 0x01C0: return "EXCEL9FILE";\n\n            case 0x0802: return "QSISXTAG";   // Pivot Table and Query Table Extensions\n            case 0x0803: return "DBQUERYEXT";\n            case 0x0805: return "TXTQUERY";\n            case 0x0810: return "SXVIEWEX9";  // Pivot Table Extensions\n\n            case 0x0812: return "CONTINUEFRT";\n            case QUICKTIP_0800: return "QUICKTIP";\n            case SHEETEXT_0862: return "SHEETEXT";\n            case 0x0863: return "BOOKEXT";\n            case 0x0864: return "SXADDL";    // Pivot Table Additional Info\n            case SHEETPROTECTION_0867: return "SHEETPROTECTION";\n            case 0x086B: return "DATALABEXTCONTENTS";\n            case 0x086C: return "CELLWATCH";\n            case FeatRecord.v11_sid: return "SHARED FEATURE v11";\n            case 0x0874: return "DROPDOWNOBJIDS";\n            case 0x0876: return "DCONN";\n            case FeatRecord.v12_sid: return "SHARED FEATURE v12";\n            case 0x087B: return "CFEX";\n            case 0x087C: return "XFCRC";\n            case 0x087D: return "XFEXT";\n            case 0x087F: return "CONTINUEFRT12";\n            case 0x088B: return "PLV";\n            case 0x088C: return "COMPAT12";\n            case 0x088D: return "DXF";\n            case 0x0892: return "STYLEEXT";\n            case 0x0896: return "THEME";\n            case 0x0897: return "GUIDTYPELIB";\n            case 0x089A: return "MTRSETTINGS";\n            case 0x089B: return "COMPRESSPICTURES";\n            case HEADER_FOOTER_089C: return "HEADERFOOTER";\n            case 0x089D: return "CRTLAYOUT12";\n            case 0x089E: return "CRTMLFRT";\n            case 0x089F: return "CRTMLFRTCONTINUE";\n            case 0x08A1: return "SHAPEPROPSSTREAM";\n            case 0x08A3: return "FORCEFULLCALCULATION";\n            case 0x08A4: return "SHAPEPROPSSTREAM";\n            case 0x08A5: return "TEXTPROPSSTREAM";\n            case 0x08A6: return "RICHTEXTSTREAM";\n            case 0x08A7: return "CRTLAYOUT12A";\n\n            case 0x08C8: return "PLV{Mac Excel}";\n            \n            case 0x1001: return "UNITS";\n            case 0x1006: return "CHARTDATAFORMAT";\n            case 0x1007: return "CHARTLINEFORMAT";\n        }\n        if (isObservedButUnknown(sid)) {\n            return "UNKNOWN-" + Integer.toHexString(sid).toUpperCase(Locale.ROOT);\n        }\n\n        return null;\n    }
215	public boolean isAlternateDash() {\n        return SUBSECTION_ALTERNATE.isSet(flag);\n    }
216	@Internal\n    public boolean isFNeverBeenAutofit()\n    {\n        return fNeverBeenAutofit.isSet(field_13_widthAndFitsFlags);\n    }
217	public void addRelationship(PackageRelationship relPart) {\n        if (relPart == null || relPart.getId() == null || relPart.getId().isEmpty()) {\n            throw new IllegalArgumentException("invalid relationship part/id");\n        }\n        relationshipsByID.put(relPart.getId(), relPart);\n        relationshipsByType.put(relPart.getRelationshipType(), relPart);\n    }
218	@Beta\n    public void copyRows(int srcStartRow, int srcEndRow, int destStartRow, CellCopyPolicy cellCopyPolicy) {\n        final List<XSSFRow> srcRows = getRows(srcStartRow, srcEndRow, false); //FIXME: should be false, no need to create rows where src is only to copy them to dest\n        copyRows(srcRows, destStartRow, cellCopyPolicy);\n    }
219	public boolean isCrossCategoryAxisAtMaximum()\n    {\n        return crossCategoryAxisAtMaximum.isSet(field_6_options);\n    }
220	public Record removeChild(Record ch) {\n        Record rm = null;\n        ArrayList<Record> lst = new ArrayList<>();\n        for(Record r : _children) {\n            if(r != ch) {\n                lst.add(r);\n            } else {\n                rm = r;\n            }\n        }\n        _children = lst.toArray(new Record[lst.size()]);\n        return rm;\n    }
221	public String getCommonXpath() {\n        if (commonXPath == null) {\n            String[] commonTokens = {};\n            for (XSSFTableColumn column : getColumns()) {\n                if (column.getXmlColumnPr()!=null) {\n                    String xpath = column.getXmlColumnPr().getXPath();\n                    String[] tokens =  xpath.split("/");\n                    if (commonTokens.length==0) {\n                        commonTokens = tokens;\n                        \n                    } else {\n                        final int maxLength = Math.min(commonTokens.length, tokens.length);\n                         \n                        for (int i =0; i<maxLength; i++) {\n                            if (!commonTokens[i].equals(tokens[i])) {\n                             List<String> subCommonTokens = Arrays.asList(commonTokens).subList(0, i);\n                             \n                             String[] container = {};\n                             \n                             commonTokens = subCommonTokens.toArray(container);\n                             break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            commonTokens[0] = "";\n            commonXPath = StringUtil.join(commonTokens, "/");\n        }\n        \n        return commonXPath;\n    }
222	public static ToHtml create(Workbook wb, Appendable output) {\n        return new ToHtml(wb, output);\n    }
223	public void addFunction(String name, String clazzName) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> clazzInst = Class.forName(clazzName);\n        Object newInst = clazzInst.newInstance();\n        if(newInst instanceof FreeRefFunction) {\n            addFunction(name, (FreeRefFunction)newInst);\n        }\n\n    }
224	public void writeTo( ByteArrayOutputStream tableStream ) throws IOException\n    {\n        String[] toSave = new String[entries.length * 2];\n        int counter = 0;\n        for ( SavedByEntry entry : entries )\n        {\n            toSave[counter++] = entry.getUserName();\n            toSave[counter++] = entry.getSaveLocation();\n        }\n        SttbUtils.writeSttbSavedBy( toSave, tableStream );\n    }
225	private void paintSelectedBorder(Graphics g, int x, int y, int width,\n                                  int height) {\n     if (selected) {\n       //Need to setup thickness of 2\n       g.setColor(Color.black);\n       //paint the border\n       g.drawRect(x,y,width-1,height-1);\n\n       //paint the filled rectangle at the bottom left hand position\n       g.fillRect(x+width-5, y+height-5, 5, 5);\n     }\n   }
226	@Internal\n    public boolean isFDot()\n    {\n        return fDot.isSet(field_6_flags1);\n    }
227	public boolean isFResultEdited()\n    {\n        return fResultEdited.isSet( field_2_flt );\n\n    }
228	public void untrackAllColumns() {\n        trackAllColumns = false;\n        maxColumnWidths.clear();\n        untrackedColumns.clear();\n    }
229	public XSSFTextParagraph addNewTextParagraph() {\n        CTTextBody txBody = ctShape.getTxBody();\n        CTTextParagraph p = txBody.addNewP();\n        XSSFTextParagraph paragraph = new XSSFTextParagraph(p, ctShape);\n        _paragraphs.add(paragraph);\n        return paragraph;\n    }
230	@SuppressWarnings("unchecked")\n    public final <T extends TextProp> T findByName(String textPropName) {\n		return (T)textProps.get(textPropName);\n	}
231	public void updateWindowMapMode() {\n        Rectangle2D win = prop.getWindow();\n        HwmfMapMode mapMode = prop.getMapMode();\n        graphicsCtx.setTransform(initialAT);\n\n        switch (mapMode) {\n        default:\n        case MM_ANISOTROPIC:\n            // scale window bounds to output bounds\n            graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getHeight()/win.getHeight());\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        case MM_ISOTROPIC:\n            // TODO: to be validated ...\n            // like anisotropic, but use x-axis as reference\n            graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getWidth()/win.getWidth());\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        case MM_LOMETRIC:\n        case MM_HIMETRIC:\n        case MM_LOENGLISH:\n        case MM_HIENGLISH:\n        case MM_TWIPS: {\n            // TODO: to be validated ...\n            GraphicsConfiguration gc = graphicsCtx.getDeviceConfiguration();\n            graphicsCtx.transform(gc.getNormalizingTransform());\n            graphicsCtx.scale(1./mapMode.scale, -1./mapMode.scale);\n            graphicsCtx.translate(-win.getX(), -win.getY());\n            break;\n        }\n        case MM_TEXT:\n            // TODO: to be validated ...\n            break;\n        }\n    }
232	public void visitShapes(ShapeVisitor visitor) {\n        try {\n            for (XDGFShape shape: _toplevelShapes) {\n                shape.visitShapes(visitor, new AffineTransform(), 0);\n            }\n        } catch (StopVisiting e) {\n            // intentionally empty\n        } catch (POIXMLException e) {\n            throw XDGFException.wrap(this, e);\n        }\n    }
233	public static void putDouble( double value, OutputStream outputStream )\n            throws IOException\n    {\n        putLong( Double.doubleToLongBits( value ), outputStream );\n    }
234	private void paintDottedBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             northBorderType == BorderStyle.DOTTED) {\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+2) {\n             g.drawLine(xc,y+k,xc,y+k);\n           }\n        }\n      }\n\n      if (eastBorder &&\n              eastBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; //need for dotted borders to show up east\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+2) {\n                g.drawLine(width-k,yc,width-k,yc);\n           }\n        }\n      }\n\n      if (southBorder &&\n              southBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(southBorderType);\n        thickness++;\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+2) {\n             g.drawLine(xc,height-k,xc,height-k);\n           }\n        }\n      }\n\n      if (westBorder &&\n            westBorderType == BorderStyle.DOTTED\n         ) {\n\n        int thickness = getThickness(westBorderType);\n//        thickness++;\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+2) {\n                g.drawLine(x+k,yc,x+k,yc);\n           }\n        }\n      }\n   }
235	@SuppressWarnings("WeakerAccess")\n    public XSLFSlideMaster getSlideMaster() {\n        if (_master == null) {\n            for (POIXMLDocumentPart p : getRelations()) {\n                if (p instanceof XSLFSlideMaster) {\n                    _master = (XSLFSlideMaster) p;\n                }\n            }\n        }\n        if (_master == null) {\n            throw new IllegalStateException("SlideMaster was not found for " + this);\n        }\n        return _master;\n    }
236	public String formatNumberDateCell(CellValueRecordInterface cell) {\n		double value;\n		if (cell instanceof NumberRecord) {\n			value = ((NumberRecord) cell).getValue();\n		} else if (cell instanceof FormulaRecord) {\n			value = ((FormulaRecord) cell).getValue();\n		} else {\n			throw new IllegalArgumentException("Unsupported CellValue Record passed in " + cell);\n		}\n\n		// Get the built in format, if there is one\n		int formatIndex = getFormatIndex(cell);\n		String formatString = getFormatString(cell);\n\n		if (formatString == null) {\n			return _defaultFormat.format(value);\n		}\n		// Format, using the nice new\n		// HSSFDataFormatter to do the work for us\n		return _formatter.formatRawCellContents(value, formatIndex, formatString);\n	}
237	void setWorkbookReferences(InternalWorkbook book, LabelSSTRecord record) {\n      _book = book;\n      _record = record;\n    }
238	@Internal\n    public WorkbookRecordList getWorkbookRecordList() {\n        return records;\n    }
239	private static void shiftBreaks(PageBreakRecord breaks, int start, int stop, int count) {\n\n        Iterator<PageBreakRecord.Break> iterator = breaks.getBreaksIterator();\n        List<PageBreakRecord.Break> shiftedBreak = new ArrayList<>();\n        while(iterator.hasNext())\n        {\n            PageBreakRecord.Break breakItem = iterator.next();\n            int breakLocation = breakItem.main;\n            boolean inStart = (breakLocation >= start);\n            boolean inEnd = (breakLocation <= stop);\n            if(inStart && inEnd) {\n                shiftedBreak.add(breakItem);\n            }\n        }\n\n        iterator = shiftedBreak.iterator();\n        while (iterator.hasNext()) {\n            PageBreakRecord.Break breakItem = iterator.next();\n            breaks.removeBreak(breakItem.main);\n            breaks.addBreak((short)(breakItem.main+count), breakItem.subFrom, breakItem.subTo);\n        }\n    }
240	public void importFromXML(String xmlInputString) throws SAXException, XPathExpressionException, IOException {\n\n        DocumentBuilder builder = DocumentHelper.newDocumentBuilder();\n\n        Document doc = builder.parse(new InputSource(new StringReader(xmlInputString.trim())));\n\n        List<XSSFSingleXmlCell> singleXmlCells = _map.getRelatedSingleXMLCell();\n\n        List<XSSFTable> tables = _map.getRelatedTables();\n\n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        XPath xpath = xpathFactory.newXPath();\n\n        // Setting namespace context to XPath\n        // Assuming that the namespace prefix in the mapping xpath is the\n        // same as the one used in the document\n        xpath.setNamespaceContext(new DefaultNamespaceContext(doc));\n\n        for (XSSFSingleXmlCell singleXmlCell : singleXmlCells) {\n\n            STXmlDataType.Enum xmlDataType = singleXmlCell.getXmlDataType();\n            String xpathString = singleXmlCell.getXpath();\n            Node result = (Node) xpath.evaluate(xpathString, doc, XPathConstants.NODE);\n            // result can be null if value is optional (xsd:minOccurs=0), see bugzilla 55864\n            if (result != null) {\n                String textContent = result.getTextContent();\n                logger.log(POILogger.DEBUG, "Extracting with xpath " + xpathString + " : value is '" + textContent + "'");\n                XSSFCell cell = singleXmlCell.getReferencedCell();\n                logger.log(POILogger.DEBUG, "Setting '" + textContent + "' to cell " + cell.getColumnIndex() + "-" + cell.getRowIndex() + " in sheet "\n                                                + cell.getSheet().getSheetName());\n                setCellValue(textContent, cell, xmlDataType);\n            }\n        }\n\n        for (XSSFTable table : tables) {\n\n            String commonXPath = table.getCommonXpath();\n            NodeList result = (NodeList) xpath.evaluate(commonXPath, doc, XPathConstants.NODESET);\n            int rowOffset = table.getStartCellReference().getRow() + table.getHeaderRowCount();\n            int columnOffset = table.getStartCellReference().getCol();\n\n            table.setDataRowCount(result.getLength());\n\n            for (int i = 0; i < result.getLength(); i++) {\n\n                // TODO: implement support for denormalized XMLs (see\n                // OpenOffice part 4: chapter 3.5.1.7)\n\n                Node singleNode = result.item(i).cloneNode(true);\n\n                for (XSSFTableColumn tableColumn : table.getColumns()) {\n\n                    XSSFXmlColumnPr xmlColumnPr = tableColumn.getXmlColumnPr();\n                    if(xmlColumnPr == null) {\n                        continue;\n                    }\n\n                    int rowId = rowOffset + i;\n                    int columnId = columnOffset + tableColumn.getColumnIndex();\n                    String localXPath = xmlColumnPr.getLocalXPath();\n                    localXPath = localXPath.substring(localXPath.indexOf('/', 1) + 1);\n\n                    // TODO: convert the data to the cell format\n                    String value = (String) xpath.evaluate(localXPath, singleNode, XPathConstants.STRING);\n                    logger.log(POILogger.DEBUG, "Extracting with xpath " + localXPath + " : value is '" + value + "'");\n                    XSSFRow row = table.getXSSFSheet().getRow(rowId);\n                    if (row == null) {\n                        row = table.getXSSFSheet().createRow(rowId);\n                    }\n\n                    XSSFCell cell = row.getCell(columnId);\n                    if (cell == null) {\n                        cell = row.createCell(columnId);\n                    }\n                    logger.log(POILogger.DEBUG, "Setting '" + value + "' to cell " + cell.getColumnIndex() + "-" + cell.getRowIndex() + " in sheet "\n                                                    + table.getXSSFSheet().getSheetName());\n                    setCellValue(value, cell, xmlColumnPr.getXmlDataType());\n                }\n            }\n        }\n    }
241	public void setFilesystem(Closeable fs) {\n	    fsToClose = fs;\n	}
242	public void process() throws IOException, OpenXML4JException, SAXException {\n        ReadOnlySharedStringsTable strings = new ReadOnlySharedStringsTable(this.xlsxPackage);\n        XSSFReader xssfReader = new XSSFReader(this.xlsxPackage);\n        StylesTable styles = xssfReader.getStylesTable();\n        XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) xssfReader.getSheetsData();\n        int index = 0;\n        while (iter.hasNext()) {\n            try (InputStream stream = iter.next()) {\n                String sheetName = iter.getSheetName();\n                this.output.println();\n                this.output.println(sheetName + " [index=" + index + "]:");\n                processSheet(styles, strings, new SheetToCSV(), stream);\n            }\n            ++index;\n        }\n    }
243	public FileIdCluster addCluster( int dgId, int numShapedUsed, boolean sort ) {\n        FileIdCluster ficNew = new FileIdCluster(dgId, numShapedUsed);\n        field_5_fileIdClusters.add(ficNew);\n        maxDgId = Math.min(maxDgId, dgId);\n        \n        if (sort) {\n            sortCluster();\n        }\n        \n        return ficNew;\n    }
244	public void dump(byte[] data, int offset, int size, PrintStream out) {\n        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory();\n        int pos = offset;\n        while ( pos < offset + size )\n        {\n            EscherRecord r = recordFactory.createRecord(data, pos);\n            int bytesRead = r.fillFields(data, pos, recordFactory );\n            out.println(r);\n            pos += bytesRead;\n        }\n    }
245	public int getPostNumPointersSkip() {\n        return 2;\n    }
246	@Internal\n    public CTWorksheet getCTWorksheet() {\n        return this.worksheet;\n    }
247	static void iconSets(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Icon Sets");\n        Row r = sheet.createRow(1);\n        r.createCell(0).setCellValue("Reds");\n        r.createCell(1).setCellValue(0);\n        r.createCell(2).setCellValue(0);\n        r.createCell(3).setCellValue(0);\n        r = sheet.createRow(2);\n        r.createCell(0).setCellValue("Yellows");\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(5);\n        r.createCell(3).setCellValue(5);\n        r = sheet.createRow(3);\n        r.createCell(0).setCellValue("Greens");\n        r.createCell(1).setCellValue(10);\n        r.createCell(2).setCellValue(10);\n        r.createCell(3).setCellValue(10);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n        CellRangeAddress[] regions = { CellRangeAddress.valueOf("B1:B4") };\n        ConditionalFormattingRule rule1 =\n                sheetCF.createConditionalFormattingRule(IconSet.GYR_3_TRAFFIC_LIGHTS);\n        IconMultiStateFormatting im1 = rule1.getMultiStateFormatting();\n        im1.getThresholds()[0].setRangeType(RangeType.MIN);\n        im1.getThresholds()[1].setRangeType(RangeType.PERCENT);\n        im1.getThresholds()[1].setValue(33d);\n        im1.getThresholds()[2].setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule1);\n        \n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("C1:C4") };\n        ConditionalFormattingRule rule2 =\n                sheetCF.createConditionalFormattingRule(IconSet.GYR_3_FLAGS);\n        IconMultiStateFormatting im2 = rule1.getMultiStateFormatting();\n        im2.getThresholds()[0].setRangeType(RangeType.PERCENT);\n        im2.getThresholds()[0].setValue(0d);\n        im2.getThresholds()[1].setRangeType(RangeType.PERCENT);\n        im2.getThresholds()[1].setValue(33d);\n        im2.getThresholds()[2].setRangeType(RangeType.PERCENT);\n        im2.getThresholds()[2].setValue(67d);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        \n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("D1:D4") };\n        ConditionalFormattingRule rule3 =\n                sheetCF.createConditionalFormattingRule(IconSet.GYR_3_SYMBOLS_CIRCLE);\n        IconMultiStateFormatting im3 = rule1.getMultiStateFormatting();\n        im3.setIconOnly(true);\n        im3.getThresholds()[0].setRangeType(RangeType.MIN);\n        im3.getThresholds()[1].setRangeType(RangeType.NUMBER);\n        im3.getThresholds()[1].setValue(3d);\n        im3.getThresholds()[2].setRangeType(RangeType.NUMBER);\n        im3.getThresholds()[2].setValue(7d);\n        sheetCF.addConditionalFormatting(regions, rule3);\n    }
248	public void setRowStyle(HSSFCellStyle style) {\n        row.setFormatted(true);\n        row.setXFIndex(style.getIndex());\n    }
249	public void setStrikethrough(boolean strike) {\n        getRPr().setStrike(strike ? STTextStrikeType.SNG_STRIKE : STTextStrikeType.NO_STRIKE);\n    }
250	public CTShape findCommentShape(int row, int col){\n        for(XmlObject itm : _items){\n            if(itm instanceof CTShape){\n                CTShape sh = (CTShape)itm;\n                if(sh.sizeOfClientDataArray() > 0){\n                    CTClientData cldata = sh.getClientDataArray(0);\n                    if(cldata.getObjectType() == STObjectType.NOTE){\n                        int crow = cldata.getRowArray(0).intValue();\n                        int ccol = cldata.getColumnArray(0).intValue();\n                        if(crow == row && ccol == col) {\n                            return sh;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }
251	public void setBulletFontFollowText() {\n        getOrCreateBulletProperties().setBulletFontFollowText();\n    }
252	public void setSummaryEntries(DirectoryNode dir, String encryptedStream, POIFSFileSystem entries)\n    throws IOException, GeneralSecurityException {\n        CryptoAPIDocumentOutputStream bos = new CryptoAPIDocumentOutputStream(this); // NOSONAR\n        byte buf[] = new byte[8];\n        \n        bos.write(buf, 0, 8); // skip header\n        List<StreamDescriptorEntry> descList = new ArrayList<>();\n\n        int block = 0;\n        for (Entry entry : entries.getRoot()) {\n            if (entry.isDirectoryEntry()) {\n                continue;\n            }\n            StreamDescriptorEntry descEntry = new StreamDescriptorEntry();\n            descEntry.block = block;\n            descEntry.streamOffset = bos.size();\n            descEntry.streamName = entry.getName();\n            descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);\n            descEntry.reserved2 = 0;\n            \n            bos.setBlock(block);\n            DocumentInputStream dis = dir.createDocumentInputStream(entry);\n            IOUtils.copy(dis, bos);\n            dis.close();\n            \n            descEntry.streamSize = bos.size() - descEntry.streamOffset;\n            descList.add(descEntry);\n            \n            block++;\n        }\n        \n        int streamDescriptorArrayOffset = bos.size();\n        \n        bos.setBlock(0);\n        LittleEndian.putUInt(buf, 0, descList.size());\n        bos.write(buf, 0, 4);\n        \n        for (StreamDescriptorEntry sde : descList) {\n            LittleEndian.putUInt(buf, 0, sde.streamOffset);\n            bos.write(buf, 0, 4);\n            LittleEndian.putUInt(buf, 0, sde.streamSize);\n            bos.write(buf, 0, 4);\n            LittleEndian.putUShort(buf, 0, sde.block);\n            bos.write(buf, 0, 2);\n            LittleEndian.putUByte(buf, 0, (short)sde.streamName.length());\n            bos.write(buf, 0, 1);\n            LittleEndian.putUByte(buf, 0, (short)sde.flags);\n            bos.write(buf, 0, 1);\n            LittleEndian.putUInt(buf, 0, sde.reserved2);\n            bos.write(buf, 0, 4);\n            byte nameBytes[] = StringUtil.getToUnicodeLE(sde.streamName);\n            bos.write(nameBytes, 0, nameBytes.length);\n            LittleEndian.putShort(buf, 0, (short)0); // null-termination\n            bos.write(buf, 0, 2);\n        }\n        \n        int savedSize = bos.size();\n        int streamDescriptorArraySize = savedSize - streamDescriptorArrayOffset;\n        LittleEndian.putUInt(buf, 0, streamDescriptorArrayOffset);\n        LittleEndian.putUInt(buf, 4, streamDescriptorArraySize);\n\n        bos.reset();\n        bos.setBlock(0);\n        bos.write(buf, 0, 8);\n        bos.setSize(savedSize);\n        \n        dir.createDocument(encryptedStream, new ByteArrayInputStream(bos.getBuf(), 0, savedSize));\n    }
253	private int unsignedInt(byte b) {\n    	return 0xFF & b;\n    }
254	public SheetBuilder setCreateEmptyCells(boolean shouldCreateEmptyCells) {\n        this.shouldCreateEmptyCells = shouldCreateEmptyCells;\n        return this;\n    }
255	private static CTWorksheet newSheet(){\n        CTWorksheet worksheet = CTWorksheet.Factory.newInstance();\n        CTSheetFormatPr ctFormat = worksheet.addNewSheetFormatPr();\n        ctFormat.setDefaultRowHeight(DEFAULT_ROW_HEIGHT);\n\n        CTSheetView ctView = worksheet.addNewSheetViews().addNewSheetView();\n        ctView.setWorkbookViewId(0);\n\n        worksheet.addNewDimension().setRef("A1");\n\n        worksheet.addNewSheetData();\n\n        CTPageMargins ctMargins = worksheet.addNewPageMargins();\n        ctMargins.setBottom(DEFAULT_MARGIN_BOTTOM);\n        ctMargins.setFooter(DEFAULT_MARGIN_FOOTER);\n        ctMargins.setHeader(DEFAULT_MARGIN_HEADER);\n        ctMargins.setLeft(DEFAULT_MARGIN_LEFT);\n        ctMargins.setRight(DEFAULT_MARGIN_RIGHT);\n        ctMargins.setTop(DEFAULT_MARGIN_TOP);\n\n        return worksheet;\n    }
256	public PackageRelationshipCollection getRelationships()\n            throws InvalidFormatException {\n        return getRelationshipsCore(null);\n    }
257	public boolean equalsContents(final Object o) {\n        final CustomProperty c = (CustomProperty) o;\n        final String name1 = c.getName();\n        final String name2 = this.getName();\n        boolean equalNames = true;\n        if (name1 == null) {\n            equalNames = name2 == null;\n        } else {\n            equalNames = name1.equals(name2);\n        }\n        return equalNames && c.getID() == this.getID()\n                && c.getType() == this.getType()\n                && c.getValue().equals(this.getValue());\n    }
258	@SuppressWarnings("unchecked")\n    public final <T extends TextProp> T addWithName(final String name) {\n        // Find the base TextProp to base on\n        T existing = findByName(name);\n        if (existing != null) return existing;\n        \n        // Add a copy of this property\n        T textProp = (T)validatePropName(name).clone();\n        textProps.put(name,textProp);\n        return textProp;\n    }
259	public void fillOval(int x, int y, int width, int height){\n        Ellipse2D oval = new Ellipse2D.Double(x, y, width, height);\n        fill(oval);\n    }
260	public boolean isRowBroken(int row) {\n        return getRowBreaksRecord().getBreak(row) != null;\n    }
261	public static int fromByte(byte b) {\n      if(b >= 0) {\n         return b;\n      }\n      return b + 256;\n   }
262	public static List<HSLFHyperlink> find(HSLFTextShape shape){\n        return find(shape.getTextParagraphs());\n    }
263	private static short getShort(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n        return 0;\n    }
264	public static <T extends EscherRecord> T getEscherChild(EscherContainerRecord owner, int recordId){\n        return owner.getChildById((short)recordId);\n    }
265	public HSSFColor findColor(byte red, byte green, byte blue)\n    {\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        for (short i = PaletteRecord.FIRST_COLOR_INDEX; b != null;\n            b = _palette.getColor(++i))\n        {\n            if (b[0] == red && b[1] == green && b[2] == blue)\n            {\n                return new CustomColor(i, b);\n            }\n        }\n        return null;\n    }
266	public void shiftColumnBreaks(short startingCol, short endingCol, short count) {\n        shiftBreaks(getColumnBreaksRecord(), startingCol, endingCol, count);\n    }
267	@SuppressWarnings("unchecked")\n    public DOMSignedInfo preSign(final DOMSignContext xmlSignContext)\n    throws XMLSignatureException, MarshalException {\n        signatureConfig.init(false);\n\n        final Document document = (Document)xmlSignContext.getParent();\n\n        // it's necessary to explicitly set the mdssi namespace, but the sign() method has no\n        // normal way to interfere with, so we need to add the namespace under the hand ...\n        EventTarget target = (EventTarget)document;\n        EventListener creationListener = signatureConfig.getSignatureMarshalListener();\n        if (creationListener != null) {\n            if (creationListener instanceof SignatureMarshalListener) {\n                ((SignatureMarshalListener)creationListener).setEventTarget(target);\n            }\n            SignatureMarshalListener.setListener(target, creationListener, true);\n        }\n\n        /*\n         * Signature context construction.\n         */\n        URIDereferencer uriDereferencer = signatureConfig.getUriDereferencer();\n        if (null != uriDereferencer) {\n            xmlSignContext.setURIDereferencer(uriDereferencer);\n        }\n\n        for (Map.Entry<String,String> me : signatureConfig.getNamespacePrefixes().entrySet()) {\n            xmlSignContext.putNamespacePrefix(me.getKey(), me.getValue());\n        }\n        xmlSignContext.setDefaultNamespacePrefix("");\n        // signatureConfig.getNamespacePrefixes().get(XML_DIGSIG_NS));\n\n        XMLSignatureFactory signatureFactory = signatureConfig.getSignatureFactory();\n\n        /*\n         * Add ds:References that come from signing client local files.\n         */\n        List<Reference> references = new ArrayList<>();\n\n        /*\n         * Invoke the signature facets.\n         */\n        List<XMLObject> objects = new ArrayList<>();\n        for (SignatureFacet signatureFacet : signatureConfig.getSignatureFacets()) {\n            LOG.log(POILogger.DEBUG, "invoking signature facet: " + signatureFacet.getClass().getSimpleName());\n            signatureFacet.preSign(document, references, objects);\n        }\n\n        /*\n         * ds:SignedInfo\n         */\n        SignedInfo signedInfo;\n        try {\n            SignatureMethod signatureMethod = signatureFactory.newSignatureMethod\n                (signatureConfig.getSignatureMethodUri(), null);\n            CanonicalizationMethod canonicalizationMethod = signatureFactory\n                .newCanonicalizationMethod(signatureConfig.getCanonicalizationMethod(),\n                (C14NMethodParameterSpec) null);\n            signedInfo = signatureFactory.newSignedInfo(\n                canonicalizationMethod, signatureMethod, references);\n        } catch (GeneralSecurityException e) {\n            throw new XMLSignatureException(e);\n        }\n\n        /*\n         * JSR105 ds:Signature creation\n         */\n        String signatureValueId = signatureConfig.getPackageSignatureId() + "-signature-value";\n        javax.xml.crypto.dsig.XMLSignature xmlSignature = signatureFactory\n            .newXMLSignature(signedInfo, null, objects, signatureConfig.getPackageSignatureId(),\n            signatureValueId);\n\n        /*\n         * ds:Signature Marshalling.\n         */\n        xmlSignature.sign(xmlSignContext);\n\n        /*\n         * Completion of undigested ds:References in the ds:Manifests.\n         */\n        for (XMLObject object : objects) {\n            LOG.log(POILogger.DEBUG, "object java type: " + object.getClass().getName());\n            List<XMLStructure> objectContentList = object.getContent();\n            for (XMLStructure objectContent : objectContentList) {\n                LOG.log(POILogger.DEBUG, "object content java type: " + objectContent.getClass().getName());\n                if (!(objectContent instanceof Manifest)) {\n                    continue;\n                }\n                Manifest manifest = (Manifest) objectContent;\n                List<Reference> manifestReferences = manifest.getReferences();\n                for (Reference manifestReference : manifestReferences) {\n                    if (manifestReference.getDigestValue() != null) {\n                        continue;\n                    }\n\n                    DOMReference manifestDOMReference = (DOMReference)manifestReference;\n                    manifestDOMReference.digest(xmlSignContext);\n                }\n            }\n        }\n\n        /*\n         * Completion of undigested ds:References.\n         */\n        List<Reference> signedInfoReferences = signedInfo.getReferences();\n        for (Reference signedInfoReference : signedInfoReferences) {\n            DOMReference domReference = (DOMReference)signedInfoReference;\n\n            // ds:Reference with external digest value\n            if (domReference.getDigestValue() != null) {\n                continue;\n            }\n\n            domReference.digest(xmlSignContext);\n        }\n\n        return (DOMSignedInfo)signedInfo;\n    }
268	private void outputCompressed(OutputStream res) throws IOException {\n	// It's not worth compressing only 1 or two bytes,\n	//  due to the overheads\n	// So if asked, just output uncompressed\n	if(rawCodeLen < 3) {\n		for(int i=0; i<rawCodeLen; i++) {\n			outputUncompressed(rawCode[i], res);\n		}\n		return;\n	}\n	\n	// Grab where the data lives\n	int codesAt = findRawCodeInBuffer();\n   codesAt -= 18;\n	if(codesAt < 0) {\n	   codesAt += 4096;\n	}\n\n	// Increment the mask bit count, we've done another code\n	maskBitsSet++;\n	\n	// Add the length+code to the buffer\n	// (The position is the first 12 bits, the\n	//  length is the last 4 bits)\n	int bp1 = (codesAt & 255);\n	int bp2 = (rawCodeLen-3) + ((codesAt-bp1) >> 4);\n	buffer[bufferLen] = HDGFLZW.fromInt(bp1);\n	bufferLen++;\n   buffer[bufferLen] = HDGFLZW.fromInt(bp2);\n   bufferLen++;\n   \n   // Copy the data to the dictionary in the new place\n   for(int i=0; i<rawCodeLen; i++) {\n      dict[(posOut&4095)] = rawCode[i];\n      posOut++; \n   }\n\n	// If we're now at 8 codes, output\n	if(maskBitsSet == 8) {\n		output8Codes(res);\n	}\n}
269	private void init() {\n		// First up is the size, in 4 bytes, which is fixed\n		// Then is the header\n		\n	    isEncrypted = (LittleEndian.getInt(encHeaderToken) == LittleEndian.getInt(_contents,12)); \n	    \n		// Grab the edit offset\n		currentEditOffset = LittleEndian.getUInt(_contents,16);\n\n		// Grab the versions\n		docFinalVersion = LittleEndian.getUShort(_contents,22);\n		docMajorNo = _contents[24];\n		docMinorNo = _contents[25];\n\n		// Get the username length\n		long usernameLen = LittleEndian.getUShort(_contents,20);\n		if(usernameLen > 512) {\n			// Handle the case of it being garbage\n			logger.log(POILogger.WARN, "Warning - invalid username length " + usernameLen + " found, treating as if there was no username set");\n			usernameLen = 0;\n		}\n\n		// Now we know the length of the username, \n		//  use this to grab the revision\n		if(_contents.length >= 28+(int)usernameLen + 4) {\n			releaseVersion = LittleEndian.getUInt(_contents,28+(int)usernameLen);\n		} else {\n			// No revision given, as not enough data. Odd\n			releaseVersion = 0;\n		}\n\n		// Grab the unicode username, if stored\n		int start = 28+(int)usernameLen+4;\n		int len = 2*(int)usernameLen;\n\n		if(_contents.length >= start+len) {\n			byte[] textBytes = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n			System.arraycopy(_contents,start,textBytes,0,len);\n			lastEditUser = StringUtil.getFromUnicodeLE(textBytes);\n		} else {\n			// Fake from the 8 bit version\n			byte[] textBytes = IOUtils.safelyAllocate(usernameLen, MAX_RECORD_LENGTH);\n			System.arraycopy(_contents,28,textBytes,0,(int)usernameLen);\n			lastEditUser = StringUtil.getFromCompressedUnicode(textBytes,0,(int)usernameLen);\n		}\n	}
270	@Internal\n    public boolean isFLegal()\n    {\n        return fLegal.isSet(field_3_info);\n    }
271	public static PropertySet create(final DirectoryEntry dir, final String name)\n    throws FileNotFoundException, NoPropertySetStreamException, IOException, UnsupportedEncodingException {\n        InputStream inp = null;\n        try {\n            DocumentEntry entry = (DocumentEntry)dir.getEntry(name);\n            inp = new DocumentInputStream(entry);\n            try {\n                return create(inp);\n            } catch (MarkUnsupportedException e) {\n                return null;\n            }\n        } finally {\n            if (inp != null) {\n                inp.close();\n            }\n        }\n    }
272	public XWPFParagraph getParagraph(CTP p) {\n        for (XWPFParagraph paragraph : paragraphs) {\n            if (paragraph.getCTP().equals(p))\n                return paragraph;\n        }\n        return null;\n    }
273	protected EmbeddedObjectRefSubRecord findObjectRecord() {\n        Iterator<SubRecord> subRecordIter = getObjRecord().getSubRecords().iterator();\n\n        while (subRecordIter.hasNext()) {\n            Object subRecord = subRecordIter.next();\n            if (subRecord instanceof EmbeddedObjectRefSubRecord) {\n                return (EmbeddedObjectRefSubRecord) subRecord;\n            }\n        }\n\n        throw new IllegalStateException("Object data does not contain a reference to an embedded object OLE2 directory");\n    }
274	int getSatOff(){\n        return getPercentageValue("satOff");\n    }
275	public String suggestFullFileName()\n    {\n        String fileExt = suggestFileExtension();\n        return Integer.toHexString( dataBlockStartOfsset )\n                + ( fileExt.length() > 0 ? "." + fileExt : "" );\n    }
276	public static void main(String[] args) throws IOException, OpenXML4JException {\n        UpdateEmbeddedDoc ued = new UpdateEmbeddedDoc(args[0]);\n        ued.updateEmbeddedDoc();\n        ued.checkUpdatedDoc();\n    }
277	public void setParentTextSize(int size) {\n        if (initialised) {\n            return;\n        }\n        \n        int pos = 0;\n        int textHandled = 0;\n\n        paragraphStyles.clear();\n        charStyles.clear();\n        \n        // While we have text in need of paragraph stylings, go ahead and\n        // grok the contents as paragraph formatting data\n        int prsize = size;\n        while(pos < rawContents.length && textHandled < prsize) {\n            // First up, fetch the number of characters this applies to\n            int textLen = LittleEndian.getInt(rawContents,pos);\n            textLen = checkTextLength(textLen, textHandled, size);\n            textHandled += textLen;\n            pos += 4;\n\n            short indent = LittleEndian.getShort(rawContents,pos);\n            pos += 2;\n\n            // Grab the 4 byte value that tells us what properties follow\n            int paraFlags = LittleEndian.getInt(rawContents,pos);\n            pos += 4;\n\n            // Now make sense of those properties\n            TextPropCollection thisCollection = new TextPropCollection(textLen, TextPropType.paragraph);\n            thisCollection.setIndentLevel(indent);\n            int plSize = thisCollection.buildTextPropList(paraFlags, rawContents, pos);\n            pos += plSize;\n\n            // Save this properties set\n            paragraphStyles.add(thisCollection);\n\n            // Handle extra 1 paragraph styles at the end\n            if(pos < rawContents.length && textHandled == size) {\n                prsize++;\n            }\n\n        }\n        if (rawContents.length > 0 && textHandled != (size+1)){\n            logger.log(POILogger.WARN, "Problem reading paragraph style runs: textHandled = " + textHandled + ", text.size+1 = " + (size+1));\n        }\n\n        // Now do the character stylings\n        textHandled = 0;\n        int chsize = size;\n        while(pos < rawContents.length && textHandled < chsize) {\n            // First up, fetch the number of characters this applies to\n            int textLen = LittleEndian.getInt(rawContents,pos);\n            textLen = checkTextLength(textLen, textHandled, size);\n            textHandled += textLen;\n            pos += 4;\n\n            // Grab the 4 byte value that tells us what properties follow\n            int charFlags = LittleEndian.getInt(rawContents,pos);\n            pos += 4;\n\n            // Now make sense of those properties\n            // (Assuming we actually have some)\n            TextPropCollection thisCollection = new TextPropCollection(textLen, TextPropType.character);\n            int chSize = thisCollection.buildTextPropList(charFlags, rawContents, pos);\n            pos += chSize;\n\n            // Save this properties set\n            charStyles.add(thisCollection);\n\n            // Handle extra 1 char styles at the end\n            if(pos < rawContents.length && textHandled == size) {\n                chsize++;\n            }\n        }\n        if (rawContents.length > 0 && textHandled != (size+1)){\n            logger.log(POILogger.WARN, "Problem reading character style runs: textHandled = " + textHandled + ", text.size+1 = " + (size+1));\n        }\n\n        // Handle anything left over\n        if(pos < rawContents.length) {\n            reserved = IOUtils.safelyAllocate(rawContents.length-pos, rawContents.length);\n            System.arraycopy(rawContents,pos,reserved,0,reserved.length);\n        }\n\n        initialised = true;\n    }
278	protected static String parseAs7BitData(byte[] data, String encoding) {\n        // Handle any encoding aliases, where outlook describes it differently\n        if ("ansi".equals(encoding)) {\n            encoding = DEFAULT_ENCODING;\n        }\n\n        // Decode\n        return new String(data, Charset.forName(encoding));\n    }
279	private LinkTable getOrCreateLinkTable() {\n        if(linkTable == null) {\n            linkTable = new LinkTable((short) getNumSheets(), records);\n        }\n        return linkTable;\n    }
280	public void removeExFormatRecord(ExtendedFormatRecord rec) {\n        records.remove(rec); // this updates XfPos for us\n        numxfs--;\n    }
281	public int getByteCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_BYTECOUNT);\n    }
282	public void write(byte[] b) {}
283	protected void onDocumentRemove() throws IOException {\n\n    }
284	public static ChunkHeader createChunkHeader(int documentVersion, byte[] data, int offset) {\n		if(documentVersion >= 6) {\n			ChunkHeaderV6 ch;\n			if(documentVersion > 6) {\n				ch = new ChunkHeaderV11();\n			} else {\n				ch = new ChunkHeaderV6();\n			}\n			ch.setType((int)LittleEndian.getUInt(data, offset + 0));\n			ch.setId((int)LittleEndian.getUInt(data, offset + 4));\n			ch.setUnknown1((int)LittleEndian.getUInt(data, offset + 8));\n			ch.setLength((int)LittleEndian.getUInt(data, offset + 12));\n			ch.setUnknown2(LittleEndian.getShort(data, offset + 16));\n			ch.setUnknown3(LittleEndian.getUByte(data, offset + 18));\n\n			return ch;\n		} else if(documentVersion == 5 || documentVersion == 4) {\n			ChunkHeaderV4V5 ch = new ChunkHeaderV4V5();\n\n			ch.setType(LittleEndian.getShort(data, offset + 0));\n			ch.setId(LittleEndian.getShort(data, offset + 2));\n			ch.setUnknown2(LittleEndian.getUByte(data, offset + 4));\n			ch.setUnknown3(LittleEndian.getUByte(data, offset + 5));\n			ch.setUnknown1(LittleEndian.getShort(data, offset + 6));\n			ch.setLength((int)LittleEndian.getUInt(data, offset + 8));\n\n			return ch;\n		} else {\n			throw new IllegalArgumentException("Visio files with versions below 4 are not supported, yours was " + documentVersion);\n		}\n	}
285	static int getCopyLenBits(int offset) {\n        for (int n = 11; n >= 4; n--) {\n            if ((offset & POWER2[n]) != 0) {\n                return 15 - n;\n            }\n        }\n        return 12;\n    }
286	private void readCurrentUserStream() {\n        try {\n            currentUser = new CurrentUserAtom(getDirectory());\n        } catch (IOException ie) {\n            logger.log(POILogger.ERROR, "Error finding Current User Atom:\n" + ie);\n            currentUser = new CurrentUserAtom();\n        }\n    }
287	byte[] getHashMagic() {\n        // in an earlier release the hashMagic (aka DigestAlgorithmIdentifier) contained only\n        // an object identifier, but to conform with the header generated by the\n        // javax-signature API, the empty <associated parameters> are also included\n        try {\n            final byte[] oidBytes = new Oid(algo.rsaOid).getDER();\n\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            bos.write(0x30);\n            bos.write(algo.hashSize+oidBytes.length+6);\n            bos.write(0x30);\n            bos.write(oidBytes.length+2);\n            bos.write(oidBytes);\n            bos.write(new byte[] {5,0,4});\n            bos.write(algo.hashSize);\n            \n            return bos.toByteArray();\n        } catch (GSSException|IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }
288	private void addLanguage() {\n        setElementTextContent(KEYWORD_LANGUAGE, namespaceDC, propsPart.getLanguageProperty());\n	}
289	public static Record[] findChildRecords(byte[] b, int start, int len) {\n		List<Record> children = new ArrayList<>(5);\n\n		// Jump our little way along, creating records as we go\n		int pos = start;\n		while(pos <= (start+len-8)) {\n			long type = LittleEndian.getUShort(b,pos+2);\n			long rlen = LittleEndian.getUInt(b,pos+4);\n\n			// Sanity check the length\n			int rleni = (int)rlen;\n			if(rleni < 0) { rleni = 0; }\n\n			// Abort if first record is of type 0000 and length FFFF,\n			//  as that's a sign of a screwed up record\n			if(pos == 0 && type == 0L && rleni == 0xffff) {\n				throw new CorruptPowerPointFileException("Corrupt document - starts with record of type 0000 and length 0xFFFF");\n			}\n\n			Record r = createRecordForType(type,b,pos,8+rleni);\n			if(r != null) {\n				children.add(r);\n			}\n			pos += 8;\n			pos += rleni;\n		}\n\n		// Turn the vector into an array, and return\n        return children.toArray( new Record[children.size()] );\n	}
290	protected final void rebase(OPCPackage pkg) throws InvalidFormatException {\n        PackageRelationshipCollection cores =\n                packagePart.getRelationshipsByType(coreDocumentRel);\n        if (cores.size() != 1) {\n            throw new IllegalStateException(\n                    "Tried to rebase using " + coreDocumentRel +\n                            " but found " + cores.size() + " parts of the right type"\n            );\n        }\n        packagePart = packagePart.getRelatedPart(cores.getRelationship(0));\n    }
291	public void clear() {\n    }
292	public void addRule(HSSFConditionalFormattingRule cfRule) {\n        cfAggregate.addRule(cfRule.getCfRuleRecord());\n    }
293	public ASN1ObjectIdentifier mapDigestAlgoToOID(HashAlgorithm digestAlgo) {\n        switch (digestAlgo) {\n        case sha1:   return X509ObjectIdentifiers.id_SHA1;\n        case sha256: return NISTObjectIdentifiers.id_sha256;\n        case sha384: return NISTObjectIdentifiers.id_sha384;\n        case sha512: return NISTObjectIdentifiers.id_sha512;\n        default:\n            throw new IllegalArgumentException("unsupported digest algo: " + digestAlgo);\n        }\n    }
294	public RoundTripHFPlaceholder12 getHFPlaceholderAtom() {\n        // special case for files saved in Office 2007\n        return getClientDataRecord(RoundTripHFPlaceholder12.typeID);\n    }
295	public void listInCell(HSSFWorkbook workbook, ArrayList<String> listItems, HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n        for(String listItem : listItems) {\n            buffer.append(listItem);\n            buffer.append("\n");\n        }\n        // The StringBuffer's contents are the source for the contents\n        // of the cell.\n        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
296	public static Ptg[] parseFormula(String formula, HSSFSheet sheet) {\n        if(formula == null) {\n            return null;\n        }\n        int sheetIndex = sheet.getWorkbook().getSheetIndex(sheet);\n        return HSSFFormulaParser.parse(formula, sheet.getWorkbook(), FormulaType.CELL, sheetIndex);\n    }
297	private void sanityCheckStartEnd() {\n		if (_start < 0) {\n			throw new IllegalArgumentException("Range start must not be negative. Given " + _start);\n		}\n		if (_end < _start) {\n			throw new IllegalArgumentException("The end (" + _end\n					+ ") must not be before the start (" + _start + ")");\n		}\n	}
298	public int readInt() throws IOException {\n        return readInt(this);\n    }
299	public boolean isSupportedType(final int variantType) {\n        for (int st : SUPPORTED_TYPES) {\n            if (variantType == st) {\n                return true;\n            }\n        }\n        return false;\n    }
300	public boolean isAutofill()\n    {\n        return autofill.isSet(field_3_option);\n    }
301	public void extractAttachments(File dir) throws IOException {\n        int count = 0;\n        for(Attachment att : message.getAttachments()) {\n            count++;\n            \n            // Decide what to call it\n            String filename = att.getLongFilename();\n            if(filename == null || filename.length() == 0) {\n                filename = att.getFilename();\n            }\n            if(filename == null || filename.length() == 0) {\n                filename = "attachment" + count;\n                if(att.getExtension() != null) {\n                    filename += att.getExtension();\n                }\n            }\n            \n            // Save it\n            File file = new File(dir, filename);\n            OutputStream fout = new FileOutputStream(file);\n            try {\n                fout.write( att.getContents() );\n            } finally {\n                fout.close();\n            }\n        }\n    }
302	public XWPFParagraph createParagraph() {\n        XWPFParagraph paragraph = new XWPFParagraph(headerFooter.addNewP(), this);\n        paragraphs.add(paragraph);\n        bodyElements.add(paragraph);\n        return paragraph;\n    }
303	private XSSFGraphicFrame createGraphicFrame(XSSFClientAnchor anchor) {\n        CTTwoCellAnchor ctAnchor = createTwoCellAnchor(anchor);\n        CTGraphicalObjectFrame ctGraphicFrame = ctAnchor.addNewGraphicFrame();\n        ctGraphicFrame.set(XSSFGraphicFrame.prototype());\n        ctGraphicFrame.setXfrm(createXfrm(anchor));\n\n        long frameId = numOfGraphicFrames++;\n        XSSFGraphicFrame graphicFrame = new XSSFGraphicFrame(this, ctGraphicFrame);\n        graphicFrame.setAnchor(anchor);\n        graphicFrame.setId(frameId);\n        graphicFrame.setName("Diagramm" + frameId);\n        return graphicFrame;\n    }
304	public final void addProp(TextProp textProp) {\n	    if (textProp == null) {\n	        throw new HSLFException("TextProp must not be null");\n	    }\n\n	    String propName = textProp.getName();\n	    validatePropName(propName);\n	    \n	    textProps.put(propName, textProp);\n	}
305	protected XSLFTextRun newTextRun(XmlObject r) {\n        return new XSLFTextRun(r, this);\n    }
306	public static void main(String[] args) {\n		if(args.length <= 0) {\n			System.err.println("No files names provided");\n		} else {\n			for (String arg : args) {\n				try {\n					Msg2txt processor = new Msg2txt(arg);\n					processor.processMessage();\n				} catch (IOException e) {\n					System.err.println("Could not process " + arg + ": " + e);\n				}\n			}\n		}\n	}
307	public void deletePartRecursive(PackagePartName partName) {\n		if (partName == null || !this.containPart(partName)) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		PackagePart partToDelete = this.getPart(partName);\n		// Remove the part\n		this.removePart(partName);\n		// Remove all relationship parts associated\n		try {\n			for (PackageRelationship relationship : partToDelete\n					.getRelationships()) {\n				PackagePartName targetPartName = PackagingURIHelper\n						.createPartName(PackagingURIHelper.resolvePartUri(\n								partName.getURI(), relationship.getTargetURI()));\n				this.deletePartRecursive(targetPartName);\n			}\n		} catch (InvalidFormatException e) {\n			logger.log(POILogger.WARN, "An exception occurs while deleting part '"\n					+ partName.getName()\n					+ "'. Some parts may remain in the package. - "\n					+ e.getMessage());\n			return;\n		}\n		// Remove the relationships part\n		PackagePartName relationshipPartName = PackagingURIHelper\n				.getRelationshipPartName(partName);\n		if (relationshipPartName != null && containPart(relationshipPartName)) {\n			this.removePart(relationshipPartName);\n		}\n	}
308	public void swapFontUse(short oldFontIndex, short newFontIndex) {\n        for (FormatRun run : field_4_format_runs) {\n            if(run._fontIndex == oldFontIndex) {\n                run._fontIndex = newFontIndex;\n            }\n        }\n    }
309	public int getCbMac()\n    {\n        return _fibRgLw.getCbMac();\n    }
310	public void read(final File poifsFile) throws IOException {\n        try (POIFSFileSystem poifs = new POIFSFileSystem(poifsFile, true)) {\n            read(poifs);\n        }\n    }
311	@Internal\n    public boolean isFFitText()\n    {\n        return fFitText.isSet(field_1_rgf);\n    }
312	public void removeBuiltinRecord(byte name, int sheetIndex) {\n        linkTable.removeBuiltinRecord(name, sheetIndex);\n        // TODO - do we need "this.records.remove(...);" similar to that in this.removeName(int namenum) {}?\n    }
313	int getAlphaOff(){\n        return getPercentageValue("alphaOff");\n    }
314	protected void fillSheet(XSSFSheet sheet, XDDFDataSource<?> categoryData, XDDFNumericalDataSource<?> valuesData) {\n        int numOfPoints = categoryData.getPointCount();\n        for (int i = 0; i < numOfPoints; i++) {\n            XSSFRow row = this.getRow(sheet, i + 1); // first row is for title\n            this.getCell(row, categoryData.getColIndex()).setCellValue(categoryData.getPointAt(i).toString());\n            this.getCell(row, valuesData.getColIndex()).setCellValue(valuesData.getPointAt(i).doubleValue());\n        }\n    }
315	public XSSFTextParagraph addNewTextParagraph(String text) {\n        XSSFTextParagraph paragraph = addNewTextParagraph();\n        paragraph.addNewTextRun().setText(text);\n        return paragraph;\n    }
316	public int addChildBefore(Record newChild, Record before) {\n		// Decide where we're going to put it\n		int loc = findChildLocation(before);\n		if(loc == -1) {\n			throw new IllegalArgumentException("Asked to add a new child before another record, but that record wasn't one of our children!");\n		}\n\n		// Add at the place of the supplied record\n		addChildAt(newChild, loc);\n		return loc;\n	}
317	@Internal\n    public boolean isFPersonalCompose()\n    {\n        return fPersonalCompose.isSet(field_5_grfstd);\n    }
318	public String toString() {\n        String nl = System.getProperty("line.separtor");\n\n        StringBuilder result = new StringBuilder();\n        result.append('[').append(getRecordName()).append(']').append(nl);\n        for (EscherRecord escherRecord : getEscherRecords()) {\n            result.append(escherRecord);\n        }\n        result.append("[/").append(getRecordName()).append(']').append(nl);\n\n        return result.toString();\n    }
319	protected void addFunction(String name, FreeRefFunction func) {\n        xlsMacroList.put(name, func);\n    }
320	public static String getDigestMethodUri(HashAlgorithm digestAlgo) {\n        switch (digestAlgo) {\n        case sha1:   return DigestMethod.SHA1;\n        case sha224: return DigestMethod_SHA224;\n        case sha256: return DigestMethod.SHA256;\n        case sha384: return DigestMethod_SHA384;\n        case sha512: return DigestMethod.SHA512;\n        case ripemd160: return DigestMethod.RIPEMD160;\n        default: throw new EncryptedDocumentException("Hash algorithm "\n            +digestAlgo+" not supported for signing.");\n        }\n    }
321	void terminate() {\n		_ulrOutput.terminate();\n	}
322	public boolean isAutomaticCategoryCrossing()\n    {\n        return automaticCategoryCrossing.isSet(field_6_options);\n    }
323	public boolean addRow(XWPFTableRow row, int pos) {\n        if (pos >= 0 && pos <= tableRows.size()) {\n            ctTbl.insertNewTr(pos);\n            ctTbl.setTrArray(pos, row.getCtRow());\n            tableRows.add(pos, row);\n            return true;\n        }\n        return false;\n    }
324	public String getText(boolean getSlideText, boolean getNoteText) {\n		return getText(getSlideText,getNoteText,commentsByDefault,masterByDefault);\n	}
325	public String getFileName() {\n        EscherComplexProperty propFile = getOptRecord().lookup(\n                      EscherProperties.BLIP__BLIPFILENAME);\n        return (null == propFile)\n            ? ""\n            : StringUtil.getFromUnicodeLE(propFile.getComplexData()).trim();\n    }
326	public int size()\n    {\n        return _crun;\n    }
327	protected XSLFTextParagraph newTextParagraph(CTTextParagraph p) {\n        return new XSLFTextParagraph(p, this);\n    }
328	public boolean isCommited() {\n        return isCommited;\n    }
329	@Internal\n    public XWPFEndnote addEndnote(CTFtnEdn note) {\n        XWPFEndnote endnote = new XWPFEndnote(this, note);\n        endnotes.addEndnote(note);\n        return endnote;\n    }
330	public boolean equalsInverted(ClassID o) {\n        return\n            o.bytes[0] == bytes[3] &&\n            o.bytes[1] == bytes[2] &&\n            o.bytes[2] == bytes[1] &&\n            o.bytes[3] == bytes[0] &&\n            o.bytes[4] == bytes[5] &&\n            o.bytes[5] == bytes[4] &&\n            o.bytes[6] == bytes[7] &&\n            o.bytes[7] == bytes[6] &&\n            o.bytes[8] == bytes[8] &&\n            o.bytes[9] == bytes[9] &&\n            o.bytes[10] == bytes[10] &&\n            o.bytes[11] == bytes[11] &&\n            o.bytes[12] == bytes[12] &&\n            o.bytes[13] == bytes[13] &&\n            o.bytes[14] == bytes[14] &&\n            o.bytes[15] == bytes[15]\n        ;\n    }
331	public void removeInsideVBorder() {\n        removeBorder(Border.INSIDE_V);\n    }
332	public static InternalSheet createSheet() {\n        return new InternalSheet();\n    }
333	protected EvaluationCell toEvaluationCell(Cell cell) {\n        if (!(cell instanceof XSSFCell)){\n            throw new IllegalArgumentException("Unexpected type of cell: " + cell.getClass() + "." +\n                    " Only XSSFCells can be evaluated.");\n        }\n\n        return new XSSFEvaluationCell((XSSFCell)cell);\n    }
334	public void groupColumnRange(int fromColumn, int toColumn, boolean indent) {\n\n        // Set the level for each column\n        _columnInfos.groupColumnRange( fromColumn, toColumn, indent);\n\n        // Determine the maximum overall level\n        int maxLevel = _columnInfos.getMaxOutlineLevel();\n\n        GutsRecord guts = getGutsRecord();\n        guts.setColLevelMax( (short) ( maxLevel+1 ) );\n        if (maxLevel == 0) {\n            guts.setTopColGutter( (short)0 );\n        } else {\n            guts.setTopColGutter( (short) ( 29 + (12 * (maxLevel-1)) ) );\n        }\n    }
335	public int getHiddenCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_HIDDENCOUNT);\n    }
336	@Internal\n    public boolean isFHasOriginalStyle()\n    {\n        return fHasOriginalStyle.isSet(field_3_info3);\n    }
337	public void setBuiltinStyle(int builtinStyleId) {\n		field_1_xf_index = isBuiltinFlag.set(field_1_xf_index);\n		field_2_builtin_style = builtinStyleId;\n	}
338	public void setVanish(boolean value) {\n        CTRPr pr = getRunProperties(true);\n        CTOnOff vanish = pr.isSetVanish() ? pr.getVanish() : pr.addNewVanish();\n        vanish.setVal(value ? STOnOff.TRUE : STOnOff.FALSE);\n    }
339	private static String unescapeString(CharSequence text) {\n        int len = text.length();\n        StringBuilder sb = new StringBuilder(len);\n        int i = 0;\n        while (i < len) {\n            char ch = text.charAt(i);\n            if (ch == '\'') {\n                // every quote must be followed by another\n                i++;\n                if (i >= len) {\n                    return null;\n                }\n                ch = text.charAt(i);\n                if (ch != '\'') {\n                    return null;\n                }\n            }\n            sb.append(ch);\n            i++;\n        }\n        return sb.toString();\n    }
340	public XSSFTextBox createTextbox(XSSFChildAnchor anchor){\n        CTShape ctShape = ctGroup.addNewSp();\n        ctShape.set(XSSFSimpleShape.prototype());\n\n        XSSFTextBox shape = new XSSFTextBox(getDrawing(), ctShape);\n        shape.parent = this;\n        shape.anchor = anchor;\n        shape.setXfrm(anchor.getCTTransform2D());\n        return shape;\n\n    }
341	public HeadersFootersAtom getHeadersFootersAtom(){\n        return hdAtom;\n    }
342	public void processRecordInternally(Record record) {\n		if (record instanceof FormatRecord) {\n			FormatRecord fr = (FormatRecord) record;\n			_customFormatRecords.put(Integer.valueOf(fr.getIndexCode()), fr);\n		}\n		if (record instanceof ExtendedFormatRecord) {\n			ExtendedFormatRecord xr = (ExtendedFormatRecord) record;\n			_xfRecords.add(xr);\n		}\n	}
343	protected List<? extends Record> getClientRecords() {\n        HSLFEscherClientDataRecord clientData = getClientData(false);\n        return (clientData == null) ? null : clientData.getHSLFChildRecords();\n    }
344	private static double evaluate(int hours, int minutes, int seconds) throws EvaluationException {\n\n		if (hours > 32767 || minutes > 32767 || seconds > 32767) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		int totalSeconds = hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;\n\n		if (totalSeconds < 0) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		return (totalSeconds % SECONDS_PER_DAY) / (double)SECONDS_PER_DAY;\n	}
345	public static void putCompressedUnicode(String input, byte[] output, int offset) {\n        byte[] bytes = input.getBytes(ISO_8859_1);\n        System.arraycopy(bytes, 0, output, offset, bytes.length);\n    }
346	public HSSFPatternFormatting createPatternFormatting()\n    {\n        return getPatternFormatting(true);\n    }
347	@Internal\n    public boolean isFHasOriginalStyle()\n    {\n        return fHasOriginalStyle.isSet(field_1_info1);\n    }
348	protected void onDocumentRead() throws IOException {\n\n    }
349	static public double fv(double r, int nper, double c, double pv) {\n		return fv(r, nper, c, pv, 0);\n	}
350	private XSSFCell getCell(XSSFRow row, int index) {\n        if (row.getCell(index) != null) {\n            return row.getCell(index);\n        } else {\n            return row.createCell(index);\n        }\n    }
351	private static SaveRecalcRecord createSaveRecalc() {\n        SaveRecalcRecord retval = new SaveRecalcRecord();\n\n        retval.setRecalc(true);\n        return retval;\n    }
352	private void isCellContentMatchesForNumeric(Locator loc1, Locator loc2) {\n        // TODO: Check for NaN\n        double num1 = loc1.cell.getNumericCellValue();\n        double num2 = loc2.cell.getNumericCellValue();\n        if (num1 != num2) {\n            addMessage(loc1, loc2, CELL_DATA_DOES_NOT_MATCH, Double.toString(num1), Double.toString(num2));\n        }\n    }
353	private void checkColumnIndex(int columnIndex) throws IndexOutOfBoundsException {\n        AreaReference pivotArea = getPivotArea();\n        int size = pivotArea.getLastCell().getCol() - pivotArea.getFirstCell().getCol() + 1;\n\n        if (columnIndex < 0 || columnIndex >= size) {\n            throw new IndexOutOfBoundsException("Column Index: " + columnIndex + ", Size: " + size);\n        }\n    }
354	public TextPropCollection addCharacterTextPropCollection(int charactersCovered) {\n        TextPropCollection tpc = new TextPropCollection(charactersCovered, TextPropType.character);\n        charStyles.add(tpc);\n        return tpc;\n    }
355	public boolean isCondenseRows() {\n        return condenseRows;\n    }
356	public int getAlignment()\n    {\n        return _lvlf.getJc();\n    }
357	public static Cell createCell(Row row, int column, String value, CellStyle style) {\n        Cell cell = getCell(row, column);\n\n        cell.setCellValue(cell.getRow().getSheet().getWorkbook().getCreationHelper()\n                .createRichTextString(value));\n        if (style != null) {\n            cell.setCellStyle(style);\n        }\n        return cell;\n    }
358	public void setVBAProject(XSSFWorkbook macroWorkbook) throws IOException, InvalidFormatException {\n        if (!macroWorkbook.isMacroEnabled()) {\n            return;\n        }\n        InputStream vbaProjectStream = XSSFRelation.VBA_MACROS.getContents(macroWorkbook.getCorePart());\n        if (vbaProjectStream != null) {\n            setVBAProject(vbaProjectStream);\n        }\n    }
359	public static String decodeURI(URI uri) {\n		StringBuilder retVal = new StringBuilder(64);\n		String uriStr = uri.toASCIIString();\n		char c;\n		final int length = uriStr.length();\n		for (int i = 0; i < length; ++i) {\n			c = uriStr.charAt(i);\n			if (c == '%') {\n				// We certainly found an encoded character, check for length\n				// now ( '%' HEXDIGIT HEXDIGIT)\n				if (((length - i) < 2)) {\n					throw new IllegalArgumentException("The uri " + uriStr\n							+ " contain invalid encoded character !");\n				}\n\n				// Decode the encoded character\n				char decodedChar = (char) Integer.parseInt(uriStr.substring(\n						i + 1, i + 3), 16);\n				retVal.append(decodedChar);\n				i += 2;\n				continue;\n			}\n			retVal.append(c);\n		}\n		return retVal.toString();\n	}
360	public short getShortValue(final short holder)\n    {\n        return ( short ) getValue(holder);\n    }
361	public int getTextPosition() {\n        CTRPr pr = getRunProperties(false);\n        return (pr != null && pr.isSetPosition()) ? pr.getPosition().getVal().intValue()\n                : -1;\n    }
362	public UnicodeString getSSTString(int str) {\n        if (sst == null) {\n            insertSST();\n        }\n        UnicodeString retval = sst.getString(str);\n\n        LOG.log(DEBUG, "Returning SST for index=", str, " String= ", retval);\n        return retval;\n    }
363	public void addMimeType(String dsReferenceUri, String mimetype) {\n        this.dataObjectFormatMimeTypes.put(dsReferenceUri, mimetype);\n    }
364	private XSSFRow getRow(XSSFSheet sheet, int index) {\n        if (sheet.getRow(index) != null) {\n            return sheet.getRow(index);\n        } else {\n            return sheet.createRow(index);\n        }\n    }
365	protected ObjRecord createObjRecord() {\n        ObjRecord obj = new ObjRecord();\n        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();\n        c.setObjectType(OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING);\n        c.setLocked(true);\n        c.setPrintable(true);\n        c.setAutofill(true);\n        c.setAutoline(true);\n        EndSubRecord e = new EndSubRecord();\n        obj.addSubRecord(c);\n        obj.addSubRecord(e);\n        return obj;\n    }
366	private void processChunkParseCommands() throws IOException {\n		String line;\n		InputStream cpd = null;\n		BufferedReader inp = null;\n		try {\n	        cpd = ChunkFactory.class.getResourceAsStream(chunkTableName);\n	        if(cpd == null) {\n	            throw new IllegalStateException("Unable to find HDGF chunk definition on the classpath - " + chunkTableName);\n	        }\n\n	        inp = new BufferedReader(new InputStreamReader(cpd, LocaleUtil.CHARSET_1252));\n		    \n		    while( (line = inp.readLine()) != null ) {\n    			if (line.isEmpty() || "# \t".contains(line.substring(0,1))) {\n    			    continue;\n    			}\n    \n    			// Start xxx\n    			if(!line.matches("^start [0-9]+$")) {\n    				throw new IllegalStateException("Expecting start xxx, found " + line);\n    			}\n    			int chunkType = Integer.parseInt(line.substring(6));\n    			ArrayList<CommandDefinition> defsL = new ArrayList<>();\n    \n    			// Data entries\n    			while( (line = inp.readLine()) != null ) {\n    			    if (line.startsWith("end")) {\n    			        break;\n    			    }\n    				StringTokenizer st = new StringTokenizer(line, " ");\n    				int defType = Integer.parseInt(st.nextToken());\n    				int offset = Integer.parseInt(st.nextToken());\n    				String name = st.nextToken("\uffff").substring(1);\n    \n    				CommandDefinition def = new CommandDefinition(defType,offset,name);\n    				defsL.add(def);\n    			}\n    \n    			CommandDefinition[] defs = defsL.toArray(new CommandDefinition[defsL.size()]);\n    \n    			// Add to the map\n    			chunkCommandDefinitions.put(Integer.valueOf(chunkType), defs);\n    		}\n		} finally {\n    		if (inp != null) {\n    		    inp.close();\n    		}\n    		if (cpd != null) {\n    		    cpd.close();\n    		}\n		}\n	}
367	private void GetChar() {\n        // The intersection operator is a space.  We track whether the run of \n        // whitespace preceeding "look" counts as an intersection operator.  \n        if (IsWhite(look)) {\n            if (look == ' ') {\n                _inIntersection = true;\n            }\n        }\n        else {\n            _inIntersection = false;\n        }\n        \n        // Check to see if we've walked off the end of the string.\n        if (_pointer > _formulaLength) {\n            throw new RuntimeException("too far");\n        }\n        if (_pointer < _formulaLength) {\n            look=_formulaString.codePointAt(_pointer);\n        } else {\n            // Just return if so and reset 'look' to something to keep\n            // SkipWhitespace from spinning\n            look = (char)0;\n            _inIntersection = false;\n        }\n        _pointer += Character.charCount(look);\n        //System.out.println(new StringBuilder("Got char: ").appendCodePoint(look)).toString();\n    }
368	public String getTextAsString() {\n		StringBuffer ret = new StringBuffer();\n		List<String> textV = getTextAsVector();\n		for(String text : textV) {\n			ret.append(text);\n			if(! text.endsWith("\n")) {\n				ret.append('\n');\n			}\n		}\n		return ret.toString();\n	}
369	@Removal(version = "4.2")\n    public List<CTRst> getItems() {\n        return Collections.unmodifiableList(strings);\n    }
370	public NameRecord getSpecificBuiltinRecord(byte name, int sheetNumber)\n    {\n        return getOrCreateLinkTable().getSpecificBuiltinRecord(name, sheetNumber);\n    }
371	@Internal\n    public boolean isFWriteReservation()\n    {\n        return fWriteReservation.isSet(field_6_flags1);\n    }
372	public static SubRecord createSubRecord(LittleEndianInput in, int cmoOt) {\n		int sid = in.readUShort();\n		int secondUShort = in.readUShort(); // Often (but not always) the datasize for the sub-record\n\n		switch (sid) {\n			case CommonObjectDataSubRecord.sid:\n				return new CommonObjectDataSubRecord(in, secondUShort);\n			case EmbeddedObjectRefSubRecord.sid:\n				return new EmbeddedObjectRefSubRecord(in, secondUShort);\n			case GroupMarkerSubRecord.sid:\n				return new GroupMarkerSubRecord(in, secondUShort);\n			case EndSubRecord.sid:\n				return new EndSubRecord(in, secondUShort);\n			case NoteStructureSubRecord.sid:\n				return new NoteStructureSubRecord(in, secondUShort);\n			case LbsDataSubRecord.sid:\n				return new LbsDataSubRecord(in, secondUShort, cmoOt);\n            case FtCblsSubRecord.sid:\n                return new FtCblsSubRecord(in, secondUShort);\n            case FtPioGrbitSubRecord.sid:\n            	return new FtPioGrbitSubRecord(in, secondUShort);\n            case FtCfSubRecord.sid:\n            	return new FtCfSubRecord(in, secondUShort);\n		}\n		return new UnknownSubRecord(in, sid, secondUShort);\n	}
373	public void processAttachment(AttachmentChunks attachment, \n	      File dir) throws IOException {\n	   String fileName = attachment.getAttachFileName().toString();\n	   if(attachment.getAttachLongFileName() != null) {\n	      fileName = attachment.getAttachLongFileName().toString();\n	   }\n	   \n		File f = new File(dir, fileName);\n		OutputStream fileOut = null;\n		try {\n			fileOut = new FileOutputStream(f);\n			fileOut.write(attachment.getAttachData().getValue());\n		} finally {\n			if(fileOut != null) {\n				fileOut.close();\n			}\n		}\n	}
374	public static boolean marshallRelationshipPart(\n			PackageRelationshipCollection rels, PackagePartName relPartName,\n			ZipArchiveOutputStream zos) {\n		// Building xml\n		Document xmlOutDoc = DocumentHelper.createDocument();\n		// make something like <Relationships\n		// xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n		Element root = xmlOutDoc.createElementNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIPS_TAG_NAME);\n        xmlOutDoc.appendChild(root);\n\n		// <Relationship\n		// TargetMode="External"\n		// Id="rIdx"\n		// Target="http://www.custom.com/images/pic1.jpg"\n		// Type="http://www.custom.com/external-resource"/>\n\n		URI sourcePartURI = PackagingURIHelper\n				.getSourcePartUriFromRelationshipPartUri(relPartName.getURI());\n\n		for (PackageRelationship rel : rels) {\n			// the relationship element\n            Element relElem = xmlOutDoc.createElementNS(PackageNamespaces.RELATIONSHIPS, PackageRelationship.RELATIONSHIP_TAG_NAME);\n            root.appendChild(relElem);\n\n			// the relationship ID\n			relElem.setAttribute(PackageRelationship.ID_ATTRIBUTE_NAME, rel.getId());\n\n			// the relationship Type\n			relElem.setAttribute(PackageRelationship.TYPE_ATTRIBUTE_NAME, rel.getRelationshipType());\n\n			// the relationship Target\n			String targetValue;\n			URI uri = rel.getTargetURI();\n			if (rel.getTargetMode() == TargetMode.EXTERNAL) {\n				// Save the target as-is - we don't need to validate it,\n				//  alter it etc\n				targetValue = uri.toString();\n\n				// add TargetMode attribute (as it is external link external)\n				relElem.setAttribute(PackageRelationship.TARGET_MODE_ATTRIBUTE_NAME, "External");\n			} else {\n                URI targetURI = rel.getTargetURI();\n                targetValue = PackagingURIHelper.relativizeURI(\n						sourcePartURI, targetURI, true).toString();\n			}\n			relElem.setAttribute(PackageRelationship.TARGET_ATTRIBUTE_NAME, targetValue);\n		}\n\n		xmlOutDoc.normalize();\n\n		// String schemaFilename = Configuration.getPathForXmlSchema()+\n		// File.separator + "opc-relationships.xsd";\n\n		// Save part in zip\n		ZipArchiveEntry ctEntry = new ZipArchiveEntry(ZipHelper.getZipURIFromOPCName(\n				relPartName.getURI().toASCIIString()).getPath());\n		try {\n			zos.putArchiveEntry(ctEntry);\n			try {\n				return StreamHelper.saveXmlInStream(xmlOutDoc, zos);\n			} finally {\n				zos.closeArchiveEntry();\n			}\n		} catch (IOException e) {\n			logger.log(POILogger.ERROR,"Cannot create zip entry " + relPartName, e);\n			return false;\n		}\n	}
375	public void write(final byte[] dst, final int offset)\n    throws ArrayStoreException {\n        /* Check array size: */\n        if (dst.length < LENGTH) {\n            throw new ArrayStoreException\n                ("Destination byte[] must have room for at least 16 bytes, " +\n                 "but has a length of only " + dst.length + ".");\n        }\n        \n        /* Write double word. */\n        dst[0 + offset] = bytes[3];\n        dst[1 + offset] = bytes[2];\n        dst[2 + offset] = bytes[1];\n        dst[3 + offset] = bytes[0];\n\n        /* Write first word. */\n        dst[4 + offset] = bytes[5];\n        dst[5 + offset] = bytes[4];\n\n        /* Write second word. */\n        dst[6 + offset] = bytes[7];\n        dst[7 + offset] = bytes[6];\n\n        /* Write 8 bytes. */\n        System.arraycopy(bytes, 8, dst, 8 + offset, 8);\n    }
376	public static XMLEventFactory newXMLEventFactory() {\n        return XMLEventFactory.newFactory();\n    }
377	public HSLFFontInfo addFont(FontInfo fontInfo) {\n        HSLFFontInfo fi = getFontInfo(fontInfo.getTypeface());\n        if (fi != null) {\n            return fi;\n        }\n\n        fi = new HSLFFontInfo(fontInfo);\n        fi.setIndex(fonts.size());\n        fonts.put(fi.getTypeface(), fi);\n        \n        FontEntityAtom fnt = fi.createRecord();\n\n        // Append new child to the end\n        appendChildRecord(fnt);\n\n        // the added font is the last in the list\n        return fi;\n    }
378	@Internal\n    public byte getFSpare()\n    {\n        return ( byte )fSpare.getValue(field_1_info1);\n    }
379	private static void buildDataSheet(Sheet dataSheet) {\n        Row row = null;\n        Cell cell = null;\n        Name name = null;\n\n        // The first row will hold the data for the first validation.\n        row = dataSheet.createRow(10);\n        cell = row.createCell(0);\n        cell.setCellValue("Animal");\n        cell = row.createCell(1);\n        cell.setCellValue("Vegetable");\n        cell = row.createCell(2);\n        cell.setCellValue("Mineral");\n        name = dataSheet.getWorkbook().createName();\n        name.setRefersToFormula("$A$11:$C$11");\n        name.setNameName("CHOICES");\n\n        // The next three rows will hold the data that will be used to\n        // populate the second, or linked, drop down list.\n        row = dataSheet.createRow(11);\n        cell = row.createCell(0);\n        cell.setCellValue("Lion");\n        cell = row.createCell(1);\n        cell.setCellValue("Tiger");\n        cell = row.createCell(2);\n        cell.setCellValue("Leopard");\n        cell = row.createCell(3);\n        cell.setCellValue("Elephant");\n        cell = row.createCell(4);\n        cell.setCellValue("Eagle");\n        cell = row.createCell(5);\n        cell.setCellValue("Horse");\n        cell = row.createCell(6);\n        cell.setCellValue("Zebra");\n        name = dataSheet.getWorkbook().createName();\n        name.setRefersToFormula("$A$12:$G$12");\n        name.setNameName("ANIMAL");\n\n        row = dataSheet.createRow(12);\n        cell = row.createCell(0);\n        cell.setCellValue("Cabbage");\n        cell = row.createCell(1);\n        cell.setCellValue("Cauliflower");\n        cell = row.createCell(2);\n        cell.setCellValue("Potato");\n        cell = row.createCell(3);\n        cell.setCellValue("Onion");\n        cell = row.createCell(4);\n        cell.setCellValue("Beetroot");\n        cell = row.createCell(5);\n        cell.setCellValue("Asparagus");\n        cell = row.createCell(6);\n        cell.setCellValue("Spinach");\n        cell = row.createCell(7);\n        cell.setCellValue("Chard");\n        name = dataSheet.getWorkbook().createName();\n        name.setRefersToFormula("$A$13:$H$13");\n        name.setNameName("VEGETABLE");\n\n        row = dataSheet.createRow(13);\n        cell = row.createCell(0);\n        cell.setCellValue("Bauxite");\n        cell = row.createCell(1);\n        cell.setCellValue("Quartz");\n        cell = row.createCell(2);\n        cell.setCellValue("Feldspar");\n        cell = row.createCell(3);\n        cell.setCellValue("Shist");\n        cell = row.createCell(4);\n        cell.setCellValue("Shale");\n        cell = row.createCell(5);\n        cell.setCellValue("Mica");\n        name = dataSheet.getWorkbook().createName();\n        name.setRefersToFormula("$A$14:$F$14");\n        name.setNameName("MINERAL");\n    }
380	public void parseProperty(byte data[], int offset) {\n        tabStops.addAll(readTabStops(new LittleEndianByteArrayInputStream(data, offset)));\n    }
381	public static String combine(String prefix, String suffix) {\n		if (!prefix.endsWith(FORWARD_SLASH_STRING) && !suffix.startsWith(FORWARD_SLASH_STRING))\n			return prefix + FORWARD_SLASH_CHAR + suffix;\n		else if (prefix.endsWith(FORWARD_SLASH_STRING) ^ suffix.startsWith(FORWARD_SLASH_STRING))\n			return prefix + suffix;\n		else\n			return "";\n	}
382	public Rectangle2D.Double getTextBounds() {\n\n        double txtPinX = _parent.getTxtPinX();\n        double txtPinY = _parent.getTxtPinY();\n\n        double txtLocPinX = _parent.getTxtLocPinX();\n        double txtLocPinY = _parent.getTxtLocPinY();\n\n        double txtWidth = _parent.getTxtWidth();\n        double txtHeight = _parent.getTxtHeight();\n\n        double x = txtPinX - txtLocPinX;\n        double y = txtPinY - txtLocPinY;\n\n        return new Rectangle2D.Double(x, y, txtWidth, txtHeight);\n    }
383	public boolean isPure() {\n        return isPure;\n    }
384	protected void onDeleteFormula(XSSFCell cell){\n\n        CTCellFormula f = cell.getCTCell().getF();\n        if (f != null && f.getT() == STCellFormulaType.SHARED && f.isSetRef() && f.getStringValue() != null) {\n\n            CellRangeAddress ref = CellRangeAddress.valueOf(f.getRef());\n            if(ref.getNumberOfCells() > 1){\n                DONE:\n                for(int i = cell.getRowIndex(); i <= ref.getLastRow(); i++){\n                    XSSFRow row = getRow(i);\n                    if(row != null) for(int j = cell.getColumnIndex(); j <= ref.getLastColumn(); j++){\n                        XSSFCell nextCell = row.getCell(j);\n                        if(nextCell != null && nextCell != cell){\n                            CTCellFormula nextF = nextCell.getCTCell().getF();\n                            nextF.setStringValue(nextCell.getCellFormula());\n                            CellRangeAddress nextRef = new CellRangeAddress(\n                                    nextCell.getRowIndex(), ref.getLastRow(),\n                                    nextCell.getColumnIndex(), ref.getLastColumn());\n                            nextF.setRef(nextRef.formatAsString());\n\n                            sharedFormulas.put((int)nextF.getSi(), nextF);\n                            break DONE;\n                        }\n                    }\n                }\n            }\n\n        }\n    }
385	public void setCellComment(Comment comment){\n        if(comment == null) {\n            removeCellComment();\n            return;\n        }\n\n        comment.setRow(_record.getRow());\n        comment.setColumn(_record.getColumn());\n        _comment = (HSSFComment)comment;\n    }
386	protected void attach(String chartRelId, XWPFRun run)\n        throws InvalidFormatException, IOException {\n        ctInline = run.addChart(chartRelId);\n        ctInline.addNewExtent();\n        setChartBoundingBox(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n    }
387	public static void copyFile(File in, File out) throws IOException {\n        try (FileInputStream fis = new FileInputStream(in);\n             FileOutputStream fos = new FileOutputStream(out);\n             FileChannel sourceChannel = fis.getChannel();\n             FileChannel destinationChannel = fos.getChannel()) {\n            \n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n        }\n    }
388	private void compareNumberOfColumnsInSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n            \n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n\n            Iterator<Row> ri1 = loc1.sheet.rowIterator();\n            Iterator<Row> ri2 = loc2.sheet.rowIterator();\n            \n            int num1 = (ri1.hasNext()) ? ri1.next().getPhysicalNumberOfCells() : 0;\n            int num2 = (ri2.hasNext()) ? ri2.next().getPhysicalNumberOfCells() : 0;\n            \n            if (num1 != num2) {\n                String str = String.format(Locale.ROOT, "%s\nworkbook1 -> %s [%d] != workbook2 -> %s [%d]",\n                    "Number Of Columns does not Match ::",\n                    loc1.sheet.getSheetName(), num1,\n                    loc2.sheet.getSheetName(), num2\n                );\n                listOfDifferences.add(str);\n            }\n        }\n    }
389	public void cloneStyleFrom(FontRecord source) {\n		field_1_font_height         = source.field_1_font_height;\n		field_2_attributes          = source.field_2_attributes;\n		field_3_color_palette_index = source.field_3_color_palette_index;\n		field_4_bold_weight         = source.field_4_bold_weight;\n		field_5_super_sub_script    = source.field_5_super_sub_script;\n		field_6_underline           = source.field_6_underline;\n		field_7_family              = source.field_7_family;\n		field_8_charset             = source.field_8_charset;\n		field_9_zero                = source.field_9_zero;\n		field_11_font_name          = source.field_11_font_name;\n	}
390	private static HashAlgorithm getDigestMethodAlgo(String digestMethodUri) {\n        if (digestMethodUri == null || digestMethodUri.isEmpty()) {\n            return null;\n        }\n        switch (digestMethodUri) {\n            case DigestMethod.SHA1:   return HashAlgorithm.sha1;\n            case DigestMethod_SHA224: return HashAlgorithm.sha224;\n            case DigestMethod.SHA256: return HashAlgorithm.sha256;\n            case DigestMethod_SHA384: return HashAlgorithm.sha384;\n            case DigestMethod.SHA512: return HashAlgorithm.sha512;\n            case DigestMethod.RIPEMD160: return HashAlgorithm.ripemd160;\n            default: throw new EncryptedDocumentException("Hash algorithm "\n                    +digestMethodUri+" not supported for signing.");\n        }\n    }
391	public int getY2() {\n        return _spgrRecord.getRectY2();\n    }
392	protected byte[] toByteArray( ByteArrayOutputStream dataStream,\n            CharIndexTranslator translator ) throws IOException\n    {\n        byte[] buf = new byte[512];\n        int size = _papxList.size();\n        int grpprlOffset = 0;\n        int bxOffset = 0;\n        int fcOffset = 0;\n        byte[] lastGrpprl = new byte[0];\n\n        // total size is currently the size of one FC\n        int totalSize = FC_SIZE;\n\n        int index = 0;\n        for ( ; index < size; index++ )\n        {\n            byte[] grpprl = _papxList.get( index ).getGrpprl();\n            int grpprlLength = grpprl.length;\n\n            // is grpprl huge?\n            if ( grpprlLength > 488 )\n            {\n                grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl\n            }\n\n            // check to see if we have enough room for an FC, a BX, and the\n            // grpprl\n            // and the 1 byte size of the grpprl.\n            int addition = 0;\n            if ( !Arrays.equals( grpprl, lastGrpprl ) )\n            {\n                addition = ( FC_SIZE + BX_SIZE + grpprlLength + 1 );\n            }\n            else\n            {\n                addition = ( FC_SIZE + BX_SIZE );\n            }\n\n            totalSize += addition;\n\n            // if size is uneven we will have to add one so the first grpprl\n            // falls\n            // on a word boundary\n            if ( totalSize > 511 + ( index % 2 ) )\n            {\n                totalSize -= addition;\n                break;\n            }\n\n            // grpprls must fall on word boundaries\n            if ( grpprlLength % 2 > 0 )\n            {\n                totalSize += 1;\n            }\n            else\n            {\n                totalSize += 2;\n            }\n            lastGrpprl = grpprl;\n        }\n\n        // see if we couldn't fit some\n        if ( index != size )\n        {\n            _overFlow = new ArrayList<>();\n            _overFlow.addAll( _papxList.subList( index, size ) );\n        }\n\n        // index should equal number of papxs that will be in this fkp now.\n        buf[511] = (byte) index;\n\n        bxOffset = ( FC_SIZE * index ) + FC_SIZE;\n        grpprlOffset = 511;\n\n        PAPX papx = null;\n        lastGrpprl = new byte[0];\n        for ( int x = 0; x < index; x++ )\n        {\n            papx = _papxList.get( x );\n            byte[] phe = papx.getParagraphHeight().toByteArray();\n            byte[] grpprl = papx.getGrpprl();\n\n            // is grpprl huge?\n            if ( grpprl.length > 488 )\n            {\n                // if so do we have storage at getHugeGrpprlOffset()\n                // int hugeGrpprlOffset = papx.getHugeGrpprlOffset();\n                // if ( hugeGrpprlOffset == -1 ) // then we have no storage...\n                // {\n                // throw new UnsupportedOperationException(\n                // "This Paragraph has no dataStream storage." );\n                // }\n                // we have some storage...\n\n                // get the size of the existing storage\n                // int maxHugeGrpprlSize = LittleEndian.getUShort( dataStream,\n                // hugeGrpprlOffset );\n                //\n                // if ( maxHugeGrpprlSize < grpprl.length - 2 )\n                // { // grpprl.length-2 because we don't store the istd\n                // throw new UnsupportedOperationException(\n                // "This Paragraph's dataStream storage is too small." );\n                // }\n\n                // store grpprl at hugeGrpprlOffset\n                // grpprl.length-2 because we don't store the istd\n                // System.arraycopy( grpprl, 2, dataStream, hugeGrpprlOffset +\n                // 2,\n                // grpprl.length - 2 );\n                // LittleEndian.putUShort( dataStream, hugeGrpprlOffset,\n                // grpprl.length - 2 );\n\n                byte[] hugePapx = new byte[grpprl.length - 2];\n                System.arraycopy( grpprl, 2, hugePapx, 0, grpprl.length - 2 );\n                int dataStreamOffset = dataStream.size();\n                dataStream.write( hugePapx );\n\n                // grpprl = grpprl containing only a sprmPHugePapx2\n                int istd = LittleEndian.getUShort( grpprl, 0 );\n\n                grpprl = new byte[8];\n                LittleEndian.putUShort( grpprl, 0, istd );\n                LittleEndian.putUShort( grpprl, 2, 0x6646 ); // sprmPHugePapx2\n                LittleEndian.putInt( grpprl, 4, dataStreamOffset );\n            }\n\n            boolean same = Arrays.equals( lastGrpprl, grpprl );\n            if ( !same )\n            {\n                grpprlOffset -= ( grpprl.length + ( 2 - grpprl.length % 2 ) );\n                grpprlOffset -= ( grpprlOffset % 2 );\n            }\n            // LittleEndian.putInt( buf, fcOffset, papx.getStartBytes() );\n            LittleEndian.putInt( buf, fcOffset,\n                    translator.getByteIndex( papx.getStart() ) );\n            buf[bxOffset] = (byte) ( grpprlOffset / 2 );\n            System.arraycopy( phe, 0, buf, bxOffset + 1, phe.length );\n\n            /*\n             * refer to the section on PAPX in the spec. Places a size on the\n             * front of the PAPX. Has to do with how the grpprl stays on word\n             * boundaries.\n             */\n            if ( !same )\n            {\n                int copyOffset = grpprlOffset;\n                if ( ( grpprl.length % 2 ) > 0 )\n                {\n                    buf[copyOffset++] = (byte) ( ( grpprl.length + 1 ) / 2 );\n                }\n                else\n                {\n                    buf[++copyOffset] = (byte) ( ( grpprl.length ) / 2 );\n                    copyOffset++;\n                }\n                System.arraycopy( grpprl, 0, buf, copyOffset, grpprl.length );\n                lastGrpprl = grpprl;\n            }\n\n            bxOffset += BX_SIZE;\n            fcOffset += FC_SIZE;\n\n        }\n\n        // LittleEndian.putInt(buf, fcOffset, papx.getEndBytes() + fcMin);\n        LittleEndian.putInt( buf, fcOffset,\n                translator.getByteIndex( papx.getEnd() ) );\n        return buf;\n    }
393	public byte getBlipTypeMacOS() {\n        return field_2_blipTypeMacOS;\n    }
394	public static boolean isType(Cell cell, CellType type) {\n        final CellType cellType = cell.getCellType();\n        return cellType == type \n              || (cellType == CellType.FORMULA \n                  && cell.getCachedFormulaResultType() == type\n                 );\n    }
395	public static String compress(byte[] data) throws IOException {\n        java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\n        java.util.zip.GZIPOutputStream gz = new java.util.zip.GZIPOutputStream(bos);\n        gz.write(data);\n        gz.finish();\n        return DatatypeConverter.printBase64Binary(bos.toByteArray());        \n    }
396	public XSSFBorderFormatting createBorderFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTBorder border;\n        if(!dxf.isSetBorder()) {\n            border = dxf.addNewBorder();\n        } else {\n            border = dxf.getBorder();\n        }\n\n        return new XSSFBorderFormatting(border, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
397	public static void resetUserTimeZone() {\n        userTimeZone.remove();\n    }
398	public final void removeBreak(int main) {\n        Integer rowKey = Integer.valueOf(main);\n        Break region = _breakMap.get(rowKey);\n        _breaks.remove(region);\n        _breakMap.remove(rowKey);\n    }
399	public HSSFDataBarFormatting createDataBarFormatting() {\n        return getDataBarFormatting(true);\n    }
400	public String makeConcise(String result, int form) {\n        if (form > 0) {\n            result = result.replaceAll("XLV", "VL"); //45\n            result = result.replaceAll("XCV", "VC"); //95\n            result = result.replaceAll("CDL", "LD"); //450\n            result = result.replaceAll("CML", "LM"); //950\n            result = result.replaceAll("CMVC", "LMVL"); //995\n        }\n        if (form == 1) {\n            result = result.replaceAll("CDXC", "LDXL"); //490\n            result = result.replaceAll("CDVC", "LDVL"); //495\n            result = result.replaceAll("CMXC", "LMXL"); //990\n            result = result.replaceAll("XCIX", "VCIV"); //99\n            result = result.replaceAll("XLIX", "VLIV"); //49\n        }\n        if (form > 1) {\n            result = result.replaceAll("XLIX", "IL"); //49\n            result = result.replaceAll("XCIX", "IC"); //99\n            result = result.replaceAll("CDXC", "XD"); //490\n            result = result.replaceAll("CDVC", "XDV"); //495\n            result = result.replaceAll("CDIC", "XDIX"); //499\n            result = result.replaceAll("LMVL", "XMV"); //995\n            result = result.replaceAll("CMIC", "XMIX"); //999\n            result = result.replaceAll("CMXC", "XM"); // 990\n        }\n        if (form > 2) {\n            result = result.replaceAll("XDV", "VD");  //495\n            result = result.replaceAll("XDIX", "VDIV"); //499\n            result = result.replaceAll("XMV", "VM"); // 995\n            result = result.replaceAll("XMIX", "VMIV"); //999\n        }\n        if (form == 4) {\n            result = result.replaceAll("VDIV", "ID"); //499\n            result = result.replaceAll("VMIV", "IM"); //999\n        }\n\n        return result;\n    }
401	public int getTextAndLinesColourRGB() { return textAndLinesColourRGB; }
402	public ValueEval evaluate(ValueEval[] args, OperationEvaluationContext ec) {\n		\n		double bottom, top;\n\n		if (args.length != 2) {\n			return ErrorEval.VALUE_INVALID;\n		}\n		\n		try {\n			bottom = OperandResolver.coerceValueToDouble(OperandResolver.getSingleValue(args[0], ec.getRowIndex(), ec.getColumnIndex()));\n			top = OperandResolver.coerceValueToDouble(OperandResolver.getSingleValue(args[1], ec.getRowIndex(), ec.getColumnIndex()));\n			if(bottom > top) {\n				return ErrorEval.NUM_ERROR;\n			}\n		} catch (EvaluationException e) {\n			return ErrorEval.VALUE_INVALID;\n		}\n\n		bottom = Math.ceil(bottom);\n		top = Math.floor(top);\n\n		if(bottom > top) {\n			top = bottom;\n		}\n		\n		return new NumberEval((bottom + (int)(Math.random() * ((top - bottom) + 1))));\n		\n	}
403	public static boolean getFlag (int x)\n  {\n    if (x != 0)\n    {\n      return true;\n    }\n	return false;\n  }
404	public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IOException {\n        if (poifsDir.hasEntry("WordDocument")) {\n            // Old or new style word document?\n            try {\n                return new WordExtractor(poifsDir);\n            } catch (OldWordFileFormatException e) {\n                return new Word6Extractor(poifsDir);\n            }\n        }\n\n        if (poifsDir.hasEntry(HSLFSlideShow.POWERPOINT_DOCUMENT)) {\n            return new SlideShowExtractor(SlideShowFactory.create(poifsDir));\n        }\n\n        if (poifsDir.hasEntry("VisioDocument")) {\n            return new VisioTextExtractor(poifsDir);\n        }\n\n        if (poifsDir.hasEntry("Quill")) {\n            return new PublisherTextExtractor(poifsDir);\n        }\n\n        final String[] outlookEntryNames = new String[] {\n                // message bodies, saved as plain text (PtypString)\n                // The first short (0x1000, 0x0047, 0x0037) refer to the Property ID (see [MS-OXPROPS].pdf)\n                // the second short (0x001e, 0x001f, 0x0102) refer to the type of data stored in this entry\n                // https://msdn.microsoft.com/endatatypes.Ex-us/library/cc433490(v=exchg.80).aspx\n                // @see org.apache.poi.hsmf.Types.MAPIType\n                "__substg1.0_1000001E", //PidTagBody ASCII\n                "__substg1.0_1000001F", //PidTagBody Unicode\n                "__substg1.0_0047001E", //PidTagMessageSubmissionId ASCII\n                "__substg1.0_0047001F", //PidTagMessageSubmissionId Unicode\n                "__substg1.0_0037001E", //PidTagSubject ASCII\n                "__substg1.0_0037001F", //PidTagSubject Unicode\n        };\n        for (String entryName : outlookEntryNames) {\n            if (poifsDir.hasEntry(entryName)) {\n                return new OutlookTextExtactor(poifsDir);\n            }\n        }\n\n        throw new IllegalArgumentException("No supported documents found in the OLE2 stream");\n    }
405	public CellFormatResult apply(Cell c) {\n        switch (ultimateType(c)) {\n        case BLANK:\n            return apply("");\n        case BOOLEAN:\n            return apply(c.getBooleanCellValue());\n        case NUMERIC:\n            Double value = c.getNumericCellValue();\n            if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                if (DateUtil.isValidExcelDate(value)) {\n                    return apply(c.getDateCellValue(), value);\n                } else {\n                    return apply(INVALID_VALUE_FOR_FORMAT);\n                }\n            } else {\n                return apply(value);\n            }\n        case STRING:\n            return apply(c.getStringCellValue());\n        default:\n            return apply("?");\n        }\n    }
406	public int getSlideCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_SLIDECOUNT);\n    }
407	public List<EscherProperty> createProperties(byte[] data, int offset, short numProperties) {\n        List<EscherProperty> results = new ArrayList<>();\n\n        int pos = offset;\n\n        for (int i = 0; i < numProperties; i++) {\n            short propId;\n            int propData;\n            propId = LittleEndian.getShort( data, pos );\n            propData = LittleEndian.getInt( data, pos + 2 );\n            short propNumber = (short) ( propId & (short) 0x3FFF );\n            boolean isComplex = ( propId & (short) 0x8000 ) != 0;\n            // boolean isBlipId = ( propId & (short) 0x4000 ) != 0;\n\n            byte propertyType = EscherProperties.getPropertyType(propNumber);\n            EscherProperty ep;\n            switch (propertyType) {\n                case EscherPropertyMetaData.TYPE_BOOLEAN:\n                    ep = new EscherBoolProperty( propId, propData );\n                    break;\n                case EscherPropertyMetaData.TYPE_RGB:\n                    ep = new EscherRGBProperty( propId, propData );\n                    break;\n                case EscherPropertyMetaData.TYPE_SHAPEPATH:\n                    ep = new EscherShapePathProperty( propId, propData );\n                    break;\n                default:\n                    if ( !isComplex ) {\n                        ep = new EscherSimpleProperty( propId, propData );\n                    } else if ( propertyType == EscherPropertyMetaData.TYPE_ARRAY) {\n                        ep = new EscherArrayProperty( propId, IOUtils.safelyAllocate(propData, MAX_RECORD_LENGTH));\n                    } else {\n                        ep = new EscherComplexProperty( propId, IOUtils.safelyAllocate(propData, MAX_RECORD_LENGTH));\n                    }\n                    break;\n            }\n            results.add( ep );\n            pos += 6;\n        }\n\n        // Get complex data\n        for (EscherProperty p : results) {\n            if (p instanceof EscherComplexProperty) {\n                if (p instanceof EscherArrayProperty) {\n                    pos += ((EscherArrayProperty)p).setArrayData(data, pos);\n                } else {\n                    byte[] complexData = ((EscherComplexProperty)p).getComplexData();\n\n                    int leftover = data.length - pos;\n                    if (leftover < complexData.length) {\n                        throw new IllegalStateException("Could not read complex escher property, length was " + complexData.length + ", but had only " +\n                                leftover + " bytes left");\n                    }\n\n                    System.arraycopy(data, pos, complexData, 0, complexData.length);\n                    pos += complexData.length;\n                }\n            }\n        }\n        return results;\n    }
408	static void sameCell(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue(84);\n        sheet.createRow(1).createCell(0).setCellValue(74);\n        sheet.createRow(2).createCell(0).setCellValue(50);\n        sheet.createRow(3).createCell(0).setCellValue(51);\n        sheet.createRow(4).createCell(0).setCellValue(49);\n        sheet.createRow(5).createCell(0).setCellValue(41);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Cell Value Is   greater than  70   (Blue Fill)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule(ComparisonOperator.GT, "70");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        // Condition 2: Cell Value Is  less than      50   (Green Fill)\n        ConditionalFormattingRule rule2 = sheetCF.createConditionalFormattingRule(ComparisonOperator.LT, "50");\n        PatternFormatting fill2 = rule2.createPatternFormatting();\n        fill2.setFillBackgroundColor(IndexedColors.GREEN.index);\n        fill2.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:A6")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1, rule2);\n\n        sheet.getRow(0).createCell(2).setCellValue("<== Condition 1: Cell Value Is greater than 70 (Blue Fill)");\n        sheet.getRow(4).createCell(2).setCellValue("<== Condition 2: Cell Value Is less than 50 (Green Fill)");\n    }
409	public String getText() {\n		return StringUtil.getFromCompressedUnicode(_text,0,_text.length);\n	}
410	@Internal\n    protected void replaceDirectory(DirectoryNode newDirectory) {\n        directory = newDirectory;\n    }
411	private void updateName(XSSFName name, String oldName, String newName) {\n        String formula = name.getRefersToFormula();\n        if (formula != null) {\n            int sheetIndex = name.getSheetIndex();\n            int rowIndex = -1; //don't care\n            Ptg[] ptgs = FormulaParser.parse(formula, _fpwb, FormulaType.NAMEDRANGE, sheetIndex, rowIndex);\n            for (Ptg ptg : ptgs) {\n                updatePtg(ptg, oldName, newName);\n            }\n            String updatedFormula = FormulaRenderer.toFormulaString(_fpwb, ptgs);\n            if (!formula.equals(updatedFormula)) name.setRefersToFormula(updatedFormula);\n        }\n    }
412	private static boolean mergeColInfoRecords(ColumnInfoRecord ciA, ColumnInfoRecord ciB) {\n		if (ciA.isAdjacentBefore(ciB) && ciA.formatMatches(ciB)) {\n			ciA.setLastColumn(ciB.getLastColumn());\n			return true;\n		}\n		return false;\n	}
413	public short getLastColumn() {\n		return field_4_last_col;\n	}
414	public static POIFSFileSystem create(File file) throws IOException {\n        // Create a new empty POIFS in the file\n        try (POIFSFileSystem tmp = new POIFSFileSystem();\n             OutputStream out = new FileOutputStream(file)) {\n            tmp.writeFilesystem(out);\n        }\n\n        // Open it up again backed by the file\n        return new POIFSFileSystem(file, false);\n    }
415	@Internal\n    public byte getVertAlign()\n    {\n        return ( byte )vertAlign.getValue(field_1_rgf);\n    }
416	private static int findLastIndexInRunOfEqualValues(LookupValueComparer lookupComparer, ValueVector vector,\n				int firstFoundIndex, int maxIx) {\n		for(int i=firstFoundIndex+1; i<maxIx; i++) {\n			if(!lookupComparer.compareTo(vector.getItem(i)).isEqual()) {\n				return i-1;\n			}\n		}\n		return maxIx - 1;\n	}
417	public int getRecordCount() {\n        return _recordCount;\n    }
418	public boolean isRevisionLocked() {\n        return workbookProtectionPresent() && workbook.getWorkbookProtection().getLockRevision();\n    }
419	public void notifyUpdateCell(EvaluationCell cell) {\n        int sheetIndex = getSheetIndex(cell.getSheet());\n        _cache.notifyUpdateCell(_workbookIx, sheetIndex, cell);\n    }
420	public boolean isReturnNullOnMissingChunk() {\n      return returnNullOnMissingChunk;\n   }
421	private void newDrawing(){\n        CTShapeLayout layout = CTShapeLayout.Factory.newInstance();\n        layout.setExt(STExt.EDIT);\n        CTIdMap idmap = layout.addNewIdmap();\n        idmap.setExt(STExt.EDIT);\n        idmap.setData("1");\n        _items.add(layout);\n        _qnames.add(QNAME_SHAPE_LAYOUT);\n\n        CTShapetype shapetype = CTShapetype.Factory.newInstance();\n        _shapeTypeId = COMMENT_SHAPE_TYPE_ID;\n        shapetype.setId(_shapeTypeId);\n        shapetype.setCoordsize("21600,21600");\n        shapetype.setSpt(202);\n        shapetype.setPath2("m,l,21600r21600,l21600,xe");\n        shapetype.addNewStroke().setJoinstyle(STStrokeJoinStyle.MITER);\n        CTPath path = shapetype.addNewPath();\n        path.setGradientshapeok(STTrueFalse.T);\n        path.setConnecttype(STConnectType.RECT);\n        _items.add(shapetype);\n        _qnames.add(QNAME_SHAPE_TYPE);\n    }
422	public static RefEval createRefEval(String refStr) {\n		return createRefEval(refStr, NumberEval.ZERO);\n	}
423	@Internal\n    public short getSti()\n    {\n        return ( short )sti.getValue(field_1_info1);\n    }
424	public int getSizeInBytes() { return 16; }
425	public boolean addAll(final IntList c)\n    {\n        if (c._limit != 0)\n        {\n            if ((_limit + c._limit) > _array.length)\n            {\n                growArray(_limit + c._limit);\n            }\n            System.arraycopy(c._array, 0, _array, _limit, c._limit);\n            _limit += c._limit;\n        }\n        return true;\n    }
426	public static InputStream getDecryptedStream(final DirectoryNode root, String password)\n            throws IOException {\n        EncryptionInfo info = new EncryptionInfo(root);\n        Decryptor d = Decryptor.getInstance(info);\n\n        try {\n            boolean passwordCorrect = false;\n            if (password != null && d.verifyPassword(password)) {\n                passwordCorrect = true;\n            }\n            if (!passwordCorrect && d.verifyPassword(Decryptor.DEFAULT_PASSWORD)) {\n                passwordCorrect = true;\n            }\n\n            if (passwordCorrect) {\n                return d.getDataStream(root);\n            } else if (password != null) {\n                throw new EncryptedDocumentException("Password incorrect");\n            } else {\n                throw new EncryptedDocumentException("The supplied spreadsheet is protected, but no password was supplied");\n            }\n        } catch (GeneralSecurityException e) {\n            throw new IOException(e);\n        }\n    }
427	public int getOffset(){\n        return offset;\n    }
428	public Pointer[] createContainerPointers(Pointer parent, byte[] data) {\n        // Where in the stream does the "number of pointers" offset live?\n        int numPointersOffset = parent.getNumPointersOffset(data);\n        // How many do we have?\n        int numPointers = parent.getNumPointers(numPointersOffset, data);\n        // How much to skip for the num pointers + any extra data?\n        int skip = parent.getPostNumPointersSkip();\n\n        // Create\n        int pos = numPointersOffset + skip;\n        Pointer[] childPointers = new Pointer[numPointers];\n        for(int i=0; i<numPointers; i++) {\n            childPointers[i] = this.createPointer(data, pos);\n            pos += childPointers[i].getSizeInBytes();\n        }\n\n        return childPointers;\n    }
429	static void unCompressSEPOperation (SectionProperties newSEP, SprmOperation sprm)\n  {\n    int operation = sprm.getOperation();\n    switch (operation)\n    {\n      case 0:\n        newSEP.setCnsPgn ((byte) sprm.getOperand());\n        break;\n      case 0x1:\n        newSEP.setIHeadingPgn ((byte) sprm.getOperand());\n        break;\n      case 0x2:\n        byte[] buf = new byte[sprm.size() - 3];\n        System.arraycopy(sprm.getGrpprl(), sprm.getGrpprlOffset(), buf, 0, buf.length);\n        newSEP.setOlstAnm (buf);\n        break;\n      case 0x3:\n        //not quite sure\n        break;\n      case 0x4:\n        //not quite sure\n        break;\n      case 0x5:\n        newSEP.setFEvenlySpaced (getFlag (sprm.getOperand()));\n        break;\n      case 0x6:\n        newSEP.setFUnlocked (getFlag (sprm.getOperand()));\n        break;\n      case 0x7:\n        newSEP.setDmBinFirst ((short) sprm.getOperand());\n        break;\n      case 0x8:\n        newSEP.setDmBinOther ((short) sprm.getOperand());\n        break;\n      case 0x9:\n        newSEP.setBkc ((byte) sprm.getOperand());\n        break;\n      case 0xa:\n        newSEP.setFTitlePage (getFlag (sprm.getOperand()));\n        break;\n      case 0xb:\n        newSEP.setCcolM1 ((short) sprm.getOperand());\n        break;\n      case 0xc:\n        newSEP.setDxaColumns (sprm.getOperand());\n        break;\n      case 0xd:\n        newSEP.setFAutoPgn (getFlag (sprm.getOperand()));\n        break;\n      case 0xe:\n        newSEP.setNfcPgn ((byte) sprm.getOperand());\n        break;\n      case 0xf:\n        newSEP.setDyaPgn ((short) sprm.getOperand());\n        break;\n      case 0x10:\n        newSEP.setDxaPgn ((short) sprm.getOperand());\n        break;\n      case 0x11:\n        newSEP.setFPgnRestart (getFlag (sprm.getOperand()));\n        break;\n      case 0x12:\n        newSEP.setFEndNote (getFlag (sprm.getOperand()));\n        break;\n      case 0x13:\n        newSEP.setLnc ((byte) sprm.getOperand());\n        break;\n      case 0x14:\n        newSEP.setGrpfIhdt ((byte) sprm.getOperand());\n        break;\n      case 0x15:\n        newSEP.setNLnnMod ((short) sprm.getOperand());\n        break;\n      case 0x16:\n        newSEP.setDxaLnn (sprm.getOperand());\n        break;\n      case 0x17:\n        newSEP.setDyaHdrTop (sprm.getOperand());\n        break;\n      case 0x18:\n        newSEP.setDyaHdrBottom (sprm.getOperand());\n        break;\n      case 0x19:\n        newSEP.setFLBetween (getFlag (sprm.getOperand()));\n        break;\n      case 0x1a:\n        newSEP.setVjc ((byte) sprm.getOperand());\n        break;\n      case 0x1b:\n        newSEP.setLnnMin ((short) sprm.getOperand());\n        break;\n      case 0x1c:\n        newSEP.setPgnStart ((short) sprm.getOperand());\n        break;\n      case 0x1d:\n        newSEP.setDmOrientPage( sprm.getOperand() != 0 );\n        break;\n      case 0x1e:\n\n        //nothing\n        break;\n      case 0x1f:\n        newSEP.setXaPage (sprm.getOperand());\n        break;\n      case 0x20:\n        newSEP.setYaPage (sprm.getOperand());\n        break;\n      case 0x21:\n        newSEP.setDxaLeft (sprm.getOperand());\n        break;\n      case 0x22:\n        newSEP.setDxaRight (sprm.getOperand());\n        break;\n      case 0x23:\n        newSEP.setDyaTop (sprm.getOperand());\n        break;\n      case 0x24:\n        newSEP.setDyaBottom (sprm.getOperand());\n        break;\n      case 0x25:\n        newSEP.setDzaGutter (sprm.getOperand());\n        break;\n      case 0x26:\n        newSEP.setDmPaperReq ((short) sprm.getOperand());\n        break;\n      case 0x27:\n        newSEP.setFPropMark (getFlag (sprm.getOperand()));\n        break;\n      case 0x28:\n        break;\n      case 0x29:\n        break;\n      case 0x2a:\n        break;\n      case 0x2b:\n        newSEP.setBrcTop(new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x2c:\n        newSEP.setBrcLeft(new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x2d:\n        newSEP.setBrcBottom(new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x2e:\n        newSEP.setBrcRight(new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x2f:\n        newSEP.setPgbProp (sprm.getOperand());\n        break;\n      case 0x30:\n        newSEP.setDxtCharSpace (sprm.getOperand());\n        break;\n      case 0x31:\n        newSEP.setDyaLinePitch (sprm.getOperand());\n        break;\n      case 0x33:\n        newSEP.setWTextFlow ((short) sprm.getOperand());\n        break;\n      case 0x3C:\n        // [MS-DOC], v20140721, 2.6.4, sprmSRncFtn        \n        newSEP.setRncFtn((short) sprm.getOperand());\n        break;\n      case 0x3E:\n        // [MS-DOC], v20140721, 2.6.4, sprmSRncEdn        \n        newSEP.setRncEdn((short) sprm.getOperand());\n        break;\n      case 0x3F:\n        // [MS-DOC], v20140721, 2.6.4, sprmSNFtn\n        newSEP.setNFtn(sprm.getOperand());\n        break;\n      case 0x40:\n        // [MS-DOC], v20140721, 2.6.4, sprmSNFtnRef\n        newSEP.setNfcFtnRef(sprm.getOperand());\n        break;\n      case 0x41:\n        // [MS-DOC], v20140721, 2.6.4, sprmSNEdn\n        newSEP.setNEdn(sprm.getOperand());\n        break;\n      case 0x42:\n        // [MS-DOC], v20140721, 2.6.4, sprmSNEdnRef\n        newSEP.setNfcEdnRef(sprm.getOperand());\n        break;\n      default:\n        logger.log(POILogger.INFO, "Unsupported Sprm operation: " + operation + " (" + HexDump.byteToHex(operation) + ")");\n        break;\n    }\n\n  }
430	public Table insertTableBefore(short columns, int rows) {\n        ParagraphProperties parProps = new ParagraphProperties();\n        parProps.setFInTable(true);\n        parProps.setItap( 1 );\n\n        final int oldEnd = this._end;\n        \n        for ( int x = 0; x < rows; x++ )\n        {\n            Paragraph cell = this.insertBefore( parProps, StyleSheet.NIL_STYLE );\n            cell.insertAfter( String.valueOf( '\u0007' ) );\n            for ( int y = 1; y < columns; y++ )\n            {\n                cell = cell.insertAfter( parProps, StyleSheet.NIL_STYLE );\n                cell.insertAfter( String.valueOf( '\u0007' ) );\n            }\n            cell = cell.insertAfter( parProps, StyleSheet.NIL_STYLE,\n                    String.valueOf( '\u0007' ) );\n            cell.setTableRowEnd( new TableProperties( columns ) );\n        }\n\n        final int newEnd = this._end;\n        final int diff = newEnd - oldEnd;\n\n        return new Table( _start, _start + diff, this, 1 );\n	}
431	public ArrayList<PackagePart> getParts() throws InvalidFormatException {\n		throwExceptionIfWriteOnly();\n\n		// If the part list is null, we parse the package to retrieve all parts.\n		if (partList == null) {\n			/* Variables use to validate OPC Compliance */\n\n			// Check rule M4.1 -> A format consumer shall consider more than\n			// one core properties relationship for a package to be an error\n		    // (We just log it and move on, as real files break this!)\n			boolean hasCorePropertiesPart = false;\n			boolean needCorePropertiesPart = true;\n\n			partList = getPartsImpl();\n			for (PackagePart part : new ArrayList<>(partList.sortedValues())) {\n			    part.loadRelationships();\n\n				// Check OPC compliance rule M4.1\n				if (ContentTypes.CORE_PROPERTIES_PART.equals(part.getContentType())) {\n					if (!hasCorePropertiesPart) {\n						hasCorePropertiesPart = true;\n					} else {\n					   logger.log(POILogger.WARN, "OPC Compliance error [M4.1]: " +\n					   		"there is more than one core properties relationship in the package! " +\n					   		"POI will use only the first, but other software may reject this file.");\n					}\n				}\n\n				PartUnmarshaller partUnmarshaller = partUnmarshallers.get(part._contentType);\n\n				if (partUnmarshaller != null) {\n					UnmarshallContext context = new UnmarshallContext(this, part._partName);\n					try {\n						PackagePart unmarshallPart = partUnmarshaller.unmarshall(context, part.getInputStream());\n						partList.remove(part.getPartName());\n						partList.put(unmarshallPart._partName, unmarshallPart);\n\n						// Core properties case-- use first CoreProperties part we come across\n						// and ignore any subsequent ones\n						if (unmarshallPart instanceof PackagePropertiesPart &&\n								hasCorePropertiesPart &&\n								needCorePropertiesPart) {\n							this.packageProperties = (PackagePropertiesPart) unmarshallPart;\n							needCorePropertiesPart = false;\n						}\n					} catch (IOException ioe) {\n						logger.log(POILogger.WARN, "Unmarshall operation : IOException for "\n								+ part._partName);\n						continue;\n					} catch (InvalidOperationException invoe) {\n						throw new InvalidFormatException(invoe.getMessage(), invoe);\n					}\n				}\n			}\n		}\n		return new ArrayList<>(partList.sortedValues());\n	}
432	private static StyleTextPropAtom findStyleAtomPresent(TextHeaderAtom header, int textLen) {\n        boolean afterHeader = false;\n        StyleTextPropAtom style = null;\n        for (Record record : header.getParentRecord().getChildRecords()) {\n            long rt = record.getRecordType();\n            if (afterHeader && rt == RecordTypes.TextHeaderAtom.typeID) {\n                // already on the next header, quit searching\n                break;\n            }\n            afterHeader |= (header == record);\n            if (afterHeader && rt == RecordTypes.StyleTextPropAtom.typeID) {\n                // found it\n                style = (StyleTextPropAtom) record;\n            }\n        }\n\n        if (style == null) {\n            logger.log(POILogger.INFO, "styles atom doesn't exist. Creating dummy record for later saving.");\n            style = new StyleTextPropAtom((textLen < 0) ? 1 : textLen);\n        } else {\n            if (textLen >= 0) {\n                style.setParentTextSize(textLen);\n            }\n        }\n\n        return style;\n    }
433	public void writeToBytes(final byte [] data)\n        throws ArrayIndexOutOfBoundsException\n    {\n        data[ _offset ] = _value;\n    }
434	public void setColumn(int col) {\n		field_2_col = col;\n	}
435	public boolean getStopIfTrue() {\n        return true;\n    }
436	@Internal\n    public boolean isFNotPageView()\n    {\n        return fNotPageView.isSet(field_32_viewFlags);\n    }
437	private String decodeFlags( int flags )\n    {\n        StringBuffer result = new StringBuffer();\n        result.append( ( flags & FLAG_GROUP ) != 0 ? "|GROUP" : "" );\n        result.append( ( flags & FLAG_CHILD ) != 0 ? "|CHILD" : "" );\n        result.append( ( flags & FLAG_PATRIARCH ) != 0 ? "|PATRIARCH" : "" );\n        result.append( ( flags & FLAG_DELETED ) != 0 ? "|DELETED" : "" );\n        result.append( ( flags & FLAG_OLESHAPE ) != 0 ? "|OLESHAPE" : "" );\n        result.append( ( flags & FLAG_HAVEMASTER ) != 0 ? "|HAVEMASTER" : "" );\n        result.append( ( flags & FLAG_FLIPHORIZ ) != 0 ? "|FLIPHORIZ" : "" );\n        result.append( ( flags & FLAG_FLIPVERT ) != 0 ? "|FLIPVERT" : "" );\n        result.append( ( flags & FLAG_CONNECTOR ) != 0 ? "|CONNECTOR" : "" );\n        result.append( ( flags & FLAG_HAVEANCHOR ) != 0 ? "|HAVEANCHOR" : "" );\n        result.append( ( flags & FLAG_BACKGROUND ) != 0 ? "|BACKGROUND" : "" );\n        result.append( ( flags & FLAG_HASSHAPETYPE ) != 0 ? "|HASSHAPETYPE" : "" );\n\n        //need to check, else blows up on some records - bug 34435\n        if(result.length() > 0) {\n            result.deleteCharAt(0);\n        }\n        return result.toString();\n    }
438	public static byte[][] decompress(byte[] data, int offset, int length) throws IOException {\n		ByteArrayInputStream bais = new ByteArrayInputStream(data, offset, length);\n\n		// Decompress\n		HDGFLZW lzw = new HDGFLZW();\n		byte[] decompressed = lzw.decompress(bais);\n\n		// Split into header and contents\n		byte[][] ret = new byte[2][];\n		ret[0] = new byte[4];\n		ret[1] = new byte[decompressed.length - 4];\n\n		System.arraycopy(decompressed, 0, ret[0], 0, 4);\n		System.arraycopy(decompressed, 4, ret[1], 0, ret[1].length);\n\n		// All done\n		return ret;\n	}
439	public void onCreate(){\n\n    }
440	public void clear() {\n        arrays.clear();\n    }
441	@Internal\n    public byte getFtsWidthIndent()\n    {\n        return ( byte )ftsWidthIndent.getValue(field_13_widthAndFitsFlags);\n    }
442	public static double evaluate(double[] v) throws EvaluationException {\n		if (v.length < 2) {\n			throw new EvaluationException(ErrorEval.NA);\n		}\n\n		// very naive impl, may need to be optimized\n		int[] counts = new int[v.length];\n		Arrays.fill(counts, 1);\n		for (int i = 0, iSize = v.length; i < iSize; i++) {\n			for (int j = i + 1, jSize = v.length; j < jSize; j++) {\n				if (v[i] == v[j])\n					counts[i]++;\n			}\n		}\n		double maxv = 0;\n		int maxc = 0;\n		for (int i = 0, iSize = counts.length; i < iSize; i++) {\n			if (counts[i] > maxc) {\n				maxv = v[i];\n				maxc = counts[i];\n			}\n		}\n		if (maxc > 1) {\n			return maxv;\n		}\n		throw new EvaluationException(ErrorEval.NA);\n\n	}
443	public boolean isFCol()\n    {\n        return fCol.isSet(field_2_bkf_flags);\n    }
444	boolean changeName(final String oldName, final String newName)\n    {\n        boolean   rval  = false;\n        EntryNode child = ( EntryNode ) _byname.get(oldName);\n\n        if (child != null)\n        {\n            rval = (( DirectoryProperty ) getProperty())\n                .changeName(child.getProperty(), newName);\n            if (rval)\n            {\n                _byname.remove(oldName);\n                _byname.put(child.getProperty().getName(), child);\n            }\n        }\n        return rval;\n    }
445	public static NameType classifyCellReference(String str, SpreadsheetVersion ssVersion) {\n        int len = str.length();\n        if (len < 1) {\n            throw new IllegalArgumentException("Empty string not allowed");\n        }\n        char firstChar = str.charAt(0);\n        switch (firstChar) {\n            case ABSOLUTE_REFERENCE_MARKER:\n            case '.':\n            case '_':\n                break;\n            default:\n                if (!Character.isLetter(firstChar) && !Character.isDigit(firstChar)) {\n                    throw new IllegalArgumentException("Invalid first char (" + firstChar\n                            + ") of cell reference or named range.  Letter expected");\n                }\n        }\n        if (!Character.isDigit(str.charAt(len-1))) {\n            // no digits at end of str\n            return validateNamedRangeName(str, ssVersion);\n        }\n        Matcher cellRefPatternMatcher = STRICTLY_CELL_REF_PATTERN.matcher(str);\n        if (!cellRefPatternMatcher.matches()) {\n            return validateNamedRangeName(str, ssVersion);\n        }\n        String lettersGroup = cellRefPatternMatcher.group(1);\n        String digitsGroup = cellRefPatternMatcher.group(2);\n        if (cellReferenceIsWithinRange(lettersGroup, digitsGroup, ssVersion)) {\n            // valid cell reference\n            return NameType.CELL;\n        }\n        // If str looks like a cell reference, but is out of (row/col) range, it is a valid\n        // named range name\n        // This behaviour is a little weird.  For example, "IW123" is a valid named range name\n        // because the column "IW" is beyond the maximum "IV".  Note - this behaviour is version\n        // dependent.  In BIFF12, "IW123" is not a valid named range name, but in BIFF8 it is.\n        if (str.indexOf(ABSOLUTE_REFERENCE_MARKER) >= 0) {\n            // Of course, named range names cannot have '$'\n            return NameType.BAD_CELL_OR_NAMED_RANGE;\n        }\n        return NameType.NAMED_RANGE;\n    }
446	public static byte[] peekFirst8Bytes(InputStream stream) throws IOException, EmptyFileException {\n        return peekFirstNBytes(stream, 8);\n    }
447	@Internal\n    public boolean isFAutofit()\n    {\n        return fAutofit.isSet(field_13_widthAndFitsFlags);\n    }
448	@Internal\n    public boolean isFVertical()\n    {\n        return fVertical.isSet(field_1_rgf);\n    }
449	public final PackagePart getPackagePart() {\n        return packagePart;\n    }
450	@Internal\n    public boolean isFHtmlUnsupported()\n    {\n        return fHtmlUnsupported.isSet(field_1_grfhic);\n    }
451	public void processRecords(InputStream in) throws RecordFormatException {\n		Record last_record = null;\n\n		RecordInputStream recStream = new RecordInputStream(in);\n\n		while (recStream.hasNextRecord()) {\n			recStream.nextRecord();\n			Record[] recs = RecordFactory.createRecord(recStream);   // handle MulRK records\n			if (recs.length > 1) {\n				for (Record rec : recs) {\n					if ( last_record != null ) {\n						if (!processRecord(last_record)) {\n							return;\n						}\n					}\n					last_record = rec; // do to keep the algorithm homogeneous...you can't\n				}							// actually continue a number record anyhow.\n			} else {\n				Record record = recs[ 0 ];\n\n				if (record != null) {\n					if (last_record != null) {\n						if (!processRecord(last_record)) {\n							return;\n						}\n					}\n					 last_record = record;\n				}\n			}\n		}\n\n		if (last_record != null) {\n			processRecord(last_record);\n		}\n	}
452	public void paint(Graphics2D g) {\n        g.setBackground(Color.CYAN);\n        AffineTransform origTransform = g.getTransform();\n        for (Painting c : paintings) {\n            c.draw(g);\n        }\n        g.setTransform(origTransform);\n\n        clear();\n    }
453	public void removePart(PackagePartName partName) {\n		throwExceptionIfReadOnly();\n		if (partName == null || !this.containPart(partName)) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		// Delete the specified part from the package.\n		if (this.partList.containsKey(partName)) {\n			this.partList.get(partName).setDeleted(true);\n			this.removePartImpl(partName);\n			this.partList.remove(partName);\n		} else {\n			this.removePartImpl(partName);\n		}\n\n		// Delete content type\n		this.contentTypeManager.removeContentType(partName);\n\n		// If this part is a relationship part, then delete all relationships of\n		// the source part.\n		if (partName.isRelationshipPartURI()) {\n			URI sourceURI = PackagingURIHelper\n					.getSourcePartUriFromRelationshipPartUri(partName.getURI());\n			PackagePartName sourcePartName;\n			try {\n				sourcePartName = PackagingURIHelper.createPartName(sourceURI);\n			} catch (InvalidFormatException e) {\n				logger\n						.log(POILogger.ERROR, "Part name URI '"\n								+ sourceURI\n								+ "' is not valid ! This message is not intended to be displayed !");\n				return;\n			}\n			if (sourcePartName.getURI().equals(\n					PackagingURIHelper.PACKAGE_ROOT_URI)) {\n				clearRelationships();\n			} else if (containPart(sourcePartName)) {\n				PackagePart part = getPart(sourcePartName);\n				if (part != null) {\n					part.clearRelationships();\n				}\n			}\n		}\n\n		this.isDirty = true;\n	}
454	@Internal\n    public boolean isFSimpleList()\n    {\n        return fSimpleList.isSet(field_4_flags);\n    }
455	private Ptg columnCopyAreaPtg(AreaPtgBase aptg) {\n        boolean changed = false;\n\n        final int aFirstColumn = aptg.getFirstColumn();\n        final int aLastColumn = aptg.getLastColumn();\n\n        if (aptg.isFirstColRelative()) {\n            final int destFirstColumnIndex = aFirstColumn + _amountToMove;\n            if (destFirstColumnIndex < 0 || _version.getLastColumnIndex() < destFirstColumnIndex)\n                return createDeletedRef(aptg);\n            aptg.setFirstColumn(destFirstColumnIndex);\n            changed = true;\n        }\n        if (aptg.isLastColRelative()) {\n            final int destLastColumnIndex = aLastColumn + _amountToMove;\n            if (destLastColumnIndex < 0 || _version.getLastColumnIndex() < destLastColumnIndex)\n                return createDeletedRef(aptg);\n            aptg.setLastColumn(destLastColumnIndex);\n            changed = true;\n        }\n        if (changed) {\n            aptg.sortTopLeftToBottomRight();\n        }\n\n        return changed ? aptg : null;\n    }
456	public static void putUByte( byte[] data, int offset, short value )\n    {\n        data[offset] = (byte) ( value & 0xFF );\n    }
457	private static DeltaRecord createDelta() {\n        return new DeltaRecord(DeltaRecord.DEFAULT_VALUE);\n    }
458	private static ScenarioProtectRecord createScenarioProtect() {\n		ScenarioProtectRecord retval = new ScenarioProtectRecord();\n		retval.setProtect(false);\n		return retval;\n	}
459	static public double ppmt(double r, int per, int nper, double pv, double fv, int type) {\n	    return pmt(r, nper, pv, fv, type) - ipmt(r, per, nper, pv, fv, type);\n	}
460	public void log(int level, Object... objs) {\n        if (!check(level)) return;\n        StringBuilder sb = new StringBuilder(32);\n        Throwable lastEx = null;\n        for (int i=0; i<objs.length; i++) {\n            if (i == objs.length-1 && objs[i] instanceof Throwable) {\n                lastEx = (Throwable)objs[i];\n            } else {\n                sb.append(objs[i]);\n            }\n        }\n        \n        String msg = sb.toString();\n        msg = msg.replaceAll("[\r\n]+", " ");  // log forging escape\n        \n        // somehow this ambiguity works and doesn't lead to a loop,\n        // but it's confusing ...\n        if (lastEx == null) {\n            _log(level, msg);\n        } else {\n            _log(level, msg, lastEx);\n        }\n    }
461	@Internal\n    public boolean isFShadow()\n    {\n        return fShadow.isSet(field_1_grpfChp);\n    }
462	public static Calendar parseDate(String strVal) throws EvaluationException {\n        String[] parts = Pattern.compile("/").split(strVal);\n        if (parts.length != 3) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        String part2 = parts[2];\n        int spacePos = part2.indexOf(' ');\n        if (spacePos > 0) {\n            // drop time portion if present\n            part2 = part2.substring(0, spacePos);\n        }\n        int f0;\n        int f1;\n        int f2;\n        try {\n            f0 = Integer.parseInt(parts[0]);\n            f1 = Integer.parseInt(parts[1]);\n            f2 = Integer.parseInt(part2);\n        } catch (NumberFormatException e) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        if (f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)) {\n            // easy to see this cannot be a valid date\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n\n        if (f0 >= 1900 && f0 < 9999) {\n            // when 4 digit value appears first, the format is YYYY/MM/DD, regardless of OS settings\n            return makeDate(f0, f1, f2);\n        }\n        // otherwise the format seems to depend on OS settings (default date format)\n//        if (false) {\n//            // MM/DD/YYYY is probably a good guess, if the in the US\n//            return makeDate(f2, f0, f1);\n//        }\n        // TODO - find a way to choose the correct date format\n        throw new RuntimeException("Unable to determine date format for text '" + strVal + "'");\n    }
463	private synchronized void createTempDirectory(File directory) throws IOException {\n        // create directory if it doesn't exist\n        final boolean dirExists = (directory.exists() || directory.mkdirs());\n        \n        if (!dirExists) {\n            throw new IOException("Could not create temporary directory '" + directory + "'");\n        }\n        else if (!directory.isDirectory()) {\n            throw new IOException("Could not create temporary directory. '" + directory + "' exists but is not a directory.");\n        }\n    }
464	@Internal\n    public XWPFEndnote addEndnote(CTFtnEdn note) {\n        CTFtnEdn newNote = ctEndnotes.addNewEndnote();\n        newNote.set(note);\n        XWPFEndnote xNote = new XWPFEndnote(newNote, this);\n        listFootnote.add(xNote);\n        return xNote;\n    }
465	private static void applyAttributes(CTRPrElt pr, CTTextCharacterProperties rPr) {\n\n        if (pr.sizeOfBArray() > 0) {\n            rPr.setB(pr.getBArray(0).getVal());\n        }\n        if (pr.sizeOfUArray() > 0) {\n            STUnderlineValues.Enum u1 = pr.getUArray(0).getVal();\n            if (u1 == STUnderlineValues.SINGLE) {\n                rPr.setU(STTextUnderlineType.SNG);\n            } else if (u1 == STUnderlineValues.DOUBLE) {\n                rPr.setU(STTextUnderlineType.DBL);\n            } else if (u1 == STUnderlineValues.NONE) {\n                rPr.setU(STTextUnderlineType.NONE);\n            }\n        }\n        if (pr.sizeOfIArray() > 0) {\n            rPr.setI(pr.getIArray(0).getVal());\n        }\n\n        if (pr.sizeOfRFontArray() > 0) {\n            CTTextFont rFont = rPr.isSetLatin() ? rPr.getLatin() : rPr.addNewLatin();\n            rFont.setTypeface(pr.getRFontArray(0).getVal());\n        }\n\n        if (pr.sizeOfSzArray() > 0) {\n            int sz = (int) (pr.getSzArray(0).getVal() * 100);\n            rPr.setSz(sz);\n        }\n\n        if (pr.sizeOfColorArray() > 0) {\n            CTSolidColorFillProperties fill = rPr.isSetSolidFill() ? rPr.getSolidFill() : rPr.addNewSolidFill();\n            org.openxmlformats.schemas.spreadsheetml.x2006.main.CTColor xlsColor = pr.getColorArray(0);\n            if (xlsColor.isSetRgb()) {\n                CTSRgbColor clr = fill.isSetSrgbClr() ? fill.getSrgbClr() : fill.addNewSrgbClr();\n                clr.setVal(xlsColor.getRgb());\n            } else if (xlsColor.isSetIndexed()) {\n                HSSFColor indexed = HSSFColor.getIndexHash().get((int) xlsColor.getIndexed());\n                if (indexed != null) {\n                    byte[] rgb = new byte[3];\n                    rgb[0] = (byte) indexed.getTriplet()[0];\n                    rgb[1] = (byte) indexed.getTriplet()[1];\n                    rgb[2] = (byte) indexed.getTriplet()[2];\n                    CTSRgbColor clr = fill.isSetSrgbClr() ? fill.getSrgbClr() : fill.addNewSrgbClr();\n                    clr.setVal(rgb);\n                }\n            }\n        }\n    }
466	public static boolean startsWithIgnoreCase(String haystack, String prefix) {\n        return haystack.regionMatches(true, 0, prefix, 0, prefix.length());\n    }
467	private int remainingBytes() {\n        if (_closed) {\n            throw new IllegalStateException("cannot perform requested operation on a closed stream");\n        }\n        return _document_size - _current_offset;\n    }
468	protected void setNextBlock(final int offset, final int nextBlock) {\n       BATBlockAndIndex bai = getBATBlockAndIndex(offset);\n       bai.getBlock().setValueAt(\n             bai.getIndex(), nextBlock\n       );\n    }
469	@SuppressWarnings("unused")\n	public int addControl(String name, String progId) {\n		ExControl ctrl = new ExControl();\n		ctrl.setProgId(progId);\n		ctrl.setMenuName(name);\n		ctrl.setClipboardName(name);\n\n		ExOleObjAtom oleObj = ctrl.getExOleObjAtom();\n		oleObj.setDrawAspect(ExOleObjAtom.DRAW_ASPECT_VISIBLE);\n		oleObj.setType(ExOleObjAtom.TYPE_CONTROL);\n		oleObj.setSubType(ExOleObjAtom.SUBTYPE_DEFAULT);\n\n		int objectId = addToObjListAtom(ctrl);\n		oleObj.setObjID(objectId);\n		return objectId;\n	}
470	private void validateSheetIndex(int index) {\n        int lastSheetIx = sheets.size() - 1;\n        if (index < 0 || index > lastSheetIx) {\n            String range = "(0.." +    lastSheetIx + ")";\n            if (lastSheetIx == -1) {\n                range = "(no sheets)";\n            }\n            throw new IllegalArgumentException("Sheet index ("\n                    + index +") is out of range " + range);\n        }\n    }
471	public void debug() {\n		System.err.println("Trailer is at " + trailerPointer.getOffset());\n		System.err.println("Trailer has type " + trailerPointer.getType());\n		System.err.println("Trailer has length " + trailerPointer.getLength());\n		System.err.println("Trailer has format " + trailerPointer.getFormat());\n\n		for(int i=0; i<trailer.getPointedToStreams().length; i++) {\n			Stream stream = trailer.getPointedToStreams()[i];\n			Pointer ptr = stream.getPointer();\n\n			System.err.println("Looking at pointer " + i);\n			System.err.println("\tType is " + ptr.getType() + "\t\t" + Integer.toHexString(ptr.getType()));\n			System.err.println("\tOffset is " + ptr.getOffset() + "\t\t" + Long.toHexString(ptr.getOffset()));\n			System.err.println("\tAddress is " + ptr.getAddress() + "\t" + Long.toHexString(ptr.getAddress()));\n			System.err.println("\tLength is " + ptr.getLength() + "\t\t" + Long.toHexString(ptr.getLength()));\n			System.err.println("\tFormat is " + ptr.getFormat() + "\t\t" + Long.toHexString(ptr.getFormat()));\n			System.err.println("\tCompressed is " + ptr.destinationCompressed());\n			System.err.println("\tStream is " + stream.getClass());\n\n			if(stream instanceof PointerContainingStream) {\n				PointerContainingStream pcs = (PointerContainingStream)stream;\n\n				if(pcs.getPointedToStreams() != null && pcs.getPointedToStreams().length > 0) {\n					System.err.println("\tContains " + pcs.getPointedToStreams().length + " other pointers/streams");\n					for(int j=0; j<pcs.getPointedToStreams().length; j++) {\n						Stream ss = pcs.getPointedToStreams()[j];\n						Pointer sptr = ss.getPointer();\n						System.err.println("\t\t" + j + " - Type is " + sptr.getType() + "\t\t" + Integer.toHexString(sptr.getType()));\n						System.err.println("\t\t" + j + " - Length is " + sptr.getLength() + "\t\t" + Long.toHexString(sptr.getLength()));\n					}\n				}\n			}\n\n			if(stream instanceof StringsStream) {\n				System.err.println("\t\t**strings**");\n				StringsStream ss = (StringsStream)stream;\n				System.err.println("\t\t" + ss._getContentsLength());\n			}\n		}\n	}
472	protected void shiftMerged(int startRow, int endRow, int n, boolean isRow) {\n        RowShifter rowShifter = new HSSFRowShifter(this);\n        rowShifter.shiftMergedRegions(startRow, endRow, n);\n    }
473	public void getRecordsById(short recordId, List<EscherRecord> out){\n        for (EscherRecord r : this) {\n            if(r instanceof EscherContainerRecord) {\n                EscherContainerRecord c = (EscherContainerRecord)r;\n                c.getRecordsById(recordId, out );\n            } else if (r.getRecordId() == recordId){\n                out.add(r);\n            }\n        }\n    }
474	@Internal\n    public boolean isFProt()\n    {\n        return fProt.isSet(field_2_bits);\n    }
475	public String getFormula2(){\n        return _cfRule.sizeOfFormulaArray() == 2 ? _cfRule.getFormulaArray(1) : null;\n    }
476	public void saveWorkbook(XSSFWorkbook workbook) throws IOException, InvalidFormatException {\n        PackagePart worksheetPart = getWorksheetPart();\n        if (worksheetPart == null) {\n            POIXMLRelation chartRelation = getChartRelation();\n            POIXMLRelation chartWorkbookRelation = getChartWorkbookRelation();\n            POIXMLFactory chartFactory = getChartFactory();\n            if (chartRelation != null && chartWorkbookRelation != null && chartFactory != null) {\n                worksheetPart = createWorksheetPart(chartRelation, chartWorkbookRelation, chartFactory);\n            } else {\n                throw new InvalidFormatException("unable to determine chart relations");\n            }\n        }\n        try (OutputStream xlsOut = worksheetPart.getOutputStream()) {\n            setWorksheetPartCommitted();\n            workbook.write(xlsOut);\n        }\n    }
477	/* package */ int getStartIdxOfTextRun(HSLFTextRun textrun) {\n        int idx = 0;\n        for (HSLFTextParagraph p : parentList) {\n            for (HSLFTextRun r : p) {\n                if (r == textrun) {\n                    return idx;\n                }\n                idx += r.getLength();\n            }\n        }\n        return -1;\n    }
478	public int findFirstRecordLocBySid( short sid ) { // TODO - remove this method\n        int max = _records.size();\n        for (int i=0; i< max; i++) {\n            Object rb = _records.get(i);\n            if (!(rb instanceof Record)) {\n                continue;\n            }\n            Record record = (Record) rb;\n            if (record.getSid() == sid) {\n                return i;\n            }\n        }\n        return -1;\n    }
479	private static BorderStyle getBorderStyle(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        BorderStyle border;\n        if (value instanceof BorderStyle) {\n            border = (BorderStyle) value;\n        }\n        // @deprecated 3.15 beta 2. getBorderStyle will only work on BorderStyle enums instead of codes in the future.\n        else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map uses Short values for "\n                        + name + ". Should use BorderStyle enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            border = BorderStyle.valueOf(code);\n        }\n        else if (value == null) {\n            border = BorderStyle.NONE;\n        }\n        else {\n            throw new RuntimeException("Unexpected border style class. Must be BorderStyle or Short (deprecated).");\n        }\n        return border;\n    }
480	private int findFirstRow(int firstrow) {\n        int rownum = firstrow + 1;\n        HSSFRow r = getRow(rownum);\n\n        while (r == null && rownum <= getLastRowNum()) {\n            r = getRow(++rownum);\n        }\n\n        if (rownum > getLastRowNum())\n            return 0;\n\n        return rownum;\n    }
481	public boolean isBoolean() {\n		return !_isError;\n	}
482	public boolean mapsTo(long id){\n        List<XSSFXmlColumnPr> pointers = getXmlColumnPrs();\n        \n        for (XSSFXmlColumnPr pointer: pointers) {\n            if (pointer.getMapId()==id) {\n                return true;\n            }\n        }\n        \n        return false;\n    }
483	public void unLockWindows() {\n        safeGetWorkbookProtection().setLockWindows(false);\n    }
484	public void addUnmarshaller(String contentType,\n			PartUnmarshaller unmarshaller) {\n		try {\n			partUnmarshallers.put(new ContentType(contentType), unmarshaller);\n		} catch (InvalidFormatException e) {\n			logger.log(POILogger.WARN, "The specified content type is not valid: '"\n					+ e.getMessage()\n					+ "'. The unmarshaller will not be added !");\n		}\n	}
485	public boolean isFBorders()\n    {\n        return fBorders.isSet( field_2_tlp_flags );\n\n    }
486	private HSLFLine createBorder(BorderEdge edge) {\n        HSLFTable table = getParent();\n        HSLFLine line = new HSLFLine(table);\n        table.addShape(line);\n\n        AbstractEscherOptRecord opt = getEscherOptRecord();\n        setEscherProperty(opt, EscherProperties.GEOMETRY__SHAPEPATH, -1);\n        setEscherProperty(opt, EscherProperties.GEOMETRY__FILLOK, -1);\n        setEscherProperty(opt, EscherProperties.SHADOWSTYLE__SHADOWOBSURED, 0x20000);\n        setEscherProperty(opt, EscherProperties.THREED__LIGHTFACE, 0x80000);\n\n        anchorBorder(edge, line);\n\n        return line;\n    }
487	public boolean isAlignToBaseline() {\n        return getAlignment().baseline;\n    }
488	static boolean isHSLF(Object shape) {\n        return shape.getClass().getName().toLowerCase(Locale.ROOT).contains("hslf");\n    }
489	public boolean release(long id) {\n        if (id < lowerbound || id > upperbound) {\n            throw new IllegalArgumentException("Value for parameter 'id' was out of bounds, had " + id + ", but should be within [" + lowerbound + ":" + upperbound + "]");\n        }\n\n        if (id == upperbound) {\n            Segment lastSegment = segments.getLast();\n            if (lastSegment.end == upperbound - 1) {\n                lastSegment.end = upperbound;\n                return true;\n            } else if (lastSegment.end == upperbound) {\n                return false;\n            } else {\n                segments.add(new Segment(upperbound, upperbound));\n                return true;\n            }\n        }\n\n        if (id == lowerbound) {\n            Segment firstSegment = segments.getFirst();\n            if (firstSegment.start == lowerbound + 1) {\n                firstSegment.start = lowerbound;\n                return true;\n            } else if (firstSegment.start == lowerbound) {\n                return false;\n            } else {\n                segments.addFirst(new Segment(lowerbound, lowerbound));\n                return true;\n            }\n        }\n\n        long higher = id + 1;\n        long lower = id - 1;\n        ListIterator<Segment> iter = segments.listIterator();\n\n        while (iter.hasNext()) {\n            Segment segment = iter.next();\n            if (segment.end < lower) {\n                continue;\n            }\n            if (segment.start > higher) {\n                iter.previous();\n                iter.add(new Segment(id, id));\n                return true;\n            }\n            if (segment.start == higher) {\n                segment.start = id;\n                return true;\n            }\n            else if (segment.end == lower) {\n                segment.end = id;\n                /* check if releasing this elements glues two segments into one */\n                if (iter.hasNext()) {\n                  Segment next = iter.next();\n                    if (next.start == segment.end + 1) {\n                        segment.end = next.end;\n                        iter.remove();\n                    }\n                }\n                return true;\n            }\n            else {\n                /* id was not reserved, return false */\n                break;\n            }\n        }\n        return false;\n    }
490	public int getMMClipCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_MMCLIPCOUNT);\n    }
491	@Internal\n    public boolean isFCellSpacing()\n    {\n        return fCellSpacing.isSet(field_25_internalFlags);\n    }
492	public void addBreak(int main, int subFrom, int subTo) {\n\n        Integer key = Integer.valueOf(main);\n        Break region = _breakMap.get(key);\n        if(region == null) {\n            region = new Break(main, subFrom, subTo);\n            _breakMap.put(key, region);\n            _breaks.add(region);\n        } else {\n            region.main = main;\n            region.subFrom = subFrom;\n            region.subTo = subTo;\n        }\n    }
493	private void saveCSVFile(File file)\n                                     throws FileNotFoundException, IOException {\n        ArrayList<String> line;\n        StringBuffer buffer;\n        String csvLineElement;\n\n        // Open a writer onto the CSV file.\n        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {\n\n            System.out.println("Saving the CSV file [" + file.getName() + "]");\n\n            // Step through the elements of the ArrayList that was used to hold\n            // all of the data recovered from the Excel workbooks' sheets, rows\n            // and cells.\n            for(int i = 0; i < this.csvData.size(); i++) {\n                buffer = new StringBuffer();\n\n                // Get an element from the ArrayList that contains the data for\n                // the workbook. This element will itself be an ArrayList\n                // containing Strings and each String will hold the data recovered\n                // from a single cell. The for() loop is used to recover elements\n                // from this 'row' ArrayList one at a time and to write the Strings\n                // away to a StringBuffer thus assembling a single line for inclusion\n                // in the CSV file. If a row was empty or if it was short, then\n                // the ArrayList that contains it's data will also be shorter than\n                // some of the others. Therefore, it is necessary to check within\n                // the for loop to ensure that the ArrayList contains data to be\n                // processed. If it does, then an element will be recovered and\n                // appended to the StringBuffer.\n                line = this.csvData.get(i);\n                for(int j = 0; j < this.maxRowWidth; j++) {\n                    if(line.size() > j) {\n                        csvLineElement = line.get(j);\n                        if(csvLineElement != null) {\n                            buffer.append(this.escapeEmbeddedCharacters(\n                                    csvLineElement));\n                        }\n                    }\n                    if(j < (this.maxRowWidth - 1)) {\n                        buffer.append(this.separator);\n                    }\n                }\n\n                // Once the line is built, write it away to the CSV file.\n                bw.write(buffer.toString().trim());\n\n                // Condition the inclusion of new line characters so as to\n                // avoid an additional, superfluous, new line at the end of\n                // the file.\n                if(i < (this.csvData.size() - 1)) {\n                    bw.newLine();\n                }\n            }\n        }\n    }
494	public void addNum(BigInteger abstractNumID, BigInteger numID) {\n        CTNum ctNum = this.ctNumbering.addNewNum();\n        ctNum.addNewAbstractNumId();\n        ctNum.getAbstractNumId().setVal(abstractNumID);\n        ctNum.setNumId(numID);\n        XWPFNum num = new XWPFNum(ctNum, this);\n        nums.add(num);\n    }
495	@Removal(version = "4.2")\n    public VerticalAlign getSubscript() {\n        CTRPr pr = getRunProperties(false);\n        return (pr != null && pr.isSetVertAlign()) ? VerticalAlign.valueOf(pr.getVertAlign().getVal().intValue()) : VerticalAlign.BASELINE;\n    }
496	private static PasswordRecord createPassword() {\n		return new PasswordRecord(0x0000);\n	}
497	public Ptg[] convertSharedFormulas(Ptg[] ptgs, int formulaRow, int formulaColumn) {\n\n        Ptg[] newPtgStack = new Ptg[ptgs.length];\n\n        for (int k = 0; k < ptgs.length; k++) {\n            Ptg ptg = ptgs[k];\n            byte originalOperandClass = -1;\n            if (!ptg.isBaseToken()) {\n                originalOperandClass = ptg.getPtgClass();\n            }\n            if (ptg instanceof RefPtgBase) {\n                RefPtgBase refNPtg = (RefPtgBase)ptg;\n                ptg = new RefPtg(fixupRelativeRow(formulaRow,refNPtg.getRow(),refNPtg.isRowRelative()),\n                                     fixupRelativeColumn(formulaColumn,refNPtg.getColumn(),refNPtg.isColRelative()),\n                                     refNPtg.isRowRelative(),\n                                     refNPtg.isColRelative());\n                ptg.setClass(originalOperandClass);\n            } else if (ptg instanceof AreaPtgBase) {\n                AreaPtgBase areaNPtg = (AreaPtgBase)ptg;\n                ptg = new AreaPtg(fixupRelativeRow(formulaRow,areaNPtg.getFirstRow(),areaNPtg.isFirstRowRelative()),\n                                fixupRelativeRow(formulaRow,areaNPtg.getLastRow(),areaNPtg.isLastRowRelative()),\n                                fixupRelativeColumn(formulaColumn,areaNPtg.getFirstColumn(),areaNPtg.isFirstColRelative()),\n                                fixupRelativeColumn(formulaColumn,areaNPtg.getLastColumn(),areaNPtg.isLastColRelative()),\n                                areaNPtg.isFirstRowRelative(),\n                                areaNPtg.isLastRowRelative(),\n                                areaNPtg.isFirstColRelative(),\n                                areaNPtg.isLastColRelative());\n                ptg.setClass(originalOperandClass);\n            } else if (ptg instanceof OperandPtg) {\n                // Any subclass of OperandPtg is mutable, so it's safest to not share these instances.\n                ptg = ((OperandPtg) ptg).copy();\n            } else {\n            	// all other Ptgs are immutable and can be shared\n            }\n            newPtgStack[k] = ptg;\n        }\n        return newPtgStack;\n    }
498	public List<byte[]> getCRLs() {\n        return this.crls;\n    }
499	@Beta\n    public XSSFPivotTable createPivotTable(Name source, CellReference position) {\n        return createPivotTable(source, position, getWorkbook().getSheet(source.getSheetName()));\n    }
500	public void setText(byte[] b) {\n		// Set the text\n		_text = b.clone();\n\n		// Update the size (header bytes 5-8)\n		LittleEndian.putInt(_header,4,_text.length);\n	}
501	public void setNextRecordSize(int recordSize, boolean isPlain) {\n    }
502	public static void closeQuietly( final Closeable closeable ) {\n        // no need to log a NullPointerException here\n        if(closeable == null) {\n            return;\n        }\n\n        try {\n            closeable.close();\n        } catch ( Exception exc ) {\n            logger.log( POILogger.ERROR, "Unable to close resource: " + exc,\n                    exc );\n        }\n    }
503	public int getSize() {\n		return PLAIN_TOKEN_SIZE\n			// data written after the all tokens:\n			+ 1 + 2 // column, row\n			+ ConstantValueParser.getEncodedSize(_arrayValues);\n	}
504	protected final RuntimeException notImplemented() {\n        return new RuntimeException("Coding Error: This method should never be called. This ptg should be converted");\n    }
505	@Internal\n    public boolean isFWhichTblStm()\n    {\n        return fWhichTblStm.isSet(field_6_flags1);\n    }
506	public void addEscherProperty( EscherProperty prop )\n    {\n        properties.add( prop );\n    }
507	public void setStrikeThrough(StrikeType strike) {\n        getOrCreateProperties().setStrikeThrough(strike);\n    }
508	public String getSignatureDescription() {\n        return signatureDescription;\n    }
509	public DocumentEntry createDocument(final String name, final int size, final POIFSWriterListener writer)\n    throws IOException {\n        return getRoot().createDocument(name, size, writer);\n    }
510	public Charset getGuessedCharset() {\n        return guessedCharset;\n    }
511	public static List<FontGroupRange> getFontGroupRanges(final String runText) {\n        final List<FontGroupRange> ttrList = new ArrayList<>();\n        if (runText == null || runText.isEmpty()) {\n            return ttrList;\n        }\n        FontGroupRange ttrLast = null;\n        final int rlen = runText.length();\n        for(int cp, i = 0, charCount; i < rlen; i += charCount) {\n            cp = runText.codePointAt(i);\n            charCount = Character.charCount(cp);\n\n            // don't switch the font group for a few default characters supposedly available in all fonts\n            final FontGroup tt;\n            if (ttrLast != null && " \n\r".indexOf(cp) > -1) {\n                tt = ttrLast.fontGroup;\n            } else {\n                tt = lookup(cp);\n            }\n\n            if (ttrLast == null || ttrLast.fontGroup != tt) {\n                ttrLast = new FontGroupRange();\n                ttrLast.fontGroup = tt;\n                ttrList.add(ttrLast);\n            }\n            ttrLast.len += charCount;\n        }\n        return ttrList;\n    }
512	public void addTabStop(double value){\n        CTTextParagraphProperties pr = _p.isSetPPr() ? _p.getPPr() : _p.addNewPPr();\n        CTTextTabStopList tabStops = pr.isSetTabLst() ? pr.getTabLst() : pr.addNewTabLst();\n        tabStops.addNewTab().setPos(Units.toEMU(value));\n    }
513	@Internal\n    public boolean isFMacChs()\n    {\n        return fMacChs.isSet(field_49_CharsetFlags);\n    }
514	@Internal\n    public boolean isFLastRow()\n    {\n        return fLastRow.isSet(field_25_internalFlags);\n    }
515	private void addOverrideContentType(PackagePartName partName,\n            String contentType) {\n        if (overrideContentType == null) {\n            overrideContentType = new TreeMap<>();\n        }\n        overrideContentType.put(partName, contentType);\n    }
516	public boolean dispose()\n    {\n        boolean success = true;\n        for (SXSSFSheet sheet : _sxFromXHash.keySet())\n        {\n            try {\n                success = sheet.dispose() && success;\n            } catch (IOException e) {\n                logger.log(POILogger.WARN, e);\n                success = false;\n            }\n        }\n        return success;\n    }
517	public static InternalWorkbook createWorkbook(List<Record> recs) {\n        LOG.log(DEBUG, "Workbook (readfile) created with reclen=", recs.size());\n        InternalWorkbook retval = new InternalWorkbook();\n        List<Record> records = new ArrayList<>(recs.size() / 3);\n        retval.records.setRecords(records);\n\n        boolean eofPassed = false;\n        for (int k = 0; k < recs.size(); k++) {\n            Record rec = recs.get(k);\n            String logObj;\n            switch (rec.getSid()) {\n\n                case EOFRecord.sid :\n                    logObj = "workbook eof";\n                    break;\n\n                case BoundSheetRecord.sid :\n                    logObj = "boundsheet";\n                    retval.boundsheets.add((BoundSheetRecord) rec);\n                    retval.records.setBspos( k );\n                    break;\n\n                case SSTRecord.sid :\n                    logObj = "sst";\n                    retval.sst = ( SSTRecord ) rec;\n                    break;\n\n                case FontRecord.sid :\n                    logObj = "font";\n                    retval.records.setFontpos( k );\n                    retval.numfonts++;\n                    break;\n\n                case ExtendedFormatRecord.sid :\n                    logObj = "XF";\n                    retval.records.setXfpos( k );\n                    retval.numxfs++;\n                    break;\n\n                case TabIdRecord.sid :\n                    logObj = "tabid";\n                    retval.records.setTabpos( k );\n                    break;\n\n                case ProtectRecord.sid :\n                    logObj = "protect";\n                    retval.records.setProtpos( k );\n                    break;\n\n                case BackupRecord.sid :\n                    logObj = "backup";\n                    retval.records.setBackuppos( k );\n                    break;\n\n                case ExternSheetRecord.sid :\n                    throw new RecordFormatException("Extern sheet is part of LinkTable");\n\n                case NameRecord.sid :\n                case SupBookRecord.sid :\n                    // LinkTable can start with either of these\n                    LOG.log(DEBUG, "found SupBook record at " + k);\n                    retval.linkTable = new LinkTable(recs, k, retval.records, retval.commentRecords);\n                    k+=retval.linkTable.getRecordCount() - 1;\n                    continue;\n\n                case FormatRecord.sid :\n                    logObj = "format";\n                    FormatRecord fr = (FormatRecord) rec;\n                    retval.formats.add(fr);\n                    retval.maxformatid = retval.maxformatid >= fr.getIndexCode() ? retval.maxformatid : fr.getIndexCode();\n                    break;\n\n                case DateWindow1904Record.sid :\n                    logObj = "datewindow1904";\n                    retval.uses1904datewindowing = ((DateWindow1904Record)rec).getWindowing() == 1;\n                    break;\n\n                case PaletteRecord.sid:\n                    logObj = "palette";\n                    retval.records.setPalettepos( k );\n                    break;\n\n                case WindowOneRecord.sid:\n                    logObj = "WindowOneRecord";\n                    retval.windowOne = (WindowOneRecord) rec;\n                    break;\n\n                case WriteAccessRecord.sid:\n                    logObj = "WriteAccess";\n                    retval.writeAccess = (WriteAccessRecord) rec;\n                    break;\n\n                case WriteProtectRecord.sid:\n                    logObj = "WriteProtect";\n                    retval.writeProtect = (WriteProtectRecord) rec;\n                    break;\n\n                case FileSharingRecord.sid:\n                    logObj = "FileSharing";\n                    retval.fileShare = (FileSharingRecord) rec;\n                    break;\n\n                case NameCommentRecord.sid:\n                    logObj = "NameComment";\n                    final NameCommentRecord ncr = (NameCommentRecord) rec;\n                    retval.commentRecords.put(ncr.getNameText(), ncr);\n                    break;\n\n                case HyperlinkRecord.sid:\n                    // Look for other interesting values that follow the EOFRecord\n                    logObj = "Hyperlink";\n                    retval.hyperlinks.add((HyperlinkRecord)rec);\n                    break;\n\n                default:\n                    logObj = "(sid=" + rec.getSid() + ")";\n                    break;\n            }\n            if (!eofPassed) {\n                records.add(rec);\n            }\n            LOG.log(DEBUG, "found "+logObj+" record at " + k);\n            if (rec.getSid() == EOFRecord.sid) {\n                eofPassed = true;\n            }\n        }\n        //What if we dont have any ranges and supbooks\n        //        if (retval.records.supbookpos == 0) {\n        //            retval.records.supbookpos = retval.records.bspos + 1;\n        //            retval.records.namepos    = retval.records.supbookpos + 1;\n        //        }\n\n        if (retval.windowOne == null) {\n            retval.windowOne = createWindowOne();\n        }\n        LOG.log(DEBUG, "exit create workbook from existing file function");\n        return retval;\n    }
518	public void addStyle(XWPFStyle style) {\n        listStyle.add(style);\n        ctStyles.addNewStyle();\n        int pos = ctStyles.sizeOfStyleArray() - 1;\n        ctStyles.setStyleArray(pos, style.getCTStyle());\n    }
519	protected InputStream decorateInputStream(FileInputStream fis) throws IOException {\n        return fis;\n    }
520	@Internal\n    public boolean isFFirstRow()\n    {\n        return fFirstRow.isSet(field_25_internalFlags);\n    }
521	private void output8Codes(OutputStream res) throws IOException {\n	// Output the mask and the data\n	res.write(new byte[] { HDGFLZW.fromInt(nextMask) } );\n	res.write(buffer, 0, bufferLen);\n\n	// Reset things\n	nextMask = 0;\n	maskBitsSet = 0;\n	bufferLen = 0;\n}
522	private static PColor[] createDefaultPalette()\n    {\n        return new PColor[] {\n                pc(0, 0, 0),\n                pc(255, 255, 255),\n                pc(255, 0, 0),\n                pc(0, 255, 0),\n                pc(0, 0, 255),\n                pc(255, 255, 0),\n                pc(255, 0, 255),\n                pc(0, 255, 255),\n                pc(128, 0, 0),\n                pc(0, 128, 0),\n                pc(0, 0, 128),\n                pc(128, 128, 0),\n                pc(128, 0, 128),\n                pc(0, 128, 128),\n                pc(192, 192, 192),\n                pc(128, 128, 128),\n                pc(153, 153, 255),\n                pc(153, 51, 102),\n                pc(255, 255, 204),\n                pc(204, 255, 255),\n                pc(102, 0, 102),\n                pc(255, 128, 128),\n                pc(0, 102, 204),\n                pc(204, 204, 255),\n                pc(0, 0, 128),\n                pc(255, 0, 255),\n                pc(255, 255, 0),\n                pc(0, 255, 255),\n                pc(128, 0, 128),\n                pc(128, 0, 0),\n                pc(0, 128, 128),\n                pc(0, 0, 255),\n                pc(0, 204, 255),\n                pc(204, 255, 255),\n                pc(204, 255, 204),\n                pc(255, 255, 153),\n                pc(153, 204, 255),\n                pc(255, 153, 204),\n                pc(204, 153, 255),\n                pc(255, 204, 153),\n                pc(51, 102, 255),\n                pc(51, 204, 204),\n                pc(153, 204, 0),\n                pc(255, 204, 0),\n                pc(255, 153, 0),\n                pc(255, 102, 0),\n                pc(102, 102, 153),\n                pc(150, 150, 150),\n                pc(0, 51, 102),\n                pc(51, 153, 102),\n                pc(0, 51, 0),\n                pc(51, 51, 0),\n                pc(153, 51, 0),\n                pc(153, 51, 102),\n                pc(51, 51, 153),\n                pc(51, 51, 51),\n        };\n    }
523	@Internal\n    public byte getJc()\n    {\n        return ( byte )jc.getValue(field_3_info);\n    }
524	public void setComment(String comment) {\n        _ctName.setComment(comment);\n    }
525	public static POIXMLException error(String message, Object o) {\n        return new POIXMLException(o + ": " + message);\n    }
526	public ValueEval evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex) {\n		try {\n			if (args.length < 1  ||  args.length > 2) {\n				return ErrorEval.VALUE_INVALID;\n			}\n\n			// extract first parameter\n			ValueEval serialDateVE = OperandResolver.getSingleValue(args[0], srcRowIndex, srcColumnIndex);\n			double serialDate = OperandResolver.coerceValueToDouble(serialDateVE);\n			if (!DateUtil.isValidExcelDate(serialDate)) {\n				return ErrorEval.NUM_ERROR;						// EXCEL uses this and no VALUE_ERROR\n			}\n			Calendar date = DateUtil.getJavaCalendar(serialDate, false);		// (XXX 1904-windowing not respected)\n			int weekday = date.get(Calendar.DAY_OF_WEEK);		// => sunday = 1, monday = 2, ..., saturday = 7\n\n			// extract second parameter\n			int returnOption = 1;					// default value\n			if (args.length == 2) {\n				ValueEval ve = OperandResolver.getSingleValue(args[1], srcRowIndex, srcColumnIndex);\n				if (ve == MissingArgEval.instance  ||  ve == BlankEval.instance) {\n					return ErrorEval.NUM_ERROR;		// EXCEL uses this and no VALUE_ERROR\n				}\n				returnOption = OperandResolver.coerceValueToInt(ve);\n				if (returnOption == 2) {\n					returnOption = 11;				// both mean the same\n				}\n			} // if\n\n			// perform calculation\n			double result;\n			if (returnOption == 1) {\n				result = weekday;\n			// value 2 is handled above (as value 11)\n			} else if (returnOption == 3) {\n				result = (weekday + 6 - 1) % 7;\n			} else if (returnOption >= 11  &&  returnOption <= 17) {\n				result = (weekday + 6 - (returnOption - 10)) % 7 + 1;		// rotate in the value range 1 to 7\n			} else {\n				return ErrorEval.NUM_ERROR;		// EXCEL uses this and no VALUE_ERROR\n			}\n\n			return new NumberEval(result);\n		} catch (EvaluationException e) {\n			return e.getErrorEval();\n		}\n	}
527	protected String getRowName( HSSFRow row )\n    {\n        return String.valueOf( row.getRowNum() + 1 );\n    }
528	public static ZipSecureFile openZipFile(File file) throws IOException, NotOfficeXmlFileException {\n        if (!file.exists()) {\n            throw new FileNotFoundException("File does not exist");\n        }\n        if (file.isDirectory()) {\n            throw new IOException("File is a directory");\n        }\n        \n        // Peek at the first few bytes to sanity check\n        try (FileInputStream input = new FileInputStream(file)) {\n            verifyZipHeader(input);\n        }\n\n        // Open as a proper zip file\n        return new ZipSecureFile(file);\n    }
529	public static String font(String font, String style) {\n		return "&\"" + font + "," + style + "\"";\n	}
530	public boolean isReserved()\n    {\n        return reserved.isSet(field_6_options);\n    }
531	public void set7BitEncoding(String charset) {\n      for(Chunk c : mainChunks.getChunks()) {\n         if(c instanceof StringChunk) {\n            ((StringChunk)c).set7BitEncoding(charset);\n         }\n      }\n\n      if (nameIdChunks!=null) {\n         for(Chunk c : nameIdChunks.getChunks()) {\n            if(c instanceof StringChunk) {\n                ((StringChunk)c).set7BitEncoding(charset);\n            }\n         }\n      }\n\n      for(RecipientChunks rc : recipientChunks) {\n         for(Chunk c : rc.getAll()) {\n            if(c instanceof StringChunk) {\n               ((StringChunk)c).set7BitEncoding(charset);\n            }\n         }\n      }\n   }
532	public PackageRelationship getRelationship(String id) {\n        return this._relationships.getRelationshipByID(id);\n    }
533	public int getAccentColourRGB() { return accentColourRGB; }
534	public void setNfcPgn(byte field_4_nfcPgn)\n    {\n        this.field_4_nfcPgn = field_4_nfcPgn;\n    }
535	static void multiCell(Sheet sheet) {\n        // header row\n        Row row0 = sheet.createRow(0);\n        row0.createCell(0).setCellValue("Units");\n        row0.createCell(1).setCellValue("Cost");\n        row0.createCell(2).setCellValue("Total");\n\n        Row row1 = sheet.createRow(1);\n        row1.createCell(0).setCellValue(71);\n        row1.createCell(1).setCellValue(29);\n        row1.createCell(2).setCellValue(2059);\n\n        Row row2 = sheet.createRow(2);\n        row2.createCell(0).setCellValue(85);\n        row2.createCell(1).setCellValue(29);\n        row2.createCell(2).setCellValue(2059);\n\n        Row row3 = sheet.createRow(3);\n        row3.createCell(0).setCellValue(71);\n        row3.createCell(1).setCellValue(29);\n        row3.createCell(2).setCellValue(2059);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =$B2>75   (Blue Fill)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("$A2>75");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:C4")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(4).setCellValue("<== Condition 1: Formula Is =$B2>75   (Blue Fill)");\n    }
536	@SuppressWarnings("WeakerAccess")\n    public void setLineHeadWidth(DecorationSize style) {\n        CTLineProperties ln = getLn(this, true);\n        if (ln == null) {\n            return;\n        }\n        CTLineEndProperties lnEnd = ln.isSetHeadEnd() ? ln.getHeadEnd() : ln.addNewHeadEnd();\n        if (style == null) {\n            if (lnEnd.isSetW()) {\n                lnEnd.unsetW();\n            }\n        } else {\n            lnEnd.setW(STLineEndWidth.Enum.forInt(style.ooxmlId));\n        }\n    }
537	public void save(OutputStream outputStream) throws IOException {\n		throwExceptionIfReadOnly();\n		this.saveImpl(outputStream);\n	}
538	private static ExtSSTRecord createExtendedSST() {\n        ExtSSTRecord retval = new ExtSSTRecord();\n        retval.setNumStringsPerBucket(( short ) 0x8);\n        return retval;\n    }
539	public int countOfAllChildren() {\n        int count = _shapes.size();\n        for (HSSFShape shape : _shapes) {\n            count += shape.countOfAllChildren();\n        }\n        return count;\n    }
540	private static ExtendedFormatRecord createExtendedFormat(int id) {\n        // we'll need multiple editions\n        switch (id) {\n            case  0: return createExtendedFormat(0,    0, 0xfffffff5,          0);\n            case  1:\n            case  2: return createExtendedFormat(1,    0, 0xfffffff5, 0xfffff400);\n            case  3:\n            case  4: return createExtendedFormat(2,    0, 0xfffffff5, 0xfffff400);\n            case  5:\n            case  6:\n            case  7:\n            case  8:\n            case  9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14: return createExtendedFormat(0,    0, 0xfffffff5, 0xfffff400);\n            // cell records\n            case 15: return createExtendedFormat(0,    0,          1,          0);\n            // style\n            case 16: return createExtendedFormat(1, 0x2b, 0xfffffff5, 0xfffff800);\n            case 17: return createExtendedFormat(1, 0x29, 0xfffffff5, 0xfffff800);\n            case 18: return createExtendedFormat(1, 0x2c, 0xfffffff5, 0xfffff800);\n            case 19: return createExtendedFormat(1, 0x2a, 0xfffffff5, 0xfffff800);\n            case 20: return createExtendedFormat(1, 0x09, 0xfffffff5, 0xfffff800);\n            // unused from this point down\n            case 21: return createExtendedFormat(5,    0,          1,      0x800);\n            case 22: return createExtendedFormat(6,    0,          1,     0x5c00);\n            case 23: return createExtendedFormat(0, 0x31,          1,     0x5c00);\n            case 24: return createExtendedFormat(0,    8,          1,     0x5c00);\n            case 25: return createExtendedFormat(6,    8,          1,     0x5c00);\n\n            default: throw new IllegalStateException("Unrecognized format id: " + id);\n        }\n    }
541	public List<String> getTextAsVector() {\n	    List<String> textV = new ArrayList<>();\n\n		// Set to the start of the file\n		int walkPos = 0;\n\n		// Start walking the file, looking for the records\n		while(walkPos != -1) {\n            walkPos = findTextRecords(walkPos,textV);\n		}\n\n		// Return what we find\n		return textV;\n	}
542	public static Record [] createRecord(RecordInputStream in) {\n        Record record = createSingleRecord(in);\n        if (record instanceof DBCellRecord) {\n            // Not needed by POI.  Regenerated from scratch by POI when spreadsheet is written\n            return new Record[] { null, };\n        }\n        if (record instanceof RKRecord) {\n            return new Record[] { convertToNumberRecord((RKRecord) record), };\n        }\n        if (record instanceof MulRKRecord) {\n            return convertRKRecords((MulRKRecord)record);\n        }\n        return new Record[] { record, };\n    }
543	public ValueEval evaluate(ValueEval[] args, OperationEvaluationContext ec) { // NOSONAR\n        if (args.length < 2 || args.length > 3) {\n            return ErrorEval.VALUE_INVALID;\n        }\n\n        int srcCellRow = ec.getRowIndex();\n        int srcCellCol = ec.getColumnIndex();\n\n        double start, end;\n        double[] holidays;\n        try {\n            start = this.evaluator.evaluateDateArg(args[0], srcCellRow, srcCellCol);\n            end = this.evaluator.evaluateDateArg(args[1], srcCellRow, srcCellCol);\n            if (start > end) {\n                return ErrorEval.NAME_INVALID;\n            }\n            ValueEval holidaysCell = args.length == 3 ? args[2] : null;\n            holidays = this.evaluator.evaluateDatesArg(holidaysCell, srcCellRow, srcCellCol);\n            return new NumberEval(WorkdayCalculator.instance.calculateWorkdays(start, end, holidays));\n        } catch (EvaluationException e) {\n            return ErrorEval.VALUE_INVALID;\n        }\n    }
544	private Record readNextRecord() {\n\n		Record record = RecordFactory.createSingleRecord(_recStream);\n		_lastRecordWasEOFLevelZero = false;\n\n		if (record instanceof BOFRecord) {\n			_bofDepth++;\n			return record;\n		}\n\n		if (record instanceof EOFRecord) {\n			_bofDepth--;\n			if (_bofDepth < 1) {\n				_lastRecordWasEOFLevelZero = true;\n			}\n\n			return record;\n		}\n\n		if (record instanceof DBCellRecord) {\n			// Not needed by POI.  Regenerated from scratch by POI when spreadsheet is written\n			return null;\n		}\n\n		if (record instanceof RKRecord) {\n			return RecordFactory.convertToNumberRecord((RKRecord) record);\n		}\n\n		if (record instanceof MulRKRecord) {\n			Record[] records = RecordFactory.convertRKRecords((MulRKRecord) record);\n\n			_unreadRecordBuffer = records;\n			_unreadRecordIndex = 1;\n			return records[0];\n		}\n\n		if (record.getSid() == DrawingGroupRecord.sid\n				&& _lastRecord instanceof DrawingGroupRecord) {\n			DrawingGroupRecord lastDGRecord = (DrawingGroupRecord) _lastRecord;\n			lastDGRecord.join((AbstractEscherHolderRecord) record);\n			return null;\n		}\n		if (record.getSid() == ContinueRecord.sid) {\n			ContinueRecord contRec = (ContinueRecord) record;\n\n			if (_lastRecord instanceof ObjRecord || _lastRecord instanceof TextObjectRecord) {\n				// Drawing records have a very strange continue behaviour.\n				//There can actually be OBJ records mixed between the continues.\n				_lastDrawingRecord.processContinueRecord(contRec.getData());\n				//we must remember the position of the continue record.\n				//in the serialization procedure the original structure of records must be preserved\n				if (_shouldIncludeContinueRecords) {\n					return record;\n				}\n				return null;\n			}\n			if (_lastRecord instanceof DrawingGroupRecord) {\n				((DrawingGroupRecord) _lastRecord).processContinueRecord(contRec.getData());\n				return null;\n			}\n			if (_lastRecord instanceof DrawingRecord) {\n//				((DrawingRecord) _lastRecord).appendContinueRecord(contRec.getData());\n				return contRec;\n			}\n			if (_lastRecord instanceof UnknownRecord) {\n				//Gracefully handle records that we don't know about,\n				//that happen to be continued\n				return record;\n			}\n			if (_lastRecord instanceof EOFRecord) {\n				// This is really odd, but excel still sometimes\n				//  outputs a file like this all the same\n				return record;\n			}\n			throw new RecordFormatException("Unhandled Continue Record followining " + _lastRecord.getClass());\n		}\n		_lastRecord = record;\n		if (record instanceof DrawingRecord) {\n			_lastDrawingRecord = (DrawingRecord) record;\n		}\n		return record;\n	}
545	public int getAccentAndHyperlinkColourRGB()\n		{ return accentAndHyperlinkColourRGB; }
546	@Internal\n    public boolean isFHybrid()\n    {\n        return fHybrid.isSet(field_4_flags);\n    }
547	private static int compareAcrossSubnormalThreshold(long normalRawBitsA, long subnormalRawBitsB, boolean isNegative) {\n		long fracB = subnormalRawBitsB & FRAC_MASK;\n		if (fracB == 0) {\n			// B is zero, so A is definitely greater than B\n			return isNegative ? -1 : +1;\n		}\n		long fracA = normalRawBitsA & FRAC_MASK;\n		if (fracA <= 0x0000000000000007L && fracB >= 0x000FFFFFFFFFFFFAL) {\n			// Both A and B close to threshold - weird results\n			if (fracA == 0x0000000000000007L && fracB == 0x000FFFFFFFFFFFFAL) {\n				// special case\n				return 0;\n			}\n			// exactly the opposite\n			return isNegative ? +1 : -1;\n		}\n		// else - typical case A and B is not close to threshold\n		return isNegative ? -1 : +1;\n	}
548	private String formatUnit(double f, int units) {\n    long Whole = (long)f;\n    f -= Whole;\n    long Num = Math.round(f * units);\n\n    return new StringBuffer().append(Whole).append(" ").append(Num).append("/").append(units).toString();\n  }
549	public String getLocalXPath() {\n        StringBuilder localXPath = new StringBuilder();\n        int numberOfCommonXPathAxis = table.getCommonXpath().split("/").length-1;\n\n        String[] xPathTokens = ctXmlColumnPr.getXpath().split("/");\n        for (int i = numberOfCommonXPathAxis; i < xPathTokens.length; i++) {\n            localXPath.append("/" + xPathTokens[i]);\n        }\n        return localXPath.toString();\n    }
550	public final char getRVAType() {\n		if (isBaseToken()) {\n			return '.';\n		}\n		switch (ptgClass) {\n			case Ptg.CLASS_REF:   return 'R';\n			case Ptg.CLASS_VALUE: return 'V';\n			case Ptg.CLASS_ARRAY: return 'A';\n		}\n		throw new RuntimeException("Unknown operand class (" + ptgClass + ")");\n	}
551	protected PackagePart addPackagePart(PackagePart part) {\n		throwExceptionIfReadOnly();\n		if (part == null) {\n			throw new IllegalArgumentException("part");\n		}\n\n		if (partList.containsKey(part._partName)) {\n			if (!partList.get(part._partName).isDeleted()) {\n				throw new InvalidOperationException(\n						"A part with the name '"\n								+ part._partName.getName()\n								+ "' already exists : Packages shall not contain equivalent part names and package implementers shall neither create nor recognize packages with equivalent part names. [M1.12]");\n			}\n			// If the specified partis flagged as deleted, we make it\n			// available\n			part.setDeleted(false);\n			// and delete the old part to replace it thereafeter\n			this.partList.remove(part._partName);\n		}\n		this.partList.put(part._partName, part);\n		this.isDirty = true;\n		return part;\n	}
552	public static double getColumnWidth(Sheet sheet, int column, boolean useMergedCells) {\n        return getColumnWidth(sheet, column, useMergedCells, sheet.getFirstRowNum(), sheet.getLastRowNum());\n    }
553	public void setRow(int row) {\n		field_1_row = row;\n	}
554	@Internal\n    public void removeHyperlink(int row, int column) {\n        // CTHyperlinks is regenerated from scratch when writing out the spreadsheet\n        // so don't worry about maintaining hyperlinks and CTHyperlinks in parallel.\n        // only maintain hyperlinks\n        String ref = new CellReference(row, column).formatAsString();\n        for (Iterator<XSSFHyperlink> it = hyperlinks.iterator(); it.hasNext();) {\n            XSSFHyperlink hyperlink = it.next();\n            if (hyperlink.getCellRef().equals(ref)) {\n                it.remove();\n                return;\n            }\n        }\n    }
555	public void updateNamesAfterCellShift(FormulaShifter shifter) {\n        for (int i = 0 ; i < getNumNames() ; ++i){\n            NameRecord nr = getNameRecord(i);\n            Ptg[] ptgs = nr.getNameDefinition();\n            if (shifter.adjustFormula(ptgs, nr.getSheetNumber())) {\n                nr.setNameDefinition(ptgs);\n            }\n        }\n    }
556	/*package*/ InternalSheet getSheet() {\n        return _sheet;\n    }
557	private void isCellFontItalicsMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        boolean b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getItalic();\n        boolean b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getItalic();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 ? "" : "NOT ")+"ITALICS",\n                (b2 ? "" : "NOT ")+"ITALICS"\n            );\n        }\n    }
558	public int compareTo(HSSFRichTextString r) {\n       return _string.compareTo(r._string);\n    }
559	@Internal\n    public boolean isFWebView()\n    {\n        return fWebView.isSet(field_32_viewFlags);\n    }
560	public boolean numExist(BigInteger numID) {\n        for (XWPFNum num : nums) {\n            if (num.getCTNum().getNumId().equals(numID))\n                return true;\n        }\n        return false;\n    }
561	public static URI resolvePartUri(URI sourcePartUri, URI targetUri) {\n		if (sourcePartUri == null || sourcePartUri.isAbsolute()) {\n			throw new IllegalArgumentException("sourcePartUri invalid - "\n					+ sourcePartUri);\n		}\n\n		if (targetUri == null || targetUri.isAbsolute()) {\n			throw new IllegalArgumentException("targetUri invalid - "\n					+ targetUri);\n		}\n\n		return sourcePartUri.resolve(targetUri);\n	}
562	protected static void preserveSpaces(STXstring xs) {\n        String text = xs.getStringValue();\n        if (text != null && text.length() > 0) {\n            char firstChar = text.charAt(0);\n            char lastChar  = text.charAt(text.length() - 1);\n            if(Character.isWhitespace(firstChar) || Character.isWhitespace(lastChar)) {\n                XmlCursor c = xs.newCursor();\n                c.toNextToken();\n                c.insertAttributeWithValue(new QName("http://www.w3.org/XML/1998/namespace", "space"), "preserve");\n                c.dispose();\n            }\n        }\n    }
563	@SuppressWarnings("unchecked")\n    public <T extends Record> T getClientDataRecord(int recordType) {\n\n        List<? extends Record> records = getClientRecords();\n        if (records != null) for (Record r : records) {\n            if (r.getRecordType() == recordType){\n                return (T)r;\n            }\n        }\n        return null;\n    }
564	static public double pmt(double r, int nper, double pv) {\n	    return pmt(r, nper, pv, 0);\n	}
565	@Internal\n    public short getGrfhic()\n    {\n        return ( short )grfhic.getValue(field_2_flags);\n    }
566	private void buildRecords() throws IOException {\n        // The format of records in a powerpoint file are:\n        //   <little endian 2 byte "info">\n        //   <little endian 2 byte "type">\n        //   <little endian 4 byte "length">\n        // If it has a zero length, following it will be another record\n        //		<xx xx yy yy 00 00 00 00> <xx xx yy yy zz zz zz zz>\n        // If it has a length, depending on its type it may have children or data\n        // If it has children, these will follow straight away\n        //		<xx xx yy yy zz zz zz zz <xx xx yy yy zz zz zz zz>>\n        // If it has data, this will come straigh after, and run for the length\n        //      <xx xx yy yy zz zz zz zz dd dd dd dd dd dd dd>\n        // All lengths given exclude the 8 byte record header\n        // (Data records are known as Atoms)\n\n        // Document should start with:\n        //   0F 00 E8 03 ## ## ## ##\n        //     (type 1000 = document, info 00 0f is normal, rest is document length)\n        //   01 00 E9 03 28 00 00 00\n        //     (type 1001 = document atom, info 00 01 normal, 28 bytes long)\n        //   80 16 00 00 E0 10 00 00 xx xx xx xx xx xx xx xx\n        //   05 00 00 00 0A 00 00 00 xx xx xx\n        //     (the contents of the document atom, not sure what it means yet)\n        //   (records then follow)\n\n        // When parsing a document, look to see if you know about that type\n        //  of the current record. If you know it's a type that has children,\n        //  process the record's data area looking for more records\n        // If you know about the type and it doesn't have children, either do\n        //  something with the data (eg TextRun) or skip over it\n        // If you don't know about the type, play safe and skip over it (using\n        //  its length to know where the next record will start)\n        //\n\n        _records = read(_docstream, (int) currentUser.getCurrentEditOffset());\n    }
567	public boolean getMirrorMargins() {\n        return ctSettings.isSetMirrorMargins();\n    }
568	private static short getShort(Object value) {\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n        return 0;\n    }
569	@Internal\n    public boolean isFLowerCase()\n    {\n        return fLowerCase.isSet(field_1_grpfChp);\n    }
570	public byte[] decompress(InputStream src) throws IOException {\n      ByteArrayOutputStream res = new ByteArrayOutputStream();\n      decompress(src,res);\n      return res.toByteArray();\n   }
571	@SuppressWarnings("WeakerAccess")\n    public void copyLayout(XSLFSlide slide) {\n        for (XSLFShape sh : getShapes()) {\n            if (sh instanceof XSLFTextShape) {\n                XSLFTextShape tsh = (XSLFTextShape) sh;\n                Placeholder ph = tsh.getTextType();\n                if (ph == null) continue;\n\n                switch (ph) {\n                    // these are special and not copied by default\n                    case DATETIME:\n                    case SLIDE_NUMBER:\n                    case FOOTER:\n                        break;\n                    default:\n                        slide.getSpTree().addNewSp().set(tsh.getXmlObject().copy());\n                }\n            }\n        }\n    }
572	public void setBulletColorFollowText() {\n        getOrCreateBulletProperties().setBulletColorFollowText();\n    }
573	public POIXMLDocumentPart newDocumentPart(POIXMLRelation descriptor) {\n         Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();\n         try {\n             return createDocumentPart(cls, null, null);\n         } catch (Exception e) {\n             throw new POIXMLException(e);\n         }\n     }
574	public static void evaluateAllFormulaCells(SXSSFWorkbook wb, boolean skipOutOfWindow) {\n        SXSSFFormulaEvaluator eval = new SXSSFFormulaEvaluator(wb);\n        \n        // Check they're all available\n        for (Sheet sheet : wb) {\n            if (((SXSSFSheet)sheet).areAllRowsFlushed()) {\n                throw new SheetsFlushedException();\n            }\n        }\n        \n        // Process the sheets as best we can\n        for (Sheet sheet : wb) {\n            \n            // Check if any rows have already been flushed out\n            int lastFlushedRowNum = ((SXSSFSheet) sheet).getLastFlushedRowNum();\n            if (lastFlushedRowNum > -1) {\n                if (! skipOutOfWindow) throw new RowFlushedException(0);\n                logger.log(POILogger.INFO, "Rows up to " + lastFlushedRowNum + " have already been flushed, skipping");\n            }\n            \n            // Evaluate what we have\n            for (Row r : sheet) {\n                for (Cell c : r) {\n                    if (c.getCellType() == CellType.FORMULA) {\n                        eval.evaluateFormulaCell(c);\n                    }\n                }\n            }\n        }\n    }
575	public Color getColor() {\n        return DrawPaint.applyColorTransform(getColorStyle());\n    }
576	public void addNewCol() {\n        if (ctTbl.sizeOfTrArray() == 0) {\n            createRow();\n        }\n        for (int i = 0; i < ctTbl.sizeOfTrArray(); i++) {\n            XWPFTableRow tabRow = new XWPFTableRow(ctTbl.getTrArray(i), this);\n            tabRow.createCell();\n        }\n    }
577	private CellFormatPart getApplicableFormatPart(Object value) {\n        \n        if (value instanceof Number) {\n            \n            double val = ((Number) value).doubleValue();\n            \n            if (formatPartCount == 1) {\n                if (!posNumFmt.hasCondition()\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else {\n                    return new CellFormatPart(locale, "General");\n                }\n            } else if (formatPartCount == 2) {\n                if ((!posNumFmt.hasCondition() && val >= 0)\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else if (!negNumFmt.hasCondition()\n                        || (negNumFmt.hasCondition() && negNumFmt.applies(val))) {\n                    return negNumFmt;\n                } else {\n                    // Return ###...### (255 #s) to match Excel 2007 behaviour\n                    return new CellFormatPart(QUOTE + INVALID_VALUE_FOR_FORMAT + QUOTE);\n                }\n            } else {\n                if ((!posNumFmt.hasCondition() && val > 0)\n                        || (posNumFmt.hasCondition() && posNumFmt.applies(val))) {\n                    return posNumFmt;\n                } else if ((!negNumFmt.hasCondition() && val < 0)\n                        || (negNumFmt.hasCondition() && negNumFmt.applies(val))) {\n                    return negNumFmt;\n                // Only the first two format parts can have conditions\n                } else {\n                    return zeroNumFmt;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException("value must be a Number");\n        }\n        \n    }
578	public int getRandomAccessWindowSize() {\n    	return _randomAccessWindowSize;\n    }
579	public void setPictureData(HSLFPictureData data){\n        AbstractEscherOptRecord opt = shape.getEscherOptRecord();\n        HSLFShape.setEscherProperty(opt, (short)(EscherProperties.FILL__PATTERNTEXTURE + 0x4000), (data == null ? 0 : data.getIndex()));\n        if(data != null && shape.getSheet() != null) {\n            EscherBSERecord bse = getEscherBSERecord(data.getIndex());\n            if (bse != null) {\n                bse.setRef(bse.getRef() + 1);\n            }\n        }\n    }
580	public List<PackagePart> getPartsByName(final Pattern namePattern) {\n	    if (namePattern == null) {\n	        throw new IllegalArgumentException("name pattern must not be null");\n	    }\n	    Matcher matcher = namePattern.matcher("");\n	    ArrayList<PackagePart> result = new ArrayList<>();\n	    for (PackagePart part : partList.sortedValues()) {\n	        PackagePartName partName = part.getPartName();\n	        if (matcher.reset(partName.getName()).matches()) {\n	            result.add(part);\n	        }\n	    }\n	    return result;\n	}
581	private static void centerAcrossSelection(XSSFWorkbook wb, XSSFRow row,\n            int start_column, int end_column, VerticalAlignment valign) {\n        CreationHelper ch = wb.getCreationHelper();\n\n        // Create cell style with ALIGN_CENTER_SELECTION\n        XSSFCellStyle cellStyle = wb.createCellStyle();\n        cellStyle.setAlignment(HorizontalAlignment.CENTER_SELECTION);\n        cellStyle.setVerticalAlignment(valign);\n\n        // Create cells over the selected area\n        for (int i = start_column; i <= end_column; i++) {\n            XSSFCell cell = row.createCell(i);\n            cell.setCellStyle(cellStyle);\n        }\n\n        // Set value to the first cell\n        XSSFCell cell = row.getCell(start_column);\n        cell.setCellValue(ch.createRichTextString("Align It"));\n\n        // Make the selection\n        CTRowImpl ctRow = (CTRowImpl) row.getCTRow();\n\n        // Add object with format start_coll:end_coll. For example 1:3 will span from\n        // cell 1 to cell 3, where the column index starts with 0\n        //\n        // You can add multiple spans for one row\n        Object span = start_column + ":" + end_column;\n\n        List<Object> spanList = new ArrayList<>();\n        spanList.add(span);\n\n        //add spns to the row\n        ctRow.setSpans(spanList);\n    }
582	public void unregisterPartAndContentType(PackagePartName partName) {\n        removePart(partName);\n        this.contentTypeManager.removeContentType(partName);\n        this.isDirty = true;\n    }
583	protected void writeProperties() throws IOException {\n        validateInPlaceWritePossible();\n        writeProperties(directory.getFileSystem(), null);\n    }
584	public void setValue(Chunk chunk) {\n        // TODO\n    }
585	public Integer[] getBulletOffsets(){\n        return leftMargin;\n    }
586	public void setRncFtn(final short field_60_rncftn) {\n        this.field_60_rncftn = field_60_rncftn;\n    }
587	public void updateNameCommentRecordCache(final NameCommentRecord commentRecord) {\n       if(commentRecords.containsValue(commentRecord)) {\n          for(Entry<String,NameCommentRecord> entry : commentRecords.entrySet()) {\n             if(entry.getValue().equals(commentRecord)) {\n                commentRecords.remove(entry.getKey());\n                break;\n             }\n          }\n       }\n       commentRecords.put(commentRecord.getNameText(), commentRecord);\n    }
588	@Internal\n    public CTInline addChart(String chartRelId)\n            throws InvalidFormatException, IOException {\n        try {\n            CTInline inline = run.addNewDrawing().addNewInline();\n\n            //xml part of chart in document\n            String xml =\n                    "<a:graphic xmlns:a=\"" + CTGraphicalObject.type.getName().getNamespaceURI() + "\">" +\n                            "<a:graphicData uri=\"" + CTChart.type.getName().getNamespaceURI() + "\">" +\n                            "<c:chart xmlns:c=\"" + CTChart.type.getName().getNamespaceURI() + "\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"" + chartRelId + "\" />" +\n                            "</a:graphicData>" +\n                            "</a:graphic>";\n\n            InputSource is = new InputSource(new StringReader(xml));\n\n            org.w3c.dom.Document doc = DocumentHelper.readDocument(is);\n\n            inline.set(XmlToken.Factory.parse(doc.getDocumentElement(), DEFAULT_XML_OPTIONS));\n\n            // Setup the inline with 0 margin\n            inline.setDistT(0);\n            inline.setDistR(0);\n            inline.setDistB(0);\n            inline.setDistL(0);\n\n            CTNonVisualDrawingProps docPr = inline.addNewDocPr();\n            long id = getParent().getDocument().getDrawingIdManager().reserveNew();\n            docPr.setId(id);\n            //This name is not visible in Word anywhere.\n            docPr.setName("chart " + id);\n\n            return inline;\n        } catch (XmlException e) {\n            throw new IllegalStateException(e);\n        } catch (SAXException e) {\n            throw new IllegalStateException(e);\n        }\n    }
589	// -> May be null\n    public List<XDGFShape> getShapes() {\n        return _shapes;\n    }
590	public void setStringValue(String cellName, String value) {\n        Cell cell = getCell(cellName);\n        cell.setCellValue(value);\n    }
591	public static long copy(InputStream srcStream, File destFile) throws IOException {\n        File destDirectory = destFile.getParentFile();\n        if (!(destDirectory.exists() || destDirectory.mkdirs())) {\n            throw new RuntimeException("Can't create destination directory: "+destDirectory);\n        }\n        try (OutputStream destStream = new FileOutputStream(destFile)) {\n            return IOUtils.copy(srcStream, destStream);\n        }\n    }
592	public static double getColumnWidth(Sheet sheet, int column, boolean useMergedCells, int firstRow, int lastRow){\n        DataFormatter formatter = new DataFormatter();\n        int defaultCharWidth = getDefaultCharWidth(sheet.getWorkbook());\n\n        double width = -1;\n        for (int rowIdx = firstRow; rowIdx <= lastRow; ++rowIdx) {\n            Row row = sheet.getRow(rowIdx);\n            if( row != null ) {\n                double cellWidth = getColumnWidthForRow(row, column, defaultCharWidth, formatter, useMergedCells);\n                width = Math.max(width, cellWidth);\n            }\n        }\n        return width;\n    }
593	public short getShortRawValue(final short holder)\n    {\n        return ( short ) getRawValue(holder);\n    }
594	protected CTOleObject readOleObject(long shapeId) {\n        if (!getCTWorksheet().isSetOleObjects()) {\n            return null;\n        }\n\n        // we use a XmlCursor here to handle oleObject with-/out AlternateContent wrappers\n        String xquery = "declare namespace p='"+XSSFRelation.NS_SPREADSHEETML+"' .//p:oleObject";\n        XmlCursor cur = getCTWorksheet().getOleObjects().newCursor();\n        try {\n            cur.selectPath(xquery);\n            CTOleObject coo = null;\n            while (cur.toNextSelection()) {\n                String sId = cur.getAttributeText(new QName(null, "shapeId"));\n                if (sId == null || Long.parseLong(sId)  != shapeId) {\n                    continue;\n                }\n\n                XmlObject xObj = cur.getObject();\n                if (xObj instanceof CTOleObject) {\n                    // the unusual case ...\n                    coo = (CTOleObject)xObj;\n                } else {\n                    XMLStreamReader reader = cur.newXMLStreamReader();\n                    try {\n                        CTOleObjects coos = CTOleObjects.Factory.parse(reader);\n                        if (coos.sizeOfOleObjectArray() == 0) {\n                            continue;\n                        }\n                        coo = coos.getOleObjectArray(0);\n                    } catch (XmlException e) {\n                        logger.log(POILogger.INFO, "can't parse CTOleObjects", e);\n                    } finally {\n                        try {\n                            reader.close();\n                        } catch (XMLStreamException e) {\n                            logger.log(POILogger.INFO, "can't close reader", e);\n                        }\n                    }\n                }\n\n                // there are choice and fallback OleObject ... we prefer the one having the objectPr element,\n                // which is in the choice element\n                if (cur.toChild(XSSFRelation.NS_SPREADSHEETML, "objectPr")) {\n                    break;\n                }\n            }\n            return (coo == null) ? null : coo;\n        } finally {\n            cur.dispose();\n        }\n    }
595	public ValueEval evaluate(String formula, CellReference ref) {\n        final String sheetName = ref == null ? null : ref.getSheetName();\n        int sheetIndex;\n        if (sheetName == null) {\n            sheetIndex = -1; // workbook scope only\n        } else {\n            sheetIndex = getWorkbook().getSheetIndex(sheetName);\n        }\n        int rowIndex = ref == null ? -1 : ref.getRow();\n        short colIndex = ref == null ? -1 : ref.getCol();\n        final OperationEvaluationContext ec = new OperationEvaluationContext(\n                this, \n                getWorkbook(), \n                sheetIndex, \n                rowIndex, \n                colIndex, \n                new EvaluationTracker(_cache)\n            );\n        Ptg[] ptgs = FormulaParser.parse(formula, (FormulaParsingWorkbook) getWorkbook(), FormulaType.CELL, sheetIndex, rowIndex);\n        return evaluateNameFormula(ptgs, ec);\n    }
596	public static Font makeFont(HSSFFont font) {\n    boolean isbold = font.getBold();\n    boolean isitalics = font.getItalic();\n    int fontstyle = Font.PLAIN;\n    if (isbold) {\n      fontstyle = Font.BOLD;\n    }\n    if (isitalics) {\n      fontstyle = fontstyle | Font.ITALIC;\n    }\n\n    int fontheight = font.getFontHeightInPoints();\n    if (fontheight == 9) {\n      //fix for stupid ol Windows\n      fontheight = 10;\n    }\n\n    return new Font(font.getFontName(), fontstyle, fontheight);\n  }
597	private InputStream openClasspathResource(String sampleFileName) {\n        return getClass().getResourceAsStream("/" + _moduleDir + "/" + sampleFileName);\n    }
598	public boolean getWrapText() {\n        return cellAlignement.getWrapText();\n    }
599	public void setDgId(short dgId) {\n        EscherContainerRecord dgContainer = getEscherContainer();\n        EscherDgRecord dg = dgContainer.getChildById(EscherDgRecord.RECORD_ID);\n        dg.setOptions((short) (dgId << 4));\n    }
600	public void setLineWidth( double lineWidth ) {\n        CTShapeProperties props = getShapeProperties();\n        CTLineProperties ln = props.isSetLn() ? props.getLn() : props.addNewLn();\n        ln.setW((int)(lineWidth*Units.EMU_PER_POINT));\n    }
601	protected short processRecord(Record rec) throws HSSFUserException {\n		List<HSSFListener> listeners = _records.get(Short.valueOf(rec.getSid()));\n		short userCode = 0;\n\n		if (listeners != null) {\n\n			for (int k = 0; k < listeners.size(); k++) {\n				Object listenObj = listeners.get(k);\n				if (listenObj instanceof AbortableHSSFListener) {\n					AbortableHSSFListener listener = (AbortableHSSFListener) listenObj;\n					userCode = listener.abortableProcessRecord(rec);\n					if (userCode != 0)\n						break;\n				} else {\n					HSSFListener listener = (HSSFListener) listenObj;\n					listener.processRecord(rec);\n				}\n			}\n		}\n		return userCode;\n	}
602	public boolean hasNextRecord() throws LeftoverDataException {\n		if (_currentDataLength != -1 && _currentDataLength != _currentDataOffset) {\n			throw new LeftoverDataException(_currentSid, remaining());\n		}\n		if (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {\n			_nextSid = readNextSid();\n		}\n		return _nextSid != INVALID_SID_VALUE;\n	}
603	public void findChunks() {\n		ArrayList<Chunk> chunksA = new ArrayList<>();\n\n		if(getPointer().getOffset() == 0x64b3) {\n			int i = 0;\n			i++;\n		}\n\n		int pos = 0;\n		byte[] contents = getStore().getContents();\n		try {\n			while(pos < contents.length) {\n				// Ensure we have enough data to create a chunk from\n				int headerSize = ChunkHeader.getHeaderSize(chunkFactory.getVersion());\n				if(pos+headerSize <= contents.length) {\n					Chunk chunk = chunkFactory.createChunk(contents, pos);\n					chunksA.add(chunk);\n\n					pos += chunk.getOnDiskSize();\n				} else {\n					logger.log(POILogger.WARN, "Needed " + headerSize + " bytes to create the next chunk header, but only found " + (contents.length-pos) + " bytes, ignoring rest of data");\n					pos = contents.length;\n				}\n			}\n		}\n		catch (Exception e)\n		{\n			logger.log(POILogger.ERROR, "Failed to create chunk at " + pos + ", ignoring rest of data." + e);\n		}\n\n		chunks = chunksA.toArray(new Chunk[chunksA.size()]);\n	}
604	public void updateColumnWidths(Row row) {\n        // track new columns\n        implicitlyTrackColumnsInRow(row);\n        \n        // update the widths\n        // for-loop over the shorter of the number of cells in the row and the number of tracked columns\n        // these two for-loops should do the same thing\n        if (maxColumnWidths.size() < row.getPhysicalNumberOfCells()) {\n            // loop over the tracked columns, because there are fewer tracked columns than cells in this row\n            for (final Entry<Integer, ColumnWidthPair> e : maxColumnWidths.entrySet()) {\n                final int column = e.getKey();\n                final Cell cell = row.getCell(column); //is MissingCellPolicy=Row.RETURN_NULL_AND_BLANK needed?\n\n                // FIXME: if cell belongs to a merged region, some of the merged region may have fallen outside of the random access window\n                // In this case, getting the column width may result in an error. Need to gracefully handle this.\n\n                // FIXME: Most cells are not merged, so calling getCellWidth twice re-computes the same value twice.\n                // Need to rewrite this to avoid unnecessary computation if this proves to be a performance bottleneck.\n\n                if (cell != null) {\n                    final ColumnWidthPair pair = e.getValue();\n                    updateColumnWidth(cell, pair);\n                }\n            }\n        }\n        else {\n            // loop over the cells in this row, because there are fewer cells in this row than tracked columns\n            for (final Cell cell : row) {\n                final int column = cell.getColumnIndex();\n\n                // FIXME: if cell belongs to a merged region, some of the merged region may have fallen outside of the random access window\n                // In this case, getting the column width may result in an error. Need to gracefully handle this.\n\n                // FIXME: Most cells are not merged, so calling getCellWidth twice re-computes the same value twice.\n                // Need to rewrite this to avoid unnecessary computation if this proves to be a performance bottleneck.\n\n                if (maxColumnWidths.containsKey(column)) {\n                    final ColumnWidthPair pair = maxColumnWidths.get(column);\n                    updateColumnWidth(cell, pair);\n                }\n            }\n        }\n    }
605	public static void optimiseCellStyles(HSSFWorkbook workbook) {\n       // Where each style has ended up, and if we need to\n       //  delete the record for it. Start off with no change\n       short[] newPos = new short[workbook.getWorkbook().getNumExFormats()];\n       boolean[] isUsed = new boolean[newPos.length];\n       boolean[] zapRecords = new boolean[newPos.length];\n       for(int i=0; i<newPos.length; i++) {\n           isUsed[i] = false;\n           newPos[i] = (short)i;\n           zapRecords[i] = false;\n       }\n\n       // Get each style record, so we can do deletes\n       //  without getting confused\n       ExtendedFormatRecord[] xfrs = new ExtendedFormatRecord[newPos.length];\n       for(int i=0; i<newPos.length; i++) {\n           xfrs[i] = workbook.getWorkbook().getExFormatAt(i);\n       }\n\n	   // Loop over each style, seeing if it is the same\n	   //  as an earlier one. If it is, point users of the\n	   //  later duplicate copy to the earlier one, and\n	   //  mark the later one as needing deleting\n	   // Only work on user added ones, which come after 20\n	   for (int i = 21; i < newPos.length; i++) {\n		   // Check this one for being a duplicate\n		   //  of an earlier one\n		   int earlierDuplicate = -1;\n		   for (int j = 0; j < i && earlierDuplicate == -1; j++) {\n			   ExtendedFormatRecord xfCheck = workbook.getWorkbook().getExFormatAt(j);\n			   if (xfCheck.equals(xfrs[i]) &&\n					   // newer duplicate user defined styles\n					   !isUserDefined(workbook, j)) {\n				   earlierDuplicate = j;\n			   }\n		   }\n\n           // If we got a duplicate, mark it as such\n           if(earlierDuplicate != -1) {\n               newPos[i] = (short)earlierDuplicate;\n               zapRecords[i] = true;\n           }\n       }\n\n	   // Loop over all the cells in the file, and identify any user defined\n	   //  styles aren't actually being used (don't touch built-in ones)\n	   for (int sheetNum = 0; sheetNum < workbook.getNumberOfSheets(); sheetNum++) {\n		   HSSFSheet s = workbook.getSheetAt(sheetNum);\n		   for (Row row : s) {\n			   for (Cell cellI : row) {\n				   HSSFCell cell = (HSSFCell) cellI;\n				   short oldXf = cell.getCellValueRecord().getXFIndex();\n				   // some documents contain invalid values here\n				   if(oldXf < newPos.length) {\n					   isUsed[oldXf] = true;\n				   }\n			   }\n\n			   // also mark row style as being used\n			   short oldXf = ((HSSFRow) row).getRowRecord().getXFIndex();\n			   // some documents contain invalid values here\n			   if(oldXf < newPos.length) {\n				   isUsed[oldXf] = true;\n			   }\n		   }\n\n		   // also mark column styles as being used\n		   for (int col = s.getSheet().getMinColumnIndex(); col <= s.getSheet().getMaxColumnIndex(); col++) {\n			   short oldXf = s.getSheet().getXFIndexForColAt((short) col);\n			   // some documents contain invalid values here\n			   if(oldXf < newPos.length) {\n				   isUsed[oldXf] = true;\n			   }\n		   }\n	   }\n\n	   // Propagate isUsed for duplicates and always set user styles to being used to never optimize them away\n	   for (int i = 21; i < isUsed.length; i++) {\n		   // user defined styles are always "used"\n		   if (isUserDefined(workbook, i)) {\n			   isUsed[i] = true;\n		   }\n\n		   // If we got a duplicate which is used, mark the one we're keeping as used\n		   if(newPos[i] != i && isUsed[i]) {\n		   		isUsed[newPos[i]] = true;\n		   }\n	   }\n\n       // Mark any that aren't used as needing zapping\n       for (int i=21; i<isUsed.length; i++) {\n           if (! isUsed[i]) {\n               // Un-used style, can be removed\n               zapRecords[i] = true;\n               newPos[i] = 0;\n           }\n       }\n\n       // Update the new positions based on\n       //  deletes that have occurred between\n       //  the start and them\n       // Only work on user added ones, which come after 20\n       for(int i=21; i<newPos.length; i++) {\n           // Find the number deleted to that\n           //  point, and adjust\n           short preDeletePos = newPos[i];\n           short newPosition = preDeletePos;\n           for(int j=0; j<preDeletePos; j++) {\n               if(zapRecords[j]) newPosition--;\n           }\n\n		   // Update the new position\n		   newPos[i] = newPosition;\n		   // also update StyleRecord and Parent-link\n		   if (i != newPosition && newPosition != 0) {\n			   workbook.getWorkbook().updateStyleRecord(i, newPosition);\n\n			   ExtendedFormatRecord exFormat = workbook.getWorkbook().getExFormatAt(i);\n			   short oldParent = exFormat.getParentIndex();\n			   // some documents contain invalid values here\n			   if(oldParent < newPos.length) {\n				   short newParent = newPos[oldParent];\n				   exFormat.setParentIndex(newParent);\n			   }\n		   }\n	   }\n\n       // Zap the un-needed user style records\n       // removing by index, because removing by object may delete\n       // styles we did not intend to (the ones that _were_ duplicated and not the duplicates)\n       int max = newPos.length;\n       int removed = 0; // to adjust index after deletion\n       for(int i=21; i<max; i++) {\n           if(zapRecords[i + removed]) {\n               workbook.getWorkbook().removeExFormatRecord(i);\n               i--;\n               max--;\n               removed++;\n           }\n       }\n\n	   // Finally, update the cells to point at their new extended format records\n	   for (int sheetNum = 0; sheetNum < workbook.getNumberOfSheets(); sheetNum++) {\n		   HSSFSheet s = workbook.getSheetAt(sheetNum);\n		   for (Row row : s) {\n			   for (Cell cell : row) {\n				   short oldXf = ((HSSFCell) cell).getCellValueRecord().getXFIndex();\n				   // some documents contain invalid values here\n				   if(oldXf >= newPos.length) {\n				   		continue;\n				   }\n				   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n				   cell.setCellStyle(newStyle);\n			   }\n\n			   // adjust row column style\n			   short oldXf = ((HSSFRow) row).getRowRecord().getXFIndex();\n			   // some documents contain invalid values here\n			   if(oldXf >= newPos.length) {\n				   continue;\n			   }\n			   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n			   row.setRowStyle(newStyle);\n		   }\n\n		   // adjust cell column style\n		   for (int col = s.getSheet().getMinColumnIndex(); col <= s.getSheet().getMaxColumnIndex(); col++) {\n			   short oldXf = s.getSheet().getXFIndexForColAt((short) col);\n			   // some documents contain invalid values here\n			   if(oldXf >= newPos.length) {\n				   continue;\n			   }\n			   HSSFCellStyle newStyle = workbook.getCellStyleAt(newPos[oldXf]);\n			   s.setDefaultColumnStyle(col, newStyle);\n		   }\n	   }\n   }
606	public void convertExcelToCSV(String strSource, String strDestination,\n                                  String separator, int formattingConvention)\n                       throws FileNotFoundException, IOException,\n                              IllegalArgumentException {\n        File source = new File(strSource);\n        File destination = new File(strDestination);\n        File[] filesList;\n        String destinationFilename;\n\n        // Check that the source file/folder exists.\n        if(!source.exists()) {\n            throw new IllegalArgumentException("The source for the Excel " +\n                    "file(s) cannot be found.");\n        }\n\n        // Ensure thaat the folder the user has chosen to save the CSV files\n        // away into firstly exists and secondly is a folder rather than, for\n        // instance, a data file.\n        if(!destination.exists()) {\n            throw new IllegalArgumentException("The folder/directory for the " +\n                    "converted CSV file(s) does not exist.");\n        }\n        if(!destination.isDirectory()) {\n            throw new IllegalArgumentException("The destination for the CSV " +\n                    "file(s) is not a directory/folder.");\n        }\n\n        // Ensure the value passed to the formattingConvention parameter is\n        // within range.\n        if(formattingConvention != ToCSV.EXCEL_STYLE_ESCAPING &&\n           formattingConvention != ToCSV.UNIX_STYLE_ESCAPING) {\n            throw new IllegalArgumentException("The value passed to the " +\n                    "formattingConvention parameter is out of range.");\n        }\n\n        // Copy the spearator character and formatting convention into local\n        // variables for use in other methods.\n        this.separator = separator;\n        this.formattingConvention = formattingConvention;\n\n        // Check to see if the sourceFolder variable holds a reference to\n        // a file or a folder full of files.\n        if(source.isDirectory()) {\n            // Get a list of all of the Excel spreadsheet files (workbooks) in\n            // the source folder/directory\n            filesList = source.listFiles(new ExcelFilenameFilter());\n        }\n        else {\n            // Assume that it must be a file handle - although there are other\n            // options the code should perhaps check - and store the reference\n            // into the filesList variable.\n            filesList = new File[]{source};\n        }\n\n        // Step through each of the files in the source folder and for each\n        // open the workbook, convert it's contents to CSV format and then\n        // save the resulting file away into the folder specified by the\n        // contents of the destination variable. Note that the name of the\n        // csv file will be created by taking the name of the Excel file,\n        // removing the extension and replacing it with .csv. Note that there\n        // is one drawback with this approach; if the folder holding the files\n        // contains two workbooks whose names match but one is a binary file\n        // (.xls) and the other a SpreadsheetML file (.xlsx), then the names\n        // for both CSV files will be identical and one CSV file will,\n        // therefore, over-write the other.\n        if (filesList != null) {\n            for(File excelFile : filesList) {\n                // Open the workbook\n                this.openWorkbook(excelFile);\n    \n                // Convert it's contents into a CSV file\n                this.convertToCSV();\n    \n                // Build the name of the csv folder from that of the Excel workbook.\n                // Simply replace the .xls or .xlsx file extension with .csv\n                destinationFilename = excelFile.getName();\n                destinationFilename = destinationFilename.substring(\n                        0, destinationFilename.lastIndexOf(".")) +\n                        ToCSV.CSV_FILE_EXTENSION;\n    \n                // Save the CSV file away using the newly constricted file name\n                // and to the specified directory.\n                this.saveCSVFile(new File(destination, destinationFilename));\n            }\n        }\n    }
607	@Internal\n    public boolean isFAutoNum()\n    {\n        return fAutoNum.isSet(field_4_flags);\n    }
608	private static PrecisionRecord createPrecision() {\n        PrecisionRecord retval = new PrecisionRecord();\n        retval.setFullPrecision(true);   // always use real numbers in calculations!\n        return retval;\n    }
609	private void addRow(HSSFRow row, boolean addLow) {\n        _rows.put(Integer.valueOf(row.getRowNum()), row);\n        if (addLow) {\n            _sheet.addRow(row.getRowRecord());\n        }\n        boolean firstRow = _rows.size() == 1;\n        if (row.getRowNum() > getLastRowNum() || firstRow) {\n            _lastrow = row.getRowNum();\n        }\n        if (row.getRowNum() < getFirstRowNum() || firstRow) {\n            _firstrow = row.getRowNum();\n        }\n    }
610	public void setLeftMargin(double value){\n        CTTextParagraphProperties pr = _p.isSetPPr() ? _p.getPPr() : _p.addNewPPr();\n        if(value == -1) {\n            if(pr.isSetMarL()) pr.unsetMarL();\n        } else {\n            pr.setMarL(Units.toEMU(value));\n        }\n\n    }
611	public CurrentUserAtom getCurrentUserAtom() {\n        return currentUser;\n    }
612	public void addProperty(Property property) {\n        _properties.add(property);\n    }
613	public void removePartRecursive(PackagePartName partName)\n			throws InvalidFormatException {\n		// Retrieves relationship part, if one exists\n		PackagePart relPart = this.partList.get(PackagingURIHelper\n				.getRelationshipPartName(partName));\n		// Retrieves PackagePart object from the package\n		PackagePart partToRemove = this.partList.get(partName);\n\n		if (relPart != null) {\n			PackageRelationshipCollection partRels = new PackageRelationshipCollection(\n					partToRemove);\n			for (PackageRelationship rel : partRels) {\n				PackagePartName partNameToRemove = PackagingURIHelper\n						.createPartName(PackagingURIHelper.resolvePartUri(rel\n								.getSourceURI(), rel.getTargetURI()));\n				removePart(partNameToRemove);\n			}\n\n			// Finally delete its relationship part if one exists\n			this.removePart(relPart._partName);\n		}\n\n		// Delete the specified part\n		this.removePart(partToRemove._partName);\n	}
614	public String getText() {\n        return text.toString();\n    }
615	public boolean isAutoColor()\n    {\n        return autoColor.isSet(field_9_options1);\n    }
616	public static DocumentBuilderFactory getDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setExpandEntityReferences(false);\n        trySetSAXFeature(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        trySetSAXFeature(factory, "http://xml.org/sax/features/external-general-entities", false);\n        trySetSAXFeature(factory, "http://xml.org/sax/features/external-parameter-entities", false);\n        trySetSAXFeature(factory, "http://apache.org/xml/features/nonvalidating/load-external-dtd", false);\n        trySetSAXFeature(factory, "http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false);\n        return factory;\n    }
617	@Internal\n    public boolean isFFirstMerged()\n    {\n        return fFirstMerged.isSet(field_1_rgf);\n    }
618	public Data transform(Data data, XMLCryptoContext context) throws TransformException {\n        LOG.log(POILogger.DEBUG, "transform(data,context)");\n        LOG.log(POILogger.DEBUG, "data java type: " + data.getClass().getName());\n        OctetStreamData octetStreamData = (OctetStreamData) data;\n        LOG.log(POILogger.DEBUG, "URI: " + octetStreamData.getURI());\n        InputStream octetStream = octetStreamData.getOctetStream();\n        \n        Document doc;\n        try {\n            doc = DocumentHelper.readDocument(octetStream);\n        } catch (Exception e) {\n            throw new TransformException(e.getMessage(), e);\n        }\n        \n        // keep only those relationships which id is registered in the sourceIds\n        Element root = doc.getDocumentElement();\n        NodeList nl = root.getChildNodes();\n        TreeMap<String,Element> rsList = new TreeMap<>();\n        for (int i=nl.getLength()-1; i>=0; i--) {\n            Node n = nl.item(i);\n            if ("Relationship".equals(n.getLocalName())) {\n                Element el = (Element)n;\n                String id = el.getAttribute("Id");\n                if (sourceIds.contains(id)) {\n                    String targetMode = el.getAttribute("TargetMode");\n                    if (targetMode == null || targetMode.isEmpty()) {\n                        el.setAttribute("TargetMode", "Internal");\n                    }\n                    rsList.put(id, el);\n                }\n            }\n            root.removeChild(n);\n        }\n\n        for (Element el : rsList.values()) {\n            root.appendChild(el);\n        }\n        \n        LOG.log(POILogger.DEBUG, "# Relationship elements: ", rsList.size());\n        \n        return new ApacheNodeSetData(new XMLSignatureInput(root));\n    }
619	public static short[] getShortArray( byte[] data, int offset, int size )\n    {\n        short[] result = new short[size / SHORT_SIZE];\n        for ( int i = 0; i < result.length; i++ )\n        {\n            result[i] = getShort( data, offset + i * SHORT_SIZE );\n        }\n        return result;\n    }
620	/* package */ static Boolean parseBoolean(String strRep) {\n        if (strRep.length() < 1) {\n            return null;\n        }\n        switch(strRep.charAt(0)) {\n            case 't':\n            case 'T':\n                if("TRUE".equalsIgnoreCase(strRep)) {\n                    return Boolean.TRUE;\n                }\n                break;\n            case 'f':\n            case 'F':\n                if("FALSE".equalsIgnoreCase(strRep)) {\n                    return Boolean.FALSE;\n                }\n                break;\n        }\n        return null;\n    }
621	public int getTint(){\n        return getPercentageValue("tint");\n    }
622	/* package */ String getSheetName(int sheetIndex) {\n        return _workbook.getSheetName(sheetIndex);\n    }
623	private static String[] separateAreaRefs(String reference) {\n        // TODO - refactor cell reference parsing logic to one place.\n        // Current known incarnations: \n        //   FormulaParser.GetName()\n        //   CellReference.separateRefParts() \n        //   AreaReference.separateAreaRefs() (here)\n        //   SheetNameFormatter.format() (inverse)\n        \n        \n        int len = reference.length();\n        int delimiterPos = -1;\n        boolean insideDelimitedName = false;\n        for(int i=0; i<len; i++) {\n            switch(reference.charAt(i)) {\n                case CELL_DELIMITER:\n                    if(!insideDelimitedName) {\n                        if(delimiterPos >=0) {\n                            throw new IllegalArgumentException("More than one cell delimiter '" \n                                    + CELL_DELIMITER + "' appears in area reference '" + reference + "'");\n                        }\n                        delimiterPos = i;\n                    }\n                    continue; //continue the for-loop\n                case SPECIAL_NAME_DELIMITER:\n                    break;\n                default:\n                    continue; //continue the for-loop\n            }\n            if(!insideDelimitedName) {\n                insideDelimitedName = true;\n                continue;\n            }\n            \n            if(i >= len-1) {\n                // reference ends with the delimited name. \n                // Assume names like: "Sheet1!'A1'" are never legal.\n                throw new IllegalArgumentException("Area reference '" + reference \n                        + "' ends with special name delimiter '"  + SPECIAL_NAME_DELIMITER + "'");\n            }\n            if(reference.charAt(i+1) == SPECIAL_NAME_DELIMITER) {\n                // two consecutive quotes is the escape sequence for a single one\n                i++; // skip this and keep parsing the special name\n            } else {\n                // this is the end of the delimited name\n                insideDelimitedName = false;\n            }\n        }\n        if(delimiterPos < 0) {\n            return new String[] { reference, };\n        }\n\n        String partA = reference.substring(0, delimiterPos);\n        String partB = reference.substring(delimiterPos+1);\n        if(partB.indexOf(SHEET_NAME_DELIMITER) >= 0) {\n            // partB contains SHEET_NAME_DELIMITER\n            // TODO - are references like "Sheet1!A1:Sheet1:B2" ever valid?  \n            // FormulaParser has code to handle that.\n            \n            throw new RuntimeException("Unexpected " + SHEET_NAME_DELIMITER \n                    + " in second cell reference of '" + reference + "'");\n        }\n        \n        int plingPos = partA.lastIndexOf(SHEET_NAME_DELIMITER);\n        if(plingPos < 0) {\n            return new String [] { partA, partB, };\n        }\n        \n        String sheetName = partA.substring(0, plingPos + 1); // +1 to include delimiter\n        \n        return new String [] { partA, sheetName + partB, };\n    }
624	public URI getPictureLink() {\n        if (getBlipId() != null) {\n            // Internal picture, nothing to return\n            return null;\n        }\n        \n        String rId = getBlipLink();\n        if (rId == null) {\n            // No link recorded, nothing we can do\n            return null;\n        }\n        \n        PackagePart p = getSheet().getPackagePart();\n        PackageRelationship rel = p.getRelationship(rId);\n        if (rel != null) {\n            return rel.getTargetURI();\n        }\n        return null;\n    }
625	public void saveProperties() {\n        propStack.add(prop);\n        prop = new HwmfDrawProperties(prop);  \n    }
626	private void validateArrayFormulas(CellRangeAddress region) {\n        // FIXME: this may be faster if it looped over array formulas directly rather than looping over each cell in\n        // the region and searching if that cell belongs to an array formula\n        int firstRow = region.getFirstRow();\n        int firstColumn = region.getFirstColumn();\n        int lastRow = region.getLastRow();\n        int lastColumn = region.getLastColumn();\n        // for each cell in sheet, if cell belongs to an array formula, check if merged region intersects array formula cells\n        for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {\n            XSSFRow row = getRow(rowIn);\n            if (row == null) {\n                continue;\n            }\n\n            for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {\n                XSSFCell cell = row.getCell(colIn);\n                if (cell == null) {\n                    continue;\n                }\n\n                if (cell.isPartOfArrayFormulaGroup()) {\n                    CellRangeAddress arrayRange = cell.getArrayFormulaRange();\n                    if (arrayRange.getNumberOfCells() > 1 && region.intersects(arrayRange)) {\n                        String msg = "The range " + region.formatAsString() + " intersects with a multi-cell array formula. " +\n                                "You cannot merge cells of an array.";\n                        throw new IllegalStateException(msg);\n                    }\n                }\n            }\n        }\n    }
627	private CTTablePartStyle getTablePartStyle(TablePartStyle tablePartStyle) {\n        CTTable ct = table.getCTTable();\n        if (!ct.isSetTblPr()) {\n            return null;\n        }\n\n        CTTableProperties pr = ct.getTblPr();\n        boolean bandRow = (pr.isSetBandRow() && pr.getBandRow());\n        boolean firstRow = (pr.isSetFirstRow() && pr.getFirstRow());\n        boolean lastRow = (pr.isSetLastRow() && pr.getLastRow());\n        boolean bandCol = (pr.isSetBandCol() && pr.getBandCol());\n        boolean firstCol = (pr.isSetFirstCol() && pr.getFirstCol());\n        boolean lastCol = (pr.isSetLastCol() && pr.getLastCol());\n\n        TablePartStyle tps;\n        if (tablePartStyle != null) {\n            tps = tablePartStyle;\n        } else if (row == 0 && firstRow) {\n            tps = TablePartStyle.firstRow;\n        } else if (row == table.getNumberOfRows() - 1 && lastRow) {\n            tps = TablePartStyle.lastRow;\n        } else if (col == 0 && firstCol) {\n            tps = TablePartStyle.firstCol;\n        } else if (col == table.getNumberOfColumns() - 1 && lastCol) {\n            tps = TablePartStyle.lastCol;\n        } else {\n            tps = TablePartStyle.wholeTbl;\n\n            int br = row + (firstRow ? 1 : 0);\n            int bc = col + (firstCol ? 1 : 0);\n            if (bandRow && (br & 1) == 0) {\n                tps = TablePartStyle.band1H;\n            } else if (bandCol && (bc & 1) == 0) {\n                tps = TablePartStyle.band1V;\n            }\n        }\n\n        XSLFTableStyle tabStyle = table.getTableStyle();\n        if (tabStyle == null) {\n            return null;\n        }\n\n        CTTablePartStyle part = tabStyle.getTablePartStyle(tps);\n        return (part == null) ? tabStyle.getTablePartStyle(TablePartStyle.wholeTbl) : part;\n    }
628	public void preSign(\n          Document document\n        , List<Reference> references\n        , List<XMLObject> objects\n    ) throws XMLSignatureException {\n        // empty\n    }
629	@Internal\n    public void setFMinHeight( boolean field_27_fMinHeight )\n    {\n        this.field_27_fMinHeight = field_27_fMinHeight;\n    }
630	public void setIncludeHeadersFooters(boolean includeHeadersFooters) {\n       throw new IllegalStateException("Header/Footer extraction not supported in streaming mode, please use ExcelExtractor");\n   }
631	private void findCellCommentLocations(HSSFShapeContainer container, Map<CellAddress, HSSFComment> locations) {\n        for (Object object : container.getChildren()) {\n            HSSFShape shape = (HSSFShape) object;\n            if (shape instanceof HSSFShapeGroup) {\n                findCellCommentLocations((HSSFShapeGroup) shape, locations);\n                continue;\n            }\n            if (shape instanceof HSSFComment) {\n                HSSFComment comment = (HSSFComment) shape;\n                if (comment.hasPosition()) {\n                    locations.put(new CellAddress(comment.getRow(), comment.getColumn()), comment);\n                }\n            }\n        }\n    }
632	public void postSign(final DOMSignContext xmlSignContext, final String signatureValue)\n    throws MarshalException {\n        LOG.log(POILogger.DEBUG, "postSign");\n\n        final Document document = (Document)xmlSignContext.getParent();\n\n        /*\n         * Check ds:Signature node.\n         */\n        String signatureId = signatureConfig.getPackageSignatureId();\n        if (!signatureId.equals(document.getDocumentElement().getAttribute("Id"))) {\n            throw new RuntimeException("ds:Signature not found for @Id: " + signatureId);\n        }\n\n        /*\n         * Insert signature value into the ds:SignatureValue element\n         */\n        final Element signatureNode = getDsigElement(document, "SignatureValue"); \n        if (signatureNode == null) {\n            throw new RuntimeException("preSign has to be called before postSign");\n        }\n        signatureNode.setTextContent(signatureValue);\n\n        /*\n         * Allow signature facets to inject their own stuff.\n         */\n        for (SignatureFacet signatureFacet : signatureConfig.getSignatureFacets()) {\n            signatureFacet.postSign(document);\n        }\n\n        writeDocument(document);\n    }
633	private static String toHex(double a) {\n		return "0x" + Long.toHexString(Double.doubleToLongBits(a)).toUpperCase(Locale.ROOT);\n	}
634	public void characters(char[] ch, int start, int length) throws SAXException {\n        if (tIsOpen) {\n            if (inRPh && includePhoneticRuns) {\n                characters.append(ch, start, length);\n            } else if (! inRPh){\n                characters.append(ch, start, length);\n            }\n        }\n    }
635	public String formatAsString() {\n        return formatAsString(null, false);\n    }
636	@Internal\n    public boolean isFHtmlHangingIndentBeneathNumber()\n    {\n        return fHtmlHangingIndentBeneathNumber.isSet(field_1_grfhic);\n    }
637	public static SlideShow<?,?> openSampleSlideshow(String sampleName) throws IOException {\n        try (InputStream is = _slTests.openResourceAsStream(sampleName)) {\n            return SlideShowFactory.create(is);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }
638	/* package */ void detachFromEnvironment() {\n        _collaboratingWorkbookEnvironment = CollaboratingWorkbooksEnvironment.EMPTY;\n        _cache = new EvaluationCache(_evaluationListener);\n        _workbookIx = 0;\n    }
639	public static int createXorVerifier1(String password) {\n        if (password == null) {\n            throw new IllegalArgumentException("Password cannot be null");\n        }\n\n        byte[] arrByteChars = toAnsiPassword(password);\n        \n        // SET Verifier TO 0x0000\n        short verifier = 0;\n\n        if (!password.isEmpty()) {\n            // FOR EACH PasswordByte IN PasswordArray IN REVERSE ORDER\n            for (int i = arrByteChars.length-1; i >= 0; i--) {\n                // SET Verifier TO Intermediate3 BITWISE XOR PasswordByte\n                verifier = rotateLeftBase15Bit(verifier);\n                verifier ^= arrByteChars[i];\n            }\n    \n            // as we haven't prepended the password length into the input array\n            // we need to do it now separately ...\n            verifier = rotateLeftBase15Bit(verifier);\n            verifier ^= arrByteChars.length;\n            \n            // RETURN Verifier BITWISE XOR 0xCE4B\n            verifier ^= 0xCE4B; // (0x8000 | ('N' << 8) | 'K')\n        }\n        \n        return verifier & 0xFFFF;\n    }
640	public static Document process( File xlsFile ) throws Exception\n    {\n        final HSSFWorkbook workbook = AbstractExcelUtils.loadXls( xlsFile );\n        try {\n            ExcelToFoConverter excelToHtmlConverter = new ExcelToFoConverter(\n                    XMLHelper.getDocumentBuilderFactory().newDocumentBuilder()\n                            .newDocument() );\n            excelToHtmlConverter.processWorkbook( workbook );\n            return excelToHtmlConverter.getDocument();\n        } finally {\n            workbook.close();\n        }\n    }
641	public int getX1() {\n        return _spgrRecord.getRectX1();\n    }
642	public int getOptions() {\n		return LittleEndian.getShort(_header);\n	}
643	public Record cloneViaReserialise() {\n        // Do it via a re-serialization\n        // It's a cheat, but it works...\n        byte[] b = serialize();\n        RecordInputStream rinp = new RecordInputStream(new ByteArrayInputStream(b));\n        rinp.nextRecord();\n\n        Record[] r = RecordFactory.createRecord(rinp);\n        if(r.length != 1) {\n            throw new IllegalStateException("Re-serialised a record to clone it, but got " + r.length + " records back!");\n        }\n        return r[0];\n    }
644	@SuppressWarnings("WeakerAccess")\n    public String getMinorFont(){\n        return _theme.getThemeElements().getFontScheme().getMinorFont().getLatin().getTypeface();\n    }
645	public void setRotationDegree(short value){\n        setPropertyValue(new EscherSimpleProperty(EscherProperties.TRANSFORM__ROTATION , (value << 16)));\n    }
646	public boolean isLocked()\n    {\n        return locked.isSet(field_3_option);\n    }
647	public String toString()\n    {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append("[SHARED FORMULA (").append(HexDump.intToHex(sid)).append("]\n");\n        buffer.append("    .range      = ").append(getRange()).append("\n");\n        buffer.append("    .reserved    = ").append(HexDump.shortToHex(field_5_reserved)).append("\n");\n\n        Ptg[] ptgs = field_7_parsed_expr.getTokens();\n        for (int k = 0; k < ptgs.length; k++ ) {\n           buffer.append("Formula[").append(k).append("]");\n           Ptg ptg = ptgs[k];\n           buffer.append(ptg).append(ptg.getRVAType()).append("\n");\n        }\n\n        buffer.append("[/SHARED FORMULA]\n");\n        return buffer.toString();\n    }
648	private synchronized String generateTempFileName(File directory) {\n		File tmpFilename;\n		do {\n			tmpFilename = new File(directory.getAbsoluteFile() + File.separator\n					+ "OpenXML4J" + System.nanoTime());\n		} while (tmpFilename.exists());\n		return FileHelper.getFilename(tmpFilename.getAbsoluteFile());\n	}
649	@SuppressWarnings("WeakerAccess")\n    protected static PaintStyle selectPaint(XSLFFillProperties fp, final CTSchemeColor phClr, final PackagePart parentPart, final XSLFTheme theme, boolean hasPlaceholder) {\n        if (fp == null || fp.isSetNoFill()) {\n            return null;\n        } else if (fp.isSetSolidFill()) {\n            return selectPaint(fp.getSolidFill(), phClr, theme);\n        } else if (fp.isSetBlipFill()) {\n            return selectPaint(fp.getBlipFill(), parentPart);\n        } else if (fp.isSetGradFill()) {\n            return selectPaint(fp.getGradFill(), phClr, theme);\n        } else if (fp.isSetMatrixStyle()) {\n            return selectPaint(fp.getMatrixStyle(), theme, fp.isLineStyle(), hasPlaceholder);\n        } else {\n            return null;\n        }\n    }
650	public static CFRule12Record createColorScale(HSSFSheet sheet) {\n        int numPoints = 3;\n        ExtendedColor[] colors = new ExtendedColor[numPoints];\n        ColorGradientThreshold[] ts = new ColorGradientThreshold[numPoints];\n        for (int i=0; i<ts.length; i++) {\n            ts[i] = new ColorGradientThreshold();\n            colors[i] = new ExtendedColor();\n        }\n        \n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_COLOR_SCALE, \n                                              ComparisonOperator.NO_COMPARISON);\n        ColorGradientFormatting cgf = r.createColorGradientFormatting();\n        cgf.setNumControlPoints(numPoints);\n        cgf.setThresholds(ts);\n        cgf.setColors(colors);\n        return r;\n    }
651	public void setUnderline(UnderlineType underline) {\n        getOrCreateProperties().setUnderline(underline);\n    }
652	public void removeTableAlignment() {\n        CTTblPr tPr = getTblPr(false);\n        if (tPr != null && tPr.isSetJc()) {\n            tPr.unsetJc();\n        }\n    }
653	private static double[] RGB2HSL(Color color)\n    {\n        //  Get RGB values in the range 0 - 1\n\n        float[] rgb = color.getRGBColorComponents( null );\n        double r = rgb[0];\n        double g = rgb[1];\n        double b = rgb[2];\n\n        //  Minimum and Maximum RGB values are used in the HSL calculations\n\n        double min = Math.min(r, Math.min(g, b));\n        double max = Math.max(r, Math.max(g, b));\n\n        //  Calculate the Hue\n\n        double h = 0;\n\n        if (max == min) {\n            h = 0;\n        } else if (max == r) {\n            h = ((60d * (g - b) / (max - min)) + 360d) % 360d;\n        } else if (max == g) {\n            h = (60d * (b - r) / (max - min)) + 120d;\n        } else if (max == b) {\n            h = (60d * (r - g) / (max - min)) + 240d;\n        }\n\n        //  Calculate the Luminance\n\n        double l = (max + min) / 2d;\n\n        //  Calculate the Saturation\n\n        final double s;\n\n        if (max == min) {\n            s = 0;\n        } else if (l <= .5d) {\n            s = (max - min) / (max + min);\n        } else {\n            s = (max - min) / (2d - max - min);\n        }\n\n        return new double[] {h, s * 100, l * 100};\n    }
654	public void save(File targetFile) throws IOException {\n		if (targetFile == null) {\n			throw new IllegalArgumentException("targetFile");\n		}\n\n		this.throwExceptionIfReadOnly();\n		\n		// You shouldn't save the the same file, do a close instead\n		if(targetFile.exists() && \n		        targetFile.getAbsolutePath().equals(this.originalPackagePath)) {\n		    throw new InvalidOperationException(\n		            "You can't call save(File) to save to the currently open " +\n		            "file. To save to the current file, please just call close()"\n		    );\n		}\n		\n		// Do the save\n		FileOutputStream fos = null;\n		try {\n			fos = new FileOutputStream(targetFile);\n			this.save(fos);\n		} finally {\n			if (fos != null) {\n                fos.close();\n            }\n		}\n	}
655	private void onWorkbookCreate() {\n        workbook = CTWorkbook.Factory.newInstance();\n\n        // don't EVER use the 1904 date system\n        CTWorkbookPr workbookPr = workbook.addNewWorkbookPr();\n        workbookPr.setDate1904(false);\n\n        setBookViewsIfMissing();\n        workbook.addNewSheets();\n\n        POIXMLProperties.ExtendedProperties expProps = getProperties().getExtendedProperties();\n        expProps.getUnderlyingProperties().setApplication(DOCUMENT_CREATOR);\n\n        sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, this.xssfFactory);\n        stylesSource = (StylesTable)createRelationship(XSSFRelation.STYLES, this.xssfFactory);\n        stylesSource.setWorkbook(this);\n\n        namedRanges = new ArrayList<>();\n        namedRangesByName = new ArrayListValuedHashMap<>();\n        sheets = new ArrayList<>();\n        pivotTables = new ArrayList<>();\n    }
656	protected static void fixLineEndings(List<HSLFTextParagraph> paragraphs) {\n        HSLFTextRun lastRun = null;\n        for (HSLFTextParagraph p : paragraphs) {\n            if (lastRun != null && !lastRun.getRawText().endsWith("\r")) {\n                lastRun.setText(lastRun.getRawText() + "\r");\n            }\n            List<HSLFTextRun> ltr = p.getTextRuns();\n            if (ltr.isEmpty()) {\n                throw new HSLFException("paragraph without textruns found");\n            }\n            lastRun = ltr.get(ltr.size() - 1);\n            assert (lastRun.getRawText() != null);\n        }\n    }
657	public static synchronized void registerDsigProvider() {\n        // the xml signature classes will try to find a special TransformerService,\n        // which is ofcourse unknown to JCE before ...\n        final String dsigProvider = "POIXmlDsigProvider";\n        if (Security.getProperty(dsigProvider) == null) {\n            Provider p = new Provider(dsigProvider, 1.0, dsigProvider){\n                static final long serialVersionUID = 1L;\n            };\n            p.put("TransformService." + TRANSFORM_URI, RelationshipTransformService.class.getName());\n            p.put("TransformService." + TRANSFORM_URI + " MechanismType", "DOM");\n            Security.addProvider(p);\n        }\n    }
658	private void readPictures() throws IOException {\n        _pictures = new ArrayList<>();\n\n        // if the presentation doesn't contain pictures - will use a null set instead\n        if (!getDirectory().hasEntry("Pictures")) {\n            return;\n        }\n\n        DocumentEntry entry = (DocumentEntry) getDirectory().getEntry("Pictures");\n        DocumentInputStream is = getDirectory().createDocumentInputStream(entry);\n        byte[] pictstream = IOUtils.toByteArray(is, entry.getSize());\n        is.close();\n\n        try (HSLFSlideShowEncrypted decryptData = new HSLFSlideShowEncrypted(getDocumentEncryptionAtom())) {\n\n            int pos = 0;\n            // An empty picture record (length 0) will take up 8 bytes\n            while (pos <= (pictstream.length - 8)) {\n                int offset = pos;\n\n                decryptData.decryptPicture(pictstream, offset);\n\n                // Image signature\n                int signature = LittleEndian.getUShort(pictstream, pos);\n                pos += LittleEndianConsts.SHORT_SIZE;\n                // Image type + 0xF018\n                int type = LittleEndian.getUShort(pictstream, pos);\n                pos += LittleEndianConsts.SHORT_SIZE;\n                // Image size (excluding the 8 byte header)\n                int imgsize = LittleEndian.getInt(pictstream, pos);\n                pos += LittleEndianConsts.INT_SIZE;\n\n                // When parsing the BStoreDelay stream, [MS-ODRAW] says that we\n                //  should terminate if the type isn't 0xf007 or 0xf018->0xf117\n                if (!((type == 0xf007) || (type >= 0xf018 && type <= 0xf117))) {\n                    break;\n                }\n\n                // The image size must be 0 or greater\n                // (0 is allowed, but odd, since we do wind on by the header each\n                //  time, so we won't get stuck)\n                if (imgsize < 0) {\n                    throw new CorruptPowerPointFileException("The file contains a picture, at position " + _pictures.size() + ", which has a negatively sized data length, so we can't trust any of the picture data");\n                }\n\n                // If they type (including the bonus 0xF018) is 0, skip it\n                PictureType pt = PictureType.forNativeID(type - 0xF018);\n                if (pt == null) {\n                    logger.log(POILogger.ERROR, "Problem reading picture: Invalid image type 0, on picture with length " + imgsize + ".\nYou document will probably become corrupted if you save it!");\n                    logger.log(POILogger.ERROR, "" + pos);\n                } else {\n                    //The pictstream can be truncated halfway through a picture.\n                    //This is not a problem if the pictstream contains extra pictures\n                    //that are not used in any slide -- BUG-60305\n                    if (pos + imgsize > pictstream.length) {\n                        logger.log(POILogger.WARN, "\"Pictures\" stream may have ended early. In some circumstances, this is not a problem; " +\n                                "in others, this could indicate a corrupt file");\n                        break;\n                    }\n                    // Build the PictureData object from the data\n                    try {\n                        HSLFPictureData pict = HSLFPictureData.create(pt);\n                        pict.setSignature(signature);\n\n                        // Copy the data, ready to pass to PictureData\n                        byte[] imgdata = IOUtils.safelyAllocate(imgsize, MAX_RECORD_LENGTH);\n                        System.arraycopy(pictstream, pos, imgdata, 0, imgdata.length);\n                        pict.setRawData(imgdata);\n\n                        pict.setOffset(offset);\n                        pict.setIndex(_pictures.size());\n                        _pictures.add(pict);\n                    } catch (IllegalArgumentException e) {\n                        logger.log(POILogger.ERROR, "Problem reading picture: " + e + "\nYou document will probably become corrupted if you save it!");\n                    }\n                }\n\n                pos += imgsize;\n            }\n        }\n    }
659	public HSSFShapeGroup createGroup(HSSFChildAnchor anchor) {\n        HSSFShapeGroup group = new HSSFShapeGroup(this, anchor);\n        group.setParent(this);\n        group.setAnchor(anchor);\n        shapes.add(group);\n        onCreate(group);\n        return group;\n    }
660	public static void setUserTimeZone(TimeZone timezone) {\n        userTimeZone.set(timezone);\n    }
661	public static boolean matchesPngHeader(byte[] data, int offset) {\n        if (data == null || data.length - offset < PNG_FILE_HEADER.length) {\n            return false;\n        }\n\n        for (int i = 0; i < PNG_FILE_HEADER.length; i++) {\n            if (PNG_FILE_HEADER[i] != data[i + offset]) {\n                return false;\n            }\n        }\n\n        return true;\n    }
662	HSSFCell createCellFromRecord(CellValueRecordInterface cell) {\n        HSSFCell hcell = new HSSFCell(book, sheet, cell);\n\n        addCell(hcell);\n        int colIx = cell.getColumn();\n        if (row.isEmpty()) {\n            row.setFirstCol(colIx);\n            row.setLastCol(colIx + 1);\n        } else {\n            if (colIx < row.getFirstCol()) {\n                row.setFirstCol(colIx);\n            } else if (colIx > row.getLastCol()) {\n                row.setLastCol(colIx + 1);\n            } /*else {\n                // added cell is within first and last cells\n            }*/\n        }\n        // TODO - RowRecord column boundaries need to be updated for cell comments too\n        return hcell;\n    }
663	@Internal\n    public void addHyperlink(XSSFHyperlink hyperlink) {\n        hyperlinks.add(hyperlink);\n    }
664	public boolean delete()\n    {\n        boolean rval = false;\n\n        if ((!isRoot()) && isDeleteOK())\n        {\n            rval = _parent.deleteEntry(this);\n        }\n        return rval;\n    }
665	private static int indexOf(byte[] data, int offset, byte[] pattern) {\n        int[] failure = computeFailure(pattern);\n\n        int j = 0;\n        if (data.length == 0) {\n            return -1;\n        }\n\n        for (int i = offset; i < data.length; i++) {\n            while (j > 0 && pattern[j] != data[i]) {\n                j = failure[j - 1];\n            }\n            if (pattern[j] == data[i]) { j++; }\n            if (j == pattern.length) {\n                return i - pattern.length + 1;\n            }\n        }\n        return -1;\n    }
666	public DocumentEntry createDocument(final InputStream stream,\n                                        final String name)\n        throws IOException\n    {\n        return getRoot().createDocument(name, stream);\n    }
667	@Internal\n    public boolean isFRecalc()\n    {\n        return fRecalc.isSet(field_2_bits);\n    }
668	public InputStream getInputStream() throws IOException {\n        return getPackagePart().getInputStream();\n    }
669	private static FnGroupCountRecord createFnGroupCount() {\n        FnGroupCountRecord retval = new FnGroupCountRecord();\n\n        retval.setCount(( short ) 14);\n        return retval;\n    }
670	private static double getColumnWidthForRow(\n            Row row, int column, int defaultCharWidth, DataFormatter formatter, boolean useMergedCells) {\n        if( row == null ) {\n            return -1;\n        }\n\n        Cell cell = row.getCell(column);\n\n        if (cell == null) {\n            return -1;\n        }\n\n        return getCellWidth(cell, defaultCharWidth, formatter, useMergedCells);\n    }
671	public int addMovie(String path, int type) {\n		ExMCIMovie mci;\n		switch (type) {\n			case MovieShape.MOVIE_MPEG:\n				mci = new ExMCIMovie();\n				break;\n			case MovieShape.MOVIE_AVI:\n				mci = new ExAviMovie();\n				break;\n			default:\n				throw new IllegalArgumentException("Unsupported Movie: " + type);\n		}\n\n		ExVideoContainer exVideo = mci.getExVideo();\n		exVideo.getExMediaAtom().setMask(0xE80000);\n		exVideo.getPathAtom().setText(path);\n\n		int objectId = addToObjListAtom(mci);\n		exVideo.getExMediaAtom().setObjectId(objectId);\n\n		return objectId;\n	}
672	public static boolean isNeverEncryptedRecord(int sid) {\n        switch (sid) {\n            case BOFRecord.sid:\n                // sheet BOFs for sure\n                // TODO - find out about chart BOFs\n\n            case InterfaceHdrRecord.sid:\n                // don't know why this record doesn't seem to get encrypted\n\n            case FilePassRecord.sid:\n                // this only really counts when writing because FILEPASS is read early\n\n            // UsrExcl(0x0194)\n            // FileLock\n            // RRDInfo(0x0196)\n            // RRDHead(0x0138)\n\n                return true;\n\n            default:\n                return false;\n        }\n    }
673	private static int lookupIndexOfExactValue(LookupValueComparer lookupComparer, ValueVector vector) {\n\n		// find first occurrence of lookup value\n		int size = vector.getSize();\n		for (int i = 0; i < size; i++) {\n			if(lookupComparer.compareTo(vector.getItem(i)).isEqual()) {\n				return i;\n			}\n		}\n		return -1;\n	}
674	protected void onAddTextShape(HSLFTextShape shape) {\n    }
675	@Internal\n    public boolean isFHighlight()\n    {\n        return fHighlight.isSet(field_48_Highlight);\n    }
676	public boolean removeAbstractNum(BigInteger abstractNumID) {\n        if (abstractNumID.byteValue() < abstractNums.size()) {\n            ctNumbering.removeAbstractNum(abstractNumID.byteValue());\n            abstractNums.remove(abstractNumID.byteValue());\n            return true;\n        }\n        return false;\n    }
677	public static String getText(int errorCode) {\n        if(FormulaError.isValidCode(errorCode)) {\n            return FormulaError.forInt(errorCode).getString();\n        }\n        // Give a special string, based on ~, to make clear this isn't a standard Excel error\n        return "~non~std~err(" + errorCode + ")~";\n    }
678	int getRed(){\n        return getPercentageValue("red");\n    }
679	public XWPFRun insertNewRun(int pos) {\n        if (pos >= 0 && pos <= runs.size()) {\n            // calculate the correct pos as our run/irun list contains\n            // hyperlinks\n            // and fields so it is different to the paragraph R array.\n            int rPos = 0;\n            for (int i = 0; i < pos; i++) {\n                XWPFRun currRun = runs.get(i);\n                if (!(currRun instanceof XWPFHyperlinkRun\n                        || currRun instanceof XWPFFieldRun)) {\n                    rPos++;\n                }\n            }\n\n            CTR ctRun = paragraph.insertNewR(rPos);\n            XWPFRun newRun = new XWPFRun(ctRun, (IRunBody) this);\n\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != -1) {\n                    iPos = oldAt;\n                }\n            }\n            iruns.add(iPos, newRun);\n\n            // Runs itself is easy to update\n            runs.add(pos, newRun);\n\n            return newRun;\n        }\n\n        return null;\n    }
680	public static boolean xslfOnly() {\n        try {\n            Class.forName("org.apache.poi.hslf.usermodel.HSLFSlideShow");\n            return false;\n        } catch (Exception e) {\n            return true;\n        }\n    }
681	static void shadeAlt(Sheet sheet) {\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =A2=A1   (White Font)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("MOD(ROW(),2)");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.LIGHT_GREEN.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:Z100")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.createRow(0).createCell(1).setCellValue("Shade Alternating Rows");\n        sheet.createRow(1).createCell(1).setCellValue("Condition: Formula Is  =MOD(ROW(),2)   (Light Green Fill)");\n    }
682	private void setColWidthAttribute(CTCols ctCols) {\n        for (CTCol col : ctCols.getColArray()) {\n            if (!col.isSetWidth()) {\n                col.setWidth(getDefaultColumnWidth());\n                col.setCustomWidth(false);\n            }\n        }\n    }
683	static int evaluateIntArg(ValueEval eval, int srcCellRow, int srcCellCol) throws EvaluationException {\n        ValueEval ve = OperandResolver.getSingleValue(eval, srcCellRow, srcCellCol);\n        return OperandResolver.coerceValueToInt(ve);\n    }
684	@Internal\n    public boolean isFRcaSimple()\n    {\n        return fRcaSimple.isSet(field_6_flags);\n    }
685	public boolean isBuiltin() {\n        return false;\n    }
686	public int write(final OutputStream out, final int codepage)\n    throws IOException, WritingNotSupportedException {\n        int length = 0;\n        long variantType = getType();\n\n        /* Ensure that wide strings are written if the codepage is Unicode. */\n//        if (codepage == CodePageUtil.CP_UNICODE && variantType == Variant.VT_LPSTR) {\n//            variantType = Variant.VT_LPWSTR;\n//        }\n\n        if (variantType == Variant.VT_LPSTR && codepage != CodePageUtil.CP_UTF16) {\n            String csStr = CodePageUtil.codepageToEncoding(codepage > 0 ? codepage : Property.DEFAULT_CODEPAGE);\n            if (!Charset.forName(csStr).newEncoder().canEncode((String)value)) {\n                variantType = Variant.VT_LPWSTR;\n            }\n        }\n\n        LittleEndian.putUInt(variantType, out);\n        length += LittleEndianConsts.INT_SIZE;\n        length += VariantSupport.write(out, variantType, getValue(), codepage);\n        return length;\n    }
687	public boolean containsColumn(int colInd) {\n		return _firstCol <= colInd && colInd <= _lastCol;\n	}
688	private NotImplementedException addExceptionInfo(NotImplementedException inner, int sheetIndex, int rowIndex, int columnIndex) {\n\n        try {\n            String sheetName = _workbook.getSheetName(sheetIndex);\n            CellReference cr = new CellReference(sheetName, rowIndex, columnIndex, false, false);\n            String msg =  "Error evaluating cell " + cr.formatAsString();\n            return new NotImplementedException(msg, inner);\n        } catch (Exception e) {\n            // avoid bombing out during exception handling\n            LOG.log(POILogger.ERROR, "Can't add exception info", e);\n            return inner; // preserve original exception\n        }\n    }
689	private Workbook loadWorkbook() {\n        if (excelFileName == null) {\n            throw new BuildException("fileName attribute must be set!", getLocation());\n        }\n\n        try {\n            try (FileInputStream fis = new FileInputStream(excelFileName)) {\n                workbook = WorkbookFactory.create(fis);\n            }\n        } catch(Exception e) {\n            throw new BuildException("Cannot load file " + excelFileName\n                    + ". Make sure the path and file permissions are correct.", e);\n        }\n\n        return workbook;\n    }
690	private void ensureFormatsSize(int index) {\n	   if(_formats.size() <= index) {\n	      _formats.setSize(index+1);\n	   }\n	}
691	public void setTable(int pos, XWPFTable table) {\n        tables.set(pos, table);\n        ctDocument.getBody().setTblArray(pos, table.getCTTbl());\n    }
692	int getNameIndex(HSSFName name) {\n      for (int k = 0; k < names.size(); k++) {\n        if (name == names.get(k)) {\n            return k;\n        }\n      }\n      return -1;\n    }
693	private CellFormatResult apply(JLabel label, Date date, double numericValue) {\n        CellFormatResult result = apply(date, numericValue);\n        label.setText(result.text);\n        if (result.textColor != null) {\n            label.setForeground(result.textColor);\n        }\n        return result;\n    }
694	public boolean isFunctionName() {\n        return _definedNameRec.isFunctionName();\n    }
695	public XDDFTextRun appendRegularRun(String text) {\n        CTRegularTextRun r = _p.addNewR();\n        r.setT(text);\n        CTTextCharacterProperties rPr = r.addNewRPr();\n        rPr.setLang(LocaleUtil.getUserLocale().toLanguageTag());\n        XDDFTextRun run = new XDDFTextRun(r, this);\n        _runs.add(run);\n        return run;\n    }
696	public int numSections() {\n		initSections();\n		return _sectionEnd - _sectionStart;\n	}
697	public static String toHex(String value) {\n        return (value == null || value.length() == 0)\n            ? "[]"\n            : toHex(value.getBytes(LocaleUtil.CHARSET_1252));\n    }
698	private boolean isCharFlagsTextPropVal(int index) {\n		return getFlag(index);\n	}
699	public void restoreProperties(int index) {\n        if (index == 0) {\n            return;\n        }\n        int stackIndex = index;\n        if (stackIndex < 0) {\n            int curIdx = propStack.indexOf(prop);\n            if (curIdx == -1) {\n                // the current element is not pushed to the stacked, i.e. it's the last\n                curIdx = propStack.size();\n            }\n            stackIndex = curIdx + index;\n        }\n        if (stackIndex == -1) {\n            // roll to last when curIdx == 0\n            stackIndex = propStack.size()-1;\n        }\n        prop = propStack.get(stackIndex);\n    }
700	public static Date getJavaDate(double date, TimeZone tz) {\n       return getJavaDate(date, false, tz, false);\n    }
701	public SummaryInformation getSummaryInformation() {\n        if(!initialized) {\n            readProperties();\n        }\n        return sInf;\n    }
702	public HSSFComment createComment(HSSFAnchor anchor) {\n        HSSFComment shape = new HSSFComment(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
703	public static Record[] getRecords(HSSFSheet hSheet, int streamOffset) {\n		RecordCollector rc = new RecordCollector();\n		hSheet.getSheet().visitContainedRecords(rc, streamOffset);\n		return rc.getRecords();\n	}
704	private static int getInt(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        if (value instanceof Number) {\n            return ((Number) value).intValue();\n        }\n        return 0;\n    }
705	private void readOtherStreams() {\n        // Currently, there aren't any\n    }
706	public int appendChildRecord(Record newChild) {\n		return appendChild(newChild);\n	}
707	@Internal\n    public boolean isFInvalHeight()\n    {\n        return fInvalHeight.isSet(field_1_info1);\n    }
708	public static String cp950ToString(byte[] data, int offset, int lengthInBytes) {\n        StringBuilder sb = new StringBuilder();\n        LittleEndianCP950Reader reader = new LittleEndianCP950Reader(data, offset, lengthInBytes);\n        int c = reader.read();\n        while (c != -1) {\n            sb.append((char)c);\n            c = reader.read();\n        }\n        reader.close();\n        return sb.toString();\n    }
709	public String findSheetFirstNameFromExternSheet(int externSheetIndex){\n        int indexToSheet = linkTable.getFirstInternalSheetIndexForExtIndex(externSheetIndex);\n        return findSheetNameFromIndex(indexToSheet);\n    }
710	public static void dumpHeap(String fileName, boolean live) throws IOException {\n        // initialize hotspot diagnostic MBean\n        initHotspotMBean();\n        hotspotMBean.dumpHeap(fileName, live);\n    }
711	public boolean isFHdrRows()\n    {\n        return fHdrRows.isSet( field_2_tlp_flags );\n\n    }
712	@Beta\n    @Internal\n    public void copyCellFrom(Cell srcCell, CellCopyPolicy policy) {\n        // Copy cell value (cell type is updated implicitly)\n        if (policy.isCopyCellValue()) {\n            if (srcCell != null) {\n                CellType copyCellType = srcCell.getCellType();\n                if (copyCellType == CellType.FORMULA && !policy.isCopyCellFormula()) {\n                    // Copy formula result as value\n                    // FIXME: Cached value may be stale\n                    copyCellType = srcCell.getCachedFormulaResultType();\n                }\n                switch (copyCellType) {\n                    case NUMERIC:\n                        // DataFormat is not copied unless policy.isCopyCellStyle is true\n                        if (DateUtil.isCellDateFormatted(srcCell)) {\n                            setCellValue(srcCell.getDateCellValue());\n                        }\n                        else {\n                            setCellValue(srcCell.getNumericCellValue());\n                        }\n                        break;\n                    case STRING:\n                        setCellValue(srcCell.getStringCellValue());\n                        break;\n                    case FORMULA:\n                        setCellFormula(srcCell.getCellFormula());\n                        break;\n                    case BLANK:\n                        setBlank();\n                        break;\n                    case BOOLEAN:\n                        setCellValue(srcCell.getBooleanCellValue());\n                        break;\n                    case ERROR:\n                        setCellErrorValue(srcCell.getErrorCellValue());\n                        break;\n\n                    default:\n                        throw new IllegalArgumentException("Invalid cell type " + srcCell.getCellType());\n                }\n            } else { //srcCell is null\n                setBlank();\n            }\n        }\n        \n        // Copy CellStyle\n        if (policy.isCopyCellStyle()) {\n            setCellStyle(srcCell == null ? null : srcCell.getCellStyle());\n        }\n        \n        final Hyperlink srcHyperlink = (srcCell == null) ? null : srcCell.getHyperlink();\n\n        if (policy.isMergeHyperlink()) {\n            // if srcCell doesn't have a hyperlink and destCell has a hyperlink, don't clear destCell's hyperlink\n            if (srcHyperlink != null) {\n                setHyperlink(new XSSFHyperlink(srcHyperlink));\n            }\n        } else if (policy.isCopyHyperlink()) {\n            // overwrite the hyperlink at dest cell with srcCell's hyperlink\n            // if srcCell doesn't have a hyperlink, clear the hyperlink (if one exists) at destCell\n            setHyperlink(srcHyperlink == null ? null : new XSSFHyperlink(srcHyperlink));\n        }\n    }
713	@Internal\n    public boolean isFBiDi()\n    {\n        return fBiDi.isSet(field_1_grpfChp);\n    }
714	public void resize() {\n        PictureShape<?,?> ps = getShape();\n        Dimension dim = ps.getPictureData().getImageDimension();\n\n        Rectangle2D origRect = ps.getAnchor();\n        double x = origRect.getX();\n        double y = origRect.getY();\n        double w = dim.getWidth();\n        double h = dim.getHeight();\n        ps.setAnchor(new Rectangle2D.Double(x, y, w, h));\n    }
715	private XSSFPivotTable createPivotTable(CellReference position, Sheet sourceSheet, PivotTableReferenceConfigurator refConfig) {\n\n        XSSFPivotTable pivotTable = createPivotTable();\n        //Creates default settings for the pivot table\n        pivotTable.setDefaultPivotTableDefinition();\n\n        //Set sources and references\n        pivotTable.createSourceReferences(position, sourceSheet, refConfig);\n\n        //Create cachefield/s and empty SharedItems - must be after creating references\n        pivotTable.getPivotCacheDefinition().createCacheFields(sourceSheet);\n        pivotTable.createDefaultDataColumns();\n\n        return pivotTable;\n    }
716	public HSLFFontInfo addFont(FontInfo fontInfo) {\n		return getDocumentRecord().getEnvironment().getFontCollection().addFont(fontInfo);\n	}
717	private static ExtendedFormatRecord createExtendedFormat() {\n        ExtendedFormatRecord retval = new ExtendedFormatRecord();\n\n        retval.setFontIndex(( short ) 0);\n        retval.setFormatIndex(( short ) 0x0);\n        retval.setCellOptions(( short ) 0x1);\n        retval.setAlignmentOptions(( short ) 0x20);\n        retval.setIndentionOptions(( short ) 0);\n        retval.setBorderOptions(( short ) 0);\n        retval.setPaletteOptions(( short ) 0);\n        retval.setAdtlPaletteOptions(( short ) 0);\n        retval.setFillPaletteOptions(( short ) 0x20c0);\n        retval.setTopBorderPaletteIdx(HSSFColorPredefined.BLACK.getIndex());\n        retval.setBottomBorderPaletteIdx(HSSFColorPredefined.BLACK.getIndex());\n        retval.setLeftBorderPaletteIdx(HSSFColorPredefined.BLACK.getIndex());\n        retval.setRightBorderPaletteIdx(HSSFColorPredefined.BLACK.getIndex());\n        return retval;\n    }
718	public short getHorizontalSplitTopRow() {\n	  return topRow;\n	}
719	public static HSLFSoundData[] find(Document document){\n        ArrayList<HSLFSoundData> lst = new ArrayList<>();\n        Record[] ch = document.getChildRecords();\n        for (int i = 0; i < ch.length; i++) {\n            if(ch[i].getRecordType() == RecordTypes.SoundCollection.typeID){\n                RecordContainer col = (RecordContainer)ch[i];\n                Record[] sr = col.getChildRecords();\n                for (int j = 0; j < sr.length; j++) {\n                    if(sr[j] instanceof Sound){\n                        lst.add(new HSLFSoundData((Sound)sr[j]));\n                    }\n                }\n            }\n\n        }\n        return lst.toArray(new HSLFSoundData[lst.size()]);\n    }
720	public static void main(String args[]) throws IOException {\n		if (args.length < 1) {\n			System.err.println("Useage:");\n			System.err.println("\tPowerPointExtractor [-notes] <file>");\n			System.exit(1);\n		}\n\n		boolean notes = false;\n		boolean comments = false;\n        boolean master = true;\n        \n		String file;\n		if (args.length > 1) {\n			notes = true;\n			file = args[1];\n			if (args.length > 2) {\n				comments = true;\n			}\n		} else {\n			file = args[0];\n		}\n\n		PowerPointExtractor ppe = new PowerPointExtractor(file);\n		System.out.println(ppe.getText(true, notes, comments, master));\n		ppe.close();\n	}
721	public static DVConstraint createTimeConstraint(int comparisonOperator, String expr1, String expr2) {\n		if (expr1 == null) {\n			throw new IllegalArgumentException("expr1 must be supplied");\n		}\n		OperatorType.validateSecondArg(comparisonOperator, expr1);\n		\n		// formula1 and value1 are mutually exclusive\n		String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertTime(expr1) : null;\n		// formula2 and value2 are mutually exclusive\n		String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertTime(expr2) : null;\n		return new DVConstraint(ValidationType.TIME, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
722	@Internal\n    public boolean isFLoadOverride()\n    {\n        return fLoadOverride.isSet(field_6_flags1);\n    }
723	public static String mapMsCodepointString(String string) {\n        if (string == null || string.isEmpty()) return string;\n        initMsCodepointMap();\n\n        StringBuilder sb = new StringBuilder();\n        final int length = string.length();\n        for (int offset = 0; offset < length; ) {\n            Integer msCodepoint = string.codePointAt(offset);\n            Integer uniCodepoint = msCodepointToUnicode.get(msCodepoint);\n            sb.appendCodePoint(uniCodepoint == null ? msCodepoint : uniCodepoint);\n            offset += Character.charCount(msCodepoint);\n        }\n\n        return sb.toString();\n    }
724	@Internal\n    public boolean isFHidden()\n    {\n        return fHidden.isSet(field_5_grfstd);\n    }
725	protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {\n       boolean firstInStore = false;\n       if (_mini_stream.getStartBlock() == POIFSConstants.END_OF_CHAIN) {\n           firstInStore = true;\n       }\n       \n       // Try to get it without extending the stream\n       if (! firstInStore) {\n           try {\n              return getBlockAt(offset);\n           } catch(IndexOutOfBoundsException e) {}\n       }\n       \n       // Need to extend the stream\n       // TODO Replace this with proper append support\n       // For now, do the extending by hand...\n\n       // Ask for another block\n       int newBigBlock = _filesystem.getFreeBlock();\n       _filesystem.createBlockIfNeeded(newBigBlock);\n       \n       // If we are the first block to be allocated, initialise the stream\n       if (firstInStore) {\n           _filesystem._get_property_table().getRoot().setStartBlock(newBigBlock);\n           _mini_stream = new POIFSStream(_filesystem, newBigBlock);\n       } else {\n           // Tack it onto the end of our chain\n           ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\n           int block = _mini_stream.getStartBlock();\n           while(true) {\n              loopDetector.claim(block);\n              int next = _filesystem.getNextBlock(block);\n              if(next == POIFSConstants.END_OF_CHAIN) {\n                 break;\n              }\n              block = next;\n           }\n           _filesystem.setNextBlock(block, newBigBlock);\n       }\n       \n       // This is now the new end\n       _filesystem.setNextBlock(newBigBlock, POIFSConstants.END_OF_CHAIN);\n\n       // Now try again, to get the real small block\n       return createBlockIfNeeded(offset);\n    }
726	public static BATBlock createEmptyBATBlock(final POIFSBigBlockSize bigBlockSize, boolean isXBAT) {\n       BATBlock block = new BATBlock(bigBlockSize);\n       if(isXBAT) {\n           final int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();\n           block._values[ _entries_per_xbat_block ] = POIFSConstants.END_OF_CHAIN;\n       }\n       return block;\n    }
727	public void applyBorders(Sheet sheet) {\n        Workbook wb = sheet.getWorkbook();\n        for (Map.Entry<CellAddress, Map<String, Object>> entry : _propertyTemplate\n                .entrySet()) {\n            CellAddress cellAddress = entry.getKey();\n            if (cellAddress.getRow() < wb.getSpreadsheetVersion().getMaxRows()\n                    && cellAddress.getColumn() < wb.getSpreadsheetVersion()\n                            .getMaxColumns()) {\n                Map<String, Object> properties = entry.getValue();\n                Row row = CellUtil.getRow(cellAddress.getRow(), sheet);\n                Cell cell = CellUtil.getCell(row, cellAddress.getColumn());\n                CellUtil.setCellStyleProperties(cell, properties);\n            }\n        }\n    }
728	public XWPFHeader createHeader(HeaderFooterType type) {\n        XWPFHeaderFooterPolicy hfPolicy = createHeaderFooterPolicy();\n        // TODO this needs to be migrated out into section code\n        if (type == HeaderFooterType.FIRST) {\n            CTSectPr ctSectPr = getSection();\n            if (!ctSectPr.isSetTitlePg()) {\n                CTOnOff titlePg = ctSectPr.addNewTitlePg();\n                titlePg.setVal(STOnOff.ON);\n            }\n            // } else if (type == HeaderFooterType.EVEN) {\n            // TODO Add support for Even/Odd headings and footers\n        }\n        return hfPolicy.createHeader(STHdrFtr.Enum.forInt(type.toInt()));\n    }
729	public void concatenate(byte[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException("array cannot be null");\n        }\n        arrays.add(array);\n    }
730	private void readCoreContents() throws IOException {\n       // Grab the block size\n       bigBlockSize = _header.getBigBlockSize();\n       \n       // Each block should only ever be used by one of the\n       //  FAT, XFAT or Property Table. Ensure it does\n       ChainLoopDetector loopDetector = getChainLoopDetector();\n       \n       // Read the FAT blocks\n       for(int fatAt : _header.getBATArray()) {\n          readBAT(fatAt, loopDetector);\n       }\n       \n       // Work out how many FAT blocks remain in the XFATs\n       int remainingFATs = _header.getBATCount() - _header.getBATArray().length;\n       \n       // Now read the XFAT blocks, and the FATs within them\n       BATBlock xfat; \n       int nextAt = _header.getXBATIndex();\n       for(int i=0; i<_header.getXBATCount(); i++) {\n          loopDetector.claim(nextAt);\n          ByteBuffer fatData = getBlockAt(nextAt);\n          xfat = BATBlock.createBATBlock(bigBlockSize, fatData);\n          xfat.setOurBlockIndex(nextAt);\n          nextAt = xfat.getValueAt(bigBlockSize.getXBATEntriesPerBlock());\n          _xbat_blocks.add(xfat);\n          \n          // Process all the (used) FATs from this XFAT\n          int xbatFATs = Math.min(remainingFATs, bigBlockSize.getXBATEntriesPerBlock());\n          for(int j=0; j<xbatFATs; j++) {\n             int fatAt = xfat.getValueAt(j);\n             if(fatAt == POIFSConstants.UNUSED_BLOCK || fatAt == POIFSConstants.END_OF_CHAIN) break;\n             readBAT(fatAt, loopDetector);\n          }\n          remainingFATs -= xbatFATs;\n       }\n       \n       // We're now able to load steams\n       // Use this to read in the properties\n       _property_table = new PropertyTable(_header, this);\n       \n       // Finally read the Small Stream FAT (SBAT) blocks\n       BATBlock sfat;\n       List<BATBlock> sbats = new ArrayList<>();\n       _mini_store     = new POIFSMiniStore(this, _property_table.getRoot(), sbats, _header);\n       nextAt = _header.getSBATStart();\n       for(int i=0; i<_header.getSBATCount() && nextAt != POIFSConstants.END_OF_CHAIN; i++) {\n          loopDetector.claim(nextAt);\n          ByteBuffer fatData = getBlockAt(nextAt);\n          sfat = BATBlock.createBATBlock(bigBlockSize, fatData);\n          sfat.setOurBlockIndex(nextAt);\n          sbats.add(sfat);\n          nextAt = getNextBlock(nextAt);  \n       }\n    }
731	@SuppressWarnings("WeakerAccess")\n    public void updateAndWriteDependantRecords(OutputStream os, Map<RecordTypes, PositionDependentRecord> interestingRecords)\n            throws IOException {\n        // For position dependent records, hold where they were and now are\n        // As we go along, update, and hand over, to any Position Dependent\n        //  records we happen across\n        Map<Integer, Integer> oldToNewPositions = new HashMap<>();\n\n        // First pass - figure out where all the position dependent\n        //   records are going to end up, in the new scheme\n        // (Annoyingly, some powerpoint files have PersistPtrHolders\n        //  that reference slides after the PersistPtrHolder)\n        UserEditAtom usr = null;\n        PersistPtrHolder ptr = null;\n        CountingOS cos = new CountingOS();\n        for (Record record : _records) {\n            // all top level records are position dependent\n            assert (record instanceof PositionDependentRecord);\n            PositionDependentRecord pdr = (PositionDependentRecord) record;\n            int oldPos = pdr.getLastOnDiskOffset();\n            int newPos = cos.size();\n            pdr.setLastOnDiskOffset(newPos);\n            if (oldPos != UNSET_OFFSET) {\n                // new records don't need a mapping, as they aren't in a relation yet\n                oldToNewPositions.put(oldPos, newPos);\n            }\n\n            // Grab interesting records as they come past\n            // this will only save the very last record of each type\n            RecordTypes saveme = null;\n            int recordType = (int) record.getRecordType();\n            if (recordType == RecordTypes.PersistPtrIncrementalBlock.typeID) {\n                saveme = RecordTypes.PersistPtrIncrementalBlock;\n                ptr = (PersistPtrHolder) pdr;\n            } else if (recordType == RecordTypes.UserEditAtom.typeID) {\n                saveme = RecordTypes.UserEditAtom;\n                usr = (UserEditAtom) pdr;\n            }\n            if (interestingRecords != null && saveme != null) {\n                interestingRecords.put(saveme, pdr);\n            }\n\n            // Dummy write out, so the position winds on properly\n            record.writeOut(cos);\n        }\n        cos.close();\n\n        if (usr == null || ptr == null) {\n            throw new HSLFException("UserEditAtom or PersistPtr can't be determined.");\n        }\n\n        Map<Integer, Integer> persistIds = new HashMap<>();\n        for (Map.Entry<Integer, Integer> entry : ptr.getSlideLocationsLookup().entrySet()) {\n            persistIds.put(oldToNewPositions.get(entry.getValue()), entry.getKey());\n        }\n\n        HSLFSlideShowEncrypted encData = new HSLFSlideShowEncrypted(getDocumentEncryptionAtom());\n\n        for (Record record : _records) {\n            assert (record instanceof PositionDependentRecord);\n            // We've already figured out their new location, and\n            // told them that\n            // Tell them of the positions of the other records though\n            PositionDependentRecord pdr = (PositionDependentRecord) record;\n            Integer persistId = persistIds.get(pdr.getLastOnDiskOffset());\n            if (persistId == null) {\n                persistId = 0;\n            }\n\n            // For now, we're only handling PositionDependentRecord's that\n            // happen at the top level.\n            // In future, we'll need the handle them everywhere, but that's\n            // a bit trickier\n            pdr.updateOtherRecordReferences(oldToNewPositions);\n\n            // Whatever happens, write out that record tree\n            if (os != null) {\n                record.writeOut(encData.encryptRecord(os, persistId, record));\n            }\n        }\n\n        encData.close();\n\n        // Update and write out the Current User atom\n        int oldLastUserEditAtomPos = (int) currentUser.getCurrentEditOffset();\n        Integer newLastUserEditAtomPos = oldToNewPositions.get(oldLastUserEditAtomPos);\n        if (newLastUserEditAtomPos == null || usr.getLastOnDiskOffset() != newLastUserEditAtomPos) {\n            throw new HSLFException("Couldn't find the new location of the last UserEditAtom that used to be at " + oldLastUserEditAtomPos);\n        }\n        currentUser.setCurrentEditOffset(usr.getLastOnDiskOffset());\n    }
732	@Internal\n    public boolean isFFarEast()\n    {\n        return fFarEast.isSet(field_6_flags1);\n    }
733	private int addMergedRegion(CellRangeAddress region, boolean validate) {\n        if (region.getNumberOfCells() < 2) {\n            throw new IllegalArgumentException("Merged region " + region.formatAsString() + " must contain 2 or more cells");\n        }\n        region.validate(SpreadsheetVersion.EXCEL2007);\n\n        if (validate) {\n            // throw IllegalStateException if the argument CellRangeAddress intersects with\n            // a multi-cell array formula defined in this sheet\n            validateArrayFormulas(region);\n\n            // Throw IllegalStateException if the argument CellRangeAddress intersects with\n            // a merged region already in this sheet \n            validateMergedRegions(region);\n        }\n\n        CTMergeCells ctMergeCells = worksheet.isSetMergeCells() ? worksheet.getMergeCells() : worksheet.addNewMergeCells();\n        CTMergeCell ctMergeCell = ctMergeCells.addNewMergeCell();\n        ctMergeCell.setRef(region.formatAsString());\n        return ctMergeCells.sizeOfMergeCellArray();\n    }
734	public static boolean isPropertySetStream(final InputStream stream)\n    throws IOException {\n        /*\n         * Read at most this many bytes.\n         */\n        final int BUFFER_SIZE = 50;\n\n        /*\n         * Read a couple of bytes from the stream.\n         */\n        try {\n            final byte[] buffer = IOUtils.peekFirstNBytes(stream, BUFFER_SIZE);\n            return isPropertySetStream(buffer, 0, buffer.length);\n        } catch (EmptyFileException e) {\n            return false;\n        }\n    }
735	public static HSLFShape createShape(EscherContainerRecord spContainer, ShapeContainer<HSLFShape,HSLFTextParagraph> parent){\n        if (spContainer.getRecordId() == EscherContainerRecord.SPGR_CONTAINER){\n            return createShapeGroup(spContainer, parent);\n        }\n        return createSimpleShape(spContainer, parent);\n    }
736	private static DateWindow1904Record createDateWindow1904() {\n        DateWindow1904Record retval = new DateWindow1904Record();\n\n        retval.setWindowing(( short ) 0);   // don't EVER use 1904 date windowing...tick tock..\n        return retval;\n    }
737	public HSSFTextbox createTextbox(HSSFClientAnchor anchor) {\n        HSSFTextbox shape = new HSSFTextbox(null, anchor);\n        addShape(shape);\n        onCreate(shape);\n        return shape;\n    }
738	private void attemptMergeColInfoRecords(int colInfoIx) {\n		int nRecords = records.size();\n		if (colInfoIx < 0 || colInfoIx >= nRecords) {\n			throw new IllegalArgumentException("colInfoIx " + colInfoIx\n					+ " is out of range (0.." + (nRecords-1) + ")");\n		}\n		ColumnInfoRecord currentCol = getColInfo(colInfoIx);\n		int nextIx = colInfoIx+1;\n		if (nextIx < nRecords) {\n			if (mergeColInfoRecords(currentCol, getColInfo(nextIx))) {\n    			records.remove(nextIx);\n			}\n		}\n		if (colInfoIx > 0) {\n			if (mergeColInfoRecords(getColInfo(colInfoIx - 1), currentCol)) {\n    			records.remove(colInfoIx);\n    		}\n		}\n	}
739	public XWPFParagraph addParagraph() {\n        XWPFParagraph p = new XWPFParagraph(ctTc.addNewP(), this);\n        addParagraph(p);\n        return p;\n    }
740	public XSSFTextParagraph addNewTextParagraph(XSSFRichTextString str) {\n        CTTextBody txBody = ctShape.getTxBody();\n        CTTextParagraph p = txBody.addNewP();\n\n        if (str.numFormattingRuns() == 0) {\n            CTRegularTextRun r = p.addNewR();\n            CTTextCharacterProperties rPr = r.addNewRPr();\n            rPr.setLang("en-US");\n            rPr.setSz(1100);\n            r.setT(str.getString());\n\n        } else {\n            for (int i = 0; i < str.getCTRst().sizeOfRArray(); i++) {\n                CTRElt lt = str.getCTRst().getRArray(i);\n                CTRPrElt ltPr = lt.getRPr();\n                if (ltPr == null) {\n                    ltPr = lt.addNewRPr();\n                }\n\n                CTRegularTextRun r = p.addNewR();\n                CTTextCharacterProperties rPr = r.addNewRPr();\n                rPr.setLang("en-US");\n\n                applyAttributes(ltPr, rPr);\n\n                r.setT(lt.getT());\n            }\n        }\n\n        // Note: the XSSFTextParagraph constructor will create its required\n        // XSSFTextRuns from the provided CTTextParagraph\n        XSSFTextParagraph paragraph = new XSSFTextParagraph(p, ctShape);\n        _paragraphs.add(paragraph);\n\n        return paragraph;\n    }
741	public void demonstrateMethodCalls(String outputFilename) throws IOException {\n        try (HSSFWorkbook workbook = new HSSFWorkbook()) {\n            HSSFSheet sheet = workbook.createSheet("In Cell Lists");\n            HSSFRow row = sheet.createRow(0);\n\n            // Create a cell at A1 and insert a single, bulleted, item into\n            // that cell.\n            HSSFCell cell = row.createCell(0);\n            this.bulletedItemInCell(workbook, "List Item", cell);\n\n            // Create a cell at A2 and insert a plain list - that is one\n            // whose items are neither bulleted or numbered - into that cell.\n            row = sheet.createRow(1);\n            cell = row.createCell(0);\n            ArrayList<String> listItems = new ArrayList<>();\n            listItems.add("List Item One.");\n            listItems.add("List Item Two.");\n            listItems.add("List Item Three.");\n            listItems.add("List Item Four.");\n            this.listInCell(workbook, listItems, cell);\n            // The row height and cell width are set here to ensure that the\n            // list may be seen.\n            row.setHeight((short) 1100);\n            sheet.setColumnWidth(0, 9500);\n\n            // Create a cell at A3 and insert a numbered list into that cell.\n            // Note that a couple of items have been added to the listItems\n            // ArrayList\n            row = sheet.createRow(2);\n            cell = row.createCell(0);\n            listItems.add("List Item Five.");\n            listItems.add("List Item Six.");\n            this.numberedListInCell(workbook, listItems, cell, 1, 2);\n            row.setHeight((short) 1550);\n\n            // Create a cell at A4 and insert a numbered list into that cell.\n            // Note that a couple of items have been added to the listItems\n            // ArrayList\n            row = sheet.createRow(3);\n            cell = row.createCell(0);\n            listItems.add("List Item Seven.");\n            listItems.add("List Item Eight.");\n            listItems.add("List Item Nine.");\n            listItems.add("List Item Ten.");\n            this.bulletedListInCell(workbook, listItems, cell);\n            row.setHeight((short) 2550);\n\n            // Insert a plain, multi-level list into cell A5. Note that\n            // the major difference here is that the list items are passed as\n            // an ArrayList of MultiLevelListItems. Note that an ArrayList\n            // of instances of an inner class was used here in preference to\n            // a Hashtable or HashMap as the ArrayList will preserve the\n            // ordering of the items added to it; the first item added will\n            // be the first item recovered and the last item added, the last\n            // item recovered. Alternatively, a LinkedHashMap could be used\n            // to preserve order.\n            row = sheet.createRow(4);\n            cell = row.createCell(0);\n            ArrayList<MultiLevelListItem> multiLevelListItems = new ArrayList<>();\n            listItems = new ArrayList<>();\n            listItems.add("ML List Item One - Sub Item One.");\n            listItems.add("ML List Item One - Sub Item Two.");\n            listItems.add("ML List Item One - Sub Item Three.");\n            listItems.add("ML List Item One - Sub Item Four.");\n            multiLevelListItems.add(new MultiLevelListItem("List Item One.", listItems));\n            // Passing either null or an empty ArrayList will signal that\n            // there are no lower level items associated with the top level\n            // item\n            multiLevelListItems.add(new MultiLevelListItem("List Item Two.", null));\n            multiLevelListItems.add(new MultiLevelListItem("List Item Three.", null));\n            listItems = new ArrayList<>();\n            listItems.add("ML List Item Four - Sub Item One.");\n            listItems.add("ML List Item Four - Sub Item Two.");\n            listItems.add("ML List Item Four - Sub Item Three.");\n            multiLevelListItems.add(new MultiLevelListItem("List Item Four.", listItems));\n            this.multiLevelListInCell(workbook, multiLevelListItems, cell);\n            row.setHeight((short) 2800);\n\n            // Insert a numbered multi-level list into cell A6. Note that the\n            // same ArrayList as constructed for the above plain multi-level\n            // list example will be re-used\n            row = sheet.createRow(5);\n            cell = row.createCell(0);\n            this.multiLevelNumberedListInCell(workbook, multiLevelListItems,\n                    cell, 1, 1, 1, 2);\n            row.setHeight((short) 2800);\n\n            // Insert a numbered multi-level list into cell A7. Note that the\n            // same ArrayList as constructed for the plain multi-level list\n            // example will be re-used\n            row = sheet.createRow(6);\n            cell = row.createCell(0);\n            this.multiLevelBulletedListInCell(workbook, multiLevelListItems, cell);\n            row.setHeight((short) 2800);\n\n            // Save the completed workbook\n            try (FileOutputStream fos = new FileOutputStream(new File(outputFilename))) {\n                workbook.write(fos);\n            }\n        } catch (IOException ioEx) {\n            System.out.println("Caught a: " + ioEx.getClass().getName());\n            System.out.println("Message: " + ioEx.getMessage());\n            System.out.println("Stacktrace follows...........");\n            ioEx.printStackTrace(System.out);\n        }\n    }
742	public static ErrorEval valueOf(int errorCode) {\n        FormulaError error = FormulaError.forInt(errorCode);\n        ErrorEval eval = evals.get(error);\n        if (eval != null) {\n            return eval;\n        } else {\n            throw new RuntimeException("Unhandled error type for code " + errorCode);\n        }\n    }
743	public String getTextRecursively() {\n\n        StringBuilder text = new StringBuilder(64);\n        for (int i = 0; i < bodyElements.size(); i++) {\n            boolean isLast = (i == bodyElements.size() - 1);\n            appendBodyElementText(text, bodyElements.get(i), isLast);\n        }\n\n        return text.toString();\n    }
744	private boolean isCursorInFtn(XmlCursor cursor) {\n        XmlCursor verify = cursor.newCursor();\n        verify.toParent();\n        if (verify.getObject() == this.ctFtnEdn) {\n            return true;\n        }\n        return false;\n    }
745	void updateContents(byte[] contents) throws IOException {\n       OutputStream os = getOutputStream();\n       os.write(contents);\n       os.close();\n   }
746	public int getValue(final int holder)\n    {\n        return getRawValue(holder) >>> _shift_count;\n    }
747	public void setActiveXIndex(int idx) {\n        ExObjRefAtom oe = getClientDataRecord(RecordTypes.ExObjRefAtom.typeID);\n        if (oe == null) {\n            throw new HSLFException("OEShapeAtom for ActiveX doesn't exist");\n        }\n        oe.setExObjIdRef(idx);\n    }
748	private void addContentStatus() {\n        setElementTextContent(KEYWORD_CONTENT_STATUS, namespaceCoreProperties, propsPart.getContentStatusProperty());\n	}
749	private CTHdrFtr buildHdrFtr(XWPFParagraph[] paragraphs, XWPFHeaderFooter wrapper) {\n        CTHdrFtr ftr = wrapper._getHdrFtr();\n        if (paragraphs != null) {\n            for (int i = 0; i < paragraphs.length; i++) {\n                /*CTP p =*/ ftr.addNewP();\n                ftr.setPArray(i, paragraphs[i].getCTP());\n            }\n//        } else {\n//            CTP p = ftr.addNewP();\n//            CTBody body = doc.getDocument().getBody();\n//            if (body.sizeOfPArray() > 0) {\n//                CTP p0 = body.getPArray(0);\n//                if (p0.isSetRsidR()) {\n//                    byte[] rsidr = p0.getRsidR();\n//                    byte[] rsidrdefault = p0.getRsidRDefault();\n//                    p.setRsidP(rsidr);\n//                    p.setRsidRDefault(rsidrdefault);\n//                }\n//            }\n//            CTPPr pPr = p.addNewPPr();\n//            pPr.addNewPStyle().setVal(pStyle);\n        }\n        return ftr;\n    }
750	public void draw(Graphics2D graphics) {\n        visitShapes(new ShapeRenderer(graphics));\n    }
751	public static byte[] getBytesInCodePage(final String string, final int codepage) \n    throws UnsupportedEncodingException \n    {\n        String encoding = codepageToEncoding(codepage);\n        return string.getBytes(encoding);\n    }
752	public void setParentSize(int size) {\n        assert(size > 0);\n        int covered = 0;\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TextSpecInfoRun runs[] = getTextSpecInfoRuns();\n        assert(runs.length > 0);\n        for (int i=0; i<runs.length && covered < size; i++) {\n            TextSpecInfoRun run = runs[i];\n            if (covered + run.getLength() > size || i == runs.length-1) {\n                run.setLength(size-covered);\n            }\n            covered += run.getLength();\n            try {\n                run.writeOut(bos);\n            } catch (IOException e) {\n                throw new HSLFException(e);\n            }\n        }\n        _data = bos.toByteArray();\n\n        // Update the size (header bytes 5-8)\n        LittleEndian.putInt(_header, 4, _data.length);\n    }
753	public boolean isDefaultDateSettings()\n    {\n        return defaultDateSettings.isSet(field_9_options);\n    }
754	@NotImplemented\n	public boolean validatePackage(OPCPackage pkg) throws InvalidFormatException {\n		throw new InvalidOperationException("Not implemented yet !!!");\n	}
755	protected void setChart(XSSFChart chart, String relId) {\n		CTGraphicalObjectData data = graphicFrame.getGraphic().addNewGraphicData();\n		appendChartElement(data, relId);\n		chart.setGraphicFrame(this);\n	}
756	public void resize(Rectangle2D target) {\n        resize(target, RectAlign.CENTER);\n    }
757	public void setChartTitle(String title) {\n		if(chartTitleText != null) {\n			chartTitleText.setText(title);\n		} else {\n			throw new IllegalStateException("No chart title found to change");\n		}\n	}
758	public InputStream getContents(PackagePart corePart) throws IOException, InvalidFormatException {\n        PackageRelationshipCollection prc =\n                corePart.getRelationshipsByType(getRelation());\n        Iterator<PackageRelationship> it = prc.iterator();\n        if(it.hasNext()) {\n            PackageRelationship rel = it.next();\n            PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n            PackagePart part = corePart.getPackage().getPart(relName);\n            return part.getInputStream();\n        }\n        log.log(POILogger.WARN, "No part " + getDefaultFileName() + " found");\n        return null;\n    }
759	private static void applyShade(double hsl[], ColorStyle fc) {\n        int shade = fc.getShade();\n        if (shade == -1) {\n            return;\n        }\n\n        double shadePct = shade / 100000.;\n\n        hsl[2] *= 1. - shadePct;\n    }
760	@Beta\n    public void addReportFilter(int columnIndex) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n        // check and change row of location\n        CTLocation location = pivotTableDefinition.getLocation();\n        AreaReference destination = new AreaReference(location.getRef(), SpreadsheetVersion.EXCEL2007);\n        if (destination.getFirstCell().getRow() < 2) {\n            AreaReference newDestination = new AreaReference(new CellReference(2, destination.getFirstCell().getCol()), new CellReference(\n                    3, destination.getFirstCell().getCol()+1), SpreadsheetVersion.EXCEL2007);\n            location.setRef(newDestination.formatAsString());\n       }\n\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_PAGE);\n        pivotField.setShowAll(false);\n        for(int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTPageFields pageFields;\n        if (pivotTableDefinition.getPageFields()!= null) {\n            pageFields = pivotTableDefinition.getPageFields();\n            //Another filter has already been created\n            pivotTableDefinition.setMultipleFieldFilters(true);\n        } else {\n            pageFields = pivotTableDefinition.addNewPageFields();\n        }\n        CTPageField pageField = pageFields.addNewPageField();\n        pageField.setHier(-1);\n        pageField.setFld(columnIndex);\n\n        pageFields.setCount(pageFields.sizeOfPageFieldArray());\n        pivotTableDefinition.getLocation().setColPageCount(pageFields.getCount());\n    }
761	protected void updateIntegrityHMAC(File tmpFile, int oleStreamSize) throws GeneralSecurityException, IOException {\n        // as the integrity hmac needs to contain the StreamSize,\n        // it's not possible to calculate it on-the-fly while buffering\n        // TODO: add stream size parameter to getDataStream()\n        AgileEncryptionHeader header = (AgileEncryptionHeader)getEncryptionInfo().getHeader();\n        int blockSize = header.getBlockSize();\n        HashAlgorithm hashAlgo = header.getHashAlgorithm();\n        Mac integrityMD = CryptoFunctions.getMac(hashAlgo);\n        byte hmacKey[] = getBlock0(this.integritySalt, getNextBlockSize(this.integritySalt.length, blockSize));\n        integrityMD.init(new SecretKeySpec(hmacKey, hashAlgo.jceHmacId));\n\n        byte buf[] = new byte[1024];\n        LittleEndian.putLong(buf, 0, oleStreamSize);\n        integrityMD.update(buf, 0, LittleEndianConsts.LONG_SIZE);\n        \n        InputStream fis = new FileInputStream(tmpFile);\n        try {\n            int readBytes;\n            while ((readBytes = fis.read(buf)) != -1) {\n                integrityMD.update(buf, 0, readBytes);\n            }\n        } finally {\n        	fis.close();\n        }\n        \n        byte hmacValue[] = integrityMD.doFinal();\n        byte hmacValueFilled[] = getBlock0(hmacValue, getNextBlockSize(hmacValue.length, blockSize));\n        \n        byte iv[] = CryptoFunctions.generateIv(header.getHashAlgorithm(), header.getKeySalt(), kIntegrityValueBlock, blockSize);\n        Cipher cipher = CryptoFunctions.getCipher(getSecretKey(), header.getCipherAlgorithm(), header.getChainingMode(), iv, Cipher.ENCRYPT_MODE);\n        byte encryptedHmacValue[] = cipher.doFinal(hmacValueFilled);\n        \n        header.setEncryptedHmacValue(encryptedHmacValue);\n    }
762	protected void preSerialize(){\n        if (_patriarch != null){\n            _patriarch.preSerialize();\n        }\n    }
763	public void setIncludeCellComments(boolean includeComments) {\n       throw new IllegalStateException("Comment extraction not supported in streaming mode, please use ExcelExtractor");\n   }
764	public void writeTo( ByteArrayOutputStream tableStream ) throws IOException\n    {\n        SttbUtils.writeSttbfRMark( entries, tableStream );\n    }
765	public byte getItcLim()\n    {\n        return ( byte )itcLim.getValue(field_2_bkf_flags);\n    }
766	@SuppressWarnings("resource")\n    protected static List<HSLFHyperlink> find(List<HSLFTextParagraph> paragraphs){\n        List<HSLFHyperlink> lst = new ArrayList<>();\n        if (paragraphs == null || paragraphs.isEmpty()) return lst;\n\n        HSLFTextParagraph firstPara = paragraphs.get(0);\n\n        HSLFSlideShow ppt = firstPara.getSheet().getSlideShow();\n        //document-level container which stores info about all links in a presentation\n        ExObjList exobj = ppt.getDocumentRecord().getExObjList(false);\n        if (exobj != null) {\n            Record[] records = firstPara.getRecords();\n            find(Arrays.asList(records), exobj, lst);\n        }\n\n        return lst;\n    }
767	public void serialize(ContinuableRecordOutput out) {\n        int numberOfRichTextRuns = 0;\n        int extendedDataSize = 0;\n        if (isRichText() && field_4_format_runs != null) {\n            numberOfRichTextRuns = field_4_format_runs.size();\n        }\n        if (isExtendedText() && field_5_ext_rst != null) {\n            extendedDataSize = 4 + field_5_ext_rst.getDataSize();\n        }\n       \n        // Serialise the bulk of the String\n        // The writeString handles tricky continue stuff for us\n        out.writeString(field_3_string, numberOfRichTextRuns, extendedDataSize);\n\n        if (numberOfRichTextRuns > 0) {\n\n          //This will ensure that a run does not split a continue\n          for (int i=0;i<numberOfRichTextRuns;i++) {\n              if (out.getAvailableSpace() < 4) {\n                  out.writeContinue();\n              }\n              FormatRun r = field_4_format_runs.get(i);\n              r.serialize(out);\n          }\n        }\n\n        if (extendedDataSize > 0 && field_5_ext_rst != null) {\n           field_5_ext_rst.serialize(out);\n        }\n    }
768	protected boolean isLatentStyle(String latentStyleID) {\n        for (CTLsdException lsd : latentStyles.getLsdExceptionArray()) {\n            if (lsd.getName().equals(latentStyleID)) {\n                return true;\n            }\n        }\n        return false;\n    }
769	public static ZipSecureFile openZipFile(String path) throws IOException {\n        return openZipFile(new File(path));\n    }
770	public void removeExFormatRecord(int index) {\n        int xfptr = records.getXfpos() - (numxfs - 1) + index;\n        records.remove(xfptr); // this updates XfPos for us\n        numxfs--;\n    }
771	public XWPFTable insertNewTbl(XmlCursor cursor) {\n        if (isCursorInFtn(cursor)) {\n            String uri = CTTbl.type.getName().getNamespaceURI();\n            String localPart = "tbl";\n            cursor.beginElement(localPart, uri);\n            cursor.toParent();\n            CTTbl t = (CTTbl) cursor.getObject();\n            XWPFTable newT = new XWPFTable(t, this);\n            cursor.removeXmlContents();\n            XmlObject o = null;\n            while (!(o instanceof CTTbl) && (cursor.toPrevSibling())) {\n                o = cursor.getObject();\n            }\n            if (!(o instanceof CTTbl)) {\n                tables.add(0, newT);\n            } else {\n                int pos = tables.indexOf(getTable((CTTbl) o)) + 1;\n                tables.add(pos, newT);\n            }\n            int i = 0;\n            cursor = t.newCursor();\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (o instanceof CTP || o instanceof CTTbl)\n                    i++;\n            }\n            bodyElements.add(i, newT);\n            XmlCursor c2 = t.newCursor();\n            cursor.toCursor(c2);\n            cursor.toEndToken();\n            c2.dispose();\n            return newT;\n        }\n        return null;\n    }
772	public Integer[] getTextOffsets(){\n        return indent;\n    }
773	@Internal\n    public boolean isF97LidsSet()\n    {\n        return f97LidsSet.isSet(field_5_grfstd);\n    }
774	public NameXPtg getNameXPtg(String name, int sheetRefIndex) {\n        // first find any external book block that contains the name:\n        for (int i = 0; i < _externalBookBlocks.length; i++) {\n            int definedNameIndex = _externalBookBlocks[i].getIndexOfName(name);\n            if (definedNameIndex < 0) {\n                continue;\n            }\n\n            // Found one\n            int thisSheetRefIndex = findRefIndexFromExtBookIndex(i);\n            if (thisSheetRefIndex >= 0) {\n                // Check for the sheet index match, if requested\n                if (sheetRefIndex == -1 || thisSheetRefIndex == sheetRefIndex) {\n                    return new NameXPtg(thisSheetRefIndex, definedNameIndex);\n                }\n            }\n        }\n        return null;\n    }
775	/* package */ static boolean isSimpleAscii(char c) {\n\n		if (c>=0x21 && c<=0x7E) {\n			// everything from '!' to '~' (includes letters, digits, punctuation\n			return true;\n		}\n		// some specific whitespace chars below 0x21:\n		switch(c) {\n			case ' ':\n			case '\t':\n			case '\r':\n			case '\n':\n				return true;\n		}\n		return false;\n	}
776	public boolean isFFont()\n    {\n        return fFont.isSet( field_2_tlp_flags );\n\n    }
777	public static void setExcelStyleRoundingMode(DecimalFormat format) {\n        setExcelStyleRoundingMode(format, RoundingMode.HALF_UP);\n    }
778	public DocumentSummaryInformation getDocSummaryInformation() {\n       throw new IllegalStateException("Metadata extraction not supported in streaming mode, please use ExcelExtractor");\n   }
779	public static byte[] readData( String filename ) throws IOException {\n        File file = new File( filename );\n        InputStream stream = new FileInputStream( file );\n        try {\n            return readData( stream, -1 );\n        } finally {\n            stream.close();\n        }\n    }
780	public String toString()\n    {\n        return getString();\n    }
781	public void setFormatId(int formatId){\n         LittleEndian.putUShort(_recdata, 0, formatId);\n    }
782	public Set<CellPosition> getPosition(int rowInd, int colInd) {\n	    Set<CellPosition> positions = EnumSet.noneOf(CellPosition.class);\n	    if (rowInd > getFirstRow() && rowInd < getLastRow() && colInd > getFirstColumn() && colInd < getLastColumn()) {\n	        positions.add(CellPosition.INSIDE);\n	        return positions; // entirely inside, matches no boundaries\n	    }\n	    // check edges\n	    if (rowInd == getFirstRow()) positions.add(CellPosition.TOP);\n	    if (rowInd == getLastRow()) positions.add(CellPosition.BOTTOM);\n	    if (colInd == getFirstColumn()) positions.add(CellPosition.LEFT);\n	    if (colInd == getLastColumn()) positions.add(CellPosition.RIGHT);\n	    \n	    return positions;\n	}
783	public static String getBlipType(byte b) {\n        switch (b) {\n            case BT_ERROR:   return " ERROR";\n            case BT_UNKNOWN: return " UNKNOWN";\n            case BT_EMF:     return " EMF";\n            case BT_WMF:     return " WMF";\n            case BT_PICT:    return " PICT";\n            case BT_JPEG:    return " JPEG";\n            case BT_PNG:     return " PNG";\n            case BT_DIB:     return " DIB";\n        }\n        if ( b < 32 ) {\n            return " NotKnown";\n        }\n        return " Client";\n    }
784	protected int calculateNonWeekendHolidays(double start, double end, double[] holidays) {\n        int nonWeekendHolidays = 0;\n        double startDay = start < end ? start : end;\n        double endDay = end > start ? end : start;\n        for (double holiday : holidays) {\n            if (isInARange(startDay, endDay, holiday)) {\n                if (!isWeekend(holiday)) {\n                    nonWeekendHolidays++;\n                }\n            }\n        }\n        return start <= end ? nonWeekendHolidays : -nonWeekendHolidays;\n    }
785	public HashAlgorithm getTspDigestAlgo() {\n        return nvl(tspDigestAlgo,digestAlgo);\n    }
786	public void remove( Object record ) {\n	   // can't use List.indexOf here because it checks the records for equality and not identity\n	   int i = 0;\n	   for (Record r : records) {\n	       if (r == record) {\n	           remove(i);\n	           break;\n	       }\n	       i++;\n	   }\n	}
787	public void removeRow(RowRecord row) {\n        _rowsAggregate.removeRow(row);\n    }
788	private static int[] computeFailure(byte[] pattern) {\n        int[] failure = new int[pattern.length];\n\n        int j = 0;\n        for (int i = 1; i < pattern.length; i++) {\n            while (j > 0 && pattern[j] != pattern[i]) {\n                j = failure[j - 1];\n            }\n            if (pattern[j] == pattern[i]) {\n                j++;\n            }\n            failure[i] = j;\n        }\n\n        return failure;\n    }
789	@Beta\n    protected void createSourceReferences(CellReference position, Sheet sourceSheet, PivotTableReferenceConfigurator refConfig){\n        \n        //Get cell one to the right and one down from position, add both to AreaReference and set pivot table location.\n        AreaReference destination = new AreaReference(position, new CellReference(\n                position.getRow()+1, position.getCol()+1), SpreadsheetVersion.EXCEL2007);\n\n        CTLocation location;\n        if(pivotTableDefinition.getLocation() == null) {\n            location = pivotTableDefinition.addNewLocation();\n            location.setFirstDataCol(1);\n            location.setFirstDataRow(1);\n            location.setFirstHeaderRow(1);\n        } else {\n            location = pivotTableDefinition.getLocation();\n        }\n        location.setRef(destination.formatAsString());\n        pivotTableDefinition.setLocation(location);\n\n        //Set source for the pivot table\n        CTPivotCacheDefinition cacheDef = getPivotCacheDefinition().getCTPivotCacheDefinition();\n        CTCacheSource cacheSource = cacheDef.addNewCacheSource();\n        cacheSource.setType(STSourceType.WORKSHEET);\n        CTWorksheetSource worksheetSource = cacheSource.addNewWorksheetSource();\n        worksheetSource.setSheet(sourceSheet.getSheetName());\n        setDataSheet(sourceSheet);\n\n        refConfig.configureReference(worksheetSource);\n        if (worksheetSource.getName() == null && worksheetSource.getRef() == null) throw new IllegalArgumentException("Pivot table source area reference or name must be specified.");\n    }
790	public void setAllBorders(Object... args) {\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = { BorderEdge.top, BorderEdge.left, null, null };\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[2] = (col == cols - 1) ? BorderEdge.right : null;\n                edges[3] = (row == rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
791	private short applyUserCellStyle(HSSFCellStyle style){\n        if(style.getUserStyleName() == null) {\n            throw new IllegalArgumentException("Expected user-defined style");\n        }\n\n        InternalWorkbook iwb = _book.getWorkbook();\n        short userXf = -1;\n        int numfmt = iwb.getNumExFormats();\n        for(short i = 0; i < numfmt; i++){\n            ExtendedFormatRecord xf = iwb.getExFormatAt(i);\n            if(xf.getXFType() == ExtendedFormatRecord.XF_CELL && xf.getParentIndex() == style.getIndex() ){\n                userXf = i;\n                break;\n            }\n        }\n        short styleIndex;\n        if (userXf == -1){\n            ExtendedFormatRecord xfr = iwb.createCellXF();\n            xfr.cloneStyleFrom(iwb.getExFormatAt(style.getIndex()));\n            xfr.setIndentionOptions((short)0);\n            xfr.setXFType(ExtendedFormatRecord.XF_CELL);\n            xfr.setParentIndex(style.getIndex());\n            styleIndex = (short)numfmt;\n        } else {\n            styleIndex = userXf;\n        }\n\n        return styleIndex;\n    }
792	public void updateSheet() {\n		if (cachedFontInfo != null) {\n		    for (FontGroup tt : FontGroup.values()) {\n		        setFontInfo(cachedFontInfo[tt.ordinal()], tt);\n		    }\n		    cachedFontInfo = null;\n		}\n	}
793	public XWPFTable createTable(int rows, int cols) {\n        XWPFTable table = new XWPFTable(headerFooter.addNewTbl(), this, rows, cols);\n        tables.add(table);\n        bodyElements.add(table);\n        return table;\n    }
794	public int getPriority() {\n        CFRule12Record rule12 = getCFRule12Record(false);\n        if (rule12 == null) return 0;\n        return rule12.getPriority();\n    }
795	private static boolean fullfillsConditions(AreaEval db, int row, AreaEval cdb)\n            throws EvaluationException {\n        // Only one row must match to accept the input, so rows are ORed.\n        // Each row is made up of cells where each cell is a condition,\n        // all have to match, so they are ANDed.\n        final int height = cdb.getHeight();\n        for(int conditionRow = 1; conditionRow < height; ++conditionRow) {\n            boolean matches = true;\n            final int width = cdb.getWidth();\n            for(int column = 0; column < width; ++column) { // columns are ANDed\n                // Whether the condition column matches a database column, if not it's a\n                // special column that accepts formulas.\n                boolean columnCondition = true;\n                ValueEval condition;\n                \n                // The condition to apply.\n                condition = resolveReference(cdb, conditionRow, column);\n                \n                // If the condition is empty it matches.\n                if(condition instanceof BlankEval)\n                    continue;\n                // The column in the DB to apply the condition to.\n                ValueEval targetHeader = resolveReference(cdb, 0, column);\n\n                if(!(targetHeader instanceof StringValueEval)) {\n                    throw new EvaluationException(ErrorEval.VALUE_INVALID);\n                }\n                \n                if (getColumnForName(targetHeader, db) == -1)\n                    // No column found, it's again a special column that accepts formulas.\n                    columnCondition = false;\n\n                if(columnCondition) { // normal column condition\n                    // Should not throw, checked above.\n                    ValueEval value = resolveReference(db, row, getColumnForName(targetHeader, db));\n                    if(!testNormalCondition(value, condition)) {\n                        matches = false;\n                        break;\n                    }\n                } else { // It's a special formula condition.\n                    // TODO: Check whether the condition cell contains a formula and return #VALUE! if it doesn't.\n                    if(OperandResolver.coerceValueToString(condition).isEmpty()) {\n                        throw new EvaluationException(ErrorEval.VALUE_INVALID);\n                    }\n                    throw new NotImplementedException(\n                            "D* function with formula conditions");\n                }\n            }\n            if (matches) {\n                return true;\n            }\n        }\n        return false;\n    }
796	public static void setByteArrayMaxOverride(int maxOverride) {\n        BYTE_ARRAY_MAX_OVERRIDE = maxOverride;\n    }
797	@Internal\n    public boolean isFWarichu()\n    {\n        return fWarichu.isSet(field_29_ufel);\n    }
798	public static PackagePartName createPartName(URI partUri)\n			throws InvalidFormatException {\n		if (partUri == null)\n			throw new IllegalArgumentException("partName");\n\n		return new PackagePartName(partUri, true);\n	}
799	private static int compareSubnormalNumbers(long fracA, long fracB, boolean isNegative) {\n		if(isNegative) {\n			return Long.compare(fracB, fracA);\n		} else {\n			return Long.compare(fracA, fracB);\n		}\n	}
800	private void transformNode(ParseNode node, byte desiredOperandClass,\n			boolean callerForceArrayFlag) {\n		Ptg token = node.getToken();\n		ParseNode[] children = node.getChildren();\n		boolean isSimpleValueFunc = isSimpleValueFunction(token);\n\n		if (isSimpleValueFunc) {\n			boolean localForceArray = desiredOperandClass == Ptg.CLASS_ARRAY;\n			for (int i = 0; i < children.length; i++) {\n				transformNode(children[i], desiredOperandClass, localForceArray);\n			}\n			setSimpleValueFuncClass((AbstractFunctionPtg) token, desiredOperandClass, callerForceArrayFlag);\n			return;\n		}\n\n		if (isSingleArgSum(token)) {\n			// Need to process the argument of SUM with transformFunctionNode below\n			// so make a dummy FuncVarPtg for that call.\n			token = FuncVarPtg.SUM;\n			// Note - the tAttrSum token (node.getToken()) is a base\n			// token so does not need to have its operand class set\n		}\n		if (token instanceof ValueOperatorPtg || token instanceof ControlPtg\n				|| token instanceof MemFuncPtg\n				|| token instanceof MemAreaPtg\n				|| token instanceof UnionPtg\n				|| token instanceof IntersectionPtg) {\n			// Value Operator Ptgs and Control are base tokens, so token will be unchanged\n			// but any child nodes are processed according to desiredOperandClass and callerForceArrayFlag\n\n			// As per OOO documentation Sec 3.2.4 "Token Class Transformation", "Step 1"\n			// All direct operands of value operators that are initially 'R' type will\n			// be converted to 'V' type.\n			byte localDesiredOperandClass = desiredOperandClass == Ptg.CLASS_REF ? Ptg.CLASS_VALUE : desiredOperandClass;\n			for (int i = 0; i < children.length; i++) {\n				transformNode(children[i], localDesiredOperandClass, callerForceArrayFlag);\n			}\n			return;\n		}\n		if (token instanceof AbstractFunctionPtg) {\n			transformFunctionNode((AbstractFunctionPtg) token, children, desiredOperandClass, callerForceArrayFlag);\n			return;\n		}\n		if (children.length > 0) {\n			if (token == RangePtg.instance) {\n				// TODO is any token transformation required under the various ref operators?\n				return;\n			}\n			throw new IllegalStateException("Node should not have any children");\n		}\n\n		if (token.isBaseToken()) {\n			// nothing to do\n			return;\n		}\n		token.setClass(transformClass(token.getPtgClass(), desiredOperandClass, callerForceArrayFlag));\n	}
801	public void dumpDrawingRecords(boolean fat, PrintWriter pw) {\n        _sheet.aggregateDrawingRecords(_book.getDrawingManager(), false);\n\n        EscherAggregate r = (EscherAggregate) getSheet().findFirstRecordBySid(EscherAggregate.sid);\n        List<EscherRecord> escherRecords = r.getEscherRecords();\n        for (EscherRecord escherRecord : escherRecords) {\n            if (fat) {\n                pw.println(escherRecord);\n            } else {\n                escherRecord.display(pw, 0);\n            }\n        }\n        pw.flush();\n    }
802	private int readChunk() throws IOException {\n        pos = 0;\n        int w = readShort(in);\n        if (w == -1 || w == 0) {\n            return -1;\n        }\n        int chunkSize = (w & 0x0FFF) + 1; // plus 3 bytes minus 2 for the length\n        if ((w & 0x7000) != 0x3000) {\n            throw new IllegalArgumentException(String.format(Locale.ROOT, "Chunksize header A should be 0x3000, received 0x%04X", w & 0xE000));\n        }\n        boolean rawChunk = (w & 0x8000) == 0;\n        if (rawChunk) {\n            if (in.read(buf, 0, chunkSize) < chunkSize) {\n                throw new IllegalStateException(String.format(Locale.ROOT, "Not enough bytes read, expected %d", chunkSize));\n            }\n            return chunkSize;\n        } else {\n            int inOffset = 0;\n            int outOffset = 0;\n            while (inOffset < chunkSize) {\n                int tokenFlags = in.read();\n                inOffset++;\n                if (tokenFlags == -1) {\n                    break;\n                }\n                for (int n = 0; n < 8; n++) {\n                    if (inOffset >= chunkSize) {\n                        break;\n                    }\n                    if ((tokenFlags & POWER2[n]) == 0) {\n                        // literal\n                        final int b = in.read();\n                        if (b == -1) {\n                            return -1;\n                        }\n                        buf[outOffset++] = (byte) b;\n                        inOffset++;\n                    } else {\n                        // compressed token\n                        int token = readShort(in);\n                        if (token == -1) {\n                            return -1;\n                        }\n                        inOffset += 2;\n                        int copyLenBits = getCopyLenBits(outOffset - 1);\n                        int copyOffset = (token >> (copyLenBits)) + 1;\n                        int copyLen = (token & (POWER2[copyLenBits] - 1)) + 3;\n                        int startPos = outOffset - copyOffset;\n                        int endPos = startPos + copyLen;\n                        for (int i = startPos; i < endPos; i++) {\n                            buf[outOffset++] = buf[i];\n                        }\n                    }\n                }\n            }\n            return outOffset;\n        }\n    }
803	protected void onDeleteFormula(XSSFCell cell){\n        if(calcChain != null) {\n            int sheetId = (int)cell.getSheet().sheet.getSheetId();\n            calcChain.removeItem(sheetId, cell.getReference());\n        }\n    }
804	protected void matchVariableSizedPropertiesToChunks() {\n        // Index the Parent Group chunks for easy lookup\n        // TODO Is this the right way?\n        Map<Integer, Chunk> chunks = new HashMap<>();\n        for (Chunk chunk : parentGroup.getChunks()) {\n            chunks.put(chunk.getChunkId(), chunk);\n        }\n\n        // Loop over our values, looking for chunk based ones\n        for (PropertyValue val : properties.values()) {\n            if (val instanceof ChunkBasedPropertyValue) {\n                ChunkBasedPropertyValue cVal = (ChunkBasedPropertyValue) val;\n                Chunk chunk = chunks.get(cVal.getProperty().id);\n                // System.err.println(cVal.getProperty() + " = " + cVal + " -> "\n                // + HexDump.toHex(cVal.data));\n\n                // TODO Make sense of the raw offset value\n\n                if (chunk != null) {\n                    cVal.setValue(chunk);\n                } else {\n                    logger.log(POILogger.WARN, "No chunk found matching Property " + cVal);\n                }\n            }\n        }\n    }
805	public DocumentInputStream createDocumentInputStream(\n            final String documentName) throws IOException {\n    	return getRoot().createDocumentInputStream(documentName);\n    }
806	public static POITextExtractor createExtractor(OPCPackage pkg) throws IOException, OpenXML4JException, XmlException {\n        try {\n            // Check for the normal Office core document\n            PackageRelationshipCollection core;\n            core = pkg.getRelationshipsByType(CORE_DOCUMENT_REL);\n              \n            // If nothing was found, try some of the other OOXML-based core types\n            if (core.size() == 0) {\n                // Could it be an OOXML-Strict one?\n                core = pkg.getRelationshipsByType(STRICT_DOCUMENT_REL);\n            }\n            if (core.size() == 0) {\n                // Could it be a visio one?\n                core = pkg.getRelationshipsByType(VISIO_DOCUMENT_REL);\n                if (core.size() == 1)\n                    return new XDGFVisioExtractor(pkg);\n            }\n              \n            // Should just be a single core document, complain if not\n            if (core.size() != 1) {\n                throw new IllegalArgumentException("Invalid OOXML Package received - expected 1 core document, found " + core.size());\n            }\n     \n            // Grab the core document part, and try to identify from that\n            final PackagePart corePart = pkg.getPart(core.getRelationship(0));\n            final String contentType = corePart.getContentType();\n     \n            // Is it XSSF?\n            for (XSSFRelation rel : XSSFExcelExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    if (getPreferEventExtractor()) {\n                        return new XSSFEventBasedExcelExtractor(pkg);\n                    }\n                    return new XSSFExcelExtractor(pkg);\n                }\n            }\n     \n            // Is it XWPF?\n            for (XWPFRelation rel : XWPFWordExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    return new XWPFWordExtractor(pkg);\n                }\n            }\n     \n            // Is it XSLF?\n            for (XSLFRelation rel : XSLFPowerPointExtractor.SUPPORTED_TYPES) {\n                if ( rel.getContentType().equals( contentType ) ) {\n                    return new SlideShowExtractor<>(new XMLSlideShow(pkg));\n                }\n            }\n     \n            // special handling for SlideShow-Theme-files, \n            if (XSLFRelation.THEME_MANAGER.getContentType().equals(contentType)) {\n                return new SlideShowExtractor<>(new XMLSlideShow(pkg));\n            }\n\n            // How about xlsb?\n            for (XSSFRelation rel : XSSFBEventBasedExcelExtractor.SUPPORTED_TYPES) {\n                if (rel.getContentType().equals(contentType)) {\n                    return new XSSFBEventBasedExcelExtractor(pkg);\n                }\n            }\n\n            throw new IllegalArgumentException("No supported documents found in the OOXML package (found "+contentType+")");\n\n        } catch (IOException | Error | RuntimeException | XmlException | OpenXML4JException e) { // NOSONAR\n            // ensure that we close the package again if there is an error opening it, however\n            // we need to revert the package to not re-write the file via close(), which is very likely not wanted for a TextExtractor!\n            pkg.revert();\n            throw e;\n        }\n    }
807	@Beta\n    public AreaReference getPivotArea(Workbook wb) throws IllegalArgumentException {\n        final CTWorksheetSource wsSource = ctPivotCacheDefinition.getCacheSource().getWorksheetSource();\n        \n        final String ref = wsSource.getRef();\n        final String name = wsSource.getName();\n        \n        if (ref == null && name == null) {\n            throw new IllegalArgumentException("Pivot cache must reference an area, named range, or table.");\n        }\n        \n        // this is the XML format, so tell the reference that.\n        if (ref != null) {\n            return new AreaReference(ref, SpreadsheetVersion.EXCEL2007);\n        }\n        \n        assert (name != null);\n        \n        // named range or table?\n        final Name range = wb.getName(name);\n        if (range != null) {\n            return new AreaReference(range.getRefersToFormula(), SpreadsheetVersion.EXCEL2007);\n        }\n        \n        // not a named range, check for a table.\n        // do this second, as tables are sheet-specific, but named ranges are not, and may not have a sheet name given.\n        final XSSFSheet sheet = (XSSFSheet) wb.getSheet(wsSource.getSheet());\n        for (XSSFTable table : sheet.getTables()) {\n            // TODO: case-sensitive?\n            if (name.equals(table.getName())) {\n                return new AreaReference(table.getStartCellReference(), table.getEndCellReference(),\n                        SpreadsheetVersion.EXCEL2007);\n            }\n        }\n        \n        throw new IllegalArgumentException("Name '" + name + "' was not found.");\n    }
808	public static double irr(double[] income) {\n        return irr(income, 0.1d);\n    }
809	/* package */ static Color getAWTColor(int index, Color deflt) {\n    HSSFColor clr = colors.get(index);\n    if (clr == null) {\n      return deflt;\n    }\n    short[] rgb = clr.getTriplet();\n    return new Color(rgb[0],rgb[1],rgb[2]);\n  }
810	public void setCharacterStyles(List<TextPropCollection> cs) { charStyles = cs; }
811	@Internal\n    public boolean isFOwnHelp()\n    {\n        return fOwnHelp.isSet(field_2_bits);\n    }
812	public Chunk createChunk(byte[] data, int offset) {\n		// Create the header\n		ChunkHeader header =\n			ChunkHeader.createChunkHeader(version, data, offset);\n		// Sanity check\n		if(header.getLength() < 0) {\n			throw new IllegalArgumentException("Found a chunk with a negative length, which isn't allowed");\n		}\n\n		// How far up to look\n		int endOfDataPos = offset + header.getLength() + header.getSizeInBytes();\n\n		// Check we have enough data, and tweak the header size\n		//  as required\n		if(endOfDataPos > data.length) {\n			logger.log(POILogger.WARN,\n				"Header called for " + header.getLength() +" bytes, but that would take us past the end of the data!");\n\n			endOfDataPos = data.length;\n			header.setLength(data.length - offset - header.getSizeInBytes());\n\n			if(header.hasTrailer()) {\n				header.setLength(header.getLength() - 8);\n				endOfDataPos  -= 8;\n			}\n			if(header.hasSeparator()) {\n                header.setLength(header.getLength() - 4);\n				endOfDataPos  -= 4;\n			}\n		}\n\n\n		// Create the trailer and separator, if required\n		ChunkTrailer trailer = null;\n		ChunkSeparator separator = null;\n		if(header.hasTrailer()) {\n			if(endOfDataPos <= data.length-8) {\n				trailer = new ChunkTrailer(\n					data, endOfDataPos);\n				endOfDataPos += 8;\n			} else {\n				logger.log(POILogger.ERROR, "Header claims a length to " + endOfDataPos + " there's then no space for the trailer in the data (" + data.length + ")");\n			}\n		}\n		if(header.hasSeparator()) {\n			if(endOfDataPos <= data.length-4) {\n				separator = new ChunkSeparator(\n						data, endOfDataPos);\n			} else {\n				logger.log(POILogger.ERROR, "Header claims a length to " + endOfDataPos + " there's then no space for the separator in the data (" + data.length + ")");\n			}\n		}\n\n		// Now, create the chunk\n		byte[] contents = IOUtils.safelyAllocate(header.getLength(), MAX_RECORD_LENGTH);\n		System.arraycopy(data, offset+header.getSizeInBytes(), contents, 0, contents.length);\n		Chunk chunk = new Chunk(header, trailer, separator, contents);\n\n		// Feed in the stuff from  chunks_parse_cmds.tbl\n		CommandDefinition[] defs = chunkCommandDefinitions.get(Integer.valueOf(header.getType()));\n		if (defs == null) {\n		    defs = new CommandDefinition[0];\n		}\n		chunk.commandDefinitions = defs;\n\n		// Now get the chunk to process its commands\n		chunk.processCommands();\n\n		// All done\n		return chunk;\n	}
813	public boolean isInvert()\n    {\n        return invert.isSet(field_4_formatFlags);\n    }
814	public void setVBAProject(InputStream vbaProjectStream) throws IOException {\n        if (!isMacroEnabled()) {\n            setWorkbookType(XSSFWorkbookType.XLSM);\n        }\n\n        PackagePartName ppName;\n        try {\n            ppName = PackagingURIHelper.createPartName(XSSFRelation.VBA_MACROS.getDefaultFileName());\n        } catch (InvalidFormatException e) {\n            throw new POIXMLException(e);\n        }\n        OPCPackage opc = getPackage();\n        OutputStream outputStream;\n        if (!opc.containPart(ppName)) {\n            POIXMLDocumentPart relationship = createRelationship(XSSFRelation.VBA_MACROS, this.xssfFactory);\n            outputStream = relationship.getPackagePart().getOutputStream();\n        } else {\n            PackagePart part = opc.getPart(ppName);\n            outputStream = part.getOutputStream();\n        }\n        try {\n            IOUtils.copy(vbaProjectStream, outputStream);\n        } finally {\n            IOUtils.closeQuietly(outputStream);\n        }\n    }
815	@SuppressWarnings("resource")\n    public static ZipArchiveThresholdInputStream openZipStream(InputStream stream) throws IOException {\n        // Peek at the first few bytes to sanity check\n        InputStream checkedStream = FileMagic.prepareToCheckMagic(stream);\n        verifyZipHeader(checkedStream);\n        \n        // Open as a proper zip stream\n        return new ZipArchiveThresholdInputStream(new ZipArchiveInputStream(checkedStream));\n    }
816	@Internal\n    public byte getFtsWidthBefore()\n    {\n        return ( byte )ftsWidthBefore.getValue(field_13_widthAndFitsFlags);\n    }
817	public void setParagraph(XWPFParagraph paragraph, int pos) {\n        paragraphs.set(pos, paragraph);\n        ctDocument.getBody().setPArray(pos, paragraph.getCTP());\n        /* TODO update body element, update xwpf element, verify that\n         * incoming paragraph belongs to this document or if not, XML was\n         * copied properly (namespace-abbreviations, etc.)\n         */\n    }
818	public void setInsideBorders(Object... args) {\n        if (args.length == 0) return;\n\n        TableShape<?,?> table = getShape();\n        final int rows = table.getNumberOfRows();\n        final int cols = table.getNumberOfColumns();\n\n        BorderEdge edges[] = new BorderEdge[2];\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                edges[0] = (col > 0 && col < cols - 1) ? BorderEdge.right : null;\n                edges[1] = (row > 0 && row < rows - 1) ? BorderEdge.bottom : null;\n                setEdges(table.getCell(row, col), edges, args);\n            }\n        }\n    }
819	@Internal\n    public boolean isFNoProof()\n    {\n        return fNoProof.isSet(field_1_grpfChp);\n    }
820	public void draw(Graphics2D graphics) {\n\n        String textContent = getTextContent();\n        if (textContent.length() == 0)\n            return;\n\n        Rectangle2D.Double bounds = getTextBounds();\n\n        String[] lines = textContent.trim().split("\n");\n        FontRenderContext frc = graphics.getFontRenderContext();\n        Font font = graphics.getFont();\n\n        AffineTransform oldTr = graphics.getTransform();\n\n        // visio is in flipped coordinates, so translate the text to be in the\n        // right place\n        Boolean flipX = _parent.getFlipX();\n        Boolean flipY = _parent.getFlipY();\n\n        if (flipY == null || !_parent.getFlipY()) {\n            graphics.translate(bounds.x, bounds.y);\n            graphics.scale(1, -1);\n            graphics.translate(0, -bounds.height\n                    + graphics.getFontMetrics().getMaxCharBounds(graphics)\n                    .getHeight());\n        }\n\n        if (flipX != null && _parent.getFlipX()) {\n            graphics.scale(-1, 1);\n            graphics.translate(-bounds.width, 0);\n        }\n\n        Double txtAngle = _parent.getTxtAngle();\n        if (txtAngle != null && Math.abs(txtAngle) > 0.01)\n            graphics.rotate(txtAngle);\n\n        float nextY = 0;\n        for (String line : lines) {\n\n            if (line.length() == 0)\n                continue;\n\n            TextLayout layout = new TextLayout(line, font, frc);\n\n            if (layout.isLeftToRight())\n                layout.draw(graphics, 0, nextY);\n            else\n                layout.draw(graphics,\n                        (float) (bounds.width - layout.getAdvance()), nextY);\n\n            nextY += layout.getAscent() + layout.getDescent()\n                    + layout.getLeading();\n        }\n\n        graphics.setTransform(oldTr);\n    }
821	public static ZipArchiveEntry getCorePropertiesZipEntry(ZipPackage pkg) {\n        PackageRelationship corePropsRel = pkg.getRelationshipsByType(\n                PackageRelationshipTypes.CORE_PROPERTIES).getRelationship(0);\n\n        if (corePropsRel == null) {\n            return null;\n        }\n\n        return new ZipArchiveEntry(corePropsRel.getTargetURI().getPath());\n    }
822	public InputStream openResourceAsStream(String sampleFileName) {\n\n        if (_sampleDataIsAvaliableOnClassPath) {\n            InputStream result = sampleFileName == null ? null :\n                    openClasspathResource(sampleFileName);\n            if(result == null) {\n                throw new RuntimeException("specified test sample file '" + sampleFileName\n                        + "' not found on the classpath");\n            }\n            // wrap to avoid temp warning method about auto-closing input stream\n            return new NonSeekableInputStream(result);\n        }\n        if (_resolvedDataDir == null) {\n            throw new RuntimeException("Must set system property '"\n                    + TEST_PROPERTY\n                    + "' properly before running tests");\n        }\n\n        File f = getFile(sampleFileName);\n        try {\n            return new FileInputStream(f);\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }
823	@Internal\n    public boolean isFOwnStat()\n    {\n        return fOwnStat.isSet(field_2_bits);\n    }
824	public int compareNormalised(NormalisedDecimal other) {\n		int cmp = _relativeDecimalExponent - other._relativeDecimalExponent;\n		if (cmp != 0) {\n			return cmp;\n		}\n		if (_wholePart > other._wholePart) {\n			return 1;\n		}\n		if (_wholePart < other._wholePart) {\n			return -1;\n		}\n		return _fractionalPart - other._fractionalPart;\n	}
825	protected int getMaxNumOperands() {\n		return DEFAULT_MAX_NUM_OPERANDS;\n	}
826	protected static String parseAs7BitData(byte[] data) {\n        return parseAs7BitData(data, DEFAULT_ENCODING);\n    }
827	static void inList(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Codes");\n        sheet.createRow(1).createCell(0).setCellValue("AA");\n        sheet.createRow(2).createCell(0).setCellValue("BB");\n        sheet.createRow(3).createCell(0).setCellValue("GG");\n        sheet.createRow(4).createCell(0).setCellValue("AA");\n        sheet.createRow(5).createCell(0).setCellValue("FF");\n        sheet.createRow(6).createCell(0).setCellValue("XX");\n        sheet.createRow(7).createCell(0).setCellValue("CC");\n\n        sheet.getRow(0).createCell(2).setCellValue("Valid");\n        sheet.getRow(1).createCell(2).setCellValue("AA");\n        sheet.getRow(2).createCell(2).setCellValue("BB");\n        sheet.getRow(3).createCell(2).setCellValue("CC");\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =A2=A1   (White Font)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("COUNTIF($C$2:$C$4,A2)");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.LIGHT_BLUE.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A8")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(3).setCellValue("<== Use Excel conditional formatting to highlight items that are in a list on the worksheet");\n    }
828	public SignatureDocument getSignatureDocument() throws IOException, XmlException {\n        // TODO: check for XXE\n        return SignatureDocument.Factory.parse(signaturePart.getInputStream(), DEFAULT_XML_OPTIONS);\n    }
829	public long registerTo(StylesTable styles) {\n        this._themes = styles.getTheme();\n        this._index = styles.putFont(this, true);\n        return this._index;\n    }
830	public ExcelNumberFormat getNumberFormat() {\n        return null;\n    }
831	public void setSlideNumber(int newSlideNumber) {\n		_slideNo = newSlideNumber;\n	}
832	public void addBreak() {\n        run.addNewBr();\n    }
833	private void updateNamedRangesAfterSheetReorder(int oldIndex, int newIndex) {\n        // update sheet index of sheet-scoped named ranges\n        for (final HSSFName name : names) {\n            final int i = name.getSheetIndex();\n            // name has sheet-level scope\n            if (i != -1) {\n                // name refers to this sheet\n                if (i == oldIndex) {\n                    name.setSheetIndex(newIndex);\n                }\n                // if oldIndex > newIndex then this sheet moved left and sheets between newIndex and oldIndex moved right\n                else if (newIndex <= i && i < oldIndex) {\n                    name.setSheetIndex(i+1);\n                }\n                // if oldIndex < newIndex then this sheet moved right and sheets between oldIndex and newIndex moved left\n                else if (oldIndex < i && i <= newIndex) {\n                    name.setSheetIndex(i-1);\n                }\n            }\n        }\n    }
834	public XWPFFootnotes createFootnotes() {\n        if (footnotes == null) {\n            FootnotesDocument footnotesDoc = FootnotesDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.FOOTNOTE;\n            int i = getRelationIndex(relation);\n\n            XWPFFootnotes wrapper = (XWPFFootnotes) createRelationship(relation, XWPFFactory.getInstance(), i);\n            wrapper.setFootnotes(footnotesDoc.addNewFootnotes());\n            wrapper.setIdManager(this.footnoteIdManager);\n            footnotes = wrapper;\n        }\n\n        return footnotes;\n    }
835	public void setParsedExpression(Ptg[] ptgs) {\n		notifyFormulaChanging();\n		_formulaRecord.setParsedExpression(ptgs);\n	}
836	private static I_MatchPredicate createGeneralMatchPredicate(StringEval stringEval) {\n        String value = stringEval.getStringValue();\n        CmpOp operator = CmpOp.getOperator(value);\n        value = value.substring(operator.getLength());\n\n        Boolean booleanVal = parseBoolean(value);\n        if(booleanVal != null) {\n            return new BooleanMatcher(booleanVal.booleanValue(), operator);\n        }\n\n        Double doubleVal = OperandResolver.parseDouble(value);\n        if(doubleVal != null) {\n            return new NumberMatcher(doubleVal.doubleValue(), operator);\n        }\n        ErrorEval ee = parseError(value);\n        if (ee != null) {\n            return new ErrorMatcher(ee.getErrorCode(), operator);\n        }\n\n        //else - just a plain string with no interpretation.\n        return new StringMatcher(value, operator);\n    }
837	public String getText() {\n        try {\n            WordToTextConverter wordToTextConverter = new WordToTextConverter();\n\n            HeaderStories hs = new HeaderStories(doc);\n\n            if (hs.getFirstHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getFirstHeaderSubrange());\n            if (hs.getEvenHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getEvenHeaderSubrange());\n            if (hs.getOddHeaderSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getOddHeaderSubrange());\n\n            wordToTextConverter.processDocument(doc);\n            wordToTextConverter.processDocumentPart(doc,\n                    doc.getMainTextboxRange());\n\n            if (hs.getFirstFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getFirstFooterSubrange());\n            if (hs.getEvenFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getEvenFooterSubrange());\n            if (hs.getOddFooterSubrange() != null)\n                wordToTextConverter.processDocumentPart(doc,\n                        hs.getOddFooterSubrange());\n\n            return wordToTextConverter.getText();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch ( Exception exc ) {\n            throw new RuntimeException( exc );\n        }\n    }
838	public void setRule(int idx, HSSFConditionalFormattingRule cfRule) {\n        cfAggregate.setRule(idx, cfRule.getCfRuleRecord());\n    }
839	public short getVerticalSplitLeftColumn() {\n	  return leftColumn;\n	}
840	public int getNumPointersOffset(byte[] data) {\n        switch (getType()) {\n            case 0x1d:\n            case 0x4e:\n                return 30;\n            case 0x1e:\n                return 54;\n            case 0x14:\n                return 130;\n        }\n        return 10;\n    }
841	public int getTotalsRowCount() {\n        return (int) ctTable.getTotalsRowCount();\n    }
842	public int getParCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_PARCOUNT);\n    }
843	private static CalcCountRecord createCalcCount() {\n        CalcCountRecord retval = new CalcCountRecord();\n\n        retval.setIterations(( short ) 100);   // default 100 iterations\n        return retval;\n    }
844	public XWPFTable createTable(int rows, int cols) {\n        XWPFTable table = new XWPFTable(ctDocument.getBody().addNewTbl(), this, rows, cols);\n        bodyElements.add(table);\n        tables.add(table);\n        return table;\n    }
845	public void removeValueRecord(int row, CellValueRecordInterface col) {\n\n        log.log(POILogger.DEBUG, "remove value record row "+row);\n        _rowsAggregate.removeCell(col);\n    }
846	private void findEscherChildren(DefaultEscherRecordFactory erf, byte[] source, int startPos, int lenToGo, List<EscherRecord> found) {\n\n		int escherBytes = LittleEndian.getInt( source, startPos + 4 ) + 8;\n\n		// Find the record\n		EscherRecord r = erf.createRecord(source,startPos);\n		// Fill it in\n		r.fillFields( source, startPos, erf );\n		// Save it\n		found.add(r);\n\n		// Wind on\n		int size = r.getRecordSize();\n		if(size < 8) {\n			logger.log(POILogger.WARN, "Hit short DDF record at " + startPos + " - " + size);\n		}\n\n		/**\n		 * Sanity check. Always advance the cursor by the correct value.\n		 *\n		 * getRecordSize() must return exactly the same number of bytes that was written in fillFields.\n		 * Sometimes it is not so, see an example in bug #44770. Most likely reason is that one of ddf records calculates wrong size.\n		 */\n		if(size != escherBytes){\n			logger.log(POILogger.WARN, "Record length=" + escherBytes + " but getRecordSize() returned " + r.getRecordSize() + "; record: " + r.getClass());\n			size = escherBytes;\n		}\n		startPos += size;\n		lenToGo -= size;\n		if(lenToGo >= 8) {\n			findEscherChildren(erf, source, startPos, lenToGo, found);\n		}\n	}
847	public int getCch()\n    {\n        return _cch;\n    }
848	public void setDateToBeFormatted(double date) {\n        this.dateToBeFormatted = date;\n    }
849	/* package */ static HSLFHyperlink createHyperlink(HSLFSimpleShape shape) {\n        // TODO: check if a hyperlink already exists\n        ExHyperlink exHyper = new ExHyperlink();\n        int linkId = shape.getSheet().getSlideShow().addToObjListAtom(exHyper);\n        ExHyperlinkAtom obj = exHyper.getExHyperlinkAtom();\n        obj.setNumber(linkId);\n        InteractiveInfo info = new InteractiveInfo();\n        info.getInteractiveInfoAtom().setHyperlinkID(linkId);\n        HSLFEscherClientDataRecord cldata = shape.getClientData(true);\n        cldata.addChild(info);\n        HSLFHyperlink hyper = new HSLFHyperlink(exHyper, info);\n        hyper.linkToNextSlide();\n        shape.setHyperlink(hyper);\n        return hyper;\n    }
850	default boolean contains(Cell cell) {\n        if (cell == null) return false;\n        return contains(new CellReference(cell.getSheet().getSheetName(), cell.getRowIndex(), cell.getColumnIndex(), true, true));\n    }
851	public Borders getBorderBetween() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getBetween();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
852	private static int dateDiff(long startDateMS, long endDateMS) {\n		long msDiff = endDateMS - startDateMS;\n\n		// some extra checks to make sure we don't hide some other bug with the rounding \n		int remainderHours = (int) ((msDiff % MS_PER_DAY) / MS_PER_HOUR);\n		switch (remainderHours) {\n			case 0:  // normal case\n				break;\n			case 1:  // transition from normal time to daylight savings adjusted\n			case 23: // transition from daylight savings adjusted to normal time\n				// Unexpected since we are using UTC_TIME_ZONE \n			default:\n				throw new RuntimeException("Unexpected date diff between " + startDateMS + " and " + endDateMS);\n\n		}\n		return (int) (0.5 + ((double)msDiff / MS_PER_DAY));\n	}
853	public static void addNewSheetRecord(List<RecordBase> sheetRecords, RecordBase newRecord) {\n		int index = findSheetInsertPos(sheetRecords, newRecord.getClass());\n		sheetRecords.add(index, newRecord);\n	}
854	public XSSFTable createTable(AreaReference tableArea) {\n        if (!worksheet.isSetTableParts()) {\n            worksheet.addNewTableParts();\n        }\n\n        CTTableParts tblParts = worksheet.getTableParts();\n        CTTablePart tbl = tblParts.addNewTablePart();\n\n        // Table numbers need to be unique in the file, not just\n        //  unique within the sheet. Find the next one\n        int tableNumber = getPackagePart().getPackage().getPartsByContentType(XSSFRelation.TABLE.getContentType()).size() + 1;\n\n        // the id could already be taken after insertion/deletion of different tables\n        outerloop:\n        while(true) {\n            for (PackagePart packagePart : getPackagePart().getPackage().getPartsByContentType(XSSFRelation.TABLE.getContentType())) {\n                String fileName = XSSFRelation.TABLE.getFileName(tableNumber);\n                if(fileName.equals(packagePart.getPartName().getName())) {\n                    // duplicate found, increase the number and start iterating again\n                    tableNumber++;\n                    continue outerloop;\n                }\n            }\n\n            break;\n        }\n\n        RelationPart rp = createRelationship(XSSFRelation.TABLE, XSSFFactory.getInstance(), tableNumber, false);\n        XSSFTable table = rp.getDocumentPart();\n        tbl.setId(rp.getRelationship().getId());\n        table.getCTTable().setId(tableNumber);\n\n        tables.put(tbl.getId(), table);\n\n        if(tableArea != null) {\n            table.setArea(tableArea);\n        }\n\n        return table;\n    }
855	public void clearHeaderFooter() {\n       XmlCursor c = headerFooter.newCursor();\n       c.removeXmlContents();\n       c.dispose();\n       paragraphs.clear();\n       tables.clear();\n       bodyElements.clear();\n    }
856	private int addNewAuthor(String author) {\n        int index = comments.getAuthors().sizeOfAuthorArray();\n        comments.getAuthors().insertAuthor(index, author);\n        return index;\n    }
857	private void isCellUnderLineMatches(Locator loc1, Locator loc2) {\n        // TOOO: distinguish underline type\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        byte b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getUnderline();\n        byte b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getUnderline();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 == 1 ? "" : "NOT ")+"UNDERLINE",\n                (b2 == 1 ? "" : "NOT ")+"UNDERLINE"\n            );\n        }\n    }
858	public static InternalSheet createSheet(RecordStream rs) {\n        return new InternalSheet(rs);\n    }
859	public static void optimiseFonts(HSSFWorkbook workbook) {\n		// Where each font has ended up, and if we need to\n		//  delete the record for it. Start off with no change\n		short[] newPos = \n			new short[workbook.getWorkbook().getNumberOfFontRecords()+1];\n		boolean[] zapRecords = new boolean[newPos.length];\n		for(int i=0; i<newPos.length; i++) {\n			newPos[i] = (short)i;\n			zapRecords[i] = false;\n		}\n		\n		// Get each font record, so we can do deletes\n		//  without getting confused\n		FontRecord[] frecs = new FontRecord[newPos.length]; \n		for(int i=0; i<newPos.length; i++) {\n			// There is no 4!\n			if(i == 4) continue;\n			\n			frecs[i] = workbook.getWorkbook().getFontRecordAt(i);\n		}\n		\n		// Loop over each font, seeing if it is the same\n		//  as an earlier one. If it is, point users of the\n		//  later duplicate copy to the earlier one, and \n		//  mark the later one as needing deleting\n		// Note - don't change built in fonts (those before 5)\n		for(int i=5; i<newPos.length; i++) {\n			// Check this one for being a duplicate\n			//  of an earlier one\n			int earlierDuplicate = -1;\n			for(int j=0; j<i && earlierDuplicate == -1; j++) {\n				if(j == 4) continue;\n				\n				FontRecord frCheck = workbook.getWorkbook().getFontRecordAt(j);\n				if(frCheck.sameProperties(frecs[i])) {\n					earlierDuplicate = j;\n				}\n			}\n			\n			// If we got a duplicate, mark it as such\n			if(earlierDuplicate != -1) {\n				newPos[i] = (short)earlierDuplicate;\n				zapRecords[i] = true;\n			}\n		}\n		\n		// Update the new positions based on\n		//  deletes that have occurred between\n		//  the start and them\n		// Only need to worry about user fonts\n		for(int i=5; i<newPos.length; i++) {\n			// Find the number deleted to that\n			//  point, and adjust\n			short preDeletePos = newPos[i];\n			short newPosition = preDeletePos;\n			for(int j=0; j<preDeletePos; j++) {\n				if(zapRecords[j]) newPosition--;\n			}\n			\n			// Update the new position\n			newPos[i] = newPosition;\n		}\n		\n		// Zap the un-needed user font records\n		for(int i=5; i<newPos.length; i++) {\n			if(zapRecords[i]) {\n				workbook.getWorkbook().removeFontRecord(\n						frecs[i]\n				);\n			}\n		}\n		\n		// Tell HSSFWorkbook that it needs to\n		//  re-start its HSSFFontCache\n		workbook.resetFontCache();\n		\n		// Update the cell styles to point at the \n		//  new locations of the fonts\n		for(int i=0; i<workbook.getWorkbook().getNumExFormats(); i++) {\n			ExtendedFormatRecord xfr = workbook.getWorkbook().getExFormatAt(i);\n			xfr.setFontIndex(\n					newPos[ xfr.getFontIndex() ]\n			);\n		}\n		\n		// Update the rich text strings to point at\n		//  the new locations of the fonts\n		// Remember that one underlying unicode string\n		//  may be shared by multiple RichTextStrings!\n		HashSet<UnicodeString> doneUnicodeStrings = new HashSet<>();\n		for(int sheetNum=0; sheetNum<workbook.getNumberOfSheets(); sheetNum++) {\n			HSSFSheet s = workbook.getSheetAt(sheetNum);\n			for (Row row : s) {\n			   for (Cell cell : row) {\n					if(cell.getCellType() == CellType.STRING) {\n						HSSFRichTextString rtr = (HSSFRichTextString)cell.getRichStringCellValue();\n						UnicodeString u = rtr.getRawUnicodeString();\n						\n						// Have we done this string already?\n						if(! doneUnicodeStrings.contains(u)) {\n							// Update for each new position\n							for(short i=5; i<newPos.length; i++) {\n								if(i != newPos[i]) {\n									u.swapFontUse(i, newPos[i]);\n								}\n							}\n							\n							// Mark as done\n							doneUnicodeStrings.add(u);\n						}\n					}\n				}\n			}\n		}\n	}
860	public String getNotes() {\n		return getText(false, true, false, false);\n	}
861	@Internal\n    public byte getBy()\n    {\n        return ( byte )by.getValue(field_6_flags);\n    }
862	protected byte[] getDocumentEntryBytes(String name, int encryptionOffset, int len) throws IOException {\n        DirectoryNode dir = getDirectory();\n        DocumentEntry documentProps = (DocumentEntry)dir.getEntry(name);\n        DocumentInputStream dis = dir.createDocumentInputStream(documentProps);\n        EncryptionInfo ei = (encryptionOffset > -1) ? getEncryptionInfo() : null;\n        int streamSize = documentProps.getSize();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(Math.min(streamSize,len));\n\n        InputStream is = dis;\n        try {\n            if (ei != null) {\n                try {\n                    Decryptor dec = ei.getDecryptor();\n                    is = dec.getDataStream(dis, streamSize, 0);\n                    if (encryptionOffset > 0) {\n                        ChunkedCipherInputStream cis = (ChunkedCipherInputStream)is;\n                        byte plain[] = IOUtils.safelyAllocate(encryptionOffset, MAX_RECORD_LENGTH);\n                        cis.readPlain(plain, 0, encryptionOffset);\n                        bos.write(plain);\n                    }\n                } catch (GeneralSecurityException e) {\n                    throw new IOException(e.getMessage(), e);\n                }\n            }\n            // This simplifies a few combinations, so we actually always try to copy len bytes\n            // regardless if encryptionOffset is greater than 0\n            if (len < Integer.MAX_VALUE) {\n                is = new BoundedInputStream(is, len);\n            }\n            IOUtils.copy(is, bos);\n            return bos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(dis);\n        }\n    }
863	void buildShapeTree() {\n        EscherContainerRecord dgContainer = _boundAggregate.getEscherContainer();\n        if (dgContainer == null) {\n            return;\n        }\n        EscherContainerRecord spgrConrainer = dgContainer.getChildContainers().get(0);\n        List<EscherContainerRecord> spgrChildren = spgrConrainer.getChildContainers();\n\n        for (int i = 0; i < spgrChildren.size(); i++) {\n            EscherContainerRecord spContainer = spgrChildren.get(i);\n            if (i != 0) {\n                HSSFShapeFactory.createShapeTree(spContainer, _boundAggregate, this, _sheet.getWorkbook().getDirectory());\n            }\n        }\n    }
864	public void writeOut(byte headerA, byte headerB, long type, Record[] children, OutputStream out) throws IOException {\n		// If we have a mutable output stream, take advantage of that\n		if(out instanceof MutableByteArrayOutputStream) {\n			MutableByteArrayOutputStream mout =\n				(MutableByteArrayOutputStream)out;\n\n			// Grab current size\n			int oldSize = mout.getBytesWritten();\n\n			// Write out our header, less the size\n			mout.write(new byte[] {headerA,headerB});\n			byte[] typeB = new byte[2];\n			LittleEndian.putShort(typeB, 0, (short)type);\n			mout.write(typeB);\n			mout.write(new byte[4]);\n\n			// Write out the children\n			for (Record aChildren : children) {\n				aChildren.writeOut(mout);\n			}\n\n			// Update our header with the size\n			// Don't forget to knock 8 more off, since we don't include the\n			//  header in the size\n			int length = mout.getBytesWritten() - oldSize - 8;\n			byte[] size = new byte[4];\n			LittleEndian.putInt(size,0,length);\n			mout.overwrite(size, oldSize+4);\n		} else {\n			// Going to have to do it a slower way, because we have\n			// to update the length come the end\n\n			// Create a ByteArrayOutputStream to hold everything in\n			ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n			// Write out our header, less the size\n			baos.write(new byte[] {headerA,headerB});\n			byte[] typeB = new byte[2];\n			LittleEndian.putShort(typeB,0,(short)type);\n			baos.write(typeB);\n			baos.write(new byte[] {0,0,0,0});\n\n			// Write out our children\n			for (Record aChildren : children) {\n				aChildren.writeOut(baos);\n			}\n\n			// Grab the bytes back\n			byte[] toWrite = baos.toByteArray();\n\n			// Update our header with the size\n			// Don't forget to knock 8 more off, since we don't include the\n			//  header in the size\n			LittleEndian.putInt(toWrite,4,(toWrite.length-8));\n\n			// Write out the bytes\n			out.write(toWrite);\n		}\n	}
865	private PackagePart createWorksheetPart(POIXMLRelation chartRelation, POIXMLRelation chartWorkbookRelation,\n        POIXMLFactory chartFactory) throws InvalidFormatException {\n        PackageRelationship xlsx = createRelationshipInChart(chartWorkbookRelation, chartFactory, chartIndex);\n        this.setExternalId(xlsx.getId());\n        return getTargetPart(xlsx);\n    }
866	private ParseNode function(String name) {\n        Ptg nameToken = null;\n        if(!AbstractFunctionPtg.isBuiltInFunctionName(name)) {\n            // user defined function\n            // in the token tree, the name is more or less the first argument\n\n            if (_book == null) {\n                // Only test cases omit the book (expecting it not to be needed)\n                throw new IllegalStateException("Need book to evaluate name '" + name + "'");\n            }\n            // Check to see if name is a named range in the workbook\n            EvaluationName hName = _book.getName(name, _sheetIndex);\n            if (hName != null) {\n                if (!hName.isFunctionName()) {\n                    throw new FormulaParseException("Attempt to use name '" + name\n                            + "' as a function, but defined name in workbook does not refer to a function");\n                }\n    \n                // calls to user-defined functions within the workbook\n                // get a Name token which points to a defined name record\n                nameToken = hName.createPtg();\n            } else {\n                // Check if name is an external names table\n                nameToken = _book.getNameXPtg(name, null);\n                if (nameToken == null) {\n                    // name is not an internal or external name\n                    if (log.check(POILogger.WARN)) {\n                        log.log(POILogger.WARN,\n                                "FormulaParser.function: Name '" + name + "' is completely unknown in the current workbook.");\n                    }\n                    // name is probably the name of an unregistered User-Defined Function\n                    switch (_book.getSpreadsheetVersion()) {\n                        case EXCEL97:\n                            // HSSFWorkbooks require a name to be added to Workbook defined names table\n                            addName(name);\n                            hName = _book.getName(name, _sheetIndex);\n                            nameToken = hName.createPtg();\n                            break;\n                        case EXCEL2007:\n                            // XSSFWorkbooks store formula names as strings.\n                            nameToken = new NameXPxg(name);\n                            break;\n                        default:\n                            throw new IllegalStateException("Unexpected spreadsheet version: " + _book.getSpreadsheetVersion().name());\n                    }\n                }\n            }\n        }\n\n        Match('(');\n        ParseNode[] args = Arguments();\n        Match(')');\n\n        return getFunction(name, nameToken, args);\n    }
867	private int addMergedRegion(CellRangeAddress region, boolean validate) {\n        if (region.getNumberOfCells() < 2) {\n            throw new IllegalArgumentException("Merged region " + region.formatAsString() + " must contain 2 or more cells");\n        }\n        region.validate(SpreadsheetVersion.EXCEL97);\n\n        if (validate) {\n            // throw IllegalStateException if the argument CellRangeAddress intersects with\n            // a multi-cell array formula defined in this sheet\n            validateArrayFormulas(region);\n        \n            // Throw IllegalStateException if the argument CellRangeAddress intersects with\n            // a merged region already in this sheet\n            validateMergedRegions(region);\n        }\n\n        return _sheet.addMergedRegion(region.getFirstRow(),\n                region.getFirstColumn(),\n                region.getLastRow(),\n                region.getLastColumn());\n    }
868	public Color getFillColor() {\n        SolidPaint ps = getFillStyle();\n        if (ps == null) return null;\n        return DrawPaint.applyColorTransform(ps.getSolidColor());\n    }
869	private static HCenterRecord createHCenter() {\n        HCenterRecord retval = new HCenterRecord();\n\n        retval.setHCenter(false);\n        return retval;\n    }
870	public PropertyIDMap getPropertySetIDMap() {\n        return null;\n    }
871	private static int findInsertPosForNewCondFormatTable(List<RecordBase> records) {\n\n		for (int i = records.size() - 2; i >= 0; i--) { // -2 to skip EOF record\n			Object rb = records.get(i);\n			if (rb instanceof MergedCellsTable) {\n				return i + 1;\n			}\n			if (rb instanceof DataValidityTable) {\n				continue;\n			}\n\n			Record rec = (Record) rb;\n			switch (rec.getSid()) {\n				case WindowTwoRecord.sid:\n				case SCLRecord.sid:\n				case PaneRecord.sid:\n				case SelectionRecord.sid:\n				case UnknownRecord.STANDARDWIDTH_0099:\n				// MergedCellsTable usually here\n				case UnknownRecord.LABELRANGES_015F:\n				case UnknownRecord.PHONETICPR_00EF:\n					// ConditionalFormattingTable goes here\n					return i + 1;\n				// HyperlinkTable (not aggregated by POI yet)\n				// DataValidityTable\n			}\n		}\n		throw new RuntimeException("Did not find Window2 record");\n	}
872	@SuppressWarnings("unused")\n    int getLum(){\n        return getPercentageValue("lum");\n    }
873	public void cloneStyleFrom(ExtendedFormatRecord source) {\n        field_1_font_index           = source.field_1_font_index;\n        field_2_format_index         = source.field_2_format_index;\n        field_3_cell_options         = source.field_3_cell_options;\n        field_4_alignment_options    = source.field_4_alignment_options;\n        field_5_indention_options    = source.field_5_indention_options;\n        field_6_border_options       = source.field_6_border_options;\n        field_7_palette_options      = source.field_7_palette_options;\n        field_8_adtl_palette_options = source.field_8_adtl_palette_options;\n        field_9_fill_palette_options = source.field_9_fill_palette_options;\n    }
874	@Internal\n    public static void copyNodeRecursively( Entry entry, DirectoryEntry target )\n    throws IOException {\n        if ( entry.isDirectoryEntry() ) {\n        	DirectoryEntry dirEntry = (DirectoryEntry)entry;\n            DirectoryEntry newTarget = target.createDirectory( entry.getName() );\n            newTarget.setStorageClsid( dirEntry.getStorageClsid() );\n            Iterator<Entry> entries = dirEntry.getEntries();\n\n            while ( entries.hasNext() ) {\n                copyNodeRecursively( entries.next(), newTarget );\n            }\n        } else {\n            DocumentEntry dentry = (DocumentEntry) entry;\n            DocumentInputStream dstream = new DocumentInputStream( dentry );\n            target.createDocument( dentry.getName(), dstream );\n            dstream.close();\n        }\n    }
875	public static NumberRecord convertToNumberRecord(RKRecord rk) {\n        NumberRecord num = new NumberRecord();\n\n        num.setColumn(rk.getColumn());\n        num.setRow(rk.getRow());\n        num.setXFIndex(rk.getXFIndex());\n        num.setValue(rk.getRKNumber());\n        return num;\n    }
876	public void putUShort( int value ) {\n		try {\n			out.write( (byte) ( ( value ) & 0xFF ) );\n			out.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n		} catch (IOException e) {\n			throw new RuntimeException(e);\n		}\n	}
877	private void addDefaultContentType(String extension, String contentType) {\n        // Remark : Originally the latest parameter was :\n        // contentType.toLowerCase(). Change due to a request ID 1996748.\n        defaultContentType.put(extension.toLowerCase(Locale.ROOT), contentType);\n    }
878	protected CellValueRecordInterface getCellValueRecord()\n    {\n        return _record;\n    }
879	private void addDescription() {\n        setElementTextContent(KEYWORD_DESCRIPTION, namespaceDC, propsPart.getDescriptionProperty());\n	}
880	public void resize(){\n        resize(Double.MAX_VALUE);\n    }
881	public static void arrayMoveWithin(Object[] array, int moveFrom, int moveTo, int numToMove) {\n    	// If we're not asked to do anything, return now\n    	if(numToMove <= 0) { return; }\n    	if(moveFrom == moveTo) { return; }\n    	\n    	// Check that the values supplied are valid\n    	if(moveFrom < 0 || moveFrom >= array.length) {\n    		throw new IllegalArgumentException("The moveFrom must be a valid array index");\n    	}\n    	if(moveTo < 0 || moveTo >= array.length) {\n    		throw new IllegalArgumentException("The moveTo must be a valid array index");\n    	}\n    	if(moveFrom+numToMove > array.length) {\n    		throw new IllegalArgumentException("Asked to move more entries than the array has");\n    	}\n    	if(moveTo+numToMove > array.length) {\n    		throw new IllegalArgumentException("Asked to move to a position that doesn't have enough space");\n    	}\n    	\n    	// Grab the bit to move \n    	Object[] toMove = new Object[numToMove];\n    	System.arraycopy(array, moveFrom, toMove, 0, numToMove);\n    	\n    	// Grab the bit to be shifted\n    	Object[] toShift;\n    	int shiftTo;\n    	if(moveFrom > moveTo) {\n    		// Moving to an earlier point in the array\n    		// Grab everything between the two points\n    		toShift = new Object[(moveFrom-moveTo)];\n    		System.arraycopy(array, moveTo, toShift, 0, toShift.length);\n    		shiftTo = moveTo + numToMove;\n    	} else {\n    		// Moving to a later point in the array\n    		// Grab everything from after the toMove block, to the new point\n    		toShift = new Object[(moveTo-moveFrom)];\n    		System.arraycopy(array, moveFrom+numToMove, toShift, 0, toShift.length);\n    		shiftTo = moveFrom;\n    	}\n    	\n    	// Copy the moved block to its new location\n    	System.arraycopy(toMove, 0, array, moveTo, toMove.length);\n    	\n    	// And copy the shifted block to the shifted location\n    	System.arraycopy(toShift, 0, array, shiftTo, toShift.length);\n    	\n    	\n    	// We're done - array will now have everything moved as required\n    }
882	public int getLastSheetIndexFromExternSheetIndex(int externSheetNumber)\n    {\n        return linkTable.getLastInternalSheetIndexForExtIndex(externSheetNumber);\n    }
883	public List<RichTextString> getSharedStringItems() {\n        ArrayList<RichTextString> items = new ArrayList<>();\n        for (CTRst rst : strings) {\n            items.add(new XSSFRichTextString(rst));\n        }\n        return Collections.unmodifiableList(items);\n    }
884	public float getAnchorHeightInPoints(HSSFSheet sheet) {\n        int y1 = getDy1();\n        int y2 = getDy2();\n        int row1 = Math.min(getRow1(), getRow2());\n        int row2 = Math.max(getRow1(), getRow2());\n\n        float points = 0;\n        if (row1 == row2) {\n            points = ((y2 - y1) / 256.0f) * getRowHeightInPoints(sheet, row2);\n        } else {\n            points += ((256.0f - y1) / 256.0f) * getRowHeightInPoints(sheet, row1);\n            for (int i = row1 + 1; i < row2; i++) {\n                points += getRowHeightInPoints(sheet, i);\n            }\n            points += (y2 / 256.0f) * getRowHeightInPoints(sheet, row2);\n        }\n\n        return points;\n    }
885	protected void onDocumentWrite(){\n        CTCell[] cArray = new CTCell[_cells.size()];\n        int i = 0;\n        for (XSSFCell xssfCell : _cells.values()) {\n            cArray[i] = (CTCell) xssfCell.getCTCell().copy();\n            \n            // we have to copy and re-create the XSSFCell here because the \n            // elements as otherwise setCArray below invalidates all the columns!\n            // see Bug 56170, XMLBeans seems to always release previous objects\n            // in the CArray, so we need to provide completely new ones here!\n            //_cells.put(entry.getKey(), new XSSFCell(this, cArray[i]));\n            xssfCell.setCTCell(cArray[i]);\n            i++;\n        }\n\n        _row.setCArray(cArray);\n    }
886	public void writeFilesystem() throws IOException {\n       if (!(_data instanceof FileBackedDataSource)) {\n          throw new IllegalArgumentException(\n                "POIFS opened from an inputstream, so writeFilesystem() may " +\n                "not be called. Use writeFilesystem(OutputStream) instead"\n          );\n       }\n       if (! ((FileBackedDataSource)_data).isWriteable()) {\n           throw new IllegalArgumentException(\n                "POIFS opened in read only mode, so writeFilesystem() may " +\n                "not be called. Open the FileSystem in read-write mode first"\n           );\n       }\n       syncWithDataSource();\n    }
887	private void init(final byte[] src, final int offset, final int length)\n    throws UnsupportedEncodingException {\n        /* FIXME (3): Ensure that at most "length" bytes are read. */\n\n        /*\n         * Read the stream's header fields.\n         */\n        int o = offset;\n        byteOrder = LittleEndian.getUShort(src, o);\n        o += LittleEndianConsts.SHORT_SIZE;\n        format = LittleEndian.getUShort(src, o);\n        o += LittleEndianConsts.SHORT_SIZE;\n        osVersion = (int) LittleEndian.getUInt(src, o);\n        o += LittleEndianConsts.INT_SIZE;\n        classID = new ClassID(src, o);\n        o += ClassID.LENGTH;\n        final int sectionCount = LittleEndian.getInt(src, o);\n        o += LittleEndianConsts.INT_SIZE;\n        if (sectionCount < 0) {\n            throw new HPSFRuntimeException("Section count " + sectionCount + " is negative.");\n        }\n\n        /*\n         * Read the sections, which are following the header. They\n         * start with an array of section descriptions. Each one\n         * consists of a format ID telling what the section contains\n         * and an offset telling how many bytes from the start of the\n         * stream the section begins.\n         * \n         * Most property sets have only one section. The Document\n         * Summary Information stream has 2. Everything else is a rare\n         * exception and is no longer fostered by Microsoft.\n         */\n\n        /*\n         * Loop over the section descriptor array. Each descriptor\n         * consists of a ClassID and a DWord, and we have to increment\n         * "offset" accordingly.\n         */\n        for (int i = 0; i < sectionCount; i++) {\n            final Section s = new Section(src, o);\n            o += ClassID.LENGTH + LittleEndianConsts.INT_SIZE;\n            sections.add(s);\n        }\n    }
888	public static void main(String args[]) throws IOException {\n        if (args.length != 2) {\n            System.err.println(\n                "two arguments required: input filename and output filename");\n            System.exit(1);\n        }\n\n        try (FileInputStream istream = new FileInputStream(args[0])) {\n            try (FileOutputStream ostream = new FileOutputStream(args[1])) {\n                try (POIFSFileSystem fs = new POIFSFileSystem(istream)) {\n                    fs.writeFilesystem(ostream);\n                }\n            }\n        }\n    }
889	public static boolean endsWithIgnoreCase(String haystack, String suffix) {\n        int length = suffix.length();\n        int start = haystack.length() - length;\n        return haystack.regionMatches(true, start, suffix, 0, length);\n    }
890	public int addPicture(HSLFPictureData img) {\n        // Process any existing pictures if we haven't yet\n        if (_pictures == null) {\n            try {\n                readPictures();\n            } catch (IOException e) {\n                throw new CorruptPowerPointFileException(e.getMessage());\n            }\n        }\n\n        // Add the new picture in\n        int offset = 0;\n        if (_pictures.size() > 0) {\n            HSLFPictureData prev = _pictures.get(_pictures.size() - 1);\n            offset = prev.getOffset() + prev.getRawData().length + 8;\n        }\n        img.setOffset(offset);\n        img.setIndex(_pictures.size() + 1);\n        _pictures.add(img);\n        return offset;\n    }
891	public String getSignatureMethodUri() {\n        switch (getDigestAlgo()) {\n        case sha1:   return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1;\n        case sha224: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA224;\n        case sha256: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA256;\n        case sha384: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA384;\n        case sha512: return XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA512;\n        case ripemd160: return XMLSignature.ALGO_ID_SIGNATURE_RSA_RIPEMD160;\n        default: throw new EncryptedDocumentException("Hash algorithm "\n            +getDigestAlgo()+" not supported for signing.");\n        }\n    }
892	public void display(PrintWriter w, int indent)\n    {\n        for (int i = 0; i < indent * 4; i++) {\n            w.print(' ');\n        }\n        w.println(getRecordName());\n    }
893	public static void putUInt( long value, OutputStream outputStream )\n            throws IOException\n    {\n        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );\n    }
894	public void ensureThemesTable() {\n        if (theme != null) return;\n\n        setTheme((ThemesTable)workbook.createRelationship(XSSFRelation.THEME, XSSFFactory.getInstance()));\n    }
895	public int getFirstVisibleTab() {\n        return field_7_first_visible_tab;\n    }
896	public Borders getBorderLeft() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getLeft();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
897	private static double getCellWidth(int defaultCharWidth, int colspan,\n            CellStyle style, double minWidth, AttributedString str) {\n        TextLayout layout = new TextLayout(str.getIterator(), fontRenderContext);\n        final Rectangle2D bounds;\n        if(style.getRotation() != 0){\n            /*\n             * Transform the text using a scale so that it's height is increased by a multiple of the leading,\n             * and then rotate the text before computing the bounds. The scale results in some whitespace around\n             * the unrotated top and bottom of the text that normally wouldn't be present if unscaled, but\n             * is added by the standard Excel autosize.\n             */\n            AffineTransform trans = new AffineTransform();\n            trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n            trans.concatenate(\n            AffineTransform.getScaleInstance(1, fontHeightMultiple)\n            );\n            bounds = layout.getOutline(trans).getBounds();\n        } else {\n            bounds = layout.getBounds();\n        }\n        // frameWidth accounts for leading spaces which is excluded from bounds.getWidth()\n        final double frameWidth = bounds.getX() + bounds.getWidth();\n        return Math.max(minWidth, ((frameWidth / colspan) / defaultCharWidth) + style.getIndention());\n    }
898	public byte[] serialize()\n    {\n        byte[] retval = new byte[getRecordSize()];\n\n        serialize( 0, retval );\n        return retval;\n    }
899	public int addChildAfter(Record newChild, Record after) {\n		// Decide where we're going to put it\n		int loc = findChildLocation(after);\n		if(loc == -1) {\n			throw new IllegalArgumentException("Asked to add a new child after another record, but that record wasn't one of our children!");\n		}\n\n		// Add one place after the supplied record\n		addChildAt(newChild, loc+1);\n		return loc+1;\n	}
900	private Ptg adjustPtgDueToRowMove(Ptg ptg, int currentExternSheetIx) {\n        return adjustPtgDueToMove(ptg, currentExternSheetIx, true);\n    }
901	public int getSpacingBefore() {\n        CTSpacing spacing = getCTSpacing(false);\n        return (spacing != null && spacing.isSetBefore()) ? spacing.getBefore().intValue() : -1;\n    }
902	public void writeToFS(POIFSFileSystem fs) throws IOException {\n		// Grab contents\n		ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		writeOut(baos);\n		ByteArrayInputStream bais = \n			new ByteArrayInputStream(baos.toByteArray());\n\n		// Write out\n		fs.createOrUpdateDocument(bais,"Current User");\n	}
903	void removePictureRelation(XSLFPictureShape pictureShape) {\n        removeRelation(pictureShape.getBlipId());\n    }
904	public void numberedListInCell(HSSFWorkbook workbook,\n                                   ArrayList<String> listItems,\n                                   HSSFCell cell,\n                                   int startingValue,\n                                   int increment) {\n        StringBuilder buffer = new StringBuilder();\n        int itemNumber = startingValue;\n        // Note that again, an HSSFCellStye object is required and that\n        // it's wrap text property should be set to 'true'\n        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n        // Note that the basic method is identical to the listInCell() method\n        // with one difference; a number prefixed to the items text.\n        for(String listItem : listItems) {\n            buffer.append(itemNumber).append(". ");\n            buffer.append(listItem);\n            buffer.append("\n");\n            itemNumber += increment;\n        }\n        // The StringBuffer's contents are the source for the contents\n        // of the cell.\n        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
905	/*package*/ void setType(CellType type)\n    {\n        switch(type)\n        {\n            case NUMERIC:\n            {\n                _value = new NumericValue();\n                break;\n            }\n            case STRING:\n            {\n                PlainStringValue sval = new PlainStringValue();\n                if(_value != null){\n                    // if a cell is not blank then convert the old value to string\n                    String str = convertCellValueToString();\n                    sval.setValue(str);\n                }\n                _value = sval;\n                break;\n            }\n            case FORMULA:\n            {\n                _value = new NumericFormulaValue();\n                break;\n            }\n            case BLANK:\n            {\n                _value = new BlankValue();\n                break;\n            }\n            case BOOLEAN:\n            {\n                BooleanValue bval = new BooleanValue();\n                if(_value != null){\n                    // if a cell is not blank then convert the old value to string\n                    boolean val = convertCellValueToBoolean();\n                    bval.setValue(val);\n                }\n                _value = bval;\n                break;\n            }\n            case ERROR:\n            {\n                _value = new ErrorValue();\n                break;\n            }\n            default:\n            {\n                throw new IllegalArgumentException("Illegal type " + type);\n            }\n        }\n    }
906	public String getId() {\n        return id;\n    }
907	public SheetBuilder setSheetName(String sheetName) {\n        this.sheetName = sheetName;\n        return this;\n    }
908	public static List<MAPIAttribute> create(TNEFAttribute parent) throws IOException {\n      if(parent.getProperty() == TNEFProperty.ID_MAPIPROPERTIES) {\n         // Regular MAPI Properties, normally on the message\n      }\n      else if(parent.getProperty() == TNEFProperty.ID_ATTACHMENT) {\n         // MAPI Properties for an attachment\n      }\n      else {\n         // Something else, oh dear...\n         throw new IllegalArgumentException(\n               "Can only create from a MAPIProperty attribute, " +\n               "instead received a " + parent.getProperty() + " one"\n         );\n      }\n      ByteArrayInputStream inp = new ByteArrayInputStream(parent.getData());\n      \n      // First up, get the number of attributes\n      int count = LittleEndian.readInt(inp);\n      List<MAPIAttribute> attrs = new ArrayList<>();\n      \n      // Now, read each one in in turn\n      for(int i=0; i<count; i++) {\n         int typeAndMV = LittleEndian.readUShort(inp);\n         int id = LittleEndian.readUShort(inp);\n         \n         // Is it either Multi-Valued or Variable-Length?\n         boolean isMV = false;\n         boolean isVL = false;\n         int typeId = typeAndMV;\n         if( (typeAndMV & Types.MULTIVALUED_FLAG) != 0 ) {\n            isMV = true;\n            typeId -= Types.MULTIVALUED_FLAG;\n         }\n         if(typeId == Types.ASCII_STRING.getId() || typeId == Types.UNICODE_STRING.getId() ||\n               typeId == Types.BINARY.getId() || typeId == Types.DIRECTORY.getId()) {\n            isVL = true;\n         }\n         \n         // Turn the type ID into a strongly typed thing\n         MAPIType type = Types.getById(typeId);\n         if (type == null) {\n            type = Types.createCustom(typeId);\n         }\n         \n         // If it's a named property, rather than a standard\n         //  MAPI property, grab the details of it\n         MAPIProperty prop = MAPIProperty.get(id);\n         if(id >= 0x8000 && id <= 0xFFFF) {\n            byte[] guid = new byte[16];\n            IOUtils.readFully(inp, guid);\n            int mptype = LittleEndian.readInt(inp);\n            \n            // Get the name of it\n            String name;\n            if(mptype == 0) {\n               // It's based on a normal one\n               int mpid = LittleEndian.readInt(inp);\n               MAPIProperty base = MAPIProperty.get(mpid);\n               name = base.name;\n            } else {\n               // Custom name was stored\n               int mplen = LittleEndian.readInt(inp);\n               byte[] mpdata = IOUtils.safelyAllocate(mplen, MAX_RECORD_LENGTH);\n               IOUtils.readFully(inp, mpdata);\n               name = StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1);\n               skipToBoundary(mplen, inp);\n            }\n            \n            // Now create\n            prop = MAPIProperty.createCustom(id, type, name);\n         }\n         if(prop == MAPIProperty.UNKNOWN) {\n            prop = MAPIProperty.createCustom(id, type, "(unknown " + Integer.toHexString(id) + ")");\n         }\n         \n         // Now read in the value(s)\n         int values = 1;\n         if(isMV || isVL) {\n            values = LittleEndian.readInt(inp);\n         }\n         for(int j=0; j<values; j++) {\n            int len = getLength(type, inp);\n            byte[] data = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n            IOUtils.readFully(inp, data);\n            skipToBoundary(len, inp);\n            \n            // Create\n            MAPIAttribute attr;\n            if(type == Types.UNICODE_STRING || type == Types.ASCII_STRING) {\n               attr = new MAPIStringAttribute(prop, typeId, data);\n            } else if(type == Types.APP_TIME || type == Types.TIME) {\n               attr = new MAPIDateAttribute(prop, typeId, data);\n            } else if(id == MAPIProperty.RTF_COMPRESSED.id) {\n               attr = new MAPIRtfAttribute(prop, typeId, data);\n            } else {\n               attr = new MAPIAttribute(prop, typeId, data);\n            }\n            attrs.add(attr);\n         }\n      }\n      \n      // All done\n      return attrs;\n   }
909	public final boolean isExternalFunction() {\n        return _functionIndex == FUNCTION_INDEX_EXTERNAL;\n    }
910	private ParseNode powerFactor() {\n        ParseNode result = percentFactor();\n        while(true) {\n            SkipWhite();\n            if(look != '^') {\n                return result;\n            }\n            Match('^');\n            ParseNode other = percentFactor();\n            result = new ParseNode(PowerPtg.instance, result, other);\n        }\n    }
911	private Record getCoreRecordForSAS(SlideAtomsSet sas) {\n		SlidePersistAtom spa = sas.getSlidePersistAtom();\n		int refID = spa.getRefID();\n		return getCoreRecordForRefID(refID);\n	}
912	public static byte[] peekFirstNBytes(InputStream stream, int limit) throws IOException, EmptyFileException {\n        stream.mark(limit);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(limit);\n        copy(new BoundedInputStream(stream, limit), bos);\n\n        int readBytes = bos.size();\n        if (readBytes == 0) {\n            throw new EmptyFileException();\n        }\n\n        if (readBytes < limit) {\n            bos.write(new byte[limit-readBytes]);\n        }\n        byte peekedBytes[] = bos.toByteArray();\n        if(stream instanceof PushbackInputStream) {\n            PushbackInputStream pin = (PushbackInputStream)stream;\n            pin.unread(peekedBytes, 0, readBytes);\n        } else {\n            stream.reset();\n        }\n\n        return peekedBytes;\n    }
913	public static boolean isUnicodeString(final String value) {\n        return !value.equals(new String(value.getBytes(ISO_8859_1), ISO_8859_1));\n    }
914	public void setShapeIdMax(int shapeIdMax) {\n        this.field_1_shapeIdMax = shapeIdMax;\n    }
915	public static void copyNodes(POIFSFileSystem source, POIFSFileSystem target )\n    throws IOException {\n        copyNodes( source.getRoot(), target.getRoot() );\n    }
916	public static int getRecordSizeForStrings(int numStrings) {\n        return 4 + 2 + getNumberOfInfoRecsForStrings(numStrings) * 8;\n    }
917	@Internal\n    public boolean isFGlsy()\n    {\n        return fGlsy.isSet(field_6_flags1);\n    }
918	private void isCellContentMatchesForDate(Locator loc1, Locator loc2) {\n        Date date1 = loc1.cell.getDateCellValue();\n        Date date2 = loc2.cell.getDateCellValue();\n        if (!date1.equals(date2)) {\n            addMessage(loc1, loc2, CELL_DATA_DOES_NOT_MATCH, date1.toString(), date2.toString());\n        }\n    }
919	default byte[] getBytes() throws IOException {\n        try (InputStream is = getInputStream()) {\n            return IOUtils.toByteArray(is);\n        }\n    }
920	protected List<EvaluationConditionalFormatRule> getRules(Sheet sheet) {\n        final String sheetName = sheet.getSheetName();\n        List<EvaluationConditionalFormatRule> rules = formats.get(sheetName);\n        if (rules == null) {\n            if (formats.containsKey(sheetName)) {\n                return Collections.emptyList();\n            }\n            final SheetConditionalFormatting scf = sheet.getSheetConditionalFormatting();\n            final int count = scf.getNumConditionalFormattings();\n            rules = new ArrayList<>(count);\n            formats.put(sheetName, rules);\n            for (int i=0; i < count; i++) {\n                ConditionalFormatting f = scf.getConditionalFormattingAt(i);\n                //optimization, as this may be expensive for lots of ranges\n                final CellRangeAddress[] regions = f.getFormattingRanges();\n                for (int r=0; r < f.getNumberOfRules(); r++) {\n                    ConditionalFormattingRule rule = f.getRule(r);\n                    rules.add(new EvaluationConditionalFormatRule(workbookEvaluator, sheet, f, i, rule, r, regions));\n                }\n            }\n            // need them in formatting and priority order so logic works right\n            Collections.sort(rules);\n        }\n        return Collections.unmodifiableList(rules);\n    }
921	private static FormatRecord createFormat(int id) {\n        // we'll need multiple editions for the different formats\n        final int mappings[] = { 5, 6, 7, 8, 0x2a, 0x29, 0x2c, 0x2b };\n        if (id < 0 || id >= mappings.length) {\n            throw new  IllegalArgumentException("Unexpected id " + id);\n        }\n        return new FormatRecord(mappings[id], BuiltinFormats.getBuiltinFormat(mappings[id]));\n    }
922	public int countOfAllChildren() {\n        int count = shapes.size();\n        for (Iterator<HSSFShape> iterator = shapes.iterator(); iterator.hasNext(); ) {\n            HSSFShape shape = iterator.next();\n            count += shape.countOfAllChildren();\n        }\n        return count;\n    }
923	private ClientAnchorDetail fitImageToColumns(HSSFSheet sheet, int colNumber,\n            double reqImageWidthMM, int resizeBehaviour) {\n\n        double colWidthMM;\n        double colCoordinatesPerMM;\n        int pictureWidthCoordinates;\n        ClientAnchorDetail colClientAnchorDetail = null;\n\n        // Get the colum's width in millimetres\n        colWidthMM = ConvertImageUnits.widthUnits2Millimetres(\n                (short)sheet.getColumnWidth(colNumber));\n\n        // Check that the column's width will accomodate the image at the\n        // required dimension. If the width of the column is LESS than the\n        // required width of the image, decide how the application should\n        // respond - resize the column or overlay the image across one or more\n        // columns.\n        if(colWidthMM < reqImageWidthMM) {\n\n            // Should the column's width simply be expanded?\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                // Set the width of the column by converting the required image\n                // width from millimetres into Excel's column width units.\n                sheet.setColumnWidth(colNumber,\n                        ConvertImageUnits.millimetres2WidthUnits(reqImageWidthMM));\n                // To make the image occupy the full width of the column, convert\n                // the required width of the image into co-ordinates. This value\n                // will become the inset for the ClientAnchorDetail class that\n                // is then instantiated.\n                colWidthMM = reqImageWidthMM;\n                colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n                colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                        colNumber, pictureWidthCoordinates);\n            }\n            // If the user has chosen to overlay both rows and columns or just\n            // to expand ONLY the size of the rows, then calculate how to lay\n            // the image out across one or more columns.\n            else if ((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                     (resizeBehaviour == AddDimensionedImage.EXPAND_ROW)) {\n                colClientAnchorDetail = this.calculateColumnLocation(sheet,\n                        colNumber, reqImageWidthMM);\n            }\n        }\n        // If the column is wider than the image.\n        else {\n            // Mow many co-ordinate positions are there per millimetre?\n            colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n            // Given the width of the image, what should be it's co-ordinate?\n            pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n            colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                    colNumber, pictureWidthCoordinates);\n        }\n        return(colClientAnchorDetail);\n    }
924	private static void applyTint(double hsl[], ColorStyle fc) {\n        int tint = fc.getTint();\n        if (tint == -1) {\n            return;\n        }\n\n        // see 18.8.19 fgColor (Foreground Color)\n        double tintPct = tint / 100000.;\n        hsl[2] = hsl[2]*(1.-tintPct) + (100.-100.*(1.-tintPct));\n    }
925	public void setPolygonDrawArea(int width, int height) {\n        setPropertyValue(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, width));\n        setPropertyValue(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, height));\n    }
926	protected PackagePart[] getRelatedByType(String contentType) throws InvalidFormatException {\n        PackageRelationshipCollection partsC =\n            getPackagePart().getRelationshipsByType(contentType);\n\n        PackagePart[] parts = new PackagePart[partsC.size()];\n        int count = 0;\n        for (PackageRelationship rel : partsC) {\n            parts[count] = getPackagePart().getRelatedPart(rel);\n            count++;\n        }\n        return parts;\n    }
927	public XSSFFont findFont(boolean bold, Color color, short fontHeight, String name, boolean italic, boolean strikeout, short typeOffset, byte underline) {\n        for (XSSFFont font : fonts) {\n            if (    (font.getBold() == bold)\n                    && font.getXSSFColor().equals(color)\n                    && font.getFontHeight() == fontHeight\n                    && font.getFontName().equals(name)\n                    && font.getItalic() == italic\n                    && font.getStrikeout() == strikeout\n                    && font.getTypeOffset() == typeOffset\n                    && font.getUnderline() == underline)\n            {\n                return font;\n            }\n        }\n        return null;\n    }
928	int getPropertyIntValue(final int id) throws NoSingleSectionException {\n        return getFirstSection().getPropertyIntValue(id);\n    }
929	public int calcExtSSTRecordSize() {\n      return ExtSSTRecord.getRecordSizeForStrings(field_3_strings.size());\n    }
930	public void addFormatRun(FormatRun r) {\n      if (field_4_format_runs == null) {\n		field_4_format_runs = new ArrayList<>();\n	  }\n\n      int index = findFormatRunAt(r._character);\n      if (index != -1) {\n         field_4_format_runs.remove(index);\n      }\n\n      field_4_format_runs.add(r);\n      //Need to sort the font runs to ensure that the font runs appear in\n      //character order\n      Collections.sort(field_4_format_runs);\n\n      //Make sure that we now say that we are a rich string\n      field_2_optionflags = richText.setByte(field_2_optionflags);\n    }
931	private static BookBoolRecord createBookBool() {\n        BookBoolRecord retval = new BookBoolRecord();\n        retval.setSaveLinkValues(( short ) 0);\n        return retval;\n    }
932	private void cleanupTblBorders() {\n        final CTTblPr pr = getTblPr(false);\n        if (pr != null && pr.isSetTblBorders()) {\n            final CTTblBorders b = pr.getTblBorders();\n            if (!(b.isSetInsideH() ||\n                b.isSetInsideV() ||\n                b.isSetTop() ||\n                b.isSetBottom() ||\n                b.isSetLeft() ||\n                b.isSetRight())) {\n                pr.unsetTblBorders();\n            }\n        }\n    }
933	public boolean removeBodyElement(int pos) {\n        if (pos >= 0 && pos < bodyElements.size()) {\n            BodyElementType type = bodyElements.get(pos).getElementType();\n            if (type == BodyElementType.TABLE) {\n                int tablePos = getTablePos(pos);\n                tables.remove(tablePos);\n                ctDocument.getBody().removeTbl(tablePos);\n            }\n            if (type == BodyElementType.PARAGRAPH) {\n                int paraPos = getParagraphPos(pos);\n                paragraphs.remove(paraPos);\n                ctDocument.getBody().removeP(paraPos);\n            }\n            bodyElements.remove(pos);\n            return true;\n        }\n        return false;\n    }
934	public void removeHyperlinksChanged() {\n        remove1stProperty(PropertyIDMap.PID_HYPERLINKSCHANGED);\n    }
935	public int getFirstSheetIndexFromExternSheetIndex(int externSheetNumber)\n    {\n        return linkTable.getFirstInternalSheetIndexForExtIndex(externSheetNumber);\n    }
936	public void setValidSettings(boolean valid)    {\n	printSetupRecord.setValidSettings(valid);\n    }
937	@SuppressWarnings("deprecation")\n  public int type()\n  {\n    return TYPE_CHARACTER;\n  }
938	public String[] getData()\n    {\n        return _data;\n    }
939	public int addPicture(InputStream is, int format) throws IOException {\n        int imageNumber = getAllPictures().size() + 1;\n        XSSFPictureData img = createRelationship(XSSFPictureData.RELATIONS[format], this.xssfFactory, imageNumber, true).getDocumentPart();\n        try (OutputStream out = img.getPackagePart().getOutputStream()) {\n            IOUtils.copy(is, out);\n        }\n        pictures.add(img);\n        return imageNumber - 1;\n    }
940	public void write(final DirectoryEntry dir, final String name)\n    throws WritingNotSupportedException, IOException {\n        /* If there is already an entry with the same name, remove it. */\n        if (dir.hasEntry(name)) {\n            final Entry e = dir.getEntry(name);\n            e.delete();\n        }\n\n        /* Create the new entry. */\n        dir.createDocument(name, toInputStream());\n    }
941	public Object clone()\n    throws CloneNotSupportedException\n  {\n    CharacterRun cp = (CharacterRun)super.clone();\n    cp._props.setDttmRMark((DateAndTime)_props.getDttmRMark().clone());\n    cp._props.setDttmRMarkDel((DateAndTime)_props.getDttmRMarkDel().clone());\n    cp._props.setDttmPropRMark((DateAndTime)_props.getDttmPropRMark().clone());\n    cp._props.setDttmDispFldRMark((DateAndTime)_props.getDttmDispFldRMark().\n                                  clone());\n    cp._props.setXstDispFldRMark(_props.getXstDispFldRMark().clone());\n    cp._props.setShd(_props.getShd().clone());\n\n    return cp;\n  }
942	@Internal\n    public boolean isFVanish()\n    {\n        return fVanish.isSet(field_1_grpfChp);\n    }
943	public PPDrawing getPPDrawing() {\n        return _container.getPPDrawing();\n    }
944	public static Dimension getDimensionFromAnchor(Picture picture) {\n        ClientAnchor anchor = picture.getClientAnchor();\n        boolean isHSSF = (anchor instanceof HSSFClientAnchor);\n        Sheet sheet = picture.getSheet();\n\n        double w = 0;\n        int col2 = anchor.getCol1();\n\n        //space in the leftmost cell\n        w = sheet.getColumnWidthInPixels(col2++);\n        if (isHSSF) {\n            w *= 1 - anchor.getDx1()/1024d;\n        } else {\n            w -= anchor.getDx1()/(double)EMU_PER_PIXEL;\n        }\n        \n        while(col2 < anchor.getCol2()){\n            w += sheet.getColumnWidthInPixels(col2++);\n        }\n        \n        if (isHSSF) {\n            w += sheet.getColumnWidthInPixels(col2) * anchor.getDx2()/1024d;\n        } else {\n            w += anchor.getDx2()/(double)EMU_PER_PIXEL;\n        }\n\n        double h = 0;\n        int row2 = anchor.getRow1();\n        \n        h = getRowHeightInPixels(sheet,row2++);\n        if (isHSSF) {\n            h *= 1 - anchor.getDy1()/256d;\n        } else {\n            h -= anchor.getDy1()/(double)EMU_PER_PIXEL;\n        }\n\n        while(row2 < anchor.getRow2()){\n            h += getRowHeightInPixels(sheet,row2++);\n        }\n        \n        if (isHSSF) {\n            h += getRowHeightInPixels(sheet,row2) * anchor.getDy2()/256;\n        } else {\n            h += anchor.getDy2()/(double)EMU_PER_PIXEL;\n        }\n\n        w *= EMU_PER_PIXEL;\n        h *= EMU_PER_PIXEL;\n        \n        return new Dimension((int)Math.rint(w), (int)Math.rint(h));\n    }
945	public void setText(String text){\n        throw new IllegalStateException("You cannot change text of a line break, it is always '\\n'");\n    }
946	private List<? extends DataValidation> getValidations(Sheet sheet) {\n        List<? extends DataValidation> dvs = validations.get(sheet.getSheetName());\n        if (dvs == null && !validations.containsKey(sheet.getSheetName())) {\n            dvs = sheet.getDataValidations();\n            validations.put(sheet.getSheetName(), dvs);\n        }\n        return dvs;\n    }
947	public static Area3DPxg parseStructuredReference(String tableText, FormulaParsingWorkbook workbook, int rowIndex) {\n        final int sheetIndex = -1; //don't care?\n        Ptg[] arr = FormulaParser.parse(tableText, workbook, FormulaType.CELL, sheetIndex, rowIndex);\n        if (arr.length != 1 || !(arr[0] instanceof Area3DPxg) ) {\n            throw new IllegalStateException("Illegal structured reference");\n        }\n        return (Area3DPxg) arr[0];\n    }
948	public void drawShape(Graphics2D graphics, Shape<?,?> shape, Rectangle2D bounds) {\n        Rectangle2D shapeBounds = shape.getAnchor();\n        if (shapeBounds.isEmpty() || (bounds != null && bounds.isEmpty())) {\n            return;\n        }\n\n        AffineTransform txg = (AffineTransform)graphics.getRenderingHint(Drawable.GROUP_TRANSFORM);\n        AffineTransform tx = new AffineTransform();\n        try {\n            if (bounds != null) {\n                double scaleX = bounds.getWidth()/shapeBounds.getWidth();\n                double scaleY = bounds.getHeight()/shapeBounds.getHeight();\n                tx.translate(bounds.getCenterX(), bounds.getCenterY());\n                tx.scale(scaleX, scaleY);\n                tx.translate(-shapeBounds.getCenterX(), -shapeBounds.getCenterY());\n            }\n            graphics.setRenderingHint(Drawable.GROUP_TRANSFORM, tx);\n            \n            Drawable d = getDrawable(shape);\n            d.applyTransform(graphics);\n            d.draw(graphics);\n        } finally {\n            graphics.setRenderingHint(Drawable.GROUP_TRANSFORM, txg);\n        }\n    }
949	private void readPowerPointStream() throws IOException {\n        // Get the main document stream\n        DocumentEntry docProps =\n                (DocumentEntry) getDirectory().getEntry(HSLFSlideShow.POWERPOINT_DOCUMENT);\n\n        // Grab the document stream\n        int len = docProps.getSize();\n        try (InputStream is = getDirectory().createDocumentInputStream(HSLFSlideShow.POWERPOINT_DOCUMENT)) {\n            _docstream = IOUtils.toByteArray(is, len);\n        }\n    }
950	public void fixFonts(Graphics2D graphics) {\n        if (!JvmBugs.hasLineBreakMeasurerBug()) return;\n        @SuppressWarnings("unchecked")\n        Map<String,String> fontMap = (Map<String,String>)graphics.getRenderingHint(Drawable.FONT_MAP);\n        if (fontMap == null) {\n            fontMap = new HashMap<>();\n            graphics.setRenderingHint(Drawable.FONT_MAP, fontMap);\n        }\n        \n        String fonts[][] = {\n            { "Calibri", "Lucida Sans" },\n            { "Cambria", "Lucida Bright" },\n            { "Times New Roman", "Lucida Bright" },\n            { "serif", "Lucida Bright" }\n        };\n\n        for (String f[] : fonts) {\n            if (!fontMap.containsKey(f[0])) {\n                fontMap.put(f[0], f[1]);\n            }\n        }\n    }
951	@Internal\n    public boolean isFPersonal()\n    {\n        return fPersonal.isSet(field_5_grfstd);\n    }
952	static HSSFPatriarch createPatriarch(HSSFPatriarch patriarch, HSSFSheet sheet){\n        HSSFPatriarch newPatriarch = new HSSFPatriarch(sheet, new EscherAggregate(true));\n        newPatriarch.afterCreate();\n        for (HSSFShape shape: patriarch.getChildren()){\n            HSSFShape newShape;\n            if (shape instanceof HSSFShapeGroup){\n                newShape = ((HSSFShapeGroup)shape).cloneShape(newPatriarch);\n            } else {\n                newShape = shape.cloneShape();\n            }\n            newPatriarch.onCreate(newShape);\n            newPatriarch.addShape(newShape);\n        }\n        return newPatriarch;\n    }
953	@Internal\n    public boolean isFVert()\n    {\n        return fVert.isSet(field_13_widthAndFitsFlags);\n    }
954	public void construct(CellValueRecordInterface rec, RecordStream rs, SharedValueManager sfh) {\n		if (rec instanceof FormulaRecord) {\n			FormulaRecord formulaRec = (FormulaRecord)rec;\n			// read optional cached text value\n			StringRecord cachedText;\n			Class<? extends Record> nextClass = rs.peekNextClass();\n			if (nextClass == StringRecord.class) {\n				cachedText = (StringRecord) rs.getNext();\n			} else {\n				cachedText = null;\n			}\n			insertCell(new FormulaRecordAggregate(formulaRec, cachedText, sfh));\n		} else {\n			insertCell(rec);\n		}\n	}
955	protected boolean processSheet( HSSFWorkbook workbook, int sheetIndex )\n    {\n        String pageMasterName = "sheet-" + sheetIndex;\n\n        Element pageSequence = foDocumentFacade\n                .createPageSequence( pageMasterName );\n        Element flow = foDocumentFacade.addFlowToPageSequence( pageSequence,\n                "xsl-region-body" );\n\n        HSSFSheet sheet = workbook.getSheetAt( sheetIndex );\n        float tableWidthIn = processSheet( workbook, sheet, flow );\n\n        if ( tableWidthIn == 0 )\n            return false;\n\n        createPageMaster( tableWidthIn, pageMasterName );\n        foDocumentFacade.addPageSequence( pageSequence );\n        return true;\n    }
956	public void writeProperties(DirectoryEntry directory) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<PropertyValue> values = writeProperties(baos);\n        baos.close();\n\n        // write the header data with the properties declaration\n        directory.createDocument(org.apache.poi.hsmf.datatypes.PropertiesChunk.NAME,\n            new ByteArrayInputStream(baos.toByteArray()));\n\n        // write the property values\n        writeNodeData(directory, values);\n    }
957	@Internal\n    public XWPFFootnote addFootnote(CTFtnEdn note) {\n        CTFtnEdn newNote = ctFootnotes.addNewFootnote();\n        newNote.set(note);\n        XWPFFootnote xNote = new XWPFFootnote(newNote, this);\n        listFootnote.add(xNote);\n        return xNote;\n    }
958	private void addCreated() {\n        setElementTextContent(KEYWORD_CREATED, namespaceDcTerms, propsPart.getCreatedProperty(),\n                propsPart.getCreatedPropertyString(), "dcterms:W3CDTF");\n	}
959	@Internal\n    public boolean isFHasPic()\n    {\n        return fHasPic.isSet(field_6_flags1);\n    }
960	public String getText() {\n        DataFormatter formatter;\n        if(locale == null) {\n            formatter = new DataFormatter();\n        } else  {\n            formatter = new DataFormatter(locale);\n        }\n\n        StringBuilder text = new StringBuilder(64);\n        for(Sheet sh : workbook) {\n            XSSFSheet sheet = (XSSFSheet) sh;\n            if(includeSheetNames) {\n                text.append(sheet.getSheetName()).append("\n");\n            }\n\n            // Header(s), if present\n            if(includeHeadersFooters) {\n                text.append(\n                        extractHeaderFooter(sheet.getFirstHeader())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getOddHeader())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getEvenHeader())\n                        );\n            }\n\n            // Rows and cells\n            for (Object rawR : sheet) {\n                Row row = (Row)rawR;\n                for(Iterator<Cell> ri = row.cellIterator(); ri.hasNext();) {\n                    Cell cell = ri.next();\n\n                    // Is it a formula one?\n                    if(cell.getCellType() == CellType.FORMULA) {\n                        if (formulasNotResults) {\n                            String contents = cell.getCellFormula();\n                            checkMaxTextSize(text, contents);\n                            text.append(contents);\n                        } else {\n                            if (cell.getCachedFormulaResultType() == CellType.STRING) {\n                                handleStringCell(text, cell);\n                            } else {\n                                handleNonStringCell(text, cell, formatter);\n                            }\n                        }\n                    } else if(cell.getCellType() == CellType.STRING) {\n                        handleStringCell(text, cell);\n                    } else {\n                        handleNonStringCell(text, cell, formatter);\n                    }\n\n                    // Output the comment, if requested and exists\n                    Comment comment = cell.getCellComment();\n                    if(includeCellComments && comment != null) {\n                        // Replace any newlines with spaces, otherwise it\n                        //  breaks the output\n                        String commentText = comment.getString().getString().replace('\n', ' ');\n                        checkMaxTextSize(text, commentText);\n                        text.append(" Comment by ").append(comment.getAuthor()).append(": ").append(commentText);\n                    }\n\n                    if(ri.hasNext()) {\n                        text.append("\t");\n                    }\n                }\n                text.append("\n");\n            }\n            \n            // add textboxes\n            if (includeTextBoxes){\n                XSSFDrawing drawing = sheet.getDrawingPatriarch();\n                if (drawing != null) {\n                    for (XSSFShape shape : drawing.getShapes()){\n                        if (shape instanceof XSSFSimpleShape){\n                            String boxText = ((XSSFSimpleShape)shape).getText();\n                            if (boxText.length() > 0){\n                                text.append(boxText);\n                                text.append('\n');\n                            }\n                        }\n                    }\n                }\n            }\n            // Finally footer(s), if present\n            if(includeHeadersFooters) {\n                text.append(\n                        extractHeaderFooter(sheet.getFirstFooter())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getOddFooter())\n                        );\n                text.append(\n                        extractHeaderFooter(sheet.getEvenFooter())\n                        );\n            }\n        }\n\n        return text.toString();\n    }
961	public void setRectY1( int y1 )\n    {\n        this.field_2_rectY1 = y1;\n    }
962	private String valueToRoman(int value) {\n        StringBuilder out = new StringBuilder();\n        for (int i = 0; value > 0 && i < _romanChars.length; i++) {\n            while (_romanAlphaValues[i] <= value) {\n                out.append(_romanChars[i]);\n                value -= _romanAlphaValues[i];\n            }\n        }\n        return out.toString();\n    }
963	public void deletePart(PackagePartName partName) {\n		if (partName == null) {\n			throw new IllegalArgumentException("partName");\n		}\n\n		// Remove the part\n		this.removePart(partName);\n		// Remove the relationships part\n		this.removePart(PackagingURIHelper.getRelationshipPartName(partName));\n	}
964	public void removeCellComment() {\n        HSSFComment comment = _sheet.findCellComment(_record.getRow(), _record.getColumn());\n        _comment = null;\n        if (null == comment){\n            return;\n        }\n        _sheet.getDrawingPatriarch().removeShape(comment);\n    }
965	public XWPFFooter createFooter(Enum type) {\n        return createFooter(type, null);\n    }
966	/* package */ void clearButKeepProperties() {\n        CTTextParagraph thisP = getXmlObject();\n        for (int i=thisP.sizeOfBrArray(); i>0; i--) {\n            thisP.removeBr(i-1);\n        }\n        for (int i=thisP.sizeOfFldArray(); i>0; i--) {\n            thisP.removeFld(i-1);\n        }\n        if (!_runs.isEmpty()) {\n            int size = _runs.size();\n            XSLFTextRun lastRun = _runs.get(size-1);\n            CTTextCharacterProperties cpOther = lastRun.getRPr(false);\n            if (cpOther != null) {\n                if (thisP.isSetEndParaRPr()) {\n                    thisP.unsetEndParaRPr();\n                }\n                CTTextCharacterProperties cp = thisP.addNewEndParaRPr();\n                cp.set(cpOther);\n            }\n            for (int i=size; i>0; i--) {\n                thisP.removeR(i-1);\n            }\n            _runs.clear();\n        }\n    }
967	private static DefaultRowHeightRecord createDefaultRowHeight() {\n        DefaultRowHeightRecord retval = new DefaultRowHeightRecord();\n\n        retval.setOptionFlags(( short ) 0);\n        retval.setRowHeight(DefaultRowHeightRecord.DEFAULT_ROW_HEIGHT);\n        return retval;\n    }
968	void importPart(PackageRelationship srcRel, PackagePart srcPafrt) {\n        PackagePart destPP = getPackagePart();\n        PackagePartName srcPPName = srcPafrt.getPartName();\n\n        OPCPackage pkg = destPP.getPackage();\n        if(pkg.containPart(srcPPName)){\n            // already exists\n            return;\n        }\n\n        destPP.addRelationship(srcPPName, TargetMode.INTERNAL, srcRel.getRelationshipType());\n\n        PackagePart part = pkg.createPart(srcPPName, srcPafrt.getContentType());\n        try {\n            OutputStream out = part.getOutputStream();\n            InputStream is = srcPafrt.getInputStream();\n            IOUtils.copy(is, out);\n            is.close();\n            out.close();\n        } catch (IOException e){\n            throw new POIXMLException(e);\n        }\n    }
969	public void clearDrawingGroups() {\n    	drawingGroups.clear(); \n    }
970	@Internal\n    public boolean isFHasListBox()\n    {\n        return fHasListBox.isSet(field_2_bits);\n    }
971	public void setBackwardDiagonalOn(boolean on) {\n        field_13_border_styles1 = bordTlBrLineOnOff.setBoolean(field_13_border_styles1, on);\n    }
972	protected int fillFields( byte[] data, EscherRecordFactory f )\n    {\n        return fillFields( data, 0, f );\n    }
973	public XSSFTableColumn createColumn(String columnName, int columnIndex) {\n                \n        int columnCount = getColumnCount();\n        if(columnIndex < 0 || columnIndex > columnCount) {\n            throw new IllegalArgumentException("Column index out of bounds");\n        }\n        \n        // Ensure we have Table Columns\n        CTTableColumns columns = ctTable.getTableColumns();\n        if (columns == null) {\n            columns = ctTable.addNewTableColumns();\n        }\n        \n        // check if name is unique and calculate unique column id \n        long nextColumnId = 1; \n        for (XSSFTableColumn tableColumn : getColumns()) {\n            if (columnName != null && columnName.equalsIgnoreCase(tableColumn.getName())) {\n                throw new IllegalArgumentException("Column '" + columnName\n                        + "' already exists. Column names must be unique per table.");\n            }\n            nextColumnId = Math.max(nextColumnId, tableColumn.getId());\n        }\n        \n        // Add the new Column\n        CTTableColumn column = columns.insertNewTableColumn(columnIndex);\n        columns.setCount(columns.sizeOfTableColumnArray());\n        \n        column.setId(nextColumnId);\n        if(columnName != null) {\n            column.setName(columnName); \n        } else {\n            column.setName("Column " + nextColumnId);\n        }\n        \n        if (ctTable.getRef() != null) {\n            // calculate new area\n            int newColumnCount = columnCount + 1;\n            CellReference tableStart = getStartCellReference();\n            CellReference tableEnd = getEndCellReference();\n            SpreadsheetVersion version = getXSSFSheet().getWorkbook().getSpreadsheetVersion();\n            CellReference newTableEnd = new CellReference(tableEnd.getRow(),\n                    tableStart.getCol() + newColumnCount - 1);\n            AreaReference newTableArea = new AreaReference(tableStart, newTableEnd, version);\n\n            setCellRef(newTableArea);\n        }\n        \n        updateHeaders();\n        \n        return getColumns().get(columnIndex);\n    }
974	public void setDoubleValue(String cellName, double value) {\n        log("starting setCellValue()", Project.MSG_DEBUG);\n        Cell cell = getCell(cellName);\n        log("working on cell: " + cell, Project.MSG_DEBUG);\n        cell.setCellValue(value);\n        log("after cell.setCellValue()", Project.MSG_DEBUG);\n\n        log("set cell " + cellName + " to value " + value, Project.MSG_DEBUG);\n    }
975	public List<Picture> getAllPictures() {\n    ArrayList<Picture> pictures = new ArrayList<>();\n\n    Range range = _document.getOverallRange();\n    for (int i = 0; i < range.numCharacterRuns(); i++) {\n    	CharacterRun run = range.getCharacterRun(i);\n\n        if (run==null) {\n            continue;\n        }\n\n    	Picture picture = extractPicture(run, false);\n    	if (picture != null) {\n    		pictures.add(picture);\n    	}\n	}\n\n    searchForPictures(_dgg.getEscherRecords(), pictures);\n\n    return pictures;\n  }
976	private static int performBinarySearch(ValueVector vector, LookupValueComparer lookupComparer) {\n		// both low and high indexes point to values assumed too low and too high.\n		BinarySearchIndexes bsi = new BinarySearchIndexes(vector.getSize());\n\n		while(true) {\n			int midIx = bsi.getMidIx();\n\n			if(midIx < 0) {\n				return bsi.getLowIx();\n			}\n			CompareResult cr = lookupComparer.compareTo(vector.getItem(midIx));\n			if(cr.isTypeMismatch()) {\n				int newMidIx = handleMidValueTypeMismatch(lookupComparer, vector, bsi, midIx);\n				if(newMidIx < 0) {\n					continue;\n				}\n				midIx = newMidIx;\n				cr = lookupComparer.compareTo(vector.getItem(midIx));\n			}\n			if(cr.isEqual()) {\n				return findLastIndexInRunOfEqualValues(lookupComparer, vector, midIx, bsi.getHighIx());\n			}\n			bsi.narrowSearch(midIx, cr.isLessThan());\n		}\n	}
977	@Internal\n    public boolean isFIndentSav()\n    {\n        return fIndentSav.isSet(field_3_info);\n    }
978	@Internal\n    public CTComment newComment(CellAddress ref) {\n        CTComment ct = comments.getCommentList().addNewComment();\n        ct.setRef(ref.formatAsString());\n        ct.setAuthorId(DEFAULT_AUTHOR_ID);\n        \n        if(commentRefs != null) {\n           commentRefs.put(ref, ct);\n        }\n        return ct;\n    }
979	private static String processFormatPattern(String f) {\n        String t = f.replaceAll("MMMMM", MMMMM_START_SYMBOL + "MMM" + MMMMM_TRUNCATE_SYMBOL);\n        t = t.replaceAll("\\[H]", String.valueOf(H_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[HH]", String.valueOf(HH_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[m]", String.valueOf(M_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[mm]", String.valueOf(MM_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[s]", String.valueOf(S_BRACKET_SYMBOL));\n        t = t.replaceAll("\\[ss]", String.valueOf(SS_BRACKET_SYMBOL));\n        t = t.replaceAll("s.000", "s.SSS");\n        t = t.replaceAll("s.00", "s." + LL_BRACKET_SYMBOL);\n        t = t.replaceAll("s.0", "s." + L_BRACKET_SYMBOL);\n        return t;\n    }
980	private void addLastPrinted() {\n        setElementTextContent(KEYWORD_LAST_PRINTED, namespaceCoreProperties, propsPart.getLastPrintedProperty(), propsPart.getLastPrintedPropertyString());\n	}
981	private void isCellFillPatternMatches(Locator loc1, Locator loc2) {\n        // TOOO: Check for NPE\n        FillPatternType fill1 = loc1.cell.getCellStyle().getFillPattern();\n        FillPatternType fill2 = loc2.cell.getCellStyle().getFillPattern();\n        if (fill1 != fill2) {\n            addMessage(loc1, loc2,\n                "Cell Fill pattern does not Match ::",\n                fill1.name(),\n                fill2.name()\n            );\n        }\n    }
982	static boolean isValidIndex(int index)\n    {\n        return index != _NO_INDEX;\n    }
983	public static SimpleFraction buildFractionExactDenominator(double val, int exactDenom){\n        int num =  (int)Math.round(val*exactDenom);\n        return new SimpleFraction(num,exactDenom);\n    }
984	public CellReference getFirstCell() {\n        return _firstCell;\n    }
985	public static PackagePartName createPartName(String partName)\n			throws InvalidFormatException {\n		URI partNameURI;\n		try {\n			partNameURI = toURI(partName);\n		} catch (URISyntaxException e) {\n			throw new InvalidFormatException(e.getMessage());\n		}\n		return createPartName(partNameURI);\n	}
986	@Beta\n    public void addRowLabel(int columnIndex) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        final int lastRowIndex = pivotArea.getLastCell().getRow() - pivotArea.getFirstCell().getRow();\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n        CTItems items = pivotField.addNewItems();\n\n        pivotField.setAxis(STAxis.AXIS_ROW);\n        pivotField.setShowAll(false);\n        for (int i = 0; i <= lastRowIndex; i++) {\n            items.addNewItem().setT(STItemType.DEFAULT);\n        }\n        items.setCount(items.sizeOfItemArray());\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n\n        CTRowFields rowFields;\n        if(pivotTableDefinition.getRowFields() != null) {\n            rowFields = pivotTableDefinition.getRowFields();\n        } else {\n            rowFields = pivotTableDefinition.addNewRowFields();\n        }\n\n        rowFields.addNewField().setX(columnIndex);\n        rowFields.setCount(rowFields.sizeOfFieldArray());\n    }
987	public Pointer createPointer(byte[] data, int offset) {\n        Pointer p;\n        if(version >= 6) {\n            p = new PointerV6();\n            p.setType(LittleEndian.getInt(data, offset+0));\n            p.setAddress((int)LittleEndian.getUInt(data, offset+4));\n            p.setOffset((int)LittleEndian.getUInt(data, offset+8));\n            p.setLength((int)LittleEndian.getUInt(data, offset+12));\n            p.setFormat(LittleEndian.getShort(data, offset+16));\n\n            return p;\n        } else if(version == 5) {\n            p = new PointerV5();\n            p.setType(LittleEndian.getShort(data, offset+0));\n            p.setFormat(LittleEndian.getShort(data, offset+2));\n            p.setAddress((int)LittleEndian.getUInt(data, offset+4));\n            p.setOffset((int)LittleEndian.getUInt(data, offset+8));\n            p.setLength((int)LittleEndian.getUInt(data, offset+12));\n\n            return p;\n        } else {\n            throw new IllegalArgumentException("Visio files with versions below 5 are not supported, yours was " + version);\n        }\n    }
988	public boolean isInPlaceWriteable() {\n        return (_data instanceof FileBackedDataSource) && ((FileBackedDataSource) _data).isWriteable();\n    }
989	void addDirectory(final DirectoryProperty directory)\n    {\n        _property_table.addProperty(directory);\n    }
990	public void setOurBlockIndex(int index) {\n       this.ourBlockIndex = index;\n    }
991	private Set<ValueAndFormat> getMeaningfulValues(CellRangeAddress region, boolean withText, ValueFunction func) {\n        Set<ValueAndFormat> values = meaningfulRegionValues.get(region);\n        if (values != null) {\n            return values;\n        }\n        \n        List<ValueAndFormat> allValues = new ArrayList<>((region.getLastColumn() - region.getFirstColumn() + 1) * (region.getLastRow() - region.getFirstRow() + 1));\n        \n        for (int r=region.getFirstRow(); r <= region.getLastRow(); r++) {\n            final Row row = sheet.getRow(r);\n            if (row == null) {\n                continue;\n            }\n            for (int c = region.getFirstColumn(); c <= region.getLastColumn(); c++) {\n                Cell cell = row.getCell(c);\n                final ValueAndFormat cv = getCellValue(cell);\n                if (withText || cv.isNumber()) {\n                    allValues.add(cv);\n                }\n            }\n        }\n        \n        values = func.evaluate(allValues);\n        meaningfulRegionValues.put(region, values);\n        \n        return values;\n    }
992	int getSatMod(){\n        return getPercentageValue("satMod");\n    }
993	public CFRecordsAggregate cloneCFAggregate() {\n        CFRuleBase[] newRecs = new CFRuleBase[rules.size()];\n        for (int i = 0; i < newRecs.length; i++) {\n            newRecs[i] = getRule(i).clone();\n        }\n        return new CFRecordsAggregate(header.clone(), newRecs);\n    }
994	public PackageRelationship addRelationship(URI targetUri,\n            TargetMode targetMode, String relationshipType, String id) {\n      if (id == null) {\n         // Generate a unique ID is id parameter is null.\n         if (nextRelationshipId == -1) {\n            nextRelationshipId = size() + 1;\n         }\n\n         // Work up until we find a unique number (there could be gaps etc)\n         do {\n            id = "rId" + nextRelationshipId++;\n         } while (relationshipsByID.get(id) != null);\n      }\n\n        PackageRelationship rel = new PackageRelationship(container,\n                sourcePart, targetUri, targetMode, relationshipType, id);\n        addRelationship(rel);\n        if (targetMode == TargetMode.INTERNAL){\n            internalRelationshipsByTargetName.put(targetUri.toASCIIString(), rel);\n        }\n        return rel;\n    }
995	protected static OPCPackage newPackage() {\n        try {\n            OPCPackage pkg = OPCPackage.create(new ByteArrayOutputStream());    // NOSONAR - we do not want to close this here\n            // Main part\n            PackagePartName corePartName = PackagingURIHelper.createPartName(XWPFRelation.DOCUMENT.getDefaultFileName());\n            // Create main part relationship\n            pkg.addRelationship(corePartName, TargetMode.INTERNAL, PackageRelationshipTypes.CORE_DOCUMENT);\n            // Create main document part\n            pkg.createPart(corePartName, XWPFRelation.DOCUMENT.getContentType());\n\n            pkg.getPackageProperties().setCreatorProperty(DOCUMENT_CREATOR);\n\n            return pkg;\n        } catch (Exception e) {\n            throw new POIXMLException(e);\n        }\n    }
996	public void clearStyles() {\n        paragraphStyles.clear();\n        charStyles.clear();\n        reserved = new byte[0];\n        initialised = true;\n    }
997	public void addSlideListWithText(SlideListWithText slwt) {\n		// The new SlideListWithText should go in\n		//  just before the EndDocumentRecord\n		Record endDoc = _children[_children.length - 1];\n		if(endDoc.getRecordType() == RecordTypes.RoundTripCustomTableStyles12Atom.typeID) {\n		    // last record can optionally be a RoundTripCustomTableStyles12Atom\n		    endDoc = _children[_children.length - 2];\n		}\n		if(endDoc.getRecordType() != RecordTypes.EndDocument.typeID) {\n			throw new IllegalStateException("The last child record of a Document should be EndDocument, but it was " + endDoc);\n		}\n\n		// Add in the record\n		addChildBefore(slwt, endDoc);\n\n		// Updated our cached list of SlideListWithText records\n		int newSize = slwts.length + 1;\n		SlideListWithText[] nl = new SlideListWithText[newSize];\n		System.arraycopy(slwts, 0, nl, 0, slwts.length);\n		nl[nl.length-1] = slwt;\n		slwts = nl;\n	}
998	private static SelectionRecord createSelection() {\n        return new SelectionRecord(0, 0);\n    }
999	private void convertToCSV() {\n        Sheet sheet;\n        Row row;\n        int lastRowNum;\n        this.csvData = new ArrayList<>();\n\n        System.out.println("Converting files contents to CSV format.");\n\n        // Discover how many sheets there are in the workbook....\n        int numSheets = this.workbook.getNumberOfSheets();\n\n        // and then iterate through them.\n        for(int i = 0; i < numSheets; i++) {\n\n            // Get a reference to a sheet and check to see if it contains\n            // any rows.\n            sheet = this.workbook.getSheetAt(i);\n            if(sheet.getPhysicalNumberOfRows() > 0) {\n\n                // Note down the index number of the bottom-most row and\n                // then iterate through all of the rows on the sheet starting\n                // from the very first row - number 1 - even if it is missing.\n                // Recover a reference to the row and then call another method\n                // which will strip the data from the cells and build lines\n                // for inclusion in the resylting CSV file.\n                lastRowNum = sheet.getLastRowNum();\n                for(int j = 0; j <= lastRowNum; j++) {\n                    row = sheet.getRow(j);\n                    this.rowToCSV(row);\n                }\n            }\n        }\n    }
1000	public static synchronized DocumentBuilder newDocumentBuilder() {\n        try {\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n            documentBuilder.setEntityResolver(SAXHelper.IGNORING_ENTITY_RESOLVER);\n            documentBuilder.setErrorHandler(new DocHelperErrorHandler());\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException("cannot create a DocumentBuilder", e);\n        }\n    }
1001	protected static CTConnector prototype() {\n        if(prototype == null) {\n            CTConnector shape = CTConnector.Factory.newInstance();\n            CTConnectorNonVisual nv = shape.addNewNvCxnSpPr();\n            CTNonVisualDrawingProps nvp = nv.addNewCNvPr();\n            nvp.setId(1);\n            nvp.setName("Shape 1");\n            nv.addNewCNvCxnSpPr();\n\n            CTShapeProperties sp = shape.addNewSpPr();\n            CTTransform2D t2d = sp.addNewXfrm();\n            CTPositiveSize2D p1 = t2d.addNewExt();\n            p1.setCx(0);\n            p1.setCy(0);\n            CTPoint2D p2 = t2d.addNewOff();\n            p2.setX(0);\n            p2.setY(0);\n\n            CTPresetGeometry2D geom = sp.addNewPrstGeom();\n            geom.setPrst(STShapeType.LINE);\n            geom.addNewAvLst();\n\n            CTShapeStyle style = shape.addNewStyle();\n            CTSchemeColor scheme = style.addNewLnRef().addNewSchemeClr();\n            scheme.setVal(STSchemeColorVal.ACCENT_1);\n            style.getLnRef().setIdx(1);\n\n            CTStyleMatrixReference fillref = style.addNewFillRef();\n            fillref.setIdx(0);\n            fillref.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);\n\n            CTStyleMatrixReference effectRef = style.addNewEffectRef();\n            effectRef.setIdx(0);\n            effectRef.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);\n\n            CTFontReference fontRef = style.addNewFontRef();\n            fontRef.setIdx(STFontCollectionIndex.MINOR);\n            fontRef.addNewSchemeClr().setVal(STSchemeColorVal.TX_1);\n\n            prototype = shape;\n        }\n        return prototype;\n    }
1002	@Internal\n    public boolean isFOle2()\n    {\n        return fOle2.isSet(field_1_grpfChp);\n    }
1003	static int[] buildTableCellEdgesArray( Table table )\n    {\n        Set<Integer> edges = new TreeSet<>();\n\n        for ( int r = 0; r < table.numRows(); r++ )\n        {\n            TableRow tableRow = table.getRow( r );\n            for ( int c = 0; c < tableRow.numCells(); c++ )\n            {\n                TableCell tableCell = tableRow.getCell( c );\n\n                edges.add( Integer.valueOf( tableCell.getLeftEdge() ) );\n                edges.add( Integer.valueOf( tableCell.getLeftEdge()\n                        + tableCell.getWidth() ) );\n            }\n        }\n\n        Integer[] sorted = edges.toArray( new Integer[edges.size()] );\n        int[] result = new int[sorted.length];\n        for ( int i = 0; i < sorted.length; i++ )\n        {\n            result[i] = sorted[i].intValue();\n        }\n\n        return result;\n    }
1004	private static WSBoolRecord createWSBool() {\n        WSBoolRecord retval = new WSBoolRecord();\n\n        retval.setWSBool1(( byte ) 0x4);\n        retval.setWSBool2(( byte ) 0xffffffc1);\n        return retval;\n    }
1005	public String getRecipientName() {\n        if (recipientNameChunk != null) {\n            return recipientNameChunk.getValue();\n        }\n        if (recipientDisplayNameChunk != null) {\n            return recipientDisplayNameChunk.getValue();\n        }\n\n        // Can't find it\n        return null;\n    }
1006	@SuppressWarnings({"unused", "WeakerAccess"})\n    public static boolean isPropertySetStream(final byte[] src, final int offset, final int length) {\n        LittleEndianByteArrayInputStream leis = new LittleEndianByteArrayInputStream(src, offset, length);\n\n        /*\n         * Read the header fields of the stream. They must always be\n         * there.\n         */\n        try {\n            final int byteOrder = leis.readUShort();\n            if (byteOrder != BYTE_ORDER_ASSERTION) {\n                return false;\n            }\n            final int format = leis.readUShort();\n            if (format != FORMAT_ASSERTION) {\n                return false;\n            }\n            final long osVersion = leis.readUInt();\n            byte[] clsBuf = new byte[ClassID.LENGTH];\n            leis.readFully(clsBuf);\n\n            final ClassID classID = new ClassID(clsBuf, 0);\n\n            final long sectionCount = leis.readUInt();\n            return (sectionCount >= 0);\n        } catch (RuntimeException e) {\n            return false;\n        }\n    }
1007	public static XMLOutputFactory newXMLOutputFactory() {\n        XMLOutputFactory factory = XMLOutputFactory.newFactory();\n        trySetProperty(factory, XMLOutputFactory.IS_REPAIRING_NAMESPACES, true);\n        return factory;\n    }
1008	public String getDateTimeText(){\n        CString cs = _container == null ? null : _container.getUserDateAtom();\n        return getPlaceholderText(Placeholder.DATETIME, cs);\n    }
1009	public void resize(Rectangle2D target, RectAlign align) {\n        PictureShape<?,?> ps = getShape();\n        Dimension dim = ps.getPictureData().getImageDimension();\n        if (dim.width <= 0 || dim.height <= 0) {\n            // nothing useful to be done for this case\n            ps.setAnchor(target);\n            return;\n        }\n\n        double w = target.getWidth();\n        double h = target.getHeight();\n\n        // scaling\n        double sx = w / dim.width;\n        double sy = h / dim.height;\n\n        // position adjustments\n        double dx = 0, dy = 0;\n\n        if (sx > sy) {\n            // use y-scaling for both, reposition x accordingly\n            w  = sy * dim.width;\n            dx = target.getWidth() - w;\n        } else if (sy > sx) {\n            // use x-scaling for both, reposition y accordingly\n            h  = sx * dim.height;\n            dy = target.getHeight() - h;\n        } else {\n            // uniform scaling, can use target values directly\n            ps.setAnchor(target);\n            return;\n        }\n\n        // the positioning\n        double x = target.getX();\n        double y = target.getY();\n        switch (align) {\n            case TOP:           // X=balance, Y=ok\n                x += dx/2;\n                break;\n            case TOP_RIGHT:     // X=shift, Y=ok\n                x += dx;\n                break;\n            case RIGHT:         // X=shift, Y=balance\n                x += dx;\n                y += dy/2;\n                break;\n            case BOTTOM_RIGHT:  // X=shift, Y=shift\n                x += dx;\n                y += dy;\n                break;\n            case BOTTOM:        // X=balance, Y=shift\n                x += dx/2;\n                y += dy;\n                break;\n            case BOTTOM_LEFT:   // X=ok, Y=shift\n                y += dy;\n                break;\n            case LEFT:          // X=ok, Y=balance\n                y += dy/2;\n                break;\n            case TOP_LEFT:      // X=ok, Y=ok\n                /* no-op */\n                break;\n            default:            // CENTER: X=balance, Y=balance\n                x += dx/2;\n                y += dy/2;\n                break;\n        }\n\n        ps.setAnchor(new Rectangle2D.Double(x, y, w, h));\n    }
1010	private String performDateFormatting(Date d, Format dateFormat) {\n       return (dateFormat != null ? dateFormat : defaultDateformat).format(d);\n    }
1011	private void outHex( int bytes, InputStream in, PrintStream out ) throws IOException, LittleEndian.BufferUnderrunException\n    {\n        switch ( bytes )\n        {\n            case 1:\n                out.print( HexDump.toHex( (byte) in.read() ) );\n                break;\n            case 2:\n                out.print( HexDump.toHex( LittleEndian.readShort( in ) ) );\n                break;\n            case 4:\n                out.print( HexDump.toHex( LittleEndian.readInt( in ) ) );\n                break;\n            default:\n                throw new IOException( "Unable to output variable of that width" );\n        }\n    }
1012	public static int createXorKey1(String password) {\n        // the xor key for method 1 is part of the verifier for method 2\n        // so we simply chop it from there\n        return createXorVerifier2(password) >>> 16;\n    }
1013	public void setCapitals(CapsType caps) {\n        getOrCreateProperties().setCapitals(caps);\n    }
1014	public boolean isInRange(int rowInd, int colInd) {\n		return _firstRow <= rowInd && rowInd <= _lastRow && //containsRow\n				_firstCol <= colInd && colInd <= _lastCol; //containsColumn\n	}
1015	public HSSFColorScaleFormatting createColorScaleFormatting() {\n        return getColorScaleFormatting(true);\n    }
1016	public String getName() {\n        return _cell.getN();\n    }
1017	public String signDigest(final DOMSignContext xmlSignContext, final DOMSignedInfo signedInfo) {\n        final PrivateKey key = signatureConfig.getKey();\n        final HashAlgorithm algo = signatureConfig.getDigestAlgo();\n\n        if (algo.hashSize*4/3 > Base64.BASE64DEFAULTLENGTH && !XMLUtils.ignoreLineBreaks()) {\n            throw new EncryptedDocumentException("The hash size of the choosen hash algorithm ("+algo+" = "+algo.hashSize+" bytes), "+\n                "will motivate XmlSec to add linebreaks to the generated digest, which results in an invalid signature (... at least "+\n                "for Office) - please persuade it otherwise by adding '-Dorg.apache.xml.security.ignoreLineBreaks=true' to the JVM "+\n                "system properties.");\n        }\n        \n        try (final DigestOutputStream dos = getDigestStream(algo, key)) {\n            dos.init();\n\n            final Document document = (Document)xmlSignContext.getParent();\n            final Element el = getDsigElement(document, "SignedInfo");\n            final DOMSubTreeData subTree = new DOMSubTreeData(el, true);\n            signedInfo.getCanonicalizationMethod().transform(subTree, xmlSignContext, dos);\n\n            return DatatypeConverter.printBase64Binary(dos.sign());\n        } catch (GeneralSecurityException|IOException|TransformException e) {\n            throw new EncryptedDocumentException(e);\n        }\n    }
1018	protected void copyBlockHeaderToContents() {\n		if(blockHeaderInContents) return;\n\n		prependContentsWith(blockHeader);\n		blockHeaderInContents = true;\n	}
1019	public boolean getTopBorder() {\n    	return topBorder.isSet(field_8_option_flags);\n    }
1020	private static void setEdges(TableCell<?,?> cell, BorderEdge edges[], Object... args) {\n        if (cell == null) {\n            return;\n        }\n        for (BorderEdge be : edges) {\n            if (be != null) {\n                if (args.length == 0) {\n                    cell.removeBorder(be);\n                } else {\n                    for (Object o : args) {\n                        if (o instanceof Double) {\n                            cell.setBorderWidth(be, (Double)o);\n                        } else if (o instanceof Color) {\n                            cell.setBorderColor(be, (Color)o);\n                        } else if (o instanceof LineDash) {\n                            cell.setBorderDash(be, (LineDash)o);\n                        } else if (o instanceof LineCompound) {\n                            cell.setBorderCompound(be, (LineCompound)o);\n                        }\n                    }\n                }\n            }\n        }\n    }
1021	private void parse() {\n        _pointer=0;\n        GetChar();\n        _rootNode = unionExpression();\n\n        if(_pointer <= _formulaLength) {\n            String msg = "Unused input [" + _formulaString.substring(_pointer-1)\n                + "] after attempting to parse the formula [" + _formulaString + "]";\n            throw new FormulaParseException(msg);\n        }\n    }
1022	private void isCellContentMatchesForFormula(Locator loc1, Locator loc2) {\n        // TODO: actually evaluate the formula / NPE checks\n        String form1 = loc1.cell.getCellFormula();\n        String form2 = loc2.cell.getCellFormula();\n        if (!form1.equals(form2)) {\n            addMessage(loc1, loc2, CELL_DATA_DOES_NOT_MATCH, form1, form2);\n        }\n    }
1023	private void addUnknownRecord(Record rec) {\n        // ony a few distinct record IDs are encountered by the existing POI test cases:\n        // 0x1065 // many\n        // 0x01C2 // several\n        // 0x0034 // few\n        // No documentation could be found for these\n\n        // keep the unknown records for re-serialization\n        _unknownRecords.add(rec);\n    }
1024	private static double evaluate(int year, int month, int pDay) throws EvaluationException {\n	   // We don't support negative years yet\n		if (year < 0) {\n			throw new EvaluationException(ErrorEval.VALUE_INVALID);\n		}\n		// Negative months are fairly easy\n		while (month < 0) {\n		   year--;\n		   month += 12;\n		}\n		// Negative days are handled by the Java Calendar\n		\n		// Excel has bugs around leap years in 1900, handle them\n		// Special case for the non-existant 1900 leap year\n		if (year == 1900 && month == Calendar.FEBRUARY && pDay == 29) {\n			return 60.0;\n		}\n\n		// If they give a date in 1900 in Jan/Feb, with the days\n		//  putting it past the leap year, adjust\n		int day = pDay;\n		if (year == 1900) {\n			if ((month == Calendar.JANUARY && day >= 60) ||\n					(month == Calendar.FEBRUARY && day >= 30)) {\n				day--;\n			}\n		}\n\n		// Turn this into a Java date\n		Calendar c = LocaleUtil.getLocaleCalendar(year, month, day);\n		\n		// Handle negative days of the week, that pull us across\n		//  the 29th of Feb 1900\n		if (pDay < 0 && c.get(Calendar.YEAR) == 1900 &&\n		      month > Calendar.FEBRUARY && \n		      c.get(Calendar.MONTH) < Calendar.MARCH) {\n		   c.add(Calendar.DATE, 1);\n		}\n\n		// TODO Identify if we're doing 1900 or 1904 date windowing\n		boolean use1904windowing = false;\n		\n		// Have this Java date turned back into an Excel one\n		return DateUtil.getExcelDate(c.getTime(), use1904windowing);\n	}
1025	public static void putShortArray( byte[] data, int startOffset,\n            short[] value )\n    {\n        int offset = startOffset;\n        for ( short s : value )\n        {\n            putShort( data, offset, s );\n            offset += SHORT_SIZE;\n        }\n    }
1026	protected void updateCellNum(short num)\n    {\n        _record.setColumn(num);\n    }
1027	protected void init(boolean onlyValidation) {\n        if (opcPackage == null) {\n            throw new EncryptedDocumentException("opcPackage is null");\n        }\n        if (uriDereferencer == null) {\n            uriDereferencer = new OOXMLURIDereferencer();\n        }\n        if (uriDereferencer instanceof SignatureConfigurable) {\n            ((SignatureConfigurable)uriDereferencer).setSignatureConfig(this);\n        }\n        if (namespacePrefixes.isEmpty()) {\n            /*\n             * OOo doesn't like ds namespaces so per default prefixing is off.\n             */\n            // namespacePrefixes.put(XML_DIGSIG_NS, "");\n            namespacePrefixes.put(OO_DIGSIG_NS, "mdssi");\n            namespacePrefixes.put(XADES_132_NS, "xd");\n        }\n        \n        if (onlyValidation) {\n            return;\n        }\n\n        if (signatureMarshalListener == null) {\n            signatureMarshalListener = new SignatureMarshalListener();\n        }\n        \n        if (signatureMarshalListener instanceof SignatureConfigurable) {\n            ((SignatureConfigurable)signatureMarshalListener).setSignatureConfig(this);\n        }\n        \n        if (tspService != null) {\n            tspService.setSignatureConfig(this);\n        }\n        \n        if (signatureFacets.isEmpty()) {\n            addSignatureFacet(new OOXMLSignatureFacet());\n            addSignatureFacet(new KeyInfoSignatureFacet());\n            addSignatureFacet(new XAdESSignatureFacet());\n            addSignatureFacet(new Office2010SignatureFacet());\n        }\n\n        for (SignatureFacet sf : signatureFacets) {\n            sf.setSignatureConfig(this);\n        }\n    }
1028	public PackagePart put(final PackagePartName partName, final PackagePart part) {\n	    final String ppName = partName.getName();\n        final StringBuilder concatSeg = new StringBuilder();\n        // split at slash, but keep leading slash\n        final String delim = "(?=["+PackagingURIHelper.FORWARD_SLASH_STRING+".])";\n		for (String seg : ppName.split(delim)) {\n			concatSeg.append(seg);\n			if (registerPartNameStr.contains(concatSeg.toString())) {\n				throw new InvalidOperationException(\n					"You can't add a part with a part name derived from another part ! [M1.11]");\n			}\n		}\n		registerPartNameStr.add(ppName);\n		return packagePartLookup.put(ppName, part);\n	}
1029	protected void generateData() {\n		int size = 0;\n		for(int i=0; i<records.length; i++) {\n			size += records[i].getRecordSize();\n		}\n\n		byte data[] = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n		size = 0;\n		for(int i=0; i<records.length; i++) {\n			int thisSize =\n				records[i].serialize(size, data);\n			size += thisSize;\n		}\n		\n		setData(data);\n	}
1030	public static void setExcelStyleRoundingMode(DecimalFormat format, RoundingMode roundingMode) {\n       format.setRoundingMode(roundingMode);\n    }
1031	public boolean isAutoXPositioning()\n    {\n        return autoXPositioning.isSet(field_7_options);\n    }
1032	static void formatDuplicates(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Code");\n        sheet.createRow(1).createCell(0).setCellValue(4);\n        sheet.createRow(2).createCell(0).setCellValue(3);\n        sheet.createRow(3).createCell(0).setCellValue(6);\n        sheet.createRow(4).createCell(0).setCellValue(3);\n        sheet.createRow(5).createCell(0).setCellValue(5);\n        sheet.createRow(6).createCell(0).setCellValue(8);\n        sheet.createRow(7).createCell(0).setCellValue(0);\n        sheet.createRow(8).createCell(0).setCellValue(2);\n        sheet.createRow(9).createCell(0).setCellValue(8);\n        sheet.createRow(10).createCell(0).setCellValue(6);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =A2=A1   (White Font)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("COUNTIF($A$2:$A$11,A2)>1");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontStyle(false, true);\n        font.setFontColorIndex(IndexedColors.BLUE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A11")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(2).createCell(1).setCellValue("<== Duplicates numbers in the column are highlighted.  " +\n                "Condition: Formula Is =COUNTIF($A$2:$A$11,A2)>1   (Blue Font)");\n    }
1033	public boolean isXadesIssuerNameNoReverseOrder() {\n        return xadesIssuerNameNoReverseOrder;\n    }
1034	public void setEmpty() {\n        field_2_first_col = 0;\n        field_3_last_col = 0;\n    }
1035	public String getRecipientEmailAddress() {\n        // If we have this, it really has the email\n        if (recipientSMTPChunk != null) {\n            return recipientSMTPChunk.getValue();\n        }\n\n        // This might be a real email, or might be\n        // in CN=... format\n        if (recipientEmailChunk != null) {\n            String email = recipientEmailChunk.getValue();\n            int cne = email.indexOf("/CN=");\n            if (cne < 0) {\n                // Normal smtp address\n                return email;\n            } else {\n                // /O=..../CN=em@ail\n                return email.substring(cne + 4);\n            }\n        }\n\n        // Might be in the name field, check there\n        if (recipientNameChunk != null) {\n            String name = recipientNameChunk.getValue();\n            if (name.contains("@")) {\n                // Strip leading and trailing quotes if needed\n                if (name.startsWith("'") && name.endsWith("'")) {\n                    return name.substring(1, name.length() - 1);\n                }\n                return name;\n            }\n        }\n\n        // Check the search chunk, see if it's\n        // encoded as a SMTP destination in there.\n        if (recipientSearchChunk != null) {\n            String search = recipientSearchChunk.getAs7bitString();\n            int idx = search.indexOf("SMTP:");\n            if (idx >= 0) {\n                return search.substring(idx + 5);\n            }\n        }\n\n        // Can't find it\n        return null;\n    }
1036	public boolean getObjectProtect() {\n        return getProtectionBlock().isObjectProtected();\n    }
1037	public void clear() {\n		if(_evaluationListener != null) {\n			_evaluationListener.onClearWholeCache();\n		}\n		_plainCellCache.clear();\n		_formulaCellCache.clear();\n	}
1038	public void setConcatenatePhoneticRuns(boolean concatenatePhoneticRuns) {\n        this.concatenatePhoneticRuns = concatenatePhoneticRuns;\n    }
1039	public int getX2() {\n        return _spgrRecord.getRectX2();\n    }
1040	@Internal\n    public boolean isFLoadOverridePage()\n    {\n        return fLoadOverridePage.isSet(field_10_flags2);\n    }
1041	public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (getClass() != other.getClass()) return false;\n        \n        TextPropCollection o = (TextPropCollection)other;\n        if (o.maskSpecial != this.maskSpecial || o.indentLevel != this.indentLevel) {\n            return false;\n        }\n\n        return textProps.equals(o.textProps);\n    }
1042	public static byte[] splitRGB(int rgb) {\n		byte[] ret = new byte[3];\n\n		// Serialise to bytes, then grab the right ones out\n		ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		try {\n			writeLittleEndian(rgb,baos);\n		} catch(IOException ie) {\n			// Should never happen\n			throw new HSLFException(ie);\n		}\n		byte[] b = baos.toByteArray();\n		System.arraycopy(b,0,ret,0,3);\n\n		return ret;\n	}
1043	public BigInteger addNum(XWPFNum num) {\n        ctNumbering.addNewNum();\n        int pos = ctNumbering.sizeOfNumArray() - 1;\n        ctNumbering.setNumArray(pos, num.getCTNum());\n        nums.add(num);\n        return num.getCTNum().getNumId();\n    }
1044	private static void verifyZipHeader(InputStream stream) throws NotOfficeXmlFileException, IOException {\n        InputStream is = FileMagic.prepareToCheckMagic(stream);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        switch (fm) {\n        case OLE2:\n            throw new OLE2NotOfficeXmlFileException(\n                "The supplied data appears to be in the OLE2 Format. " +\n                "You are calling the part of POI that deals with OOXML "+\n                "(Office Open XML) Documents. You need to call a different " +\n                "part of POI to process this data (eg HSSF instead of XSSF)");\n        case XML:\n            throw new NotOfficeXmlFileException(\n                "The supplied data appears to be a raw XML file. " +\n                "Formats such as Office 2003 XML are not supported");\n        default:\n        case OOXML:\n        case UNKNOWN:\n            // Don't check for a Zip header, as to maintain backwards\n            //  compatibility we need to let them seek over junk at the\n            //  start before beginning processing.\n            break;\n        }\n    }
1045	private Record getCoreRecordForRefID(int refID) {\n		Integer coreRecordId = _sheetIdToCoreRecordsLookup.get(refID);\n		if (coreRecordId != null) {\n			return _mostRecentCoreRecords[coreRecordId];\n		}\n		logger.log(POILogger.ERROR,\n				"We tried to look up a reference to a core record, but there was no core ID for reference ID "\n						+ refID);\n		return null;\n	}
1046	public String simpleFormat(Object value) {\n        StringBuffer sb = new StringBuffer();\n        simpleValue(sb, value);\n        return sb.toString();\n    }
1047	private static void copy(OPCPackage pkg, PackagePart part, OPCPackage tgt, PackagePart part_tgt) throws OpenXML4JException, IOException {\n        PackageRelationshipCollection rels = part.getRelationships();\n        if(rels != null) for (PackageRelationship rel : rels) {\n            PackagePart p;\n            if(rel.getTargetMode() == TargetMode.EXTERNAL){\n                part_tgt.addExternalRelationship(rel.getTargetURI().toString(), rel.getRelationshipType(), rel.getId());\n                //external relations don't have associated package parts\n                continue;\n            }\n            URI uri = rel.getTargetURI();\n\n            if(uri.getRawFragment() != null) {\n                part_tgt.addRelationship(uri, rel.getTargetMode(), rel.getRelationshipType(), rel.getId());\n                continue;\n            }\n            PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n            p = pkg.getPart(relName);\n            part_tgt.addRelationship(p.getPartName(), rel.getTargetMode(), rel.getRelationshipType(), rel.getId());\n\n            PackagePart dest;\n            if(!tgt.containPart(p.getPartName())){\n                dest = tgt.createPart(p.getPartName(), p.getContentType());\n                OutputStream out = dest.getOutputStream();\n                IOUtils.copy(p.getInputStream(), out);\n                out.close();\n                copy(pkg, p, tgt, dest);\n            }\n        }\n    }
1048	@Internal\n    public boolean isFChsDiff()\n    {\n        return fChsDiff.isSet(field_49_CharsetFlags);\n    }
1049	public static DocumentSummaryInformation newDocumentSummaryInformation() {\n        return new DocumentSummaryInformation();\n    }
1050	private String valueToAlpha(int value) {\n        String alpha = "";\n        int modulo;\n        while (value > 0) {\n            modulo = (value - 1) % 26;\n            alpha = (char) (65 + modulo) + alpha;\n            value = (value - modulo) / 26;\n        }\n        return alpha;\n    }
1051	public void setRow1( short field_4_row1 )\n    {\n        this.field_4_row1 = field_4_row1;\n    }
1052	@Internal\n    public boolean isFKeepFollow()\n    {\n        return fKeepFollow.isSet(field_13_widthAndFitsFlags);\n    }
1053	public static void setFont(Cell cell, Font font) {\n        // Check if font belongs to workbook\n        Workbook wb = cell.getSheet().getWorkbook();\n        final int fontIndex = font.getIndexAsInt();\n        if (!wb.getFontAt(fontIndex).equals(font)) {\n            throw new IllegalArgumentException("Font does not belong to this workbook");\n        }\n\n        // Check if cell belongs to workbook\n        // (checked in setCellStyleProperty)\n\n        setCellStyleProperty(cell, FONT, fontIndex);\n    }
1054	private static GutsRecord createGuts() {\n        GutsRecord retval = new GutsRecord();\n\n        retval.setLeftRowGutter(( short ) 0);\n        retval.setTopColGutter(( short ) 0);\n        retval.setRowLevelMax(( short ) 0);\n        retval.setColLevelMax(( short ) 0);\n        return retval;\n    }
1055	public ValueEval evaluate(String sheetName, int rowIndex, int columnIndex) {\n		EvaluationCell cell = _sewb.getEvaluationCell(sheetName, rowIndex, columnIndex);\n\n		switch (cell.getCellType()) {\n			case BOOLEAN:\n				return BoolEval.valueOf(cell.getBooleanCellValue());\n			case ERROR:\n				return ErrorEval.valueOf(cell.getErrorCellValue());\n			case FORMULA:\n				return _evaluator.evaluate(cell);\n			case NUMERIC:\n				return new NumberEval(cell.getNumericCellValue());\n			case STRING:\n				return new StringEval(cell.getStringCellValue());\n			case BLANK:\n				return null;\n			default:\n				throw new IllegalStateException("Bad cell type (" + cell.getCellType() + ")");\n		}\n	}
1056	public void overwrite(byte[] b, int startPos) {}
1057	static void unCompressCHPOperation (CharacterProperties oldCHP,\n                                      CharacterProperties newCHP,\n                                      SprmOperation sprm)\n  {\n\n    switch (sprm.getOperation())\n    {\n      case 0:\n        newCHP.setFRMarkDel (getFlag (sprm.getOperand()));\n        break;\n      case 0x1:\n        newCHP.setFRMark (getFlag (sprm.getOperand()));\n        break;\n      case 0x2:\n        newCHP.setFFldVanish (getFlag (sprm.getOperand()));\n        break;\n        case 0x3:\n            // sprmCPicLocation -- 0x6A03\n            /*\n             * [MS-DOC]\n             * \n             * Page 104 of 622\n             * \n             * A signed 32-bit integer that specifies either the position in the\n             * Data Stream of a picture or binary data or the name of an OLE\n             * object storage.\n             */\n            newCHP.setFcPic( sprm.getOperand() );\n            newCHP.setFSpec( true );\n            break;\n      case 0x4:\n        newCHP.setIbstRMark ((short) sprm.getOperand());\n        break;\n      case 0x5:\n        newCHP.setDttmRMark (new DateAndTime(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x6:\n        newCHP.setFData (getFlag (sprm.getOperand()));\n        break;\n      case 0x7:\n        //don't care about this\n        break;\n      case 0x8:\n        //short chsDiff = (short)((param & 0xff0000) >>> 16);\n        int operand =sprm.getOperand();\n        short chsDiff = (short) (operand & 0x0000ff);\n        newCHP.setFChsDiff (getFlag (chsDiff));\n        newCHP.setChse ((short) (operand & 0xffff00));\n        break;\n      case 0x9:\n        newCHP.setFSpec (true);\n        newCHP.setFtcSym (LittleEndian.getShort (sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        newCHP.setXchSym (LittleEndian.getShort (sprm.getGrpprl(), sprm.getGrpprlOffset() + 2));\n        break;\n      case 0xa:\n        newCHP.setFOle2 (getFlag (sprm.getOperand()));\n        break;\n      case 0xb:\n\n        // Obsolete\n        break;\n      case 0xc:\n        newCHP.setIcoHighlight ((byte) sprm.getOperand());\n        newCHP.setFHighlight (getFlag (sprm.getOperand()));\n        break;\n      case 0xd:\n\n        //	undocumented\n        break;\n      case 0xe:\n        newCHP.setFcObj (sprm.getOperand());\n        break;\n      case 0xf:\n\n        // undocumented\n        break;\n      case 0x10:\n\n        // undocumented\n        break;\n\n        // undocumented till 0x30\n\n      case 0x11:\n        // sprmCFWebHidden\n        break;\n      case 0x12:\n        break;\n      case 0x13:\n        break;\n      case 0x14:\n        break;\n      case 0x15:\n        // sprmCRsidProp\n        break;\n      case 0x16:\n        // sprmCRsidText\n        break;\n      case 0x17:\n        // sprmCRsidRMDel\n        break;\n      case 0x18:\n        // sprmCFSpecVanish\n        break;\n      case 0x19:\n        break;\n      case 0x1a:\n        // sprmCFMathPr\n        break;\n      case 0x1b:\n        break;\n      case 0x1c:\n        break;\n      case 0x1d:\n        break;\n      case 0x1e:\n        break;\n      case 0x1f:\n        break;\n      case 0x20:\n        break;\n      case 0x21:\n        break;\n      case 0x22:\n        break;\n      case 0x23:\n        break;\n      case 0x24:\n        break;\n      case 0x25:\n        break;\n      case 0x26:\n        break;\n      case 0x27:\n        break;\n      case 0x28:\n        break;\n      case 0x29:\n        break;\n      case 0x2a:\n        break;\n      case 0x2b:\n        break;\n      case 0x2c:\n        break;\n      case 0x2d:\n        break;\n      case 0x2e:\n        break;\n      case 0x2f:\n        break;\n        case 0x30:\n            newCHP.setIstd( sprm.getOperand() );\n            // 0x30 is supported by uncompressCHP(...)\n            break;\n      case 0x31:\n\n        //permutation vector for fast saves, who cares!\n        break;\n      case 0x32:\n        newCHP.setFBold (false);\n        newCHP.setFItalic (false);\n        newCHP.setFOutline (false);\n        newCHP.setFStrike (false);\n        newCHP.setFShadow (false);\n        newCHP.setFSmallCaps (false);\n        newCHP.setFCaps (false);\n        newCHP.setFVanish (false);\n        newCHP.setKul ((byte) 0);\n        newCHP.setIco ((byte) 0);\n        break;\n        case 0x33:\n            // preserve the fSpec setting from the original CHP\n            boolean fSpec = newCHP.isFSpec();\n            newCHP = oldCHP.clone();\n            newCHP.setFSpec( fSpec );\n            return;\n      case 0x34:\n        // sprmCKcd\n        break;\n      case 0x35:\n        newCHP.setFBold (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFBold ()));\n        break;\n      case 0x36:\n        newCHP.setFItalic (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFItalic ()));\n        break;\n      case 0x37:\n        newCHP.setFStrike (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFStrike ()));\n        break;\n      case 0x38:\n        newCHP.setFOutline (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFOutline ()));\n        break;\n      case 0x39:\n        newCHP.setFShadow (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFShadow ()));\n        break;\n      case 0x3a:\n        newCHP.setFSmallCaps (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFSmallCaps ()));\n        break;\n      case 0x3b:\n        newCHP.setFCaps (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFCaps ()));\n        break;\n      case 0x3c:\n        newCHP.setFVanish (getCHPFlag ((byte) sprm.getOperand(), oldCHP.isFVanish ()));\n        break;\n      case 0x3d:\n        newCHP.setFtcAscii ((short) sprm.getOperand());\n        break;\n      case 0x3e:\n        newCHP.setKul ((byte) sprm.getOperand());\n        break;\n      case 0x3f:\n        operand = sprm.getOperand();\n        int hps = operand & 0xff;\n        if (hps != 0)\n        {\n          newCHP.setHps (hps);\n        }\n\n        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);\n        byte cInc = (byte) ((operand & 0xff00) >>> 8);\n        cInc >>>= 1;\n        if (cInc != 0)\n        {\n          newCHP.setHps (Math.max (newCHP.getHps () + (cInc * 2), 2));\n        }\n\n        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);\n        byte hpsPos = (byte) ((operand & 0xff0000) >>> 16);\n        if (hpsPos != (byte)0x80)\n        {\n          newCHP.setHpsPos (hpsPos);\n        }\n        boolean fAdjust = (operand & 0x0100) > 0;\n        if (fAdjust && (hpsPos & 0xFF) != 128 && hpsPos != 0 && oldCHP.getHpsPos () == 0)\n        {\n          newCHP.setHps (Math.max (newCHP.getHps () + ( -2), 2));\n        }\n        if (fAdjust && hpsPos == 0 && oldCHP.getHpsPos () != 0)\n        {\n          newCHP.setHps (Math.max (newCHP.getHps () + 2, 2));\n        }\n        break;\n      case 0x40:\n        newCHP.setDxaSpace (sprm.getOperand());\n        break;\n      case 0x41:\n        newCHP.setLidDefault ((short) sprm.getOperand());\n        break;\n      case 0x42:\n        newCHP.setIco ((byte) sprm.getOperand());\n        break;\n      case 0x43:\n        newCHP.setHps (sprm.getOperand());\n        break;\n      case 0x44:\n        byte hpsLvl = (byte) sprm.getOperand();\n        newCHP.setHps (Math.max (newCHP.getHps () + (hpsLvl * 2), 2));\n        break;\n      case 0x45:\n        newCHP.setHpsPos ((short) sprm.getOperand());\n        break;\n      case 0x46:\n        if (sprm.getOperand() != 0)\n        {\n          if (oldCHP.getHpsPos () == 0)\n          {\n            newCHP.setHps (Math.max (newCHP.getHps () + ( -2), 2));\n          }\n        }\n        else\n        {\n          if (oldCHP.getHpsPos () != 0)\n          {\n            newCHP.setHps (Math.max (newCHP.getHps () + 2, 2));\n          }\n        }\n        break;\n      case 0x47:\n        /*CharacterProperties genCHP = new CharacterProperties ();\n        genCHP.setFtcAscii (4);\n        genCHP = (CharacterProperties) unCompressProperty (varParam, genCHP,\n          styleSheet);\n        CharacterProperties styleCHP = styleSheet.getStyleDescription (oldCHP.\n          getBaseIstd ()).getCHP ();\n        if (genCHP.isFBold () == newCHP.isFBold ())\n        {\n          newCHP.setFBold (styleCHP.isFBold ());\n        }\n        if (genCHP.isFItalic () == newCHP.isFItalic ())\n        {\n          newCHP.setFItalic (styleCHP.isFItalic ());\n        }\n        if (genCHP.isFSmallCaps () == newCHP.isFSmallCaps ())\n        {\n          newCHP.setFSmallCaps (styleCHP.isFSmallCaps ());\n        }\n        if (genCHP.isFVanish () == newCHP.isFVanish ())\n        {\n          newCHP.setFVanish (styleCHP.isFVanish ());\n        }\n        if (genCHP.isFStrike () == newCHP.isFStrike ())\n        {\n          newCHP.setFStrike (styleCHP.isFStrike ());\n        }\n        if (genCHP.isFCaps () == newCHP.isFCaps ())\n        {\n          newCHP.setFCaps (styleCHP.isFCaps ());\n        }\n        if (genCHP.getFtcAscii () == newCHP.getFtcAscii ())\n        {\n          newCHP.setFtcAscii (styleCHP.getFtcAscii ());\n        }\n        if (genCHP.getFtcFE () == newCHP.getFtcFE ())\n        {\n          newCHP.setFtcFE (styleCHP.getFtcFE ());\n        }\n        if (genCHP.getFtcOther () == newCHP.getFtcOther ())\n        {\n          newCHP.setFtcOther (styleCHP.getFtcOther ());\n        }\n        if (genCHP.getHps () == newCHP.getHps ())\n        {\n          newCHP.setHps (styleCHP.getHps ());\n        }\n        if (genCHP.getHpsPos () == newCHP.getHpsPos ())\n        {\n          newCHP.setHpsPos (styleCHP.getHpsPos ());\n        }\n        if (genCHP.getKul () == newCHP.getKul ())\n        {\n          newCHP.setKul (styleCHP.getKul ());\n        }\n        if (genCHP.getDxaSpace () == newCHP.getDxaSpace ())\n        {\n          newCHP.setDxaSpace (styleCHP.getDxaSpace ());\n        }\n        if (genCHP.getIco () == newCHP.getIco ())\n        {\n          newCHP.setIco (styleCHP.getIco ());\n        }\n        if (genCHP.getLidDefault () == newCHP.getLidDefault ())\n        {\n          newCHP.setLidDefault (styleCHP.getLidDefault ());\n        }\n        if (genCHP.getLidFE () == newCHP.getLidFE ())\n        {\n          newCHP.setLidFE (styleCHP.getLidFE ());\n        }*/\n        break;\n      case 0x48:\n        newCHP.setIss ((byte) sprm.getOperand());\n        break;\n      case 0x49:\n        newCHP.setHps (LittleEndian.getShort (sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x4a:\n        int increment = LittleEndian.getShort (sprm.getGrpprl(), sprm.getGrpprlOffset());\n        newCHP.setHps (Math.max (newCHP.getHps () + increment, 8));\n        break;\n      case 0x4b:\n        newCHP.setHpsKern (sprm.getOperand());\n        break;\n        // Microsoft Office Word 97-2007 Binary File Format (.doc) Specification\n        // Page 59 of 210\n        case 0x4c:\n            // sprmCMajority50 -- 0xCA4C\n            // unCompressCHPOperation (oldCHP, newCHP, 0x47, param, varParam,\n            // styleSheet, opSize);\n            break;\n        case 0x4d:\n            // sprmCHpsMul -- 0x4A4D\n            float percentage = sprm.getOperand() / 100.0f;\n            int add = (int) ( percentage * newCHP.getHps() );\n            newCHP.setHps( newCHP.getHps() + add );\n            break;\n        case 0x4e:\n            // sprmCHresi -- 0x484e\n            Hyphenation hyphenation = new Hyphenation(\n                    (short) sprm.getOperand() );\n            newCHP.setHresi( hyphenation );\n            break;\n      case 0x4f:\n        newCHP.setFtcAscii ((short) sprm.getOperand());\n        break;\n      case 0x50:\n        newCHP.setFtcFE ((short) sprm.getOperand());\n        break;\n      case 0x51:\n        newCHP.setFtcOther ((short) sprm.getOperand());\n        break;\n      case 0x52:\n        // sprmCCharScale\n        break;\n      case 0x53:\n        newCHP.setFDStrike (getFlag (sprm.getOperand()));\n        break;\n      case 0x54:\n        newCHP.setFImprint (getFlag (sprm.getOperand()));\n        break;\n        case 0x55:\n            // sprmCFSpec -- 0x0855\n            newCHP.setFSpec( getFlag( sprm.getOperand() ) );\n            break;\n      case 0x56:\n        newCHP.setFObj (getFlag (sprm.getOperand()));\n        break;\n        case 0x57:\n            // sprmCPropRMark -- 0xCA57\n            /*\n             * Microsoft Office Word 97-2007 Binary File Format (.doc)\n             * Specification\n             * \n             * Page 78 of 210\n             * \n             * sprmCPropRMark (opcode 0xCA57) is interpreted by moving the first\n             * parameter byte to chp.fPropRMark, the next two bytes to\n             * chp.ibstPropRMark, and the remaining four bytes to\n             * chp.dttmPropRMark.\n             */\n            byte[] buf = sprm.getGrpprl();\n            int offset = sprm.getGrpprlOffset();\n            newCHP.setFPropRMark( buf[offset] != 0 );\n            newCHP.setIbstPropRMark( LittleEndian.getShort( buf, offset + 1 ) );\n            newCHP.setDttmPropRMark( new DateAndTime( buf, offset + 3 ) );\n            break;\n      case 0x58:\n        newCHP.setFEmboss (getFlag (sprm.getOperand()));\n        break;\n      case 0x59:\n        newCHP.setSfxtText ((byte) sprm.getOperand());\n        break;\n      case 0x5a:\n        // sprmCFBiDi\n        break;\n      case 0x5b:\n        break;\n      case 0x5c:\n        // sprmCFBoldBi\n        break;\n      case 0x5d:\n        // sprmCFItalicBi\n        break;\n      case 0x5e:\n        // sprmCFtcBi\n        break;\n      case 0x5f:\n        // sprmCLidBi \n        break;\n      case 0x60:\n        // sprmCIcoBi\n        break;\n      case 0x61:\n        // sprmCHpsBi\n        break;\n        case 0x62:\n            // sprmCDispFldRMark -- 0xCA62\n            /*\n             * Microsoft Office Word 97-2007 Binary File Format (.doc)\n             * Specification\n             * \n             * Page 78 of 210\n             * \n             * sprmCDispFldRMark (opcode 0xCA62) is interpreted by moving the\n             * first parameter byte to chp.fDispFldRMark, the next two bytes to\n             * chp.ibstDispFldRMark, the next four bytes to\n             * chp.dttmDispFldRMark, and the remaining 32 bytes to\n             * chp.xstDispFldRMark.\n             */\n            byte[] xstDispFldRMark = new byte[32];\n            buf = sprm.getGrpprl();\n            offset = sprm.getGrpprlOffset();\n            newCHP.setFDispFldRMark( 0 != buf[offset] );\n            newCHP.setIbstDispFldRMark( LittleEndian.getShort( buf, offset + 1 ) );\n            newCHP.setDttmDispFldRMark( new DateAndTime( buf, offset + 3 ) );\n            System.arraycopy( buf, offset + 7, xstDispFldRMark, 0, 32 );\n            newCHP.setXstDispFldRMark( xstDispFldRMark );\n            break;\n      case 0x63:\n        newCHP.setIbstRMarkDel ((short) sprm.getOperand());\n        break;\n      case 0x64:\n        newCHP.setDttmRMarkDel (new DateAndTime(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n      case 0x65:\n        newCHP.setBrc (new BorderCode(sprm.getGrpprl(), sprm.getGrpprlOffset()));\n        break;\n        case 0x66:\n            // sprmCShd80\n            /*\n             * "A Shd80 structure that specifies the background shading for the text. By default, text is not shaded."\n             * \n             * Word (.doc) Binary File Format. Copyright (c) 2011 Microsoft\n             * Corporation. Release: Tuesday, March 15, 2011\n             */\n            ShadingDescriptor80 oldDescriptor = new ShadingDescriptor80(\n                    sprm.getGrpprl(), sprm.getGrpprlOffset() );\n            ShadingDescriptor newDescriptor = oldDescriptor\n                    .toShadingDescriptor();\n            newCHP.setShd( newDescriptor );\n            break;\n      case 0x67:\n        // Obsolete\n        break;\n      case 0x68:\n        //  sprmCFUsePgsuSettings\n        break;\n      case 0x69:\n        break;\n      case 0x6a:\n        break;\n      case 0x6b:\n        break;\n      case 0x6c:\n        break;\n      case 0x6d:\n        newCHP.setLidDefault ((short) sprm.getOperand());\n        break;\n      case 0x6e:\n        newCHP.setLidFE ((short) sprm.getOperand());\n        break;\n      case 0x6f:\n        newCHP.setIdctHint ((byte) sprm.getOperand());\n        break;\n        case 0x70:\n            // sprmCCv -- 0x6870\n            newCHP.setCv( new Colorref( sprm.getOperand() ) );\n            break;\n      case 0x71:\n        // sprmCShd\n        break;\n      case 0x72:\n        // sprmCBrc\n        break;\n      case 0x73:\n        // sprmCRgLid0\n        break;\n      case 0x74:\n          // sprmCRgLid1\n          break;\n		case 0x75:\n			// sprmCFNoProof -- 0x875\n			/*\n			 * "A ToggleOperand value that specifies whether the text is excluded from the proofing analysis. By default, text is not excluded from the proofing analysis."\n			 * \n			 * Word (.doc) Binary File Format. Copyright (c) 2012 Microsoft\n			 * Corporation. Released: October 8, 2012\n			 */\n			newCHP.setFNoProof(getCHPFlag((byte) sprm.getOperand(),\n					oldCHP.isFNoProof()));\n			break;\n      default:\n          logger.log( POILogger.DEBUG, "Unknown CHP sprm ignored: " + sprm );\n          break;\n    }\n  }
1058	public static int getEncodedSize(int numberOfRanges) {\n		return 2 + CellRangeAddress.getEncodedSize(numberOfRanges);\n	}
1059	@Internal\n    public void setLbrCRJ( byte field_64_lbrCRJ )\n    {\n        this.field_64_lbrCRJ = field_64_lbrCRJ;\n    }
1060	public XSLFTextParagraph addNewTextParagraph() {\n        CTTextBody txBody = getTextBody(false);\n        CTTextParagraph p;\n        if (txBody == null) {\n            txBody = getTextBody(true);\n            p = txBody.getPArray(0);\n            p.removeR(0);\n        } else {\n            p = txBody.addNewP();\n        }\n        XSLFTextParagraph paragraph = newTextParagraph(p);\n        _paragraphs.add(paragraph);\n        return paragraph;\n    }
1061	private String tab2space(TextRun tr) {\n        AttributedString string = new AttributedString(" ");\n        String fontFamily = tr.getFontFamily();\n        if (fontFamily == null) {\n            fontFamily = "Lucida Sans";\n        }\n        string.addAttribute(TextAttribute.FAMILY, fontFamily);\n\n        Double fs = tr.getFontSize();\n        if (fs == null) {\n            fs = 12d;\n        }\n        string.addAttribute(TextAttribute.SIZE, fs.floatValue());\n\n        TextLayout l = new TextLayout(string.getIterator(), new FontRenderContext(null, true, true));\n        double wspace = l.getAdvance();\n\n        Double tabSz = paragraph.getDefaultTabSize();\n        if (tabSz == null) {\n            tabSz = wspace*4;\n        }\n\n        int numSpaces = (int)Math.ceil(tabSz / wspace);\n        StringBuilder buf = new StringBuilder();\n        for(int i = 0; i < numSpaces; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    }
1062	public int getRectX1()\n    {\n        return field_1_rectX1;\n    }
1063	public void dump(byte[] data, int offset, int length, int padding) throws IOException {\n        int pos = offset;\n        while (pos <= (offset + length - HEADER_SIZE)){\n            if (pos < 0) {\n                break;\n            }\n\n            //read record header\n            int info = LittleEndian.getUShort(data, pos);\n            pos += LittleEndian.SHORT_SIZE;\n            int type = LittleEndian.getUShort(data, pos);\n            pos += LittleEndian.SHORT_SIZE;\n            int size = (int)LittleEndian.getUInt(data, pos);\n            pos += LittleEndian.INT_SIZE;\n\n            //get name of the record by type\n            String recname = RecordTypes.forTypeID(type).name();\n            write(out, "<"+recname + " info=\""+info+"\" type=\""+type+"\" size=\""+size+"\" offset=\""+(pos-8)+"\"", padding);\n            if (hexHeader){\n                out.write(" header=\"");\n                dump(out, data, pos-8, 8, 0, false);\n                out.write("\"");\n            }\n            out.write(">" + CR);\n			padding++;\n            //this check works both for Escher and PowerPoint records\n            boolean isContainer = (info & 0x000F) == 0x000F;\n            if (isContainer) {\n                //continue to dump child records\n                dump(data, pos, size, padding);\n            } else {\n                //dump first 100 bytes of the atom data\n                dump(out, data, pos, Math.min(size, data.length-pos), padding, true);\n            }\n			padding--;\n            write(out, "</"+recname + ">" + CR, padding);\n\n            pos += size;\n        }\n    }
1064	public void bulletedListInCell(HSSFWorkbook workbook,\n                                   ArrayList<String> listItems,\n                                   HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n        // Note that again, an HSSFCellStye object is required and that\n        // it's wrap text property should be set to 'true'\n        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n        // Note that the basic method is identical to the listInCell() method\n        // with one difference; the bullet character prefixed to the items text.\n        for(String listItem : listItems) {\n            buffer.append(InCellLists.BULLET_CHARACTER + " ");\n            buffer.append(listItem);\n            buffer.append("\n");\n        }\n        // The StringBuffer's contents are the source for the contents\n        // of the cell.\n        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
1065	public String getFormula() {\n        return _cell.getF();\n    }
1066	private void addChildAt(Record newChild, int position) {\n		// Firstly, have the child added in at the end\n		appendChild(newChild);\n\n		// Now, have them moved to the right place\n		moveChildRecords( (_children.length-1), position, 1 );\n	}
1067	public void processSheet(\n            Styles styles,\n            SharedStrings strings,\n            SheetContentsHandler sheetHandler, \n            InputStream sheetInputStream) throws IOException, SAXException {\n        DataFormatter formatter = new DataFormatter();\n        InputSource sheetSource = new InputSource(sheetInputStream);\n        try {\n            XMLReader sheetParser = SAXHelper.newXMLReader();\n            ContentHandler handler = new XSSFSheetXMLHandler(\n                  styles, null, strings, sheetHandler, formatter, false);\n            sheetParser.setContentHandler(handler);\n            sheetParser.parse(sheetSource);\n         } catch(ParserConfigurationException e) {\n            throw new RuntimeException("SAX parser appears to be broken - " + e.getMessage());\n         }\n    }
1068	public boolean isTrue()\n    {\n        return getPropertyValue() != 0;\n    }
1069	public Borders getBorderRight() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getRight();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
1070	public boolean areFieldsStripped() {\n		return stripFields;\n	}
1071	public boolean isDefaultPlotDimensions() {\n        return defaultPlotDimensions.isSet(field_1_flags);\n    }
1072	@Beta\n    public XSSFPivotTable createPivotTable(AreaReference source, CellReference position){\n        final String sourceSheetName = source.getFirstCell().getSheetName();\n        if(sourceSheetName != null && !sourceSheetName.equalsIgnoreCase(this.getSheetName())) {\n            final XSSFSheet sourceSheet = getWorkbook().getSheet(sourceSheetName);\n            return createPivotTable(source, position, sourceSheet);\n        }\n        return createPivotTable(source, position, this);\n    }
1073	public InputStream getData() {\n        if (isCompressed()) {\n            int size = LittleEndian.getInt(_data);\n\n            InputStream compressedStream = new ByteArrayInputStream(_data, 4, _data.length);\n            return new BoundedInputStream(new InflaterInputStream(compressedStream), size);\n        } else {\n            return new ByteArrayInputStream(_data, 0, _data.length);\n        }\n    }
1074	public HSSFShapeGroup createGroup(HSSFClientAnchor anchor) {\n        HSSFShapeGroup group = new HSSFShapeGroup(null, anchor);\n        addShape(group);\n        onCreate(group);\n        return group;\n    }
1075	@Beta\n    protected void createCacheFields(Sheet sheet) {\n        //Get values for start row, start and end column\n        AreaReference ar = getPivotArea(sheet.getWorkbook());\n        CellReference firstCell = ar.getFirstCell();\n        CellReference lastCell = ar.getLastCell();\n        int columnStart = firstCell.getCol();\n        int columnEnd = lastCell.getCol();\n        Row row = sheet.getRow(firstCell.getRow());\n        CTCacheFields cFields;\n        if(ctPivotCacheDefinition.getCacheFields() != null) {\n            cFields = ctPivotCacheDefinition.getCacheFields();\n        } else {\n            cFields = ctPivotCacheDefinition.addNewCacheFields();\n        }\n        //For each column, create a cache field and give it en empty sharedItems\n        for(int i=columnStart; i<=columnEnd; i++) {\n            CTCacheField cf = cFields.addNewCacheField();\n            if(i==columnEnd){\n                cFields.setCount(cFields.sizeOfCacheFieldArray());\n            }\n            //General number format\n            cf.setNumFmtId(0);\n            Cell cell = row.getCell(i);\n            cell.setCellType(CellType.STRING);\n            cf.setName(row.getCell(i).getStringCellValue());\n            cf.addNewSharedItems();\n        }\n    }
1076	void syncWithDataSource() throws IOException {\n       int blocksUsed = 0;\n       for (BATBlock sbat : _sbat_blocks) {\n          ByteBuffer block = _filesystem.getBlockAt(sbat.getOurBlockIndex());\n          sbat.writeData(block);\n\n          if (!sbat.hasFreeSectors()) {\n              blocksUsed += _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\n          } else {\n              blocksUsed += sbat.getUsedSectors(false);\n          }\n       }\n       // Set the size on the root in terms of the number of SBAT blocks\n       // RootProperty.setSize does the sbat -> bytes conversion for us\n       _filesystem._get_property_table().getRoot().setSize(blocksUsed);\n    }
1077	public void ensureRelationships() {\n		if (this.relationships == null) {\n			try {\n				this.relationships = new PackageRelationshipCollection(this);\n			} catch (InvalidFormatException e) {\n				this.relationships = new PackageRelationshipCollection();\n			}\n		}\n	}
1078	public void setSheetIndex(int index){\n        int lastSheetIx = _book.getNumberOfSheets() - 1;\n        if (index < -1 || index > lastSheetIx) {\n            throw new IllegalArgumentException("Sheet index (" + index +") is out of range" +\n                    (lastSheetIx == -1 ? "" : (" (0.." +    lastSheetIx + ")")));\n        }\n\n        _definedNameRec.setSheetNumber(index + 1);\n    }
1079	@Internal\n    public boolean isFOrigWordTableRules()\n    {\n        return fOrigWordTableRules.isSet(field_25_internalFlags);\n    }
1080	public DrawingManager2 findDrawingGroup() {\n        if(drawingManager != null) {\n           // We already have it!\n           return drawingManager;\n        }\n\n        // Need to find a DrawingGroupRecord that contains a EscherDggRecord\n        for(Record r : records.getRecords() ) {\n            if (!(r instanceof DrawingGroupRecord)) {\n                continue;\n            }\n            DrawingGroupRecord dg = (DrawingGroupRecord)r;\n            dg.processChildRecords();\n            drawingManager = findDrawingManager(dg, escherBSERecords);\n            if (drawingManager != null) {\n                return drawingManager;\n            }\n        }\n\n        // TODO: we've already scanned the records, why should this work any better now?\n        // Look for the DrawingGroup record\n        DrawingGroupRecord dg = (DrawingGroupRecord)findFirstRecordBySid(DrawingGroupRecord.sid);\n        drawingManager = findDrawingManager(dg, escherBSERecords);\n        return drawingManager;\n    }
1081	private static void copyAttributes(Font font, AttributedString str, @SuppressWarnings("SameParameterValue") int startIdx, int endIdx) {\n        str.addAttribute(TextAttribute.FAMILY, font.getFontName(), startIdx, endIdx);\n        str.addAttribute(TextAttribute.SIZE, (float)font.getFontHeightInPoints());\n        if (font.getBold()) str.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, startIdx, endIdx);\n        if (font.getItalic() ) str.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, startIdx, endIdx);\n        if (font.getUnderline() == Font.U_SINGLE ) str.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, startIdx, endIdx);\n    }
1082	public boolean isCrossesFarRight()\n    {\n        return crossesFarRight.isSet(field_4_options);\n    }
1083	public static void main(String[] args) throws Exception {\n        if(args.length < 2){\n            System.err.println("usage: ToHtml inputWorkbook outputHtmlFile");\n            return;\n        }\n\n        ToHtml toHtml = create(args[0], new PrintWriter(new FileWriter(args[1])));\n        toHtml.setCompleteHTML(true);\n        toHtml.printPage();\n    }
1084	/* package */ void appendCellReference(StringBuilder sb) {\n        if (_colIndex != -1) {\n            if(_isColAbs) {\n                sb.append(ABSOLUTE_REFERENCE_MARKER);\n            }\n            sb.append( convertNumToColString(_colIndex));\n        }\n        if (_rowIndex != -1) {\n            if(_isRowAbs) {\n                sb.append(ABSOLUTE_REFERENCE_MARKER);\n            }\n            sb.append(_rowIndex+1);\n        }\n    }
1085	public void insertColumn(ColumnInfoRecord col) {\n		records.add(col);\n		records.sort(CIRComparator.instance);\n	}
1086	public static ExcelAntWorkbookUtil getInstance(String fileName) {\n        if(workbookUtilMap == null) {\n            workbookUtilMap = new HashMap<>();\n        }\n\n        if(workbookUtilMap.containsKey(fileName)) {\n            return workbookUtilMap.get(fileName);\n        }\n\n        ExcelAntWorkbookUtil wbu = new ExcelAntWorkbookUtil(fileName);\n        workbookUtilMap.put(fileName, wbu);\n        return wbu;\n    }
1087	protected SlideAtomsSet getSlideAtomsSet() { return _atomSet;  }
1088	public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackagePart part) {\n        final PackageRelationship rel = getPackageRelationship(parent, part);\n        final String relType = rel.getRelationshipType();\n        final POIXMLRelation descriptor = getDescriptor(relType);\n\n        // don't parse the document parts, if its class can't be determined\n        // or if it's a package relation of another embedded resource\n        if (descriptor == null || descriptor.getRelationClass() == null || POIXMLDocument.PACK_OBJECT_REL_TYPE.equals(relType)) {\n            LOGGER.log(POILogger.DEBUG, "using default POIXMLDocumentPart for " + rel.getRelationshipType());\n            return new POIXMLDocumentPart(parent, part);\n        }\n\n        Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();\n        try {\n            try {\n                return createDocumentPart(cls, PARENT_PART, new Object[]{parent, part});\n            } catch (NoSuchMethodException e) {\n                return createDocumentPart(cls, ORPHAN_PART, new Object[]{part});\n            }\n        } catch (Exception e) {\n            throw new POIXMLException((e.getCause() != null ? e.getCause() : e).getMessage(), e);\n        }\n    }
1089	private static int getActualSizeOfElements(short sizeOfElements) {\n        if (sizeOfElements < 0) {\n            return (short) ( ( -sizeOfElements ) >> 2 );\n        }\n        return sizeOfElements;\n    }
1090	public int getMask() { return maskInHeader; }
1091	private UnicodeString cloneStringIfRequired() {\n      if (_book == null)\n        return _string;\n        return (UnicodeString)_string.clone();\n    }
1092	protected void onSheetDelete() {\n        for (RelationPart part : getRelationParts()) {\n            if (part.getDocumentPart() instanceof XSSFTable) {\n                // call table delete\n                removeTable(part.getDocumentPart());\n                continue;\n            }\n            removeRelation(part.getDocumentPart(), true);\n        }\n    }
1093	public void setDimensions(int firstrow, short firstcol, int lastrow, short lastcol)\n    {\n        if (log.check( POILogger.DEBUG ))\n        {\n            log.log(POILogger.DEBUG, "Sheet.setDimensions");\n            log.log(POILogger.DEBUG,\n                    (new StringBuffer("firstrow")).append(firstrow)\n                        .append("firstcol").append(firstcol).append("lastrow")\n                        .append(lastrow).append("lastcol").append(lastcol)\n                        .toString());\n        }\n        _dimensions.setFirstCol(firstcol);\n        _dimensions.setFirstRow(firstrow);\n        _dimensions.setLastCol(lastcol);\n        _dimensions.setLastRow(lastrow);\n        if (log.check( POILogger.DEBUG ))\n            log.log(POILogger.DEBUG, "Sheet.setDimensions exiting");\n    }
1094	public static String getOPCNameFromZipItemName(String zipItemName) {\n        if (zipItemName == null) {\n            throw new IllegalArgumentException("zipItemName cannot be null");\n        }\n        if (zipItemName.startsWith(FORWARD_SLASH)) {\n            return zipItemName;\n        }\n        return FORWARD_SLASH + zipItemName;\n    }
1095	public int addEmbed(POIFSFileSystem poiData) {\n        DirectoryNode root = poiData.getRoot();\n\n        // prepare embedded data\n        if (new ClassID().equals(root.getStorageClsid())) {\n        	// need to set class id\n	        Map<String,ClassID> olemap = getOleMap();\n	        ClassID classID = null;\n	    	for (Map.Entry<String,ClassID> entry : olemap.entrySet()) {\n	    		if (root.hasEntry(entry.getKey())) {\n	    			classID = entry.getValue();\n	    			break;\n	    		}\n	    	}\n	    	if (classID == null) {\n	    		throw new IllegalArgumentException("Unsupported embedded document");\n	    	}\n\n	    	root.setStorageClsid(classID);\n        }\n\n		ExEmbed exEmbed = new ExEmbed();\n        // remove unneccessary infos, so we don't need to specify the type\n        // of the ole object multiple times\n        Record children[] = exEmbed.getChildRecords();\n        exEmbed.removeChild(children[2]);\n        exEmbed.removeChild(children[3]);\n        exEmbed.removeChild(children[4]);\n\n        ExEmbedAtom eeEmbed = exEmbed.getExEmbedAtom();\n        eeEmbed.setCantLockServerB(true);\n\n        ExOleObjAtom eeAtom = exEmbed.getExOleObjAtom();\n        eeAtom.setDrawAspect(ExOleObjAtom.DRAW_ASPECT_VISIBLE);\n        eeAtom.setType(ExOleObjAtom.TYPE_EMBEDDED);\n        // eeAtom.setSubType(ExOleObjAtom.SUBTYPE_EXCEL);\n        // should be ignored?!?, see MS-PPT ExOleObjAtom, but Libre Office sets it ...\n        eeAtom.setOptions(1226240);\n\n        ExOleObjStg exOleObjStg = new ExOleObjStg();\n        try {\n            Ole10Native.createOleMarkerEntry(poiData);\n	        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n	        poiData.writeFilesystem(bos);\n	        exOleObjStg.setData(bos.toByteArray());\n        } catch (IOException e) {\n        	throw new HSLFException(e);\n        }\n\n        int psrId = addPersistentObject(exOleObjStg);\n        exOleObjStg.setPersistId(psrId);\n        eeAtom.setObjStgDataRef(psrId);\n\n		int objectId = addToObjListAtom(exEmbed);\n		eeAtom.setObjID(objectId);\n		return objectId;\n	}
1096	public static HSLFSlideShowImpl create() {\n        InputStream is = HSLFSlideShowImpl.class.getResourceAsStream("/org/apache/poi/hslf/data/empty.ppt");\n        if (is == null) {\n            throw new HSLFException("Missing resource 'empty.ppt'");\n        }\n        try {\n            try {\n                return new HSLFSlideShowImpl(is);\n            } finally {\n                is.close();\n            }\n        } catch (IOException e) {\n            throw new HSLFException(e);\n        }\n    }
1097	public void addIgnoredErrors(CellRangeAddress region, IgnoredErrorType... ignoredErrorTypes) {\n        region.validate(SpreadsheetVersion.EXCEL2007);\n        addIgnoredErrors(region.formatAsString(), ignoredErrorTypes);\n    }
1098	public static int doubleToFixedPoint(double floatPoint) {\n        double fractionalPart = floatPoint % 1d;\n        double integralPart = floatPoint - fractionalPart;\n        int i = (int)Math.floor(integralPart);\n        int f = (int)Math.rint(fractionalPart*65536d);\n        return (i << 16) | (f & 0xFFFF);\n    }
1099	private void isCellFillBackGroundMatches(Locator loc1, Locator loc2) {\n        String col1 = getCellFillBackground(loc1);\n        String col2 = getCellFillBackground(loc2);\n        if (!col1.equals(col2)) {\n            addMessage(loc1, loc2, "Cell Fill Color does not Match ::", col1, col2);\n        }\n    }
1100	public void walkEscherBasic(int indent, int pos, int len) throws IOException {\n	if(len < 8) { return; }\n\n	final String ind = (indent == 0) ? "%1$s" : "%1$"+indent+"s";\n\n	long type = LittleEndian.getUShort(docstream,pos+2);\n	long atomlen = LittleEndian.getUInt(docstream,pos+4);\n\n	String fmt = ind+"At position %2$d ($2$04x): type is %3$d (%3$04x), len is %4$d (%4$04x)";\n	out.println(String.format(Locale.ROOT, fmt, "", pos, type, atomlen));\n\n	String typeName = RecordTypes.forTypeID((short)type).name();\n	out.println(String.format(Locale.ROOT, ind+"%2$s", "That's an Escher Record: ", typeName));\n\n	// Record specific dumps\n	if(type == 61453L) {\n		// Text Box. Print out first 8 bytes of data, then 8 4 later\n	    HexDump.dump(docstream, 0, out, pos+8, 8);\n	    HexDump.dump(docstream, 0, out, pos+20, 8);\n		out.println();\n	}\n\n\n	// Blank line before next entry\n	out.println();\n\n	// Look in children if we are a container\n	if(type == 61443L || type == 61444L) {\n		walkEscherBasic((indent+3), pos+8, (int)atomlen);\n	}\n\n	// Keep going if not yet at end\n	if(atomlen < len) {\n		int atomleni = (int)atomlen;\n		walkEscherBasic(indent, pos+atomleni+8, len-atomleni-8);\n	}\n  }
1101	public PackageRelationship getRelationshipByID(String id) {\n        return relationshipsByID.get(id);\n    }
1102	public void update(Observable observable, Object localeObj) {\n        if (!(localeObj instanceof Locale))  return;\n        Locale newLocale = (Locale)localeObj;\n        if (!localeIsAdapting || newLocale.equals(locale)) return;\n        \n        locale = newLocale;\n        \n        dateSymbols = DateFormatSymbols.getInstance(locale);\n        decimalSymbols = DecimalFormatSymbols.getInstance(locale);\n        generalNumberFormat = new ExcelGeneralNumberFormat(locale);\n\n        // taken from Date.toString()\n        defaultDateformat = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", dateSymbols);\n        defaultDateformat.setTimeZone(LocaleUtil.getUserTimeZone());       \n\n        // init built-in formats\n\n        formats.clear();\n        Format zipFormat = ZipPlusFourFormat.instance;\n        addFormat("00000\\-0000", zipFormat);\n        addFormat("00000-0000", zipFormat);\n\n        Format phoneFormat = PhoneFormat.instance;\n        // allow for format string variations\n        addFormat("[<=9999999]###\\-####;\\(###\\)\\ ###\\-####", phoneFormat);\n        addFormat("[<=9999999]###-####;(###) ###-####", phoneFormat);\n        addFormat("###\\-####;\\(###\\)\\ ###\\-####", phoneFormat);\n        addFormat("###-####;(###) ###-####", phoneFormat);\n\n        Format ssnFormat = SSNFormat.instance;\n        addFormat("000\\-00\\-0000", ssnFormat);\n        addFormat("000-00-0000", ssnFormat);\n    }
1103	public static Object read( final byte[] src, final int offset,\n            final int length, final long type, final int codepage )\n    throws ReadingNotSupportedException, UnsupportedEncodingException {\n        LittleEndianByteArrayInputStream lei = new LittleEndianByteArrayInputStream(src, offset);\n        return read( lei, length, type, codepage );\n    }
1104	public boolean isReversed()\n    {\n        return reversed.isSet(field_4_options);\n    }
1105	public void setValueWithMask(int val, int writeMask) {\n	    setWriteMask(writeMask);\n	    super.setValue(maskValue(val));\n	    if (val != super.getValue()) {\n	        logger.log(POILogger.WARN, "Style properties of '"+getName()+"' don't match mask - output will be sanitized");\n	        if (logger.check(POILogger.DEBUG)) {\n	            StringBuilder sb = new StringBuilder("The following style attributes of the '"+getName()+"' property will be ignored:\n");\n	            int i=0;\n	            for (int mask : subPropMasks) {\n	                if (!subPropMatches[i] && (val & mask) != 0) {\n	                    sb.append(subPropNames[i]).append(",");\n	                }\n	                i++;\n	            }\n	            logger.log(POILogger.DEBUG, sb.toString());\n	        }\n	    }\n	}
1106	public void clearAllCachedValues() {\n        validations.clear();\n    }
1107	public void notifyDeleteCell(EvaluationCell cell) {\n        int sheetIndex = getSheetIndex(cell.getSheet());\n        _cache.notifyDeleteCell(_workbookIx, sheetIndex, cell);\n    }
1108	public void validate(SpreadsheetVersion ssVersion) {\n		validateRow(_firstRow, ssVersion);\n		validateRow(_lastRow, ssVersion);\n		validateColumn(_firstCol, ssVersion);\n		validateColumn(_lastCol, ssVersion);\n	}
1109	private void isCellContentMatchesForBoolean(Locator loc1, Locator loc2) {\n        boolean b1 = loc1.cell.getBooleanCellValue();\n        boolean b2 = loc2.cell.getBooleanCellValue();\n        if (b1 != b2) {\n            addMessage(loc1,loc2,CELL_DATA_DOES_NOT_MATCH,Boolean.toString(b1),Boolean.toString(b2));\n        }\n    }
1110	private static VCenterRecord createVCenter() {\n        VCenterRecord retval = new VCenterRecord();\n\n        retval.setVCenter(false);\n        return retval;\n    }
1111	public Borders getBorderTop() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getTop();\n        }\n        STBorder.Enum ptrn = (ct != null) ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
1112	public int getEntryCount()\n    {\n        return _entries.size();\n    }
1113	private static BoundSheetRecord createBoundSheet(int id) {\n        return new BoundSheetRecord("Sheet" + (id+1));\n    }
1114	public static List<String> compare(Workbook wb1, Workbook wb2) {\n        Locator loc1 = new Locator();\n        Locator loc2 = new Locator();\n        loc1.workbook = wb1;\n        loc2.workbook = wb2;\n\n        ExcelComparator excelComparator = new ExcelComparator();\n        excelComparator.compareNumberOfSheets(loc1, loc2 );\n        excelComparator.compareSheetNames(loc1, loc2);\n        excelComparator.compareSheetData(loc1, loc2);\n\n        return excelComparator.listOfDifferences;\n    }
1115	public int getDx1()\n    {\n        return field_1_dx1;\n    }
1116	@SuppressWarnings("unchecked")\n	private <T extends TextProp> T validatePropName(final String name) {\n       for (TextProp tp : getPotentialProperties()) {\n            if (tp.getName().equals(name)) {\n                return (T)tp;\n            }\n        }\n       String errStr = \n           "No TextProp with name " + name + " is defined to add from. " +\n           "Character and paragraphs have their own properties/names.";\n       throw new HSLFException(errStr);       \n	}
1117	public CTChartsheet getCTChartsheet() {\n        return chartsheet;\n    }
1118	public static int getEncodedSize(Ptg[] ptgs) {\n		int result = 0;\n		for (Ptg ptg : ptgs) {\n			result += ptg.getSize();\n		}\n		return result;\n	}
1119	private void addIdentifier() {\n        setElementTextContent(KEYWORD_IDENTIFIER, namespaceDC, propsPart.getIdentifierProperty());\n	}
1120	public void clearText() {\n        _paragraphs.clear();\n        CTTextBody txBody = ctShape.getTxBody();\n        txBody.setPArray(null); // remove any existing paragraphs\n    }
1121	public boolean[] getSubPropMatches() { return subPropMatches; }
1122	public Writer createWriter(File fd) throws IOException {\n        FileOutputStream fos = new FileOutputStream(fd);\n        OutputStream decorated;\n        try {\n            decorated = decorateOutputStream(fos);\n        } catch (final IOException e) {\n            fos.close();\n            throw e;\n        }\n        return new BufferedWriter(\n                new OutputStreamWriter(decorated, "UTF-8"));\n    }
1123	public int getTitleTextColourRGB() { return titleTextColourRGB; }
1124	public ParagraphProperties cloneProperties() {\n        try {\n            return (ParagraphProperties)_props.clone();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }
1125	public int getDx2()\n    {\n        return field_3_dx2;\n    }
1126	public static void main(String args[]) throws IOException\n	{\n		if(args.length < 1) {\n			System.err.println("Useage:");\n			System.err.println("\tQuickButCruddyTextExtractor <file>");\n			System.exit(1);\n		}\n\n		String file = args[0];\n\n		QuickButCruddyTextExtractor ppe = new QuickButCruddyTextExtractor(file);\n		System.out.println(ppe.getTextAsString());\n		ppe.close();\n	}
1127	public void setItalic(Boolean italic) {\n        getOrCreateProperties().setItalic(italic);\n    }
1128	public void writeImageContent( OutputStream out ) throws IOException\n    {\n        byte[] c = getContent();\n        if ( c != null && c.length > 0 )\n        {\n            out.write( c, 0, c.length );\n        }\n    }
1129	@Internal\n    public boolean isFNoRestart()\n    {\n        return fNoRestart.isSet(field_3_info);\n    }
1130	protected int pastDaysOfWeek(double start, double end, int dayOfWeek) {\n        int pastDaysOfWeek = 0;\n        int startDay = (int) Math.floor(start < end ? start : end);\n        int endDay = (int) Math.floor(end > start ? end : start);\n        for (; startDay <= endDay; startDay++) {\n            Calendar today = LocaleUtil.getLocaleCalendar();\n            today.setTime(DateUtil.getJavaDate(startDay));\n            if (today.get(Calendar.DAY_OF_WEEK) == dayOfWeek) {\n                pastDaysOfWeek++;\n            }\n        }\n        return start <= end ? pastDaysOfWeek : -pastDaysOfWeek;\n    }
1131	public void join( AbstractEscherHolderRecord record )\n    {\n        rawDataContainer.concatenate(record.getRawData());\n    }
1132	public static void writeLittleEndian(short s,OutputStream o) throws IOException {\n		byte[] bs = new byte[2];\n		LittleEndian.putShort(bs,0,s);\n		o.write(bs);\n	}
1133	public XWPFHeader createHeader(Enum type) {\n        return createHeader(type, null);\n    }
1134	public static DVConstraint createNumericConstraint(int validationType, int comparisonOperator, \n			String expr1, String expr2) {\n		switch (validationType) {\n			case ValidationType.ANY:\n				if (expr1 != null || expr2 != null) {\n					throw new IllegalArgumentException("expr1 and expr2 must be null for validation type 'any'");\n				}\n				break;\n			case ValidationType.DECIMAL:\n			case ValidationType.INTEGER:\n			case ValidationType.TEXT_LENGTH:\n				if (expr1 == null) {\n					throw new IllegalArgumentException("expr1 must be supplied");\n				}\n				OperatorType.validateSecondArg(comparisonOperator, expr2);\n				break;\n			default:\n				throw new IllegalArgumentException("Validation Type ("\n						+ validationType + ") not supported with this method");\n		}\n		// formula1 and value1 are mutually exclusive\n		String formula1 = getFormulaFromTextExpression(expr1);\n		Double value1 = formula1 == null ? convertNumber(expr1) : null;\n		// formula2 and value2 are mutually exclusive\n		String formula2 = getFormulaFromTextExpression(expr2);\n		Double value2 = formula2 == null ? convertNumber(expr2) : null;\n		return new DVConstraint(validationType, comparisonOperator, formula1, formula2, value1, value2, null);\n	}
1135	public void process() throws IOException {\n		MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener(this);\n		formatListener = new FormatTrackingHSSFListener(listener);\n\n		HSSFEventFactory factory = new HSSFEventFactory();\n		HSSFRequest request = new HSSFRequest();\n\n		if(outputFormulaValues) {\n			request.addListenerForAllRecords(formatListener);\n		} else {\n			workbookBuildingListener = new SheetRecordCollectingListener(formatListener);\n			request.addListenerForAllRecords(workbookBuildingListener);\n		}\n\n		factory.processWorkbookEvents(request, fs);\n	}
1136	public String getEmbed() {\n        return embed;\n    }
1137	public void walkEscherDDF(int indent, int pos, int len) {\n	if(len < 8) { return; }\n\n	final String ind = (indent == 0) ? "%1$s" : "%1$"+indent+"s";\n\n	byte[] contents = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n	System.arraycopy(docstream,pos,contents,0,len);\n	DefaultEscherRecordFactory erf = new HSLFEscherRecordFactory();\n	EscherRecord record = erf.createRecord(contents,0);\n\n	// For now, try filling in the fields\n	record.fillFields(contents,0,erf);\n\n	long atomType = LittleEndian.getUShort(contents,2);\n	// This lacks the 8 byte header size\n	long atomLen = LittleEndian.getUShort(contents,4);\n	// This (should) include the 8 byte header size\n	int recordLen = record.getRecordSize();\n\n    String fmt = ind+"At position %2$d (%2$04x): type is %3$d (%3$04x), len is %4$d (%4$04x) (%5$d) - record claims %6$d";\n    out.println(String.format(Locale.ROOT, fmt, "", pos, atomType, atomLen, atomLen+8, recordLen));\n	\n	\n	// Check for corrupt / lying ones\n	if(recordLen != 8 && (recordLen != (atomLen+8))) {\n		out.println(String.format(Locale.ROOT, ind+"** Atom length of $2d ($3d) doesn't match record length of %4d", "", atomLen, atomLen+8, recordLen));\n	}\n\n	// Print the record's details\n    String recordStr = record.toString().replace("\n", String.format(Locale.ROOT,  "\n"+ind, ""));\n    out.println(String.format(Locale.ROOT, ind+"%2$s", "", recordStr));\n\n    if(record instanceof EscherContainerRecord) {\n		walkEscherDDF((indent+3), pos + 8, (int)atomLen );\n	}\n\n	// Handle records that seem to lie\n	if(atomType == 61451L) {\n		// Normally claims a size of 8\n		recordLen = (int)atomLen + 8;\n	}\n	if(atomType == 61453L) {\n		// Returns EscherContainerRecord, but really msofbtClientTextbox\n		recordLen = (int)atomLen + 8;\n		record.fillFields( contents, 0, erf );\n		if(! (record instanceof EscherTextboxRecord)) {\n			out.println(String.format(Locale.ROOT, ind+"%2$s", "", "** Really a msofbtClientTextbox !"));\n		}\n	}\n\n	// Decide on what to do, based on how the lengths match up\n	if(recordLen == 8 && atomLen > 8 ) {\n		// Assume it has children, rather than being corrupted\n		walkEscherDDF((indent+3), pos + 8, (int)atomLen );\n\n		// Wind on our length + our header\n		pos += atomLen;\n		pos += 8;\n		len -= atomLen;\n		len -= 8;\n	} else {\n		// No children, wind on our real length\n		pos += atomLen;\n		pos += 8;\n		len -= atomLen;\n		len -= 8;\n	}\n\n	// Move on to the next one, if we're not at the end yet\n	if(len >= 8) {\n		walkEscherDDF(indent, pos, len );\n	}\n  }
1138	protected static CTGraphicalObjectFrame prototype() {\n		if (prototype == null) {\n			CTGraphicalObjectFrame graphicFrame = CTGraphicalObjectFrame.Factory.newInstance();\n\n			CTGraphicalObjectFrameNonVisual nvGraphic = graphicFrame.addNewNvGraphicFramePr();\n			CTNonVisualDrawingProps props = nvGraphic.addNewCNvPr();\n			props.setId(0);\n			props.setName("Diagramm 1");\n			nvGraphic.addNewCNvGraphicFramePr();\n\n			CTTransform2D transform = graphicFrame.addNewXfrm();\n			CTPositiveSize2D extPoint = transform.addNewExt();\n			CTPoint2D offPoint = transform.addNewOff();\n\n			extPoint.setCx(0);\n			extPoint.setCy(0);\n			offPoint.setX(0);\n			offPoint.setY(0);\n\n			/* CTGraphicalObject graphic = */ graphicFrame.addNewGraphic();\n\n			prototype = graphicFrame;\n		}\n		return prototype;\n	}
1139	public boolean removeRow(int pos) throws IndexOutOfBoundsException {\n        if (pos >= 0 && pos < tableRows.size()) {\n            if (ctTbl.sizeOfTrArray() > 0) {\n                ctTbl.removeTr(pos);\n            }\n            tableRows.remove(pos);\n            return true;\n        }\n        return false;\n    }
1140	public void write() throws IOException {\n        POIFSFileSystem fs = getDirectory().getFileSystem();\n        \n        validateInPlaceWritePossible();        \n        writeProperties(fs, null);\n        fs.writeFilesystem();\n    }
1141	static void colourScales(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Colour Scales");\n        Row r = sheet.createRow(1);\n        r.createCell(0).setCellValue("Red-Yellow-Green");\n        for (int i=1; i<=7; i++) {\n            r.createCell(i).setCellValue((i-1)*5);\n        }\n        r = sheet.createRow(2);\n        r.createCell(0).setCellValue("Red-White-Blue");\n        for (int i=1; i<=9; i++) {\n            r.createCell(i).setCellValue((i-1)*5);\n        }\n        r = sheet.createRow(3);\n        r.createCell(0).setCellValue("Blue-Green");\n        for (int i=1; i<=16; i++) {\n            r.createCell(i).setCellValue((i-1));\n        }\n        sheet.setColumnWidth(0, 5000);\n        \n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n        CellRangeAddress[] regions = { CellRangeAddress.valueOf("B2:H2") };\n        ConditionalFormattingRule rule1 =\n                sheetCF.createConditionalFormattingColorScaleRule();\n        ColorScaleFormatting cs1 = rule1.getColorScaleFormatting();\n        cs1.getThresholds()[0].setRangeType(RangeType.MIN);\n        cs1.getThresholds()[1].setRangeType(RangeType.PERCENTILE);\n        cs1.getThresholds()[1].setValue(50d);\n        cs1.getThresholds()[2].setRangeType(RangeType.MAX);\n        ((ExtendedColor)cs1.getColors()[0]).setARGBHex("FFF8696B");\n        ((ExtendedColor)cs1.getColors()[1]).setARGBHex("FFFFEB84");\n        ((ExtendedColor)cs1.getColors()[2]).setARGBHex("FF63BE7B");\n        sheetCF.addConditionalFormatting(regions, rule1);\n        \n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("B3:J3") };\n        ConditionalFormattingRule rule2 =\n                sheetCF.createConditionalFormattingColorScaleRule();\n        ColorScaleFormatting cs2 = rule2.getColorScaleFormatting();\n        cs2.getThresholds()[0].setRangeType(RangeType.MIN);\n        cs2.getThresholds()[1].setRangeType(RangeType.PERCENTILE);\n        cs2.getThresholds()[1].setValue(50d);\n        cs2.getThresholds()[2].setRangeType(RangeType.MAX);\n        ((ExtendedColor)cs2.getColors()[0]).setARGBHex("FFF8696B");\n        ((ExtendedColor)cs2.getColors()[1]).setARGBHex("FFFCFCFF");\n        ((ExtendedColor)cs2.getColors()[2]).setARGBHex("FF5A8AC6");\n        sheetCF.addConditionalFormatting(regions, rule2);\n        \n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("B4:Q4") };\n        ConditionalFormattingRule rule3=\n                sheetCF.createConditionalFormattingColorScaleRule();\n        ColorScaleFormatting cs3 = rule3.getColorScaleFormatting();\n        cs3.setNumControlPoints(2);\n        cs3.getThresholds()[0].setRangeType(RangeType.MIN);\n        cs3.getThresholds()[1].setRangeType(RangeType.MAX);\n        ((ExtendedColor)cs3.getColors()[0]).setARGBHex("FF5A8AC6");\n        ((ExtendedColor)cs3.getColors()[1]).setARGBHex("FF63BE7B");\n        sheetCF.addConditionalFormatting(regions, rule3);\n    }
1142	@Internal\n    public boolean isFSpec()\n    {\n        return fSpec.isSet(field_1_grpfChp);\n    }
1143	public void append(String text){\n        append(text, null);\n    }
1144	private static String[] split(String text, String separator, int max)\n    {\n        StringTokenizer tok = new StringTokenizer(text, separator);\n        int listSize = tok.countTokens();\n        if(max != -1 && listSize > max)\n            listSize = max;\n        String list[] = new String[listSize];\n        for(int i = 0; tok.hasMoreTokens(); i++)\n        {\n            if(max != -1 && i == listSize - 1)\n            {\n                StringBuffer buf = new StringBuffer((text.length() * (listSize - i)) / listSize);\n                while(tok.hasMoreTokens())\n                {\n                    buf.append(tok.nextToken());\n                    if(tok.hasMoreTokens())\n                        buf.append(separator);\n                }\n                list[i] = buf.toString().trim();\n                break;\n            }\n            list[i] = tok.nextToken().trim();\n        }\n\n        return list;\n    }
1145	private static DimensionsRecord createDimensions() {\n        DimensionsRecord retval = new DimensionsRecord();\n\n        retval.setFirstCol(( short ) 0);\n        retval.setLastRow(1);             // one more than it is\n        retval.setFirstRow(0);\n        retval.setLastCol(( short ) 1);   // one more than it is\n        return retval;\n    }
1146	public void addRun(XWPFRun r) {\n        if (!runs.contains(r)) {\n            runs.add(r);\n        }\n    }
1147	protected static OPCPackage newPackage(XSSFWorkbookType workbookType) {\n        try {\n            OPCPackage pkg = OPCPackage.create(new ByteArrayOutputStream());    // NOSONAR - we do not want to close this here\n            // Main part\n            PackagePartName corePartName = PackagingURIHelper.createPartName(XSSFRelation.WORKBOOK.getDefaultFileName());\n            // Create main part relationship\n            pkg.addRelationship(corePartName, TargetMode.INTERNAL, PackageRelationshipTypes.CORE_DOCUMENT);\n            // Create main document part\n            pkg.createPart(corePartName, workbookType.getContentType());\n\n            pkg.getPackageProperties().setCreatorProperty(DOCUMENT_CREATOR);\n\n            return pkg;\n        } catch (Exception e){\n            throw new POIXMLException(e);\n        }\n    }
1148	protected static void process(Entry entry, ChunkGroup grouping) {\n      String entryName = entry.getName();\n      Chunk chunk = null;\n      \n      // Is it a properties chunk? (They have special names)\n      if (entryName.equals(PropertiesChunk.NAME)) {\n         if (grouping instanceof Chunks) {\n            // These should be the properties for the message itself\n            chunk = new MessagePropertiesChunk(grouping,\n              entry.getParent() != null && entry.getParent().getParent() != null);\n         } else {\n            // Will be properties on an attachment or recipient\n            chunk = new StoragePropertiesChunk(grouping);\n         }\n      } else {\n         // Check it's a regular chunk\n         if(entryName.length() < 9) {\n            // Name in the wrong format\n            return;\n         }\n         if(! entryName.contains("_")) {\n            // Name in the wrong format\n            return;\n         }\n         \n         // Split it into its parts\n         int splitAt = entryName.lastIndexOf('_');\n         String namePrefix = entryName.substring(0, splitAt+1);\n         String ids = entryName.substring(splitAt+1);\n         \n         // Make sure we got what we expected, should be of \n         //  the form __<name>_<id><type>\n         if(namePrefix.equals("Olk10SideProps") ||\n            namePrefix.equals("Olk10SideProps_")) {\n            // This is some odd Outlook 2002 thing, skip\n            return;\n         } else if(splitAt <= entryName.length()-8) {\n            // In the right form for a normal chunk\n            // We'll process this further in a little bit\n         } else {\n            // Underscores not the right place, something's wrong\n            throw new IllegalArgumentException("Invalid chunk name " + entryName);\n         }\n         \n         // Now try to turn it into id + type\n         try {\n            int chunkId = Integer.parseInt(ids.substring(0, 4), 16);\n            int typeId  = Integer.parseInt(ids.substring(4, 8), 16);\n            \n            MAPIType type = Types.getById(typeId);\n            if (type == null) {\n               type = Types.createCustom(typeId);\n            }\n            \n            // Special cases based on the ID\n            if(chunkId == MAPIProperty.MESSAGE_SUBMISSION_ID.id) {\n               chunk = new MessageSubmissionChunk(namePrefix, chunkId, type);\n            } \n            else {\n               // Nothing special about this ID\n               // So, do the usual thing which is by type\n               if (type == Types.BINARY) {\n                  chunk = new ByteChunk(namePrefix, chunkId, type);\n               }\n               else if (type == Types.DIRECTORY) {\n                  if(entry instanceof DirectoryNode) {\n                      chunk = new DirectoryChunk((DirectoryNode)entry, namePrefix, chunkId, type);\n                  }\n               }\n               else if (type == Types.ASCII_STRING ||\n                        type == Types.UNICODE_STRING) {\n                  chunk = new StringChunk(namePrefix, chunkId, type);\n               } \n               else {\n                  // Type of an unsupported type! Skipping... \n               }\n            }\n         } catch(NumberFormatException e) {\n            // Name in the wrong format\n            return;\n         }\n      }\n         \n      if(chunk != null) {\n          if(entry instanceof DocumentNode) {\n             try (DocumentInputStream inp = new DocumentInputStream((DocumentNode) entry)) {\n                chunk.readValue(inp);\n                grouping.record(chunk);\n             } catch (IOException e) {\n                logger.log(POILogger.ERROR, "Error reading from part " + entry.getName() + " - " + e);\n             }\n          } else {\n             grouping.record(chunk);\n          }\n      }\n   }
1149	FontCollection getFontCollection() {\n		return _fonts;\n	}
1150	@Internal\n    public boolean isFHdr()\n    {\n        return fHdr.isSet(field_6_flags);\n    }
1151	public void addListener(HSSFListener lsnr, short sid) {\n		List<HSSFListener> list = _records.get(Short.valueOf(sid));\n\n		if (list == null) {\n			list = new ArrayList<>(1); // probably most people will use one listener\n			_records.put(Short.valueOf(sid), list);\n		}\n		list.add(lsnr);\n	}
1152	private SimpleRangePart parseSimpleRangePart() {\n        int ptr = _pointer-1; // TODO avoid StringIndexOutOfBounds\n        boolean hasDigits = false;\n        boolean hasLetters = false;\n        while (ptr < _formulaLength) {\n            char ch = _formulaString.charAt(ptr);\n            if (Character.isDigit(ch)) {\n                hasDigits = true;\n            } else if (Character.isLetter(ch)) {\n                hasLetters = true;\n            } else if (ch =='$' || ch =='_') {\n                //\n            } else {\n                break;\n            }\n            ptr++;\n        }\n        if (ptr <= _pointer-1) {\n            return null;\n        }\n        String rep = _formulaString.substring(_pointer-1, ptr);\n        if (!CELL_REF_PATTERN.matcher(rep).matches()) {\n            return null;\n        }\n        // Check range bounds against grid max\n        if (hasLetters && hasDigits) {\n            if (!isValidCellReference(rep)) {\n                return null;\n            }\n        } else if (hasLetters) {\n            if (!CellReference.isColumnWithinRange(rep.replace("$", ""), _ssVersion)) {\n                return null;\n            }\n        } else if (hasDigits) {\n            int i;\n            try {\n                i = Integer.parseInt(rep.replace("$", ""));\n            } catch (NumberFormatException e) {\n                return null;\n            }\n            if (i<1 || i>_ssVersion.getMaxRows()) {\n                return null;\n            }\n        } else {\n            // just dollars ? can this happen?\n            return null;\n        }\n\n\n        resetPointer(ptr+1); // stepping forward\n        return new SimpleRangePart(rep, hasLetters, hasDigits);\n    }
1153	public void removeTailRecord(NoteRecord note) {\n        tailRec.remove(note.getShapeId());\n    }
1154	public static boolean canComputeColumnWidth(Font font) {\n        // not sure what is the best value sample-here, only "1" did not work on some platforms...\n        AttributedString str = new AttributedString("1w");\n        copyAttributes(font, str, 0, "1w".length());\n\n        TextLayout layout = new TextLayout(str.getIterator(), fontRenderContext);\n        return (layout.getBounds().getWidth() > 0);\n    }
1155	public static void setVerticalAlignment(Cell cell, VerticalAlignment align) {\n        setCellStyleProperty(cell, VERTICAL_ALIGNMENT, align);\n    }
1156	public XSLFSlide createSlide(XSLFSlideLayout layout) {\n        int slideNumber = 256, cnt = 1;\n        CTSlideIdList slideList;\n        XSLFRelation relationType = XSLFRelation.SLIDE;\n        if (!_presentation.isSetSldIdLst()) {\n            slideList = _presentation.addNewSldIdLst();\n        } else {\n            slideList = _presentation.getSldIdLst();\n            for (CTSlideIdListEntry slideId : slideList.getSldIdArray()) {\n                slideNumber = (int) Math.max(slideId.getId() + 1, slideNumber);\n                cnt++;\n            }\n\n            cnt = findNextAvailableFileNameIndex(relationType, cnt);\n        }\n\n        RelationPart rp = createRelationship\n                (relationType, XSLFFactory.getInstance(), cnt, false);\n        XSLFSlide slide = rp.getDocumentPart();\n\n        CTSlideIdListEntry slideId = slideList.addNewSldId();\n        slideId.setId(slideNumber);\n        slideId.setId2(rp.getRelationship().getId());\n\n        layout.copyLayout(slide);\n        slide.getPackagePart().clearRelationships();\n        slide.addRelation(null, XSLFRelation.SLIDE_LAYOUT, layout);\n\n        _slides.add(slide);\n        return slide;\n    }
1157	public static Record buildRecordAtOffset(byte[] b, int offset) {\n		long type = LittleEndian.getUShort(b,offset+2);\n		long rlen = LittleEndian.getUInt(b,offset+4);\n\n		// Sanity check the length\n		int rleni = (int)rlen;\n		if(rleni < 0) { rleni = 0; }\n\n		return createRecordForType(type,b,offset,8+rleni);\n	}
1158	public List<EvaluationConditionalFormatRule> getFormatRulesForSheet(String sheetName) {\n        return getFormatRulesForSheet(workbook.getSheet(sheetName));\n    }
1159	public static XMLInputFactory newXMLInputFactory() {\n        XMLInputFactory factory = XMLInputFactory.newFactory();\n        trySetProperty(factory, XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        trySetProperty(factory, XMLInputFactory.IS_VALIDATING, false);\n        trySetProperty(factory, XMLInputFactory.SUPPORT_DTD, false);\n        trySetProperty(factory, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        return factory;\n    }
1160	public static boolean isValidExcelDate(double value)\n    {\n        return (value > -Double.MIN_VALUE);\n    }
1161	public void read(final POIFSFileSystem poifs) throws IOException {\n        registryClosed = true;\n\n        // get property table from the document\n        PropertyTable properties = poifs.getPropertyTable();\n\n        // process documents\n        RootProperty root = properties.getRoot();\n        processProperties(poifs, root, new POIFSDocumentPath());\n    }
1162	public void clearAllCachedFormats() {\n        formats.clear();\n    }
1163	public static Map<String,HSSFColor> getTripletHash()\n    {\n        return createColorsByHexStringMap();\n    }
1164	public static SimpleFraction buildFractionMaxDenominator(double value, int maxDenominator){\n        return buildFractionMaxDenominator(value, 0, maxDenominator, 100);\n    }
1165	@Internal\n    public byte getITypeTxt()\n    {\n        return ( byte )iTypeTxt.getValue(field_2_bits);\n    }
1166	void setUnicodeString(UnicodeString str) {\n      this._string = str;\n    }
1167	public int findTextRecords(int startPos, List<String> textV) {\n		// Grab the length, and the first option byte\n		// Note that the length doesn't include the 8 byte atom header\n		int len = (int)LittleEndian.getUInt(pptContents,startPos+4);\n		byte opt = pptContents[startPos];\n\n		// If it's a container, step into it and return\n		// (If it's a container, option byte 1 BINARY_AND 0x0f will be 0x0f)\n		int container = opt & 0x0f;\n		if(container == 0x0f) {\n			return (startPos+8);\n		}\n\n		// Otherwise, check the type to see if it's text\n		int type = LittleEndian.getUShort(pptContents,startPos+2);\n\n		// TextBytesAtom\n		if(type == RecordTypes.TextBytesAtom.typeID) {\n			TextBytesAtom tba = (TextBytesAtom)Record.createRecordForType(type, pptContents, startPos, len+8);\n			String text = HSLFTextParagraph.toExternalString(tba.getText(), -1);\n			textV.add(text);\n		}\n		// TextCharsAtom\n		if(type == RecordTypes.TextCharsAtom.typeID) {\n			TextCharsAtom tca = (TextCharsAtom)Record.createRecordForType(type, pptContents, startPos, len+8);\n            String text = HSLFTextParagraph.toExternalString(tca.getText(), -1);\n            textV.add(text);\n		}\n\n		// CString (doesn't go via a TextRun)\n		if(type == RecordTypes.CString.typeID) {\n			CString cs = (CString)Record.createRecordForType(type, pptContents, startPos, len+8);\n			String text = cs.getText();\n\n			// Ignore the ones we know to be rubbish\n			if(text.equals("___PPT10")) {\n			} else if(text.equals("Default Design")) {\n			} else {\n				textV.add(text);\n			}\n		}\n\n\n		// Wind on by the atom length, and check we're not at the end\n		int newPos = (startPos + 8 + len);\n		if(newPos > (pptContents.length - 8)) {\n			newPos = -1;\n		}\n		return newPos;\n	}
1168	private static PrintGridlinesRecord createPrintGridlines() {\n        PrintGridlinesRecord retval = new PrintGridlinesRecord();\n\n        retval.setPrintGridlines(false);\n        return retval;\n    }
1169	public static void putLong( byte[] data, int offset, long value )\n    {\n        data[offset + 0] = (byte) ( ( value >>> 0 ) & 0xFF );\n        data[offset + 1] = (byte) ( ( value >>> 8 ) & 0xFF );\n        data[offset + 2] = (byte) ( ( value >>> 16 ) & 0xFF );\n        data[offset + 3] = (byte) ( ( value >>> 24 ) & 0xFF );\n        data[offset + 4] = (byte) ( ( value >>> 32 ) & 0xFF );\n        data[offset + 5] = (byte) ( ( value >>> 40 ) & 0xFF );\n        data[offset + 6] = (byte) ( ( value >>> 48 ) & 0xFF );\n        data[offset + 7] = (byte) ( ( value >>> 56 ) & 0xFF );\n    }
1170	@Internal\n    public boolean isFScratch()\n    {\n        return fScratch.isSet(field_1_info1);\n    }
1171	private void implicitlyTrackColumnsInRow(Row row) {\n        // track new columns\n        if (trackAllColumns) {\n            // if column is not tracked, implicitly track the column if trackAllColumns is True and column has not been explicitly untracked \n            for (final Cell cell : row) {\n                final int column = cell.getColumnIndex();\n                implicitlyTrackColumn(column);\n            }\n        }\n    }
1172	public void setIndent(double value){\n        CTTextParagraphProperties pr = _p.isSetPPr() ? _p.getPPr() : _p.addNewPPr();\n        if(value == -1) {\n            if(pr.isSetIndent()) pr.unsetIndent();\n        } else {\n            pr.setIndent(Units.toEMU(value));\n        }\n    }
1173	public void commit() throws IOException {\n\n        if(extPart == null && ext != null && ext.props != null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n            try {\n                PackagePartName prtname = PackagingURIHelper.createPartName("/docProps/app.xml");\n                pkg.addRelationship(prtname, TargetMode.INTERNAL, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties");\n                extPart = pkg.createPart(prtname, "application/vnd.openxmlformats-officedocument.extended-properties+xml");\n            } catch (InvalidFormatException e){\n                throw new POIXMLException(e);\n            }\n        }\n        if(custPart == null && cust != null && cust.props != null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n            try {\n                PackagePartName prtname = PackagingURIHelper.createPartName("/docProps/custom.xml");\n                pkg.addRelationship(prtname, TargetMode.INTERNAL, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties");\n                custPart = pkg.createPart(prtname, "application/vnd.openxmlformats-officedocument.custom-properties+xml");\n            } catch (InvalidFormatException e){\n                throw new POIXMLException(e);\n            }\n        }\n        if(extPart != null){\n            try (OutputStream out = extPart.getOutputStream()) {\n                if (extPart.getSize() > 0) {\n                    extPart.clear();\n                }\n                ext.props.save(out, DEFAULT_XML_OPTIONS);\n            }\n        }\n        if(custPart != null){\n            try (OutputStream out = custPart.getOutputStream()) {\n                cust.props.save(out, DEFAULT_XML_OPTIONS);\n            }\n        }\n    }
1174	public static int createXorVerifier2(String password) {\n        if (password == null) {\n            throw new IllegalArgumentException("Password cannot be null");\n        }\n\n        //Array to hold Key Values\n        byte[] generatedKey = new byte[4];\n\n        //Maximum length of the password is 15 chars.\n        final int maxPasswordLength = 15; \n        \n        if (!password.isEmpty()) {\n            // Truncate the password to 15 characters\n            password = password.substring(0, Math.min(password.length(), maxPasswordLength));\n\n            byte[] arrByteChars = toAnsiPassword(password);\n            \n            // Compute the high-order word of the new key:\n\n            // --> Initialize from the initial code array (see below), depending on the passwords length. \n            int highOrderWord = INITIAL_CODE_ARRAY[arrByteChars.length - 1];\n\n            // --> For each character in the password:\n            //      --> For every bit in the character, starting with the least significant and progressing to (but excluding) \n            //          the most significant, if the bit is set, XOR the keys high-order word with the corresponding word from \n            //          the Encryption Matrix\n            for (int i = 0; i < arrByteChars.length; i++) {\n                int tmp = maxPasswordLength - arrByteChars.length + i;\n                for (int intBit = 0; intBit < 7; intBit++) {\n                    if ((arrByteChars[i] & (0x0001 << intBit)) != 0) {\n                        highOrderWord ^= ENCRYPTION_MATRIX[tmp][intBit];\n                    }\n                }\n            }\n            \n            // Compute the low-order word of the new key:\n            int verifier = createXorVerifier1(password);\n\n            // The byte order of the result shall be reversed [password "Example": 0x64CEED7E becomes 7EEDCE64],\n            // and that value shall be hashed as defined by the attribute values.\n            \n            LittleEndian.putShort(generatedKey, 0, (short)verifier);\n            LittleEndian.putShort(generatedKey, 2, (short)highOrderWord);\n        }\n        \n        return LittleEndian.getInt(generatedKey);\n    }
1175	String getPropertyStringValue(final int propertyId) {\n        Object propertyValue = getProperty(propertyId);\n        return getPropertyStringValue(propertyValue);\n    }
1176	public int countOfAllChildren() {\n        return 1;\n    }
1177	private void isCellBorderMatches(Locator loc1, Locator loc2, char borderSide) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        XSSFCellStyle style1 = ((XSSFCell)loc1.cell).getCellStyle();\n        XSSFCellStyle style2 = ((XSSFCell)loc2.cell).getCellStyle();\n        boolean b1, b2;\n        String borderName;\n        switch (borderSide) {\n            case 't': default:\n                b1 = style1.getBorderTop() == BorderStyle.THIN;\n                b2 = style2.getBorderTop() == BorderStyle.THIN;\n                borderName = "TOP";\n                break;\n            case 'b':\n                b1 = style1.getBorderBottom() == BorderStyle.THIN;\n                b2 = style2.getBorderBottom() == BorderStyle.THIN;\n                borderName = "BOTTOM";\n                break;\n            case 'l':\n                b1 = style1.getBorderLeft() == BorderStyle.THIN;\n                b2 = style2.getBorderLeft() == BorderStyle.THIN;\n                borderName = "LEFT";\n                break;\n            case 'r':\n                b1 = style1.getBorderRight() == BorderStyle.THIN;\n                b2 = style2.getBorderRight() == BorderStyle.THIN;\n                borderName = "RIGHT";\n                break;\n        }\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                "Cell Border Attributes does not Match ::",\n                (b1 ? "" : "NOT ")+borderName+" BORDER",\n                (b2 ? "" : "NOT ")+borderName+" BORDER"\n            );\n        }\n    }
1178	public static void putShort( OutputStream outputStream, short value )\n            throws IOException\n    {\n        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n    }
1179	protected String getColumnName( int columnIndex )\n    {\n        return NumberFormatter.getNumber( columnIndex + 1, 3 );\n    }
1180	private int writeHidden(RowRecord pRowRecord, int row) {\n        int rowIx = row;\n        RowRecord rowRecord = pRowRecord;\n        int level = rowRecord.getOutlineLevel();\n        while (rowRecord != null && getRow(rowIx).getOutlineLevel() >= level) {\n            rowRecord.setZeroHeight(true);\n            rowIx++;\n            rowRecord = getRow(rowIx);\n        }\n        return rowIx;\n    }
1181	public boolean renameTo(final String newName)\n    {\n        boolean rval = false;\n\n        if (!isRoot())\n        {\n            rval = _parent.changeName(getName(), newName);\n        }\n        return rval;\n    }
1182	protected static Record[] normalizeRecords(Record records[]) {\n        // http://msdn.microsoft.com/en-us/library/office/gg615594(v=office.14).aspx\n        // repeated slideIds can be overwritten, i.e. ignored\n\n        UserEditAtom uea = null;\n        PersistPtrHolder pph = null;\n        TreeMap<Integer,Integer> slideLocations = new TreeMap<>();\n        TreeMap<Integer,Record> recordMap = new TreeMap<>();\n        List<Integer> obsoleteOffsets = new ArrayList<>();\n        int duplicatedCount = 0;\n        for (Record r : records) {\n            assert(r instanceof PositionDependentRecord);\n            PositionDependentRecord pdr = (PositionDependentRecord)r;\n            if (pdr instanceof UserEditAtom) {\n                uea = (UserEditAtom)pdr;\n                continue;\n            }\n\n            if (pdr instanceof PersistPtrHolder) {\n                if (pph != null) {\n                    duplicatedCount++;\n                }\n                pph = (PersistPtrHolder)pdr;\n                for (Map.Entry<Integer,Integer> me : pph.getSlideLocationsLookup().entrySet()) {\n                    Integer oldOffset = slideLocations.put(me.getKey(), me.getValue());\n                    if (oldOffset != null) {\n                        obsoleteOffsets.add(oldOffset);\n                    }\n                }\n                continue;\n            }\n\n            recordMap.put(pdr.getLastOnDiskOffset(), r);\n        }\n\n        if (uea == null || pph == null || uea.getPersistPointersOffset() != pph.getLastOnDiskOffset()) {\n            throw new EncryptedDocumentException("UserEditAtom and PersistPtrHolder must exist and their offset need to match.");\n        }\n\n        recordMap.put(pph.getLastOnDiskOffset(), pph);\n        recordMap.put(uea.getLastOnDiskOffset(), uea);\n\n        if (duplicatedCount == 0 && obsoleteOffsets.isEmpty()) {\n            return records;\n        }\n\n        uea.setLastUserEditAtomOffset(0);\n        pph.clear();\n        for (Map.Entry<Integer,Integer> me : slideLocations.entrySet()) {\n            pph.addSlideLookup(me.getKey(), me.getValue());\n        }\n\n        for (Integer oldOffset : obsoleteOffsets) {\n            recordMap.remove(oldOffset);\n        }\n\n        return recordMap.values().toArray(new Record[recordMap.size()]);\n    }
1183	public byte[] read(final byte[] src, final int offset) {\n        /* Read double word. */\n        bytes[0] = src[3 + offset];\n        bytes[1] = src[2 + offset];\n        bytes[2] = src[1 + offset];\n        bytes[3] = src[0 + offset];\n\n        /* Read first word. */\n        bytes[4] = src[5 + offset];\n        bytes[5] = src[4 + offset];\n\n        /* Read second word. */\n        bytes[6] = src[7 + offset];\n        bytes[7] = src[6 + offset];\n\n        /* Read 8 bytes. */\n        System.arraycopy(src, 8 + offset, bytes, 8, 8);\n\n        return bytes;\n    }
1184	public boolean isDocPropsEncrypted() {\n        return !flagDocProps.isSet(getEncryptionFlags());\n    }
1185	private static CalcModeRecord createCalcMode() {\n        CalcModeRecord retval = new CalcModeRecord();\n\n        retval.setCalcMode(( short ) 1);\n        return retval;\n    }
1186	public boolean getProtect() {\n        return settingsProtectedFlag.isSet(_options);\n    }
1187	public void extractMessageBody(File dest) throws IOException {\n        MAPIAttribute body = getBodyAttribute();\n        if (body == null) {\n            System.err.println("No message body found, " + dest + " not created");\n            return;\n        }\n        if (body instanceof MAPIStringAttribute) {\n            String name = dest.toString();\n            if (name.endsWith(".rtf")) { \n                name = name.substring(0, name.length()-4);\n            }\n            dest = new File(name + ".txt");\n        }\n        \n        OutputStream fout = new FileOutputStream(dest);\n        try {\n            if (body instanceof MAPIStringAttribute) {\n                // Save in a predictable encoding, not raw bytes\n                String text = ((MAPIStringAttribute)body).getDataString();\n                fout.write(text.getBytes(StringUtil.UTF8));\n            } else {\n                // Save the raw bytes, should be raw RTF\n                fout.write(body.getData());\n            }\n        } finally {\n            fout.close();\n        }\n    }
1188	protected <T extends TextProp> T getPropVal(TextPropCollection props, String propName) {\n        String propNames[] = propName.split(",");\n        for (String pn : propNames) {\n            T prop = props.findByName(pn);\n            if (isValidProp(prop)) {\n                return prop;\n            }\n        }\n\n        return getMasterPropVal(props, propName);\n    }
1189	public BigInteger addAbstractNum(XWPFAbstractNum abstractNum) {\n        int pos = abstractNums.size();\n        if (abstractNum.getAbstractNum() != null) { // Use the current CTAbstractNum if it exists\n            ctNumbering.addNewAbstractNum().set(abstractNum.getAbstractNum());\n        } else {\n            ctNumbering.addNewAbstractNum();\n            abstractNum.getAbstractNum().setAbstractNumId(BigInteger.valueOf(pos));\n            ctNumbering.setAbstractNumArray(pos, abstractNum.getAbstractNum());\n        }\n        abstractNums.add(abstractNum);\n        return abstractNum.getCTAbstractNum().getAbstractNumId();\n    }
1190	private void write() {\n        int pos = 0;\n        _data = IOUtils.safelyAllocate(indents.size()*6, MAX_RECORD_LENGTH);\n        for (IndentProp prop : indents) {\n            LittleEndian.putInt(_data, pos, prop.getCharactersCovered());\n            LittleEndian.putShort(_data, pos+4, (short)prop.getIndentLevel());\n            pos += 6;\n        }\n    }
1191	public void addChildBefore(EscherRecord record, int insertBeforeRecordId) {\n        int idx = 0;\n        for (EscherRecord rec : this) {\n            if(rec.getRecordId() == (short)insertBeforeRecordId) {\n                break;\n            }\n            // TODO - keep looping? Do we expect multiple matches?\n            idx++;\n        }\n        _childRecords.add(idx, record);\n    }
1192	public XSSFFont findFont(boolean bold, short color, short fontHeight, String name, boolean italic, boolean strikeout, short typeOffset, byte underline) {\n        for (XSSFFont font : fonts) {\n            if (    (font.getBold() == bold)\n                    && font.getColor() == color\n                    && font.getFontHeight() == fontHeight\n                    && font.getFontName().equals(name)\n                    && font.getItalic() == italic\n                    && font.getStrikeout() == strikeout\n                    && font.getTypeOffset() == typeOffset\n                    && font.getUnderline() == underline)\n            {\n                return font;\n            }\n        }\n        return null;\n    }
1193	public Borders getBorderBottom() {\n        CTPBdr border = getCTPBrd(false);\n        CTBorder ct = null;\n        if (border != null) {\n            ct = border.getBottom();\n        }\n        STBorder.Enum ptrn = ct != null ? ct.getVal() : STBorder.NONE;\n        return Borders.valueOf(ptrn.intValue());\n    }
1194	public void addLateHeaderFooter(HeaderFooterRecord rec) {\n        if (_headerFooter != null) {\n            throw new IllegalStateException("This page settings block already has a header/footer record");\n        }\n        if (rec.getSid() != HeaderFooterRecord.sid) {\n            throw new org.apache.poi.util.RecordFormatException("Unexpected header-footer record sid: 0x" + Integer.toHexString(rec.getSid()));\n        }\n        _headerFooter = rec;\n    }
1195	private static Record createRecord(RecordInputStream in) {\n        switch (in.getSid()) {\n            case AreaFormatRecord.sid:        return new AreaFormatRecord(in);\n            case AreaRecord.sid:              return new AreaRecord(in);\n            case ArrayRecord.sid:             return new ArrayRecord(in);\n            case AxisLineFormatRecord.sid:    return new AxisLineFormatRecord(in);\n            case AxisOptionsRecord.sid:       return new AxisOptionsRecord(in);\n            case AxisParentRecord.sid:        return new AxisParentRecord(in);\n            case AxisRecord.sid:              return new AxisRecord(in);\n            case AxisUsedRecord.sid:          return new AxisUsedRecord(in);\n            case AutoFilterInfoRecord.sid:    return new AutoFilterInfoRecord(in);\n            case BOFRecord.sid:               return new BOFRecord(in);\n            case BackupRecord.sid:            return new BackupRecord(in);\n            case BarRecord.sid:               return new BarRecord(in);\n            case BeginRecord.sid:             return new BeginRecord(in);\n            case BlankRecord.sid:             return new BlankRecord(in);\n            case BookBoolRecord.sid:          return new BookBoolRecord(in);\n            case BoolErrRecord.sid:           return new BoolErrRecord(in);\n            case BottomMarginRecord.sid:      return new BottomMarginRecord(in);\n            case BoundSheetRecord.sid:        return new BoundSheetRecord(in);\n            case CFHeaderRecord.sid:          return new CFHeaderRecord(in);\n            case CFHeader12Record.sid:        return new CFHeader12Record(in);\n            case CFRuleRecord.sid:            return new CFRuleRecord(in);\n            case CFRule12Record.sid:          return new CFRule12Record(in);\n            // TODO Add CF Ex, and remove from UnknownRecord \n            case CalcCountRecord.sid:         return new CalcCountRecord(in);\n            case CalcModeRecord.sid:          return new CalcModeRecord(in);\n            case CategorySeriesAxisRecord.sid:return new CategorySeriesAxisRecord(in);\n            case ChartFormatRecord.sid:       return new ChartFormatRecord(in);\n            case ChartRecord.sid:             return new ChartRecord(in);\n            case CodepageRecord.sid:          return new CodepageRecord(in);\n            case ColumnInfoRecord.sid:        return new ColumnInfoRecord(in);\n            case ContinueRecord.sid:          return new ContinueRecord(in);\n            case CountryRecord.sid:           return new CountryRecord(in);\n            case DBCellRecord.sid:            return new DBCellRecord(in);\n            case DSFRecord.sid:               return new DSFRecord(in);\n            case DatRecord.sid:               return new DatRecord(in);\n            case DataFormatRecord.sid:        return new DataFormatRecord(in);\n            case DateWindow1904Record.sid:    return new DateWindow1904Record(in);\n            case DConRefRecord.sid:           return new DConRefRecord(in);\n            case DefaultColWidthRecord.sid:   return new DefaultColWidthRecord(in);\n            case DefaultDataLabelTextPropertiesRecord.sid: return new DefaultDataLabelTextPropertiesRecord(in);\n            case DefaultRowHeightRecord.sid:  return new DefaultRowHeightRecord(in);\n            case DeltaRecord.sid:             return new DeltaRecord(in);\n            case DimensionsRecord.sid:        return new DimensionsRecord(in);\n            case DrawingGroupRecord.sid:      return new DrawingGroupRecord(in);\n            case DrawingRecordForBiffViewer.sid: return new DrawingRecordForBiffViewer(in);\n            case DrawingSelectionRecord.sid:  return new DrawingSelectionRecord(in);\n            case DVRecord.sid:                return new DVRecord(in);\n            case DVALRecord.sid:              return new DVALRecord(in);\n            case EOFRecord.sid:               return new EOFRecord(in);\n            case EndRecord.sid:               return new EndRecord(in);\n            case ExtSSTRecord.sid:            return new ExtSSTRecord(in);\n            case ExtendedFormatRecord.sid:    return new ExtendedFormatRecord(in);\n            case ExternSheetRecord.sid:       return new ExternSheetRecord(in);\n            case ExternalNameRecord.sid:      return new ExternalNameRecord(in);\n            case FeatRecord.sid:              return new FeatRecord(in);\n            case FeatHdrRecord.sid:           return new FeatHdrRecord(in);\n            case FilePassRecord.sid:          return new FilePassRecord(in);\n            case FileSharingRecord.sid:       return new FileSharingRecord(in);\n            case FnGroupCountRecord.sid:      return new FnGroupCountRecord(in);\n            case FontBasisRecord.sid:         return new FontBasisRecord(in);\n            case FontIndexRecord.sid:         return new FontIndexRecord(in);\n            case FontRecord.sid:              return new FontRecord(in);\n            case FooterRecord.sid:            return new FooterRecord(in);\n            case FormatRecord.sid:            return new FormatRecord(in);\n            case FormulaRecord.sid:           return new FormulaRecord(in);\n            case FrameRecord.sid:             return new FrameRecord(in);\n            case GridsetRecord.sid:           return new GridsetRecord(in);\n            case GutsRecord.sid:              return new GutsRecord(in);\n            case HCenterRecord.sid:           return new HCenterRecord(in);\n            case HeaderRecord.sid:            return new HeaderRecord(in);\n            case HideObjRecord.sid:           return new HideObjRecord(in);\n            case HorizontalPageBreakRecord.sid: return new HorizontalPageBreakRecord(in);\n            case HyperlinkRecord.sid:         return new HyperlinkRecord(in);\n            case IndexRecord.sid:             return new IndexRecord(in);\n            case InterfaceEndRecord.sid:      return InterfaceEndRecord.create(in);\n            case InterfaceHdrRecord.sid:      return new InterfaceHdrRecord(in);\n            case IterationRecord.sid:         return new IterationRecord(in);\n            case LabelRecord.sid:             return new LabelRecord(in);\n            case LabelSSTRecord.sid:          return new LabelSSTRecord(in);\n            case LeftMarginRecord.sid:        return new LeftMarginRecord(in);\n            case LegendRecord.sid:            return new LegendRecord(in);\n            case LineFormatRecord.sid:        return new LineFormatRecord(in);\n            case LinkedDataRecord.sid:        return new LinkedDataRecord(in);\n            case MMSRecord.sid:               return new MMSRecord(in);\n            case MergeCellsRecord.sid:        return new MergeCellsRecord(in);\n            case MulBlankRecord.sid:          return new MulBlankRecord(in);\n            case MulRKRecord.sid:             return new MulRKRecord(in);\n            case NameRecord.sid:              return new NameRecord(in);\n            case NameCommentRecord.sid:       return new NameCommentRecord(in);\n            case NoteRecord.sid:              return new NoteRecord(in);\n            case NumberRecord.sid:            return new NumberRecord(in);\n            case ObjRecord.sid:               return new ObjRecord(in);\n            case ObjectLinkRecord.sid:        return new ObjectLinkRecord(in);\n            case PaletteRecord.sid:           return new PaletteRecord(in);\n            case PaneRecord.sid:              return new PaneRecord(in);\n            case PasswordRecord.sid:          return new PasswordRecord(in);\n            case PasswordRev4Record.sid:      return new PasswordRev4Record(in);\n            case PlotAreaRecord.sid:          return new PlotAreaRecord(in);\n            case PlotGrowthRecord.sid:        return new PlotGrowthRecord(in);\n            case PrecisionRecord.sid:         return new PrecisionRecord(in);\n            case PrintGridlinesRecord.sid:    return new PrintGridlinesRecord(in);\n            case PrintHeadersRecord.sid:      return new PrintHeadersRecord(in);\n            case PrintSetupRecord.sid:        return new PrintSetupRecord(in);\n            case ProtectRecord.sid:           return new ProtectRecord(in);\n            case ProtectionRev4Record.sid:    return new ProtectionRev4Record(in);\n            case RKRecord.sid:                return new RKRecord(in);\n            case RecalcIdRecord.sid:          return new RecalcIdRecord(in);\n            case RefModeRecord.sid:           return new RefModeRecord(in);\n            case RefreshAllRecord.sid:        return new RefreshAllRecord(in);\n            case RightMarginRecord.sid:       return new RightMarginRecord(in);\n            case RowRecord.sid:               return new RowRecord(in);\n            case SCLRecord.sid:               return new SCLRecord(in);\n            case SSTRecord.sid:               return new SSTRecord(in);\n            case SaveRecalcRecord.sid:        return new SaveRecalcRecord(in);\n            case SelectionRecord.sid:         return new SelectionRecord(in);\n            case SeriesIndexRecord.sid:       return new SeriesIndexRecord(in);\n            case SeriesListRecord.sid:        return new SeriesListRecord(in);\n            case SeriesRecord.sid:            return new SeriesRecord(in);\n            case SeriesTextRecord.sid:        return new SeriesTextRecord(in);\n            case SeriesToChartGroupRecord.sid:return new SeriesToChartGroupRecord(in);\n            case SharedFormulaRecord.sid:     return new SharedFormulaRecord(in);\n            case SheetPropertiesRecord.sid:   return new SheetPropertiesRecord(in);\n            case StringRecord.sid:            return new StringRecord(in);\n            case StyleRecord.sid:             return new StyleRecord(in);\n            case SupBookRecord.sid:           return new SupBookRecord(in);\n            case TabIdRecord.sid:             return new TabIdRecord(in);\n            case TableStylesRecord.sid:       return new TableStylesRecord(in);\n            case TableRecord.sid:             return new TableRecord(in);\n            case TextObjectRecord.sid:        return new TextObjectRecord(in);\n            case TextRecord.sid:              return new TextRecord(in);\n            case TickRecord.sid:              return new TickRecord(in);\n            case TopMarginRecord.sid:         return new TopMarginRecord(in);\n            case UncalcedRecord.sid:          return new UncalcedRecord(in);\n            case UnitsRecord.sid:             return new UnitsRecord(in);\n            case UseSelFSRecord.sid:          return new UseSelFSRecord(in);\n            case VCenterRecord.sid:           return new VCenterRecord(in);\n            case ValueRangeRecord.sid:        return new ValueRangeRecord(in);\n            case VerticalPageBreakRecord.sid: return new VerticalPageBreakRecord(in);\n            case WSBoolRecord.sid:            return new WSBoolRecord(in);\n            case WindowOneRecord.sid:         return new WindowOneRecord(in);\n            case WindowProtectRecord.sid:     return new WindowProtectRecord(in);\n            case WindowTwoRecord.sid:         return new WindowTwoRecord(in);\n            case WriteAccessRecord.sid:       return new WriteAccessRecord(in);\n            case WriteProtectRecord.sid:      return new WriteProtectRecord(in);\n\n            // chart\n            case CatLabRecord.sid:            return new CatLabRecord(in);\n            case ChartEndBlockRecord.sid:     return new ChartEndBlockRecord(in);\n            case ChartEndObjectRecord.sid:    return new ChartEndObjectRecord(in);\n            case ChartFRTInfoRecord.sid:      return new ChartFRTInfoRecord(in);\n            case ChartStartBlockRecord.sid:   return new ChartStartBlockRecord(in);\n            case ChartStartObjectRecord.sid:  return new ChartStartObjectRecord(in);\n\n            // pivot table\n            case StreamIDRecord.sid:           return new StreamIDRecord(in);\n            case ViewSourceRecord.sid:         return new ViewSourceRecord(in);\n            case PageItemRecord.sid:           return new PageItemRecord(in);\n            case ViewDefinitionRecord.sid:     return new ViewDefinitionRecord(in);\n            case ViewFieldsRecord.sid:         return new ViewFieldsRecord(in);\n            case DataItemRecord.sid:           return new DataItemRecord(in);\n            case ExtendedPivotTableViewFieldsRecord.sid: return new ExtendedPivotTableViewFieldsRecord(in);\n        }\n        return new UnknownRecord(in);\n    }
1196	private int getEscherRecordSize(List<EscherRecord> records) {\n        int size = 0;\n        for (EscherRecord record : records){\n            size += record.getRecordSize();\n        }\n        return size;\n    }
1197	public void createSplitPane(int xSplitPos, int ySplitPos, int topRow, int leftmostColumn, int activePane) {\n        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n        if (paneLoc != -1)\n            _records.remove(paneLoc);\n\n        int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n        PaneRecord r = new PaneRecord();\n        r.setX((short)xSplitPos);\n        r.setY((short)ySplitPos);\n        r.setTopRow((short) topRow);\n        r.setLeftColumn((short) leftmostColumn);\n        r.setActivePane((short) activePane);\n        _records.add(loc+1, r);\n\n        windowTwo.setFreezePanes(false);\n        windowTwo.setFreezePanesNoSplit(false);\n\n        SelectionRecord sel = (SelectionRecord) findFirstRecordBySid(SelectionRecord.sid);\n        if (sel != null) {\n            sel.setPane(PANE_LOWER_RIGHT);\n        }\n\n    }
1198	public void writeUInt( long value ) {\n		try {\n			out.write( (byte) ( ( value ) & 0xFF ) );\n			out.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n			out.write( (byte) ( ( value >>> 16 ) & 0xFF ) );\n			out.write( (byte) ( ( value >>> 24 ) & 0xFF ) );\n		} catch (IOException e) {\n			throw new RuntimeException(e);\n		}\n	}
1199	static public double pmt(double r, int nper, double pv, double fv) {\n	    return pmt(r, nper, pv, fv, 0);\n	}
1200	public boolean marshall(PackagePart part, OutputStream out)\n			throws OpenXML4JException {\n		return part.save(out);\n	}
1201	public XSSFSheet cloneSheet(int sheetNum, String newName) {\n        validateSheetIndex(sheetNum);\n        XSSFSheet srcSheet = sheets.get(sheetNum);\n\n        if (newName == null) {\n            String srcName = srcSheet.getSheetName();\n            newName = getUniqueSheetName(srcName);\n        } else {\n            validateSheetName(newName);\n        }\n\n        XSSFSheet clonedSheet = createSheet(newName);\n\n        // copy sheet's relations\n        List<RelationPart> rels = srcSheet.getRelationParts();\n        // if the sheet being cloned has a drawing then remember it and re-create it too\n        XSSFDrawing dg = null;\n        for(RelationPart rp : rels) {\n            POIXMLDocumentPart r = rp.getDocumentPart();\n            // do not copy the drawing relationship, it will be re-created\n            if(r instanceof XSSFDrawing) {\n                dg = (XSSFDrawing)r;\n                continue;\n            }\n\n            addRelation(rp, clonedSheet);\n        }\n\n        try {\n            for(PackageRelationship pr : srcSheet.getPackagePart().getRelationships()) {\n                if (pr.getTargetMode() == TargetMode.EXTERNAL) {\n                    clonedSheet.getPackagePart().addExternalRelationship\n                            (pr.getTargetURI().toASCIIString(), pr.getRelationshipType(), pr.getId());\n                }\n            }\n        } catch (InvalidFormatException e) {\n            throw new POIXMLException("Failed to clone sheet", e);\n        }\n\n\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n            srcSheet.write(out);\n            try (ByteArrayInputStream bis = new ByteArrayInputStream(out.toByteArray())) {\n                clonedSheet.read(bis);\n            }\n        } catch (IOException e){\n            throw new POIXMLException("Failed to clone sheet", e);\n        }\n        CTWorksheet ct = clonedSheet.getCTWorksheet();\n        if(ct.isSetLegacyDrawing()) {\n            logger.log(POILogger.WARN, "Cloning sheets with comments is not yet supported.");\n            ct.unsetLegacyDrawing();\n        }\n        if (ct.isSetPageSetup()) {\n            logger.log(POILogger.WARN, "Cloning sheets with page setup is not yet supported.");\n            ct.unsetPageSetup();\n        }\n\n        clonedSheet.setSelected(false);\n\n        // clone the sheet drawing along with its relationships\n        if (dg != null) {\n            if(ct.isSetDrawing()) {\n                // unset the existing reference to the drawing,\n                // so that subsequent call of clonedSheet.createDrawingPatriarch() will create a new one\n                ct.unsetDrawing();\n            }\n            XSSFDrawing clonedDg = clonedSheet.createDrawingPatriarch();\n            // copy drawing contents\n            clonedDg.getCTDrawing().set(dg.getCTDrawing());\n\n            clonedDg = clonedSheet.createDrawingPatriarch();\n\n            // Clone drawing relations\n            List<RelationPart> srcRels = srcSheet.createDrawingPatriarch().getRelationParts();\n            for (RelationPart rp : srcRels) {\n                addRelation(rp, clonedDg);\n            }\n        }\n        return clonedSheet;\n    }
1202	public boolean equals(final Object o)\n    {\n        boolean rval = this == o;\n\n        if (!rval && (o != null) && (o.getClass() == this.getClass()))\n        {\n            IntList other = ( IntList ) o;\n\n            if (other._limit == _limit)\n            {\n\n                // assume match\n                rval = true;\n                for (int j = 0; rval && (j < _limit); j++)\n                {\n                    rval = _array[ j ] == other._array[ j ];\n                }\n            }\n        }\n        return rval;\n    }
1203	public static Workbook create(final DirectoryNode root) throws IOException {\n        return create(root, null);\n    }
1204	private static int unpaddedLength(byte[] buf) {\n        final int end = (buf.length-(buf.length+3)%4);\n        for (int i = buf.length; i>end; i--) {\n            if (buf[i-1] != 0) {\n                return i;\n            }\n        }\n        return end;\n    }
1205	public static void setAlignment(Cell cell, HorizontalAlignment align) {\n        setCellStyleProperty(cell, ALIGNMENT, align);\n    }
1206	public void setDirty() {\n        _dirty = true;\n    }
1207	public boolean hasSameName(XWPFStyle compStyle) {\n        CTStyle ctCompStyle = compStyle.getCTStyle();\n        String name = ctCompStyle.getName().getVal();\n        return name.equals(ctStyle.getName().getVal());\n    }
1208	public final Break getBreak(int main) {\n        Integer rowKey = Integer.valueOf(main);\n        return _breakMap.get(rowKey);\n    }
1209	public static BATBlock createBATBlock(final POIFSBigBlockSize bigBlockSize, ByteBuffer data)\n    {\n       // Create an empty block\n       BATBlock block = new BATBlock(bigBlockSize);\n       \n       // Fill it\n       byte[] buffer = new byte[LittleEndian.INT_SIZE];\n       for(int i=0; i<block._values.length; i++) {\n          data.get(buffer);\n          block._values[i] = LittleEndian.getInt(buffer);\n       }\n       block.recomputeFree();\n       \n       // All done\n       return block;\n    }
1210	private static PaletteRecord createPalette() {\n        return new PaletteRecord();\n    }
1211	private static int findDataValidationTableInsertPos(List<RecordBase> records) {\n		int i = records.size() - 1;\n		if (!(records.get(i) instanceof EOFRecord)) {\n			throw new IllegalStateException("Last sheet record should be EOFRecord");\n		}\n		while (i > 0) {\n			i--;\n			RecordBase rb = records.get(i);\n			if (isDVTPriorRecord(rb)) {\n				Record nextRec = (Record) records.get(i + 1);\n				if (!isDVTSubsequentRecord(nextRec.getSid())) {\n					throw new IllegalStateException("Unexpected (" + nextRec.getClass().getName()\n							+ ") found after (" + rb.getClass().getName() + ")");\n				}\n				return i+1;\n			}\n			Record rec = (Record) rb;\n			if (!isDVTSubsequentRecord(rec.getSid())) {\n				throw new IllegalStateException("Unexpected (" + rec.getClass().getName()\n						+ ") while looking for DV Table insert pos");\n			}\n		}\n		return 0;\n	}
1212	public List<EvaluationConditionalFormatRule> getFormatRulesForSheet(Sheet sheet) {\n        return getRules(sheet);\n    }
1213	/* package */ void loadRelationships() throws InvalidFormatException {\n        if (this._relationships == null && !this._isRelationshipPart) {\n            this.throwExceptionIfRelationship();\n            _relationships = new PackageRelationshipCollection(this);\n        }\n    }
1214	public boolean isFNested()\n    {\n        return fNested.isSet( field_2_flt );\n\n    }
1215	public boolean getEvenAndOddHeadings() {\n        return ctSettings.isSetEvenAndOddHeaders();\n    }
1216	private int findChildLocation(Record child) {\n	    int i=0;\n		for(Record r : _children) {\n			if (r.equals(child)) {\n				return i;\n			}\n			i++;\n		}\n		return -1;\n	}
1217	private static HideObjRecord createHideObj() {\n        HideObjRecord retval = new HideObjRecord();\n        retval.setHideObj(( short ) 0);   // by default set hide object off\n        return retval;\n    }
1218	public static void putUnicodeLE(String input, byte[] output, int offset) {\n        byte[] bytes = input.getBytes(UTF16LE);\n        System.arraycopy(bytes, 0, output, offset, bytes.length);\n    }
1219	public XWPFFooter createFooter(HeaderFooterType type) {\n        XWPFHeaderFooterPolicy hfPolicy = createHeaderFooterPolicy();\n        // TODO this needs to be migrated out into section code\n        if (type == HeaderFooterType.FIRST) {\n            CTSectPr ctSectPr = getSection();\n            if (!ctSectPr.isSetTitlePg()) {\n                CTOnOff titlePg = ctSectPr.addNewTitlePg();\n                titlePg.setVal(STOnOff.ON);\n            }\n            // } else if (type == HeaderFooterType.EVEN) {\n            // TODO Add support for Even/Odd headings and footers\n        }\n        return hfPolicy.createFooter(STHdrFtr.Enum.forInt(type.toInt()));\n    }
1220	private int calculateNewFirstCell(int firstcell) {\n        int cellIx = firstcell + 1;\n        HSSFCell r = retrieveCell(cellIx);\n\n        while (r == null) {\n            if (cellIx <= cells.length) {\n                return 0;\n            }\n            r = retrieveCell(++cellIx);\n        }\n        return cellIx;\n    }
1221	public Path2D.Double getPath(Context ctx) {\n        Path2D.Double path = new Path2D.Double();\n        for(PathCommand cmd : commands) {\n            cmd.execute(path, ctx);\n        }\n        return path;\n    }
1222	public XWPFParagraph createParagraph() {\n        XWPFParagraph p = new XWPFParagraph(ctDocument.getBody().addNewP(), this);\n        bodyElements.add(p);\n        paragraphs.add(p);\n        return p;\n    }
1223	private static int clip(int row) {\n        return Math.min(\n                Math.max(0, row),\n                SpreadsheetVersion.EXCEL97.getLastRowIndex());\n    }
1224	void addDocument(final POIFSDocument document)\n    {\n        _property_table.addProperty(document.getDocumentProperty());\n    }
1225	public void notifyUpdateCell(HSSFCell cell) {\n        _bookEvaluator.notifyUpdateCell(new HSSFEvaluationCell(cell));\n    }
1226	public boolean retainAll(final IntList c)\n    {\n        boolean rval = false;\n\n        for (int j = 0; j < _limit; )\n        {\n            if (!c.contains(_array[ j ]))\n            {\n                remove(j);\n                rval = true;\n            }\n            else\n            {\n                j++;\n            }\n        }\n        return rval;\n    }
1227	public static List<List<HSLFTextParagraph>> findTextParagraphs(PPDrawing ppdrawing, HSLFSheet sheet) {\n        List<List<HSLFTextParagraph>> runsV = new ArrayList<>();\n        for (EscherTextboxWrapper wrapper : ppdrawing.getTextboxWrappers()) {\n            List<HSLFTextParagraph> p = findTextParagraphs(wrapper, sheet);\n            if (p != null) {\n                runsV.add(p);\n            }\n        }\n        return runsV;\n    }
1228	public String getFontName(){\n    	final int maxLen = Math.min(_recdata.length,64)/2;\n    	return StringUtil.getFromUnicodeLE0Terminated(_recdata, 0, maxLen);\n    }
1229	public boolean save(OutputStream outStream) {\n        Document xmlOutDoc = DocumentHelper.createDocument();\n\n        // Building namespace\n        Element typesElem = xmlOutDoc.createElementNS(TYPES_NAMESPACE_URI, TYPES_TAG_NAME);\n        xmlOutDoc.appendChild(typesElem);\n\n        // Adding default types\n        for (Entry<String, String> entry : defaultContentType.entrySet()) {\n            appendDefaultType(typesElem, entry);\n        }\n\n        // Adding specific types if any exist\n        if (overrideContentType != null) {\n            for (Entry<PackagePartName, String> entry : overrideContentType\n                    .entrySet()) {\n                appendSpecificTypes(typesElem, entry);\n            }\n        }\n        xmlOutDoc.normalize();\n\n        // Save content in the specified output stream\n        return this.saveImpl(xmlOutDoc, outStream);\n    }
1230	public boolean removeAll(final IntList c)\n    {\n        boolean rval = false;\n\n        for (int j = 0; j < c._limit; j++)\n        {\n            if (removeValue(c._array[ j ]))\n            {\n                rval = true;\n            }\n        }\n        return rval;\n    }
1231	private static ObjectProtectRecord createObjectProtect() {\n		ObjectProtectRecord retval = new ObjectProtectRecord();\n		retval.setProtect(false);\n		return retval;\n	}
1232	public void normalizeRecords() {\n        try {\n            updateAndWriteDependantRecords(null, null);\n        } catch (IOException e) {\n            throw new CorruptPowerPointFileException(e);\n        }\n        _records = HSLFSlideShowEncrypted.normalizeRecords(_records);\n    }
1233	public void removeRowBreak(int row) {\n        if (getRowBreaksRecord().getBreaks().length < 1) {\n            throw new IllegalArgumentException("Sheet does not define any row breaks");\n        }\n        getRowBreaksRecord().removeBreak((short)row);\n    }
1234	private String getUniqueSheetName(String srcName) {\n        int uniqueIndex = 2;\n        String baseName = srcName;\n        int bracketPos = srcName.lastIndexOf('(');\n        if (bracketPos > 0 && srcName.endsWith(")")) {\n            String suffix = srcName.substring(bracketPos + 1, srcName.length() - ")".length());\n            try {\n                uniqueIndex = Integer.parseInt(suffix.trim());\n                uniqueIndex++;\n                baseName = srcName.substring(0, bracketPos).trim();\n            } catch (NumberFormatException e) {\n                // contents of brackets not numeric\n            }\n        }\n        while (true) {\n            // Try and find the next sheet name that is unique\n            String index = Integer.toString(uniqueIndex++);\n            String name;\n            if (baseName.length() + index.length() + 2 < 31) {\n                name = baseName + " (" + index + ")";\n            } else {\n                name = baseName.substring(0, 31 - index.length() - 2) + "(" + index + ")";\n            }\n\n            //If the sheet name is unique, then set it otherwise move on to the next number.\n            if (getSheetIndex(name) == -1) {\n                return name;\n            }\n        }\n    }
1235	private void convertLabelRecords(List<Record> records, int offset)\n     {\n         if (log.check( POILogger.DEBUG )) {\n            log.log(POILogger.DEBUG, "convertLabelRecords called");\n        }\n         for (int k = offset; k < records.size(); k++)\n         {\n             Record rec = records.get(k);\n\n             if (rec.getSid() == LabelRecord.sid)\n             {\n                 LabelRecord oldrec = ( LabelRecord ) rec;\n\n                 records.remove(k);\n                 LabelSSTRecord newrec   = new LabelSSTRecord();\n                 int            stringid =\n                     workbook.addSSTString(new UnicodeString(oldrec.getValue()));\n\n                 newrec.setRow(oldrec.getRow());\n                 newrec.setColumn(oldrec.getColumn());\n                 newrec.setXFIndex(oldrec.getXFIndex());\n                 newrec.setSSTIndex(stringid);\n                       records.add(k, newrec);\n             }\n         }\n         if (log.check( POILogger.DEBUG )) {\n            log.log(POILogger.DEBUG, "convertLabelRecords exit");\n        }\n     }
1236	public void decompress(InputStream src, OutputStream res) throws IOException {\n      // How far through the output we've got\n      // (This is normally used &4095, so it nicely wraps)\n      // The initial value is set when populating the dictionary\n      int pos;\n      // The flag byte is treated as its 8 individual\n      //  bits, which tell us if the following 8 codes\n      //  are compressed or un-compressed\n      int flag;\n      // The mask, between 1 and 255, which is used when\n      //  processing each bit of the flag byte in turn\n      int mask;\n\n      // We use 12 bit codes:\n      // * 0-255 are real bytes\n      // * 256-4095 are the substring codes\n      // Java handily initialises our buffer / dictionary\n      //  to all zeros\n      byte[] buffer = new byte[4096];\n      pos = populateDictionary(buffer);\n\n      // These are bytes as looked up in the dictionary\n      // It needs to be signed, as it'll get passed on to\n      //  the output stream\n      byte[] dataB = IOUtils.safelyAllocate(16+codeLengthIncrease, MAX_RECORD_LENGTH);\n      // This is an unsigned byte read from the stream\n      // It needs to be unsigned, so that bit stuff works\n      int dataI;\n      // The compressed code sequence is held over 2 bytes\n      int dataIPt1, dataIPt2;\n      // How long a code sequence is, and where in the\n      //  dictionary to start at\n      int len, pntr;\n\n      while( (flag = src.read()) != -1 ) {\n         // Compare each bit in our flag byte in turn:\n         for(mask = 1; mask < 256 ; mask <<= 1) {\n            // Is this a new code (un-compressed), or\n            //  the use of existing codes (compressed)?\n            boolean isMaskSet = (flag & mask) > 0;\n            if( isMaskSet ^ maskMeansCompressed ) {\n               // Retrieve the un-compressed code\n               if( (dataI = src.read()) != -1) {\n                  // Save the byte into the dictionary\n                  buffer[(pos&4095)] = fromInt(dataI);\n                  pos++;\n                  // And output the byte\n                  res.write( new byte[] {fromInt(dataI)} );\n               }\n            } else {\n               // We have a compressed sequence\n               // Grab the next 16 bits of data\n               dataIPt1 = src.read();\n               dataIPt2 = src.read();\n               if(dataIPt1 == -1 || dataIPt2 == -1) break;\n\n               // Build up how long the code sequence is, and\n               //  what position of the code to start at\n               // (The position is the usually the first 12 bits, \n               //  and the length is usually the last 4 bits)\n               len = (dataIPt2 & 15) + codeLengthIncrease;\n               if(positionIsBigEndian) {\n                  pntr = (dataIPt1<<4) + (dataIPt2>>4);\n               } else {\n                  pntr = dataIPt1 + ((dataIPt2&0xF0)<<4);\n               }\n               \n               // Adjust the pointer as needed\n               pntr = adjustDictionaryOffset(pntr);\n\n               // Loop over the codes, outputting what they correspond to\n               for(int i=0; i<len; i++) {\n                  dataB[i] = buffer[(pntr + i) & 4095];\n                  buffer[ (pos + i) & 4095 ] = dataB[i];\n               }\n               res.write(dataB, 0, len);\n\n               // Record how far along the stream we have moved\n               pos = pos + len;\n            }\n         }\n      }\n   }
1237	public static void putInt( int value, OutputStream outputStream )\n            throws IOException\n    {\n        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );\n    }
1238	private ClientAnchorDetail fitImageToRows(HSSFSheet sheet, int rowNumber,\n            double reqImageHeightMM, int resizeBehaviour) {\n        double rowCoordinatesPerMM;\n        int pictureHeightCoordinates;\n        ClientAnchorDetail rowClientAnchorDetail = null;\n\n        // Get the row and it's height\n        HSSFRow row = sheet.getRow(rowNumber);\n        if(row == null) {\n            // Create row if it does not exist.\n            row = sheet.createRow(rowNumber);\n        }\n\n        // Get the row's height in millimetres\n        double rowHeightMM = row.getHeightInPoints() / ConvertImageUnits.POINTS_PER_MILLIMETRE;\n\n        // Check that the row's height will accomodate the image at the required\n        // dimensions. If the height of the row is LESS than the required height\n        // of the image, decide how the application should respond - resize the\n        // row or overlay the image across a series of rows.\n        if(rowHeightMM < reqImageHeightMM) {\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_ROW) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                row.setHeightInPoints((float)(reqImageHeightMM *\n                        ConvertImageUnits.POINTS_PER_MILLIMETRE));\n                rowHeightMM = reqImageHeightMM;\n                rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n                pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n                rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n            }\n            // If the user has chosen to overlay both rows and columns or just\n            // to expand ONLY the size of the columns, then calculate how to lay\n            // the image out ver one or more rows.\n            else if((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                    (resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN)) {\n                rowClientAnchorDetail = this.calculateRowLocation(sheet,\n                        rowNumber, reqImageHeightMM);\n            }\n        }\n        // Else, if the image is smaller than the space available\n        else {\n            rowCoordinatesPerMM = ConvertImageUnits.TOTAL_ROW_COORDINATE_POSITIONS /\n                    rowHeightMM;\n            pictureHeightCoordinates = (int)(reqImageHeightMM * rowCoordinatesPerMM);\n            rowClientAnchorDetail = new ClientAnchorDetail(rowNumber,\n                        rowNumber, pictureHeightCoordinates);\n        }\n        return(rowClientAnchorDetail);\n    }
1239	public int getCharCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_CHARCOUNT);\n    }
1240	private static <T> T nvl(T value, T defaultValue)  {\n        return value == null ? defaultValue : value;\n    }
1241	public ExHyperlink get(int id){\n        for(int i=0; i<_children.length; i++) {\n            if(_children[i] instanceof ExHyperlink) {\n                ExHyperlink rec = (ExHyperlink)_children[i];\n                if (rec.getExHyperlinkAtom().getNumber() == id){\n                    return rec;\n                }\n            }\n        }\n        return null;\n    }
1242	public int readShort() throws IOException {\n        return readShort(this);\n    }
1243	public String getARGBHex() {\n       byte[] rgb = getARGB();\n        if(rgb == null) {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for(byte c : rgb) {\n          int i = c & 0xff;\n          String cs = Integer.toHexString(i);\n          if(cs.length() == 1) {\n             sb.append('0');\n          }\n          sb.append(cs);\n       }\n       return sb.toString().toUpperCase(Locale.ROOT);\n    }
1244	public boolean isBuiltInName()\n	{\n		return ((field_1_option_flag & Option.OPT_BUILTIN) != 0);\n	}
1245	public static CFRule12Record create(HSSFSheet sheet, IconSet iconSet) {\n        Threshold[] ts = new Threshold[iconSet.num];\n        for (int i=0; i<ts.length; i++) {\n            ts[i] = new IconMultiStateThreshold();\n        }\n        \n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_ICON_SET, \n                                              ComparisonOperator.NO_COMPARISON);\n        IconMultiStateFormatting imf = r.createMultiStateFormatting();\n        imf.setIconSet(iconSet);\n        imf.setThresholds(ts);\n        return r;\n    }
1246	private void onSheetDelete(int index) {\n        // remove all sheet relations\n        final XSSFSheet sheet = getSheetAt(index);\n\n        sheet.onSheetDelete();\n\n        //delete the CTSheet reference from workbook.xml\n        workbook.getSheets().removeSheet(index);\n\n        //calculation chain is auxiliary, remove it as it may contain orphan references to deleted cells\n        if(calcChain != null) {\n            removeRelation(calcChain);\n            calcChain = null;\n        }\n\n        //adjust indices of names ranges\n        List<XSSFName> toRemove = new ArrayList<>();\n        for (XSSFName nm : namedRanges) {\n            CTDefinedName ct = nm.getCTName();\n            if(!ct.isSetLocalSheetId()) {\n                continue;\n            }\n            if (ct.getLocalSheetId() == index) {\n                toRemove.add(nm);\n            } else if (ct.getLocalSheetId() > index){\n                // Bump down by one, so still points at the same sheet\n                ct.setLocalSheetId(ct.getLocalSheetId()-1);\n            }\n        }\n        for (XSSFName nm : toRemove) {\n            removeName(nm);\n        }\n    }
1247	public String getReadablePath()\n    {\n        if (path != null)\n        {\n            //all of the path strings start with either 0x02 or 0x01 followed by zero or\n            //more of 0x01..0x08\n            int offset = 1;\n            while (path[offset] < 0x20 && offset < path.length)\n            {\n                offset++;\n            }\n            String out = new String(Arrays.copyOfRange(path, offset, path.length), StringUtil.UTF8);\n            //UNC paths have \u0003 chars as path separators.\n            out = out.replaceAll("\u0003", "/");\n            return out;\n        }\n        return null;\n    }
1248	private static int propLen(\n        TreeBidiMap<Long,Long> offset2Id,\n        Long entryOffset,\n        long maxSize) {\n        Long nextKey = offset2Id.nextKey(entryOffset);\n        long begin = entryOffset;\n        long end = (nextKey != null) ? nextKey : maxSize;\n        return (int)(end - begin);\n    }
1249	public static boolean validatePassword(XmlObject xobj, String password, String prefix) {\n        // TODO: is "velvetSweatshop" the default password?\n        if (password == null) return false;\n        \n        XmlCursor cur = xobj.newCursor();\n        String xorHashVal = cur.getAttributeText(getAttrName(prefix, "password"));\n        String algoName = cur.getAttributeText(getAttrName(prefix, "algorithmName"));\n        String hashVal = cur.getAttributeText(getAttrName(prefix, "hashValue"));\n        String saltVal = cur.getAttributeText(getAttrName(prefix, "saltValue"));\n        String spinCount = cur.getAttributeText(getAttrName(prefix, "spinCount"));\n        cur.dispose();\n\n        if (xorHashVal != null) {\n            int hash1 = Integer.parseInt(xorHashVal, 16);\n            int hash2 = CryptoFunctions.createXorVerifier1(password);\n            return hash1 == hash2;\n        } else {\n            if (hashVal == null || algoName == null || saltVal == null || spinCount == null) {\n                return false;\n            }\n            \n            byte hash1[] = DatatypeConverter.parseBase64Binary(hashVal);\n            HashAlgorithm hashAlgo = HashAlgorithm.fromString(algoName);\n            byte salt[] = DatatypeConverter.parseBase64Binary(saltVal);\n            int spinCnt = Integer.parseInt(spinCount);\n            byte hash2[] = CryptoFunctions.hashPassword(password, hashAlgo, salt, spinCnt, false);\n            return Arrays.equals(hash1, hash2);\n        }\n    }
1250	protected EscherContainerRecord createSpContainer() {\n        EscherContainerRecord spContainer = new EscherContainerRecord();\n        EscherSpRecord sp = new EscherSpRecord();\n        EscherOptRecord opt = new EscherOptRecord();\n        EscherClientDataRecord clientData = new EscherClientDataRecord();\n\n        spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n        spContainer.setOptions((short) 0x000F);\n        sp.setRecordId(EscherSpRecord.RECORD_ID);\n        sp.setOptions((short) ((EscherAggregate.ST_NOT_PRIMATIVE << 4) | 0x2));\n        if (getParent() == null) {\n            sp.setFlags(EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE);\n        } else {\n            sp.setFlags(EscherSpRecord.FLAG_CHILD | EscherSpRecord.FLAG_HAVEANCHOR | EscherSpRecord.FLAG_HASSHAPETYPE);\n        }\n        opt.setRecordId(EscherOptRecord.RECORD_ID);\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.TRANSFORM__ROTATION, false, false, 0));\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, false, false, 100));\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, false, false, 100));\n        opt.setEscherProperty(new EscherShapePathProperty(EscherProperties.GEOMETRY__SHAPEPATH, EscherShapePathProperty.COMPLEX));\n\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__FILLOK, false, false, 0x00010001));\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINESTARTARROWHEAD, false, false, 0x0));\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDARROWHEAD, false, false, 0x0));\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEENDCAPSTYLE, false, false, 0x0));\n\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEDASHING, LINESTYLE_SOLID));\n        opt.setEscherProperty( new EscherBoolProperty( EscherProperties.LINESTYLE__NOLINEDRAWDASH, 0x00080008));\n        opt.setEscherProperty(new EscherSimpleProperty(EscherProperties.LINESTYLE__LINEWIDTH, LINEWIDTH_DEFAULT));\n        opt.setEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, FILL__FILLCOLOR_DEFAULT));\n        opt.setEscherProperty(new EscherRGBProperty(EscherProperties.LINESTYLE__COLOR, LINESTYLE__COLOR_DEFAULT));\n        opt.setEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, 1));\n\n        opt.setEscherProperty(new EscherBoolProperty( EscherProperties.GROUPSHAPE__PRINT, 0x080000));\n\n        EscherRecord anchor = getAnchor().getEscherAnchor();\n        clientData.setRecordId(EscherClientDataRecord.RECORD_ID);\n        clientData.setOptions((short) 0x0000);\n\n        spContainer.addChildRecord(sp);\n        spContainer.addChildRecord(opt);\n        spContainer.addChildRecord(anchor);\n        spContainer.addChildRecord(clientData);\n\n        return spContainer;\n    }
1251	public boolean isAutoTextColor()\n    {\n        return autoTextColor.isSet(field_10_options);\n    }
1252	public XSSFPatternFormatting createPatternFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTFill fill;\n        if(!dxf.isSetFill()) {\n            fill = dxf.addNewFill();\n        } else {\n            fill = dxf.getFill();\n        }\n\n        return new XSSFPatternFormatting(fill, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
1253	static void overlapping(Sheet sheet) {\n        for (int i=0; i<40; i++) {\n            int rn = i+1;\n            Row r = sheet.createRow(i);\n            r.createCell(0).setCellValue("This is row " + rn + " (" + i + ")");\n            String str = "";\n            if (rn%2 == 0) {\n                str = str + "even ";\n            }\n            if (rn%3 == 0) {\n                str = str + "x3 ";\n            }\n            if (rn%5 == 0) {\n                str = str + "x5 ";\n            }\n            if (rn%10 == 0) {\n                str = str + "x10 ";\n            }\n            if (str.length() == 0) {\n                str = "nothing special...";\n            }\n            r.createCell(1).setCellValue("It is " + str);\n        }\n        sheet.autoSizeColumn(0);\n        sheet.autoSizeColumn(1);\n        \n        sheet.getRow(1).createCell(3).setCellValue("Even rows are blue");\n        sheet.getRow(2).createCell(3).setCellValue("Multiples of 3 have a grey background");\n        sheet.getRow(4).createCell(3).setCellValue("Multiples of 5 are bold");\n        sheet.getRow(9).createCell(3).setCellValue("Multiples of 10 are red (beats even)");\n        \n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n        // Condition 1: Row divides by 10, red (will beat #1)\n        ConditionalFormattingRule rule1 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),10)=0");\n        FontFormatting font1 = rule1.createFontFormatting();\n        font1.setFontColorIndex(IndexedColors.RED.index);\n        \n        // Condition 2: Row is even, blue\n        ConditionalFormattingRule rule2 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),2)=0");\n        FontFormatting font2 = rule2.createFontFormatting();\n        font2.setFontColorIndex(IndexedColors.BLUE.index);\n        \n        // Condition 3: Row divides by 5, bold\n        ConditionalFormattingRule rule3 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),5)=0");\n        FontFormatting font3 = rule3.createFontFormatting();\n        font3.setFontStyle(false, true);\n        \n        // Condition 4: Row divides by 3, grey background\n        ConditionalFormattingRule rule4 = \n                sheetCF.createConditionalFormattingRule("MOD(ROW(),3)=0");\n        PatternFormatting fill4 = rule4.createPatternFormatting();\n        fill4.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);\n        fill4.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n        \n        // Apply\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:F41")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        sheetCF.addConditionalFormatting(regions, rule3);\n        sheetCF.addConditionalFormatting(regions, rule4);\n    }
1254	public boolean isColumnBroken(int column) {\n        return getColumnBreaksRecord().getBreak(column) != null;\n    }
1255	public void decompress(InputStream src, OutputStream res) throws IOException {\n      // Validate the header on the front of the RTF\n      compressedSize = LittleEndian.readInt(src);\n      decompressedSize = LittleEndian.readInt(src);\n      int compressionType = LittleEndian.readInt(src);\n      /* int dataCRC = */ LittleEndian.readInt(src);\n      \n      // TODO - Handle CRC checking on the output side\n      \n      // Do we need to do anything?\n      if(compressionType == UNCOMPRESSED_SIGNATURE_INT) {\n         // Nope, nothing fancy to do\n         IOUtils.copy(src, res);\n      } else if(compressionType == COMPRESSED_SIGNATURE_INT) {\n         // We need to decompress it below\n      } else {\n         throw new IllegalArgumentException("Invalid compression signature " + compressionType);\n      }\n\n      // Have it processed\n      super.decompress(src, res);\n   }
1256	protected void writeDocument(Document document) throws MarshalException {\n        XmlOptions xo = new XmlOptions();\n        Map<String,String> namespaceMap = new HashMap<>();\n        for(Map.Entry<String,String> entry : signatureConfig.getNamespacePrefixes().entrySet()){\n            namespaceMap.put(entry.getValue(), entry.getKey());\n        }\n        xo.setSaveSuggestedPrefixes(namespaceMap);\n        xo.setUseDefaultNamespace();\n\n        LOG.log(POILogger.DEBUG, "output signed Office OpenXML document");\n\n        /*\n         * Copy the original OOXML content to the signed OOXML package. During\n         * copying some files need to changed.\n         */\n        OPCPackage pkg = signatureConfig.getOpcPackage();\n\n        PackagePartName sigPartName, sigsPartName;\n        try {\n            // <Override PartName="/_xmlsignatures/sig1.xml" ContentType="application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml"/>\n            sigPartName = PackagingURIHelper.createPartName("/_xmlsignatures/sig1.xml");\n            // <Default Extension="sigs" ContentType="application/vnd.openxmlformats-package.digital-signature-origin"/>\n            sigsPartName = PackagingURIHelper.createPartName("/_xmlsignatures/origin.sigs");\n        } catch (InvalidFormatException e) {\n            throw new MarshalException(e);\n        }\n\n        PackagePart sigPart = pkg.getPart(sigPartName);\n        if (sigPart == null) {\n            sigPart = pkg.createPart(sigPartName, ContentTypes.DIGITAL_SIGNATURE_XML_SIGNATURE_PART);\n        }\n\n        try {\n            OutputStream os = sigPart.getOutputStream();\n            SignatureDocument sigDoc = SignatureDocument.Factory.parse(document, DEFAULT_XML_OPTIONS);\n            sigDoc.save(os, xo);\n            os.close();\n        } catch (Exception e) {\n            throw new MarshalException("Unable to write signature document", e);\n        }\n\n        PackagePart sigsPart = pkg.getPart(sigsPartName);\n        if (sigsPart == null) {\n            // touch empty marker file\n            sigsPart = pkg.createPart(sigsPartName, ContentTypes.DIGITAL_SIGNATURE_ORIGIN_PART);\n        }\n\n        PackageRelationshipCollection relCol = pkg.getRelationshipsByType(PackageRelationshipTypes.DIGITAL_SIGNATURE_ORIGIN);\n        for (PackageRelationship pr : relCol) {\n            pkg.removeRelationship(pr.getId());\n        }\n        pkg.addRelationship(sigsPartName, TargetMode.INTERNAL, PackageRelationshipTypes.DIGITAL_SIGNATURE_ORIGIN);\n\n        sigsPart.addRelationship(sigPartName, TargetMode.INTERNAL, PackageRelationshipTypes.DIGITAL_SIGNATURE);\n    }
1257	public void referenceUpdated(CellAddress oldReference, CTComment comment) {\n       if(commentRefs != null) {\n          commentRefs.remove(oldReference);\n          commentRefs.put(new CellAddress(comment.getRef()), comment);\n       }\n    }
1258	public boolean isHorizontal()\n    {\n        return horizontal.isSet(field_3_formatFlags);\n    }
1259	public static OPCPackage open(ZipEntrySource zipEntry)\n   throws InvalidFormatException {\n       OPCPackage pack = new ZipPackage(zipEntry, PackageAccess.READ);\n       try {\n           if (pack.partList == null) {\n               pack.getParts();\n           }\n           // pack.originalPackagePath = file.getAbsolutePath();\n           return pack;\n       } catch (InvalidFormatException | RuntimeException e) {\n		   IOUtils.closeQuietly(pack);\n           throw e;\n       }\n   }
1260	private String parseAsColumnQuantifier() {\n        if ( look != '[') {\n            return null;\n        }\n        GetChar();\n        if (look == '#') {\n            return null;\n        }\n        if (look == '@') {\n            GetChar();\n        }\n        StringBuilder name = new StringBuilder();\n        while (look!=']') {\n           name.appendCodePoint(look);\n           GetChar();\n        }\n        Match(']');\n        return name.toString();\n    }
1261	public void decode()\n    {\n        if (null == escherRecords || 0 == escherRecords.size()){\n            byte[] rawData = getRawData();\n            convertToEscherRecords(0, rawData.length, rawData );\n        }\n    }
1262	private void ensureSection2() {\n        if (getSectionCount() < 2) {\n            Section s2 = new Section();\n            s2.setFormatID(USER_DEFINED_PROPERTIES);\n            addSection(s2);\n        }\n    }
1263	private static HorizontalAlignment getHorizontalAlignment(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        HorizontalAlignment align;\n        if (value instanceof HorizontalAlignment) {\n            align = (HorizontalAlignment) value;\n        }\n        // @deprecated 3.15 beta 2. getHorizontalAlignment will only work on HorizontalAlignment enums instead of codes in the future.\n        else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map used a Short value for "\n                        + name + ". Should use HorizontalAlignment enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            align = HorizontalAlignment.forInt(code);\n        }\n        else if (value == null) {\n            align = HorizontalAlignment.GENERAL;\n        }\n        else {\n            throw new RuntimeException("Unexpected horizontal alignment style class. Must be HorizontalAlignment or Short (deprecated).");\n        }\n        return align;\n    }
1264	private PackageRelationshipCollection getRelationshipsHelper(String id) {\n		throwExceptionIfWriteOnly();\n		ensureRelationships();\n		return this.relationships.getRelationships(id);\n	}
1265	public boolean isAutoYPositioning()\n    {\n        return autoYPositioning.isSet(field_7_options);\n    }
1266	public void setIndexed(int indexed) {\n        ctColor.setIndexed(indexed);\n    }
1267	public void writeContinueIfRequired(int requiredContinuousSize) {\n		if (_ulrOutput.getAvailableSpace() < requiredContinuousSize) {\n			writeContinue();\n		}\n	}
1268	private static void validateFunctionName(String functionName) {\n		int len = functionName.length();\n		int ix = len - 1;\n		if (!Character.isDigit(functionName.charAt(ix))) {\n			return;\n		}\n		while(ix >= 0) {\n			if (!Character.isDigit(functionName.charAt(ix))) {\n				break;\n			}\n			ix--;\n		}\n		if(DIGIT_ENDING_FUNCTION_NAMES_SET.contains(functionName)) {\n			return;\n		}\n		throw new RuntimeException("Invalid function name '" + functionName\n				+ "' (is footnote number incorrectly appended)");\n	}
1269	/* package */ static boolean isSpecialChar(char ch) {\n		// note - Character.isJavaIdentifierPart() would allow dollars '$'\n		if(Character.isLetterOrDigit(ch)) {\n			return false;\n		}\n		switch(ch) {\n			case '.': // dot is OK\n			case '_': // underscore is OK\n				return false;\n			case '\n':\n			case '\r':\n			case '\t':\n				throw new RuntimeException("Illegal character (0x" \n						+ Integer.toHexString(ch) + ") found in sheet name");\n		}\n		return true;\n	}
1270	@Internal\n    public boolean isFRMarkDel()\n    {\n        return fRMarkDel.isSet(field_1_grpfChp);\n    }
1271	public XWPFHyperlink getHyperlink(XWPFDocument document) {\n        String id = getHyperlinkId();\n        if (id == null)\n            return null;\n\n        return document.getHyperlinkByID(id);\n    }
1272	private void setBlank(){\n        CTCell blank = CTCell.Factory.newInstance();\n        blank.setR(_cell.getR());\n        if(_cell.isSetS()) {\n            blank.setS(_cell.getS());\n        }\n        _cell.set(blank);\n    }
1273	public static boolean isValid(Cell cell, DataValidationContext context) {\n            return values()[context.getValidation().getValidationConstraint().getValidationType()].isValidValue(cell, context);\n        }
1274	public Collection<PackagePart> sortedValues() {\n	    return Collections.unmodifiableCollection(packagePartLookup.values());\n\n	}
1275	public boolean isFColor()\n    {\n        return fColor.isSet( field_2_tlp_flags );\n\n    }
1276	private Double evalOrConstant(String formula, DataValidationContext context) throws NumberFormatException {\n            if (formula == null || formula.trim().isEmpty()) return null; // shouldn't happen, but just in case\n            try {\n                return Double.valueOf(formula);\n            } catch (NumberFormatException e) {\n                // must be an expression, then.  Overloading by Excel in the file formats.\n            }\n            // note the call to the "unwrapped" version, which returns a single value\n            ValueEval eval = context.getEvaluator().getWorkbookEvaluator().evaluate(formula, context.getTarget(), context.getRegion());\n            if (eval instanceof RefEval) {\n                eval = ((RefEval) eval).getInnerValueEval(((RefEval) eval).getFirstSheetIndex());\n            }\n            if (eval instanceof BlankEval) return null;\n            if (eval instanceof NumberEval) return Double.valueOf(((NumberEval) eval).getNumberValue());\n            if (eval instanceof StringEval) {\n                final String value = ((StringEval) eval).getStringValue();\n                if (value == null || value.trim().isEmpty()) return null; \n                // try to parse the cell value as a double and return it \n                return Double.valueOf(value);\n            }\n            throw new NumberFormatException("Formula '" + formula + "' evaluates to something other than a number");\n        }
1277	private int remainingBytes() {\n        return (int)(size - pos);\n    }
1278	public StyleTextProp9Atom[] getNumberedListInfo() {\n    	return this.getPPDrawing().getNumberedListInfo();\n    }
1279	private Ptg rowCopyAreaPtg(AreaPtgBase aptg) {\n        boolean changed = false;\n    \n        final int aFirstRow = aptg.getFirstRow();\n        final int aLastRow = aptg.getLastRow();\n    \n        if (aptg.isFirstRowRelative()) {\n            final int destFirstRowIndex = aFirstRow + _amountToMove;\n            if (destFirstRowIndex < 0 || _version.getLastRowIndex() < destFirstRowIndex)\n                return createDeletedRef(aptg);\n            aptg.setFirstRow(destFirstRowIndex);\n            changed = true;\n        }\n        if (aptg.isLastRowRelative()) {\n            final int destLastRowIndex = aLastRow + _amountToMove;\n            if (destLastRowIndex < 0 || _version.getLastRowIndex() < destLastRowIndex)\n                return createDeletedRef(aptg);\n            aptg.setLastRow(destLastRowIndex);\n            changed = true;\n        }\n        if (changed) {\n            aptg.sortTopLeftToBottomRight();\n        }\n\n        return changed ? aptg : null;\n    }
1280	public double getCharacterSpacing(){\n        CTTextCharacterProperties rPr = getRPr();\n        if(rPr.isSetSpc()){\n            return rPr.getSpc()*0.01;\n        }\n        return 0;\n    }
1281	public void adjustForDelete(int start, int length) {\n        int end = start + length;\n\n        if (_cpEnd > start) {\n            // The start of the change is before we end\n\n            if (_cpStart < end) {\n                // The delete was somewhere in the middle of us\n                _cpEnd = end >= _cpEnd ? start : _cpEnd - length;\n                _cpStart = Math.min(start, _cpStart);\n            } else {\n                // The delete was before us\n                _cpEnd -= length;\n                _cpStart -= length;\n            }\n        }\n    }
1282	static void dataBars(Sheet sheet) {\n        sheet.createRow(0).createCell(0).setCellValue("Data Bars");\n        Row r = sheet.createRow(1);\n        r.createCell(1).setCellValue("Green Positive");\n        r.createCell(2).setCellValue("Blue Mix");\n        r.createCell(3).setCellValue("Red Negative");\n        r = sheet.createRow(2);\n        r.createCell(1).setCellValue(0);\n        r.createCell(2).setCellValue(0);\n        r.createCell(3).setCellValue(0);\n        r = sheet.createRow(3);\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(-5);\n        r.createCell(3).setCellValue(-5);\n        r = sheet.createRow(4);\n        r.createCell(1).setCellValue(10);\n        r.createCell(2).setCellValue(10);\n        r.createCell(3).setCellValue(-10);\n        r = sheet.createRow(5);\n        r.createCell(1).setCellValue(5);\n        r.createCell(2).setCellValue(5);\n        r.createCell(3).setCellValue(-5);\n        r = sheet.createRow(6);\n        r.createCell(1).setCellValue(20);\n        r.createCell(2).setCellValue(-10);\n        r.createCell(3).setCellValue(-20);\n        sheet.setColumnWidth(0, 3000);\n        sheet.setColumnWidth(1, 5000);\n        sheet.setColumnWidth(2, 5000);\n        sheet.setColumnWidth(3, 5000);\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n        \n        ExtendedColor color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FF63BE7B");\n        CellRangeAddress[] regions = { CellRangeAddress.valueOf("B2:B7") };\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db1 = rule1.getDataBarFormatting();\n        db1.getMinThreshold().setRangeType(RangeType.MIN);\n        db1.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule1);\n        \n        color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FF5A8AC6");\n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("C2:C7") };\n        ConditionalFormattingRule rule2 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db2 = rule2.getDataBarFormatting();\n        db2.getMinThreshold().setRangeType(RangeType.MIN);\n        db2.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule2);\n        \n        color = sheet.getWorkbook().getCreationHelper().createExtendedColor();\n        color.setARGBHex("FFF8696B");\n        regions = new CellRangeAddress[] { CellRangeAddress.valueOf("D2:D7") };\n        ConditionalFormattingRule rule3 = sheetCF.createConditionalFormattingRule(color);\n        DataBarFormatting db3 = rule3.getDataBarFormatting();\n        db3.getMinThreshold().setRangeType(RangeType.MIN);\n        db3.getMaxThreshold().setRangeType(RangeType.MAX);\n        sheetCF.addConditionalFormatting(regions, rule3);\n    }
1283	public static String convertNumToColString(int col) {\n        // Excel counts column A as the 1st column, we\n        //  treat it as the 0th one\n        int excelColNum = col + 1;\n\n        StringBuilder colRef = new StringBuilder(2);\n        int colRemain = excelColNum;\n\n        while(colRemain > 0) {\n            int thisPart = colRemain % 26;\n            if(thisPart == 0) { thisPart = 26; }\n            colRemain = (colRemain - thisPart) / 26;\n\n            // The letter A is at 65\n            char colChar = (char)(thisPart+64);\n            colRef.insert(0, colChar);\n        }\n\n        return colRef.toString();\n    }
1284	public char[] getRgtchar()\n    {\n        return _rgtchar;\n    }
1285	public static void buildNumDataSource(CTNumDataSource ctNumDataSource,\n                                          ChartDataSource<? extends Number> dataSource) {\n        if (dataSource.isReference()) {\n            buildNumRef(ctNumDataSource.addNewNumRef(), dataSource);\n        } else {\n            buildNumLit(ctNumDataSource.addNewNumLit(), dataSource);\n        }\n    }
1286	public ExtendedFormatRecord createCellXF() {\n        ExtendedFormatRecord xf = createExtendedFormat();\n\n        records.add(records.getXfpos()+1, xf);\n        records.setXfpos( records.getXfpos() + 1 );\n        numxfs++;\n        return xf;\n    }
1287	public boolean isShowActual()\n    {\n        return showActual.isSet(field_1_formatFlags);\n    }
1288	protected PackageRelationship getPackageRelationship(POIXMLDocumentPart parent, PackagePart part) {\n         try {\n             String partName = part.getPartName().getName();\n             for (PackageRelationship pr : parent.getPackagePart().getRelationships()) {\n                 String packName = pr.getTargetURI().toASCIIString();\n                 if (packName.equalsIgnoreCase(partName)) {\n                     return pr;\n                 }\n             }\n         } catch (InvalidFormatException e) {\n             throw new POIXMLException("error while determining package relations", e);\n         }\n         \n         throw new POIXMLException("package part isn't a child of the parent document.");\n     }
1289	public List<TextProp> getTextPropList() {\n	    List<TextProp> orderedList = new ArrayList<>();\n        for (TextProp potProp : getPotentialProperties()) {\n            TextProp textProp = textProps.get(potProp.getName());\n            if (textProp != null) {\n                orderedList.add(textProp);\n            }\n        }\n	    return orderedList;\n    }
1290	// http://doc.optadata.com/en/dokumentation/application/expression/functions/financial.html\n	static public double ipmt(double r, int per, int nper, double pv, double fv, int type) {\n	    double ipmt = fv(r, per - 1, pmt(r, nper, pv, fv, type), pv, type) * r;\n	    if (type==1) ipmt /= (1 + r);\n	    return ipmt;\n	}
1291	public void flushRows() throws IOException\n    {\n        this.flushRows(0);\n    }
1292	int getLumMod(){\n        return getPercentageValue("lumMod");\n    }
1293	public static void main(String[] args) throws IOException {\n        if(args.length < 2) {\n            System.err.println("Use:");\n            System.err.println("  HMEFContentsExtractor <filename> <output dir>");\n            System.err.println("");\n            System.err.println("");\n            System.err.println("Where <filename> is the winmail.dat file to extract,");\n            System.err.println(" and <output dir> is where to place the extracted files");\n            System.exit(2);\n        }\n        \n        final String filename = args[0];\n        final String outputDir = args[1];\n        \n        HMEFContentsExtractor ext = new HMEFContentsExtractor(new File(filename));\n        \n        File dir = new File(outputDir);\n        File rtf = new File(dir, "message.rtf");\n        if(! dir.exists()) {\n            throw new FileNotFoundException("Output directory " + dir.getName() + " not found");\n        }\n        \n        System.out.println("Extracting...");\n        ext.extractMessageBody(rtf);\n        ext.extractAttachments(dir);\n        System.out.println("Extraction completed");\n    }
1294	@Internal\n    public boolean isFComplexScripts()\n    {\n        return fComplexScripts.isSet(field_1_grpfChp);\n    }
1295	public BigInteger getNumID() {\n        if (paragraph.getPPr() != null) {\n            if (paragraph.getPPr().getNumPr() != null) {\n                if (paragraph.getPPr().getNumPr().getNumId() != null) {\n                    return paragraph.getPPr().getNumPr().getNumId().getVal();\n                }\n            }\n        }\n        return null;\n    }
1296	public boolean isFPrivateResult()\n    {\n        return fPrivateResult.isSet( field_2_flt );\n\n    }
1297	public Path2D.Double getBoundsAsPath() {\n\n        Rectangle2D.Double rect = getTextBounds();\n        Double w = rect.getWidth();\n        Double h = rect.getHeight();\n\n        Path2D.Double bounds = new Path2D.Double();\n        bounds.moveTo(0, 0);\n        bounds.lineTo(w, 0);\n        bounds.lineTo(w, h);\n        bounds.lineTo(0, h);\n        bounds.lineTo(0, 0);\n\n        return bounds;\n    }
1298	public void setIncludeEntireCertificateChain(boolean includeEntireCertificateChain) {\n        this.includeEntireCertificateChain = includeEntireCertificateChain;\n    }
1299	public int getEncodedTokenSize() {\n		return _encodedTokenLen;\n	}
1300	public void removeInsideHBorder() {\n        removeBorder(Border.INSIDE_H);\n    }
1301	public void writeContinue() {\n		_ulrOutput.terminate();\n		_totalPreviousRecordsSize += _ulrOutput.getTotalSize();\n		_ulrOutput = new UnknownLengthRecordOutput(_out, ContinueRecord.sid);\n	}
1302	public static double getExcelDate(Calendar date, boolean use1904windowing) {\n        // Don't alter the supplied Calendar as we do our work\n        return internalGetExcelDate( (Calendar)date.clone(), use1904windowing );\n    }
1303	public DocumentEntry createDocument(final String name, final int size,\n                                        final POIFSWriterListener writer)\n        throws IOException\n    {\n        return createDocument(new POIFSDocument(name, size, _nfilesystem, writer));\n    }
1304	protected int getFreeBlock() throws IOException {\n       int sectorsPerSBAT = _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\n       \n       // First up, do we have any spare ones?\n       int offset = 0;\n        for (BATBlock sbat : _sbat_blocks) {\n            // Check this one\n            if (sbat.hasFreeSectors()) {\n                // Claim one of them and return it\n                for (int j = 0; j < sectorsPerSBAT; j++) {\n                    int sbatValue = sbat.getValueAt(j);\n                    if (sbatValue == POIFSConstants.UNUSED_BLOCK) {\n                        // Bingo\n                        return offset + j;\n                    }\n                }\n            }\n\n            // Move onto the next SBAT\n            offset += sectorsPerSBAT;\n        }\n       \n       // If we get here, then there aren't any\n       //  free sectors in any of the SBATs\n       // So, we need to extend the chain and add another\n       \n       // Create a new BATBlock\n       BATBlock newSBAT = BATBlock.createEmptyBATBlock(_filesystem.getBigBlockSizeDetails(), false);\n       int batForSBAT = _filesystem.getFreeBlock();\n       newSBAT.setOurBlockIndex(batForSBAT);\n       \n       // Are we the first SBAT?\n       if(_header.getSBATCount() == 0) {\n          // Tell the header that we've got our first SBAT there\n          _header.setSBATStart(batForSBAT);\n          _header.setSBATBlockCount(1);\n       } else {\n          // Find the end of the SBAT stream, and add the sbat in there\n          ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\n          int batOffset = _header.getSBATStart();\n          while(true) {\n             loopDetector.claim(batOffset);\n             int nextBat = _filesystem.getNextBlock(batOffset);\n             if(nextBat == POIFSConstants.END_OF_CHAIN) {\n                break;\n             }\n             batOffset = nextBat;\n          }\n          \n          // Add it in at the end\n          _filesystem.setNextBlock(batOffset, batForSBAT);\n          \n          // And update the count\n          _header.setSBATBlockCount(\n                _header.getSBATCount() + 1\n          );\n       }\n       \n       // Finish allocating\n       _filesystem.setNextBlock(batForSBAT, POIFSConstants.END_OF_CHAIN);\n       _sbat_blocks.add(newSBAT);\n       \n       // Return our first spot\n       return offset;\n    }
1305	public void notifyDeleteCell(HSSFCell cell) {\n        _bookEvaluator.notifyDeleteCell(new HSSFEvaluationCell(cell));\n    }
1306	public static double decodeNumber(int number) {\n        long raw_number = number;\n\n        // mask off the two low-order bits, 'cause they're not part of\n        // the number\n        raw_number = raw_number >> 2;\n        double rvalue = 0;\n\n        if ((number & 0x02) == 0x02)\n        {\n            // ok, it's just a plain ol' int; we can handle this\n            // trivially by casting\n            rvalue = raw_number;\n        }\n        else\n        {\n\n            // also trivial, but not as obvious ... left shift the\n            // bits high and use that clever static method in Double\n            // to convert the resulting bit image to a double\n            rvalue = Double.longBitsToDouble(raw_number << 34);\n        }\n        if ((number & 0x01) == 0x01)\n        {\n\n            // low-order bit says divide by 100, and so we do. Why?\n            // 'cause that's what the algorithm says. Can't fight city\n            // hall, especially if it's the city of Redmond\n            rvalue /= 100;\n        }\n\n        return rvalue;\n    }
1307	public static Document process( File xlsFile ) throws IOException, ParserConfigurationException {\n        try (HSSFWorkbook workbook = ExcelToHtmlUtils.loadXls(xlsFile)) {\n            return ExcelToHtmlConverter.process(workbook);\n        }\n    }
1308	public HSSFSimpleShape createShape(HSSFChildAnchor anchor) {\n        HSSFSimpleShape shape = new HSSFSimpleShape(this, anchor);\n        shape.setParent(this);\n        shape.setAnchor(anchor);\n        shapes.add(shape);\n        onCreate(shape);\n        EscherSpRecord sp = shape.getEscherContainer().getChildById(EscherSpRecord.RECORD_ID);\n        if (shape.getAnchor().isHorizontallyFlipped()){\n            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPHORIZ);\n        }\n        if (shape.getAnchor().isVerticallyFlipped()){\n            sp.setFlags(sp.getFlags() | EscherSpRecord.FLAG_FLIPVERT);\n        }\n        return shape;\n    }
1309	protected void preSerialize(){\n        Map<Integer, NoteRecord> tailRecords = _boundAggregate.getTailRecords();\n        /*\n         * contains coordinates of comments we iterate over\n         */\n        Set<String> coordinates = new HashSet<>(tailRecords.size());\n        for(NoteRecord rec : tailRecords.values()){\n            String noteRef = new CellReference(rec.getRow(),\n                    rec.getColumn(), true, true).formatAsString(); // A1-style notation\n            if(coordinates.contains(noteRef )){\n                throw new IllegalStateException("found multiple cell comments for cell " + noteRef );\n            } else {\n                coordinates.add(noteRef);\n            }\n        }\n    }
1310	public void moveCell(HSSFCell cell, short newColumn) {\n        // Ensure the destination is free\n        if(cells.length > newColumn && cells[newColumn] != null) {\n            throw new IllegalArgumentException("Asked to move cell to column " + newColumn + " but there's already a cell there");\n        }\n\n        // Check it's one of ours\n        if(! cells[cell.getColumnIndex()].equals(cell)) {\n            throw new IllegalArgumentException("Asked to move a cell, but it didn't belong to our row");\n        }\n\n        // Move the cell to the new position\n        // (Don't remove the records though)\n        removeCell(cell, false);\n        cell.updateCellNum(newColumn);\n        addCell(cell);\n    }
1311	public int getDefaultDropDownItemIndex()\n    {\n        return _wDef.intValue();\n    }
1312	public void cloneDrawings(InternalSheet sheet){\n\n        findDrawingGroup();\n\n        if(drawingManager == null) {\n            //this workbook does not have drawings\n            return;\n        }\n\n        //check if the cloned sheet has drawings\n        int aggLoc = sheet.aggregateDrawingRecords(drawingManager, false);\n        if(aggLoc == -1) {\n            return;\n        }\n        \n        EscherAggregate agg = (EscherAggregate) sheet.findFirstRecordBySid(EscherAggregate.sid);\n        EscherContainerRecord escherContainer = agg.getEscherContainer();\n        if (escherContainer == null) {\n            return;\n        }\n\n        EscherDggRecord dgg = drawingManager.getDgg();\n\n        //register a new drawing group for the cloned sheet\n        int dgId = drawingManager.findNewDrawingGroupId();\n        dgg.addCluster( dgId, 0 );\n        dgg.setDrawingsSaved(dgg.getDrawingsSaved() + 1);\n\n        EscherDgRecord dg = null;\n        for(EscherRecord er : escherContainer) {\n            if(er instanceof EscherDgRecord) {\n                dg = (EscherDgRecord)er;\n                //update id of the drawing in the cloned sheet\n                dg.setOptions( (short) ( dgId << 4 ) );\n            } else if (er instanceof EscherContainerRecord){\n                // iterate over shapes and re-generate shapeId\n                for(EscherRecord er2 : (EscherContainerRecord)er) {\n                    for(EscherRecord shapeChildRecord : (EscherContainerRecord)er2) {\n                        int recordId = shapeChildRecord.getRecordId();\n                        if (recordId == EscherSpRecord.RECORD_ID){\n                            if (dg == null) {\n                                throw new RecordFormatException("EscherDgRecord wasn't set/processed before.");\n                            }\n                            EscherSpRecord sp = (EscherSpRecord)shapeChildRecord;\n                            int shapeId = drawingManager.allocateShapeId(dg);\n                            //allocateShapeId increments the number of shapes. roll back to the previous value\n                            dg.setNumShapes(dg.getNumShapes()-1);\n                            sp.setShapeId(shapeId);\n                        } else if (recordId == EscherOptRecord.RECORD_ID){\n                            EscherOptRecord opt = (EscherOptRecord)shapeChildRecord;\n                            EscherSimpleProperty prop = opt.lookup(\n                                    EscherProperties.BLIP__BLIPTODISPLAY );\n                            if (prop != null){\n                                int pictureIndex = prop.getPropertyValue();\n                                // increment reference count for pictures\n                                EscherBSERecord bse = getBSERecord(pictureIndex);\n                                bse.setRef(bse.getRef() + 1);\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n    }
1313	/* package */ ValueEval evaluateReference(\n            EvaluationSheet sheet, int sheetIndex, int rowIndex,\n            int columnIndex, EvaluationTracker tracker) {\n\n        EvaluationCell cell = sheet.getCell(rowIndex, columnIndex);\n        return evaluateAny(cell, sheetIndex, rowIndex, columnIndex, tracker);\n    }
1314	private void checkClassPath(){\n        try {\n            Class.forName("org.apache.poi.hssf.usermodel.HSSFWorkbook");\n            Class.forName("org.apache.poi.ss.usermodel.WorkbookFactory");\n        } catch (Exception e) {\n            throw new BuildException(\n                    "The <classpath> for <excelant> must include poi.jar and poi-ooxml.jar " +\n                    "if not in Ant's own classpath. Processing .xlsx spreadsheets requires " +\n                    "additional poi-ooxml-schemas.jar, xmlbeans.jar" ,\n                    e, getLocation());\n        }\n\n    }
1315	int getAlphaMod(){\n        return getPercentageValue("alphaMod");\n    }
1316	public boolean removeRun(int pos) {\n        if (pos >= 0 && pos < runs.size()) {\n            // Remove the run from our high level lists\n            XWPFRun run = runs.get(pos);\n            if (run instanceof XWPFHyperlinkRun ||\n                run instanceof XWPFFieldRun) {\n                // TODO Add support for removing these kinds of nested runs,\n                //  which aren't on the CTP -> R array, but CTP -> XXX -> R array\n                throw new IllegalArgumentException("Removing Field or Hyperlink runs not yet supported");\n            }\n            runs.remove(pos);\n            iruns.remove(run);\n            // Remove the run from the low-level XML\n            //calculate the correct pos as our run/irun list contains hyperlinks and fields so is different to the paragraph R array.\n            int rPos = 0;\n            for(int i=0;i<pos;i++) {\n              XWPFRun currRun = runs.get(i);\n              if(!(currRun instanceof XWPFHyperlinkRun || currRun instanceof XWPFFieldRun)) {\n                rPos++;\n              }\n            }\n            getCTP().removeR(rPos);\n            return true;\n        }\n        return false;\n    }
1317	public static void copyNodes(DirectoryEntry sourceRoot, DirectoryEntry targetRoot)\n    throws IOException {\n        for (Entry entry : sourceRoot) {\n            copyNodeRecursively( entry, targetRoot );\n        }\n    }
1318	private int appendChild(Record newChild) {\n		// Copy over, and pop the child in at the end\n		Record[] nc = new Record[(_children.length + 1)];\n		System.arraycopy(_children, 0, nc, 0, _children.length);\n		// Switch the arrays\n		nc[_children.length] = newChild;\n		_children = nc;\n		return _children.length;\n	}
1319	public int getSizeInBytes() { return 18; }
1320	// http://arachnoid.com/lutusp/finance.html\n	static public double pmt(double r, int nper, double pv, double fv, int type) {\n        return -r * (pv * Math.pow(1 + r, nper) + fv) / ((1 + r*type) * (Math.pow(1 + r, nper) - 1));\n	}
1321	public short getIgrpprl()\n    {\n        if ( !isComplex() )\n            throw new IllegalStateException( "Not complex" );\n\n        return _figrpprl.getShortValue( value );\n    }
1322	public void setProperty(PropertyValue value) {\n        properties.put(value.getProperty(), value);\n    }
1323	String importBlip(String blipId, POIXMLDocumentPart parent) {\n        final XSLFPictureData parData = parent.getRelationPartById(blipId).getDocumentPart();\n        final XSLFPictureData pictureData;\n        if (getPackagePart().getPackage() == parent.getPackagePart().getPackage()) {\n            // handle ref counter correct, if the parent document is the same as this\n            pictureData = parData;\n        } else {\n            XMLSlideShow ppt = getSlideShow();\n            pictureData = ppt.addPicture(parData.getData(), parData.getType());\n        }\n\n        RelationPart rp = addRelation(blipId, XSLFRelation.IMAGES, pictureData);\n        return rp.getRelationship().getId();\n    }
1324	private Ptg rowCopyRefPtg(RefPtgBase rptg) {\n        final int refRow = rptg.getRow();\n        if (rptg.isRowRelative()) {\n            // check new location where the ref is located\n            final int destRowIndex = _firstMovedIndex + _amountToMove;\n            if (destRowIndex < 0 || _version.getLastRowIndex() < destRowIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            // check new location where the ref points to\n            final int newRowIndex = refRow + _amountToMove;\n            if(newRowIndex < 0 || _version.getLastRowIndex() < newRowIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            rptg.setRow(newRowIndex);\n            return rptg;\n        }\n        return null;\n    }
1325	private static WriteAccessRecord createWriteAccess() {\n        WriteAccessRecord retval = new WriteAccessRecord();\n\n        String defaultUserName = "POI";\n        try {\n            String username = System.getProperty("user.name");\n            // Google App engine returns null for user.name, see Bug 53974\n            if(username == null) {\n                username = defaultUserName;\n            }\n\n            retval.setUsername(username);\n        } catch (AccessControlException e) {\n            LOG.log(POILogger.WARN, "can't determine user.name", e);\n            // AccessControlException can occur in a restricted context\n            // (client applet/jws application or restricted security server)\n            retval.setUsername(defaultUserName);\n        }\n        return retval;\n    }
1326	@Internal\n    public boolean isFWrapToWwd()\n    {\n        return fWrapToWwd.isSet(field_32_viewFlags);\n    }
1327	public String getText() {\n      MAPIMessage msg = (MAPIMessage)document;\n      StringBuffer s = new StringBuffer();\n      \n      // See if we can get a suitable encoding for any\n      //  non unicode text in the file\n      msg.guess7BitEncoding();\n      \n      // Off we go\n      StringsIterator emails;\n      try {\n         emails = new StringsIterator(\n               msg.getRecipientEmailAddressList()\n         );\n      } catch(ChunkNotFoundException e) {\n         emails = new StringsIterator(new String[0]);\n      }\n      \n      try {\n         s.append("From: " + msg.getDisplayFrom() + "\n");\n      } catch(ChunkNotFoundException e) {}\n      \n      // For To, CC and BCC, try to match the names\n      //  up with their email addresses. Relies on the\n      //  Recipient Chunks being in the same order as\n      //  people in To + CC + BCC.\n      try {\n         handleEmails(s, "To", msg.getDisplayTo(), emails);\n      } catch(ChunkNotFoundException e) {}\n      try {\n         handleEmails(s, "CC", msg.getDisplayCC(), emails);\n      } catch(ChunkNotFoundException e) {}\n      try {\n         handleEmails(s, "BCC", msg.getDisplayBCC(), emails);\n      } catch(ChunkNotFoundException e) {}\n      \n      // Date - try two ways to find it\n      try {\n         // First try via the proper chunk\n         SimpleDateFormat f = new SimpleDateFormat("E, d MMM yyyy HH:mm:ss Z", Locale.ROOT);\n         f.setTimeZone(LocaleUtil.getUserTimeZone());\n         s.append("Date: ").append(f.format(msg.getMessageDate().getTime())).append("\n");\n      } catch(ChunkNotFoundException e) {\n         try {\n            // Failing that try via the raw headers \n            String[] headers = msg.getHeaders();\n            for(String header: headers) {\n               if(startsWithIgnoreCase(header, "date:")) {\n                  s.append("Date:").append(header, header.indexOf(':')+1, header.length()).append("\n");\n                  break;\n               }\n            }\n         } catch(ChunkNotFoundException he) {\n            // We can't find the date, sorry...\n         }\n      }\n      \n      try {\n         s.append("Subject: ").append(msg.getSubject()).append("\n");\n      } catch(ChunkNotFoundException e) {}\n      \n      // Display attachment names\n      // To get the attachments, use ExtractorFactory\n      for(AttachmentChunks att : msg.getAttachmentFiles()) {\n         StringChunk name = att.getAttachLongFileName();\n         if (name == null) name = att.getAttachFileName();\n         String attName = name == null ? null : name.getValue();\n          \n         if(att.getAttachMimeTag() != null && \n               att.getAttachMimeTag().getValue() != null) {\n             attName = att.getAttachMimeTag().getValue() + " = " + attName; \n         }\n         s.append("Attachment: ").append(attName).append("\n");\n      }\n      \n      try {\n         s.append("\n").append(msg.getTextBody()).append("\n");\n      } catch(ChunkNotFoundException e) {}\n      \n      return s.toString();\n   }
1328	public HSSFTextbox createTextbox(HSSFChildAnchor anchor) {\n        HSSFTextbox shape = new HSSFTextbox(this, anchor);\n        shape.setParent(this);\n        shape.setAnchor(anchor);\n        shapes.add(shape);\n        onCreate(shape);\n        return shape;\n    }
1329	public boolean isVertical()\n    {\n        return vertical.isSet(field_7_options);\n    }
1330	public void associateShapeToObjRecord(EscherRecord r, Record objRecord) {\n        shapeToObj.put(r, objRecord);\n    }
1331	protected static void setDigestAlgAndValue(\n            DigestAlgAndValueType digestAlgAndValue,\n            byte[] data,\n            HashAlgorithm digestAlgo) {\n        DigestMethodType digestMethod = digestAlgAndValue.addNewDigestMethod();\n        digestMethod.setAlgorithm(SignatureConfig.getDigestMethodUri(digestAlgo));\n        \n        MessageDigest messageDigest = CryptoFunctions.getMessageDigest(digestAlgo);\n        byte[] digestValue = messageDigest.digest(data);\n        digestAlgAndValue.setDigestValue(digestValue);\n    }
1332	public void setLinkedFileName(String target) {\n        String rId = link.getExternalBook().getId();\n        \n        if (rId == null || rId.isEmpty()) {\n            // We're a new External Link Table, so nothing to remove\n        } else {\n            // Relationships can't be changed, so remove the old one\n            getPackagePart().removeRelationship(rId);\n        }\n        \n        // Have a new one added\n        PackageRelationship newRel = getPackagePart().addExternalRelationship(\n                                target, PackageRelationshipTypes.EXTERNAL_LINK_PATH);\n        link.getExternalBook().setId(newRel.getId());\n    }
1333	public void writeRow(int rownum, SXSSFRow row) throws IOException {\n        if (_numberOfFlushedRows == 0)\n            _lowestIndexOfFlushedRows = rownum;\n        _numberLastFlushedRow = Math.max(rownum, _numberLastFlushedRow);\n        _numberOfCellsOfLastFlushedRow = row.getLastCellNum();\n        _numberOfFlushedRows++;\n        beginRow(rownum, row);\n        Iterator<Cell> cells = row.allCellsIterator();\n        int columnIndex = 0;\n        while (cells.hasNext()) {\n            writeCell(columnIndex++, cells.next());\n        }\n        endRow();\n    }
1334	private void addLastModifiedBy() {\n        setElementTextContent(KEYWORD_LAST_MODIFIED_BY, namespaceCoreProperties, propsPart.getLastModifiedByProperty());\n	}
1335	public static boolean hasLineBreakMeasurerBug() {\n        String version = System.getProperty("java.version");\n        String os = System.getProperty("os.name").toLowerCase(Locale.ROOT);\n        boolean ignore = Boolean.getBoolean("org.apache.poi.JvmBugs.LineBreakMeasurer.ignore");\n        boolean hasBug = (!ignore && (os.contains("win") && ("1.6.0_45".equals(version) || "1.7.0_21".equals(version))));\n        if (hasBug) {\n            LOG.log(POILogger.WARN, "JVM has LineBreakMeasurer bug - see POI bug #54904 - caller code might default to Lucida Sans");\n        }\n        return hasBug;\n    }
1336	public XWPFPicture addPicture(InputStream pictureData, int pictureType, String filename, int width, int height)\n            throws InvalidFormatException, IOException {\n        String relationId;\n        XWPFPictureData picData;\n\n        // Work out what to add the picture to, then add both the\n        //  picture and the relationship for it\n        // TODO Should we have an interface for this sort of thing?\n        if (parent.getPart() instanceof XWPFHeaderFooter) {\n            XWPFHeaderFooter headerFooter = (XWPFHeaderFooter) parent.getPart();\n            relationId = headerFooter.addPictureData(pictureData, pictureType);\n            picData = (XWPFPictureData) headerFooter.getRelationById(relationId);\n        } else {\n            @SuppressWarnings("resource")\n            XWPFDocument doc = parent.getDocument();\n            relationId = doc.addPictureData(pictureData, pictureType);\n            picData = (XWPFPictureData) doc.getRelationById(relationId);\n        }\n\n        // Create the drawing entry for it\n        try {\n            CTDrawing drawing = run.addNewDrawing();\n            CTInline inline = drawing.addNewInline();\n\n            // Do the fiddly namespace bits on the inline\n            // (We need full control of what goes where and as what)\n            String xml =\n                    "<a:graphic xmlns:a=\"" + CTGraphicalObject.type.getName().getNamespaceURI() + "\">" +\n                            "<a:graphicData uri=\"" + CTPicture.type.getName().getNamespaceURI() + "\">" +\n                            "<pic:pic xmlns:pic=\"" + CTPicture.type.getName().getNamespaceURI() + "\" />" +\n                            "</a:graphicData>" +\n                            "</a:graphic>";\n            InputSource is = new InputSource(new StringReader(xml));\n            org.w3c.dom.Document doc = DocumentHelper.readDocument(is);\n            inline.set(XmlToken.Factory.parse(doc.getDocumentElement(), DEFAULT_XML_OPTIONS));\n\n            // Setup the inline\n            inline.setDistT(0);\n            inline.setDistR(0);\n            inline.setDistB(0);\n            inline.setDistL(0);\n\n            CTNonVisualDrawingProps docPr = inline.addNewDocPr();\n            long id = getParent().getDocument().getDrawingIdManager().reserveNew();\n            docPr.setId(id);\n            /* This name is not visible in Word 2010 anywhere. */\n            docPr.setName("Drawing " + id);\n            docPr.setDescr(filename);\n\n            CTPositiveSize2D extent = inline.addNewExtent();\n            extent.setCx(width);\n            extent.setCy(height);\n\n            // Grab the picture object\n            CTGraphicalObject graphic = inline.getGraphic();\n            CTGraphicalObjectData graphicData = graphic.getGraphicData();\n            CTPicture pic = getCTPictures(graphicData).get(0);\n\n            // Set it up\n            CTPictureNonVisual nvPicPr = pic.addNewNvPicPr();\n\n            CTNonVisualDrawingProps cNvPr = nvPicPr.addNewCNvPr();\n            /* use "0" for the id. See ECM-576, 20.2.2.3 */\n            cNvPr.setId(0L);\n            /* This name is not visible in Word 2010 anywhere */\n            cNvPr.setName("Picture " + id);\n            cNvPr.setDescr(filename);\n\n            CTNonVisualPictureProperties cNvPicPr = nvPicPr.addNewCNvPicPr();\n            cNvPicPr.addNewPicLocks().setNoChangeAspect(true);\n\n            CTBlipFillProperties blipFill = pic.addNewBlipFill();\n            CTBlip blip = blipFill.addNewBlip();\n            blip.setEmbed(parent.getPart().getRelationId(picData));\n            blipFill.addNewStretch().addNewFillRect();\n\n            CTShapeProperties spPr = pic.addNewSpPr();\n            CTTransform2D xfrm = spPr.addNewXfrm();\n\n            CTPoint2D off = xfrm.addNewOff();\n            off.setX(0);\n            off.setY(0);\n\n            CTPositiveSize2D ext = xfrm.addNewExt();\n            ext.setCx(width);\n            ext.setCy(height);\n\n            CTPresetGeometry2D prstGeom = spPr.addNewPrstGeom();\n            prstGeom.setPrst(STShapeType.RECT);\n            prstGeom.addNewAvLst();\n\n            // Finish up\n            XWPFPicture xwpfPicture = new XWPFPicture(pic, this);\n            pictures.add(xwpfPicture);\n            return xwpfPicture;\n        } catch (XmlException | SAXException e) {\n            throw new IllegalStateException(e);\n        }\n    }
1337	private void buildSlidesAndNotes() {\n		// Ensure we really found a Document record earlier\n		// If we didn't, then the file is probably corrupt\n		if (_documentRecord == null) {\n			throw new CorruptPowerPointFileException(\n					"The PowerPoint file didn't contain a Document Record in its PersistPtr blocks. It is probably corrupt.");\n		}\n\n		// Fetch the SlideListWithTexts in the most up-to-date Document Record\n		//\n		// As far as we understand it:\n		// * The first SlideListWithText will contain a SlideAtomsSet\n		// for each of the master slides\n		// * The second SlideListWithText will contain a SlideAtomsSet\n		// for each of the slides, in their current order\n		// These SlideAtomsSets will normally contain text\n		// * The third SlideListWithText (if present), will contain a\n		// SlideAtomsSet for each Notes\n		// These SlideAtomsSets will not normally contain text\n		//\n		// Having indentified the masters, slides and notes + their orders,\n		// we have to go and find their matching records\n		// We always use the latest versions of these records, and use the\n		// SlideAtom/NotesAtom to match them with the StyleAtomSet\n\n		findMasterSlides();\n\n		// Having sorted out the masters, that leaves the notes and slides\n        Map<Integer,Integer> slideIdToNotes = new HashMap<>();\n\n        // Start by finding the notes records\n        findNotesSlides(slideIdToNotes);\n\n		// Now, do the same thing for our slides\n		findSlides(slideIdToNotes);\n	}
1338	public HSSFColor addColor( byte red, byte green, byte blue )\n    {\n        byte[] b = _palette.getColor(PaletteRecord.FIRST_COLOR_INDEX);\n        short i;\n        for (i = PaletteRecord.FIRST_COLOR_INDEX; i < PaletteRecord.STANDARD_PALETTE_SIZE + PaletteRecord.FIRST_COLOR_INDEX; b = _palette.getColor(++i))\n        {\n            if (b == null)\n            {\n                setColorAtIndex( i, red, green, blue );\n                return getColor(i);\n            }\n        }\n        throw new RuntimeException("Could not find free color index");\n    }
1339	public boolean isTraverseEmptyCells() {\n        return traverseEmptyCells;\n    }
1340	public int getParagraphPos(int pos) {\n        return getBodyElementSpecificPos(pos, paragraphs);\n    }
1341	public boolean isFBestFit()\n    {\n        return fBestFit.isSet( field_2_tlp_flags );\n\n    }
1342	protected void breakText(Graphics2D graphics){\n        lines.clear();\n\n        DrawFactory fact = DrawFactory.getInstance(graphics);\n        fact.fixFonts(graphics);\n        StringBuilder text = new StringBuilder();\n        AttributedString at = getAttributedString(graphics, text);\n        boolean emptyParagraph = text.toString().trim().isEmpty();\n\n        AttributedCharacterIterator it = at.getIterator();\n        LineBreakMeasurer measurer = new LineBreakMeasurer(it, graphics.getFontRenderContext());\n        for (;;) {\n            int startIndex = measurer.getPosition();\n\n            // add a pixel to compensate rounding errors\n            double wrappingWidth = getWrappingWidth(lines.isEmpty(), graphics) + 1;\n            // shape width can be smaller that the sum of insets (this was proved by a test file)\n            if(wrappingWidth < 0) {\n                wrappingWidth = 1;\n            }\n\n            int nextBreak = text.indexOf("\n", startIndex + 1);\n            if (nextBreak == -1) {\n                nextBreak = it.getEndIndex();\n            }\n\n            TextLayout layout = measurer.nextLayout((float)wrappingWidth, nextBreak, true);\n            if (layout == null) {\n                 // layout can be null if the entire word at the current position\n                 // does not fit within the wrapping width. Try with requireNextWord=false.\n                 layout = measurer.nextLayout((float)wrappingWidth, nextBreak, false);\n            }\n\n            if(layout == null) {\n                // exit if can't break any more\n                break;\n            }\n\n            int endIndex = measurer.getPosition();\n            // skip over new line breaks (we paint 'clear' text runs not starting or ending with \n)\n            if(endIndex < it.getEndIndex() && text.charAt(endIndex) == '\n'){\n                measurer.setPosition(endIndex + 1);\n            }\n\n            TextAlign hAlign = paragraph.getTextAlign();\n            if(hAlign == TextAlign.JUSTIFY || hAlign == TextAlign.JUSTIFY_LOW) {\n                layout = layout.getJustifiedLayout((float)wrappingWidth);\n            }\n\n            AttributedString str = (emptyParagraph)\n                ? null // we will not paint empty paragraphs\n                : new AttributedString(it, startIndex, endIndex);\n            DrawTextFragment line = fact.getTextFragment(layout, str);\n            lines.add(line);\n\n            maxLineHeight = Math.max(maxLineHeight, line.getHeight());\n\n            if(endIndex == it.getEndIndex()) {\n                break;\n            }\n        }\n\n        rawText = text.toString();\n    }
1343	public static InternalWorkbook createWorkbook() {\n        LOG.log( DEBUG, "creating new workbook from scratch" );\n\n        InternalWorkbook retval = new InternalWorkbook();\n        List<Record> records = new ArrayList<>(30);\n        retval.records.setRecords(records);\n        List<FormatRecord> formats = retval.formats;\n\n        records.add(createBOF());\n        records.add(new InterfaceHdrRecord(CODEPAGE));\n        records.add(createMMS());\n        records.add(InterfaceEndRecord.instance);\n        records.add(createWriteAccess());\n        records.add(createCodepage());\n        records.add(createDSF());\n        records.add(createTabId());\n        retval.records.setTabpos(records.size() - 1);\n        records.add(createFnGroupCount());\n        records.add(createWindowProtect());\n        records.add(createProtect());\n        retval.records.setProtpos(records.size() - 1);\n        records.add(createPassword());\n        records.add(createProtectionRev4());\n        records.add(createPasswordRev4());\n        retval.windowOne = createWindowOne();\n        records.add(retval.windowOne);\n        records.add(createBackup());\n        retval.records.setBackuppos(records.size() - 1);\n        records.add(createHideObj());\n        records.add(createDateWindow1904());\n        records.add(createPrecision());\n        records.add(createRefreshAll());\n        records.add(createBookBool());\n        records.add(createFont());\n        records.add(createFont());\n        records.add(createFont());\n        records.add(createFont());\n        retval.records.setFontpos( records.size() - 1 );   // last font record position\n        retval.numfonts = 4;\n\n        // set up format records\n        for (int i = 0; i <= 7; i++) {\n            FormatRecord rec = createFormat(i);\n            retval.maxformatid = retval.maxformatid >= rec.getIndexCode() ? retval.maxformatid : rec.getIndexCode();\n            formats.add(rec);\n            records.add(rec);\n        }\n\n        for (int k = 0; k < 21; k++) {\n            records.add(InternalWorkbook.createExtendedFormat(k));\n            retval.numxfs++;\n        }\n        retval.records.setXfpos( records.size() - 1 );\n        for (int k = 0; k < 6; k++) {\n            records.add(InternalWorkbook.createStyle(k));\n        }\n        records.add(InternalWorkbook.createUseSelFS());\n\n        int nBoundSheets = 1; // now just do 1\n        for (int k = 0; k < nBoundSheets; k++) {\n            BoundSheetRecord bsr = createBoundSheet(k);\n\n            records.add(bsr);\n            retval.boundsheets.add(bsr);\n            retval.records.setBspos(records.size() - 1);\n        }\n        records.add( InternalWorkbook.createCountry() );\n        for ( int k = 0; k < nBoundSheets; k++ ) {\n            retval.getOrCreateLinkTable().checkExternSheet(k);\n        }\n        retval.sst = new SSTRecord();\n        records.add(retval.sst);\n        records.add(InternalWorkbook.createExtendedSST());\n\n        records.add(EOFRecord.instance);\n        LOG.log( DEBUG, "exit create new workbook from scratch" );\n\n        return retval;\n    }
1344	private static RefModeRecord createRefMode() {\n        RefModeRecord retval = new RefModeRecord();\n\n        retval.setMode(RefModeRecord.USE_A1_MODE);\n        return retval;\n    }
1345	public boolean isAutoline()\n    {\n        return autoline.isSet(field_3_option);\n    }
1346	public void setLogBase(double logBase) {\n        if (logBase < MIN_LOG_BASE || MAX_LOG_BASE < logBase) {\n            throw new IllegalArgumentException("Axis log base must be between 2 and 1000 (inclusive), got: " + logBase);\n        }\n        CTScaling scaling = getCTScaling();\n        if (scaling.isSetLogBase()) {\n            scaling.getLogBase().setVal(logBase);\n        } else {\n            scaling.addNewLogBase().setVal(logBase);\n        }\n    }
1347	@SuppressWarnings("WeakerAccess")\n	public void reorderSlide(int oldSlideNumber, int newSlideNumber) {\n		// Ensure these numbers are valid\n		if (oldSlideNumber < 1 || newSlideNumber < 1) {\n			throw new IllegalArgumentException("Old and new slide numbers must be greater than 0");\n		}\n		if (oldSlideNumber > _slides.size() || newSlideNumber > _slides.size()) {\n			throw new IllegalArgumentException(\n					"Old and new slide numbers must not exceed the number of slides ("\n							+ _slides.size() + ")");\n		}\n\n		// The order of slides is defined by the order of slide atom sets in the\n		// SlideListWithText container.\n		SlideListWithText slwt = _documentRecord.getSlideSlideListWithText();\n		if (slwt == null) {\n			throw new IllegalStateException("Slide record not defined.");\n		}\n		SlideAtomsSet[] sas = slwt.getSlideAtomsSets();\n\n		SlideAtomsSet tmp = sas[oldSlideNumber - 1];\n		sas[oldSlideNumber - 1] = sas[newSlideNumber - 1];\n		sas[newSlideNumber - 1] = tmp;\n\n		Collections.swap(_slides, oldSlideNumber - 1, newSlideNumber - 1);\n		_slides.get(newSlideNumber - 1).setSlideNumber(newSlideNumber);\n		_slides.get(oldSlideNumber - 1).setSlideNumber(oldSlideNumber);\n\n		ArrayList<Record> lst = new ArrayList<>();\n		for (SlideAtomsSet s : sas) {\n			lst.add(s.getSlidePersistAtom());\n			lst.addAll(Arrays.asList(s.getSlideRecords()));\n		}\n\n		Record[] r = lst.toArray(new Record[0]);\n		slwt.setChildRecord(r);\n	}
1348	public static void setLogUnsupportedTypes(final boolean logUnsupportedTypes) {\n        VariantSupport.logUnsupportedTypes = logUnsupportedTypes;\n    }
1349	public int serialize( int offset, byte[] data)\n    {\n        return serialize( offset, data, new NullEscherSerializationListener() );\n    }
1350	public void updateEmbeddedDoc() throws OpenXML4JException, IOException {\n        List<PackagePart> embeddedDocs = this.doc.getAllEmbeddedParts();\n        for (PackagePart pPart : embeddedDocs) {\n            String ext = pPart.getPartName().getExtension();\n            if (BINARY_EXTENSION.equals(ext) || OPENXML_EXTENSION.equals(ext)) {\n                // Get an InputStream from the package part and pass that\n                // to the create method of the WorkbookFactory class. Update\n                // the resulting Workbook and then stream that out again\n                // using an OutputStream obtained from the same PackagePart.\n                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is);\n                     OutputStream os = pPart.getOutputStream()) {\n                    Sheet sheet = workbook.getSheetAt(SHEET_NUM);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    cell.setCellValue(NEW_VALUE);\n                    workbook.write(os);\n                }\n            }\n        }\n\n        if (!embeddedDocs.isEmpty()) {\n            // Finally, write the newly modified Word document out to file.\n            try (FileOutputStream fos = new FileOutputStream(this.docFile)) {\n                this.doc.write(fos);\n            }\n        }\n    }
1351	public boolean isLabelAsPercentage()\n    {\n        return labelAsPercentage.isSet(field_1_formatFlags);\n    }
1352	public void protectSheet(String password, boolean shouldProtectObjects,\n			boolean shouldProtectScenarios) {\n		if (password == null) {\n			_passwordRecord = null;\n			_protectRecord = null;\n			_objectProtectRecord = null;\n			_scenarioProtectRecord = null;\n			return;\n		}\n\n		ProtectRecord prec = getProtect();\n		PasswordRecord pass = getPassword();\n		prec.setProtect(true);\n		pass.setPassword((short)CryptoFunctions.createXorVerifier1(password));\n		if (_objectProtectRecord == null && shouldProtectObjects) {\n			ObjectProtectRecord rec = createObjectProtect();\n			rec.setProtect(true);\n			_objectProtectRecord = rec;\n		}\n		if (_scenarioProtectRecord == null && shouldProtectScenarios) {\n			ScenarioProtectRecord srec = createScenarioProtect();\n			srec.setProtect(true);\n			_scenarioProtectRecord = srec;\n		}\n	}
1353	public static void putFloat( float value, OutputStream outputStream )\n            throws IOException\n    {\n        putInt( Float.floatToIntBits( value ), outputStream );\n    }
1354	public XSSFTextBox createTextbox(XSSFClientAnchor anchor){\n        long shapeId = newShapeId();\n        CTTwoCellAnchor ctAnchor = createTwoCellAnchor(anchor);\n        CTShape ctShape = ctAnchor.addNewSp();\n        ctShape.set(XSSFSimpleShape.prototype());\n        ctShape.getNvSpPr().getCNvPr().setId(shapeId);\n        XSSFTextBox shape = new XSSFTextBox(this, ctShape);\n        shape.anchor = anchor;\n        return shape;\n\n    }
1355	public void setNextRecordSize(int recordSize) {\n    }
1356	public void setSheetIndex(int index) {\n        int lastSheetIx = _workbook.getNumberOfSheets() - 1;\n        if (index < -1 || index > lastSheetIx) {\n            throw new IllegalArgumentException("Sheet index (" + index +") is out of range" +\n                    (lastSheetIx == -1 ? "" : (" (0.." +    lastSheetIx + ")")));\n        }\n\n        if(index == -1) {\n            if(_ctName.isSetLocalSheetId()) _ctName.unsetLocalSheetId();\n        } else {\n            _ctName.setLocalSheetId(index);\n        }\n    }
1357	public boolean isDataTable()\n    {\n        return dataTable.isSet(field_7_options);\n    }
1358	@SuppressWarnings("resource")\n    protected static HSLFHyperlink find(HSLFShape shape){\n        HSLFSlideShow ppt = shape.getSheet().getSlideShow();\n        //document-level container which stores info about all links in a presentation\n        ExObjList exobj = ppt.getDocumentRecord().getExObjList(false);\n        HSLFEscherClientDataRecord cldata = shape.getClientData(false);\n\n        if (exobj != null && cldata != null) {\n            List<HSLFHyperlink> lst = new ArrayList<>();\n            find(cldata.getHSLFChildRecords(), exobj, lst);\n            return lst.isEmpty() ? null : lst.get(0);\n        }\n\n        return null;\n    }
1359	public NormalisedDecimal normaliseBaseTen() {\n		return NormalisedDecimal.create(_significand, _binaryExponent);\n	}
1360	public boolean isAutomaticLink() {\n		return (field_1_option_flag & OPT_AUTOMATIC_LINK) != 0;\n	}
1361	protected static synchronized void initXmlProvider() {\n        if (isInitialized) {\n            return;\n        }\n        isInitialized = true;\n\n        try {\n            Init.init();\n            RelationshipTransformService.registerDsigProvider();\n            CryptoFunctions.registerBouncyCastle();\n        } catch (Exception e) {\n            throw new RuntimeException("Xml & BouncyCastle-Provider initialization failed", e);\n        }\n    }
1362	static void shadeBands(Sheet sheet) {\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("MOD(ROW(),6)<3");\n        PatternFormatting fill1 = rule1.createPatternFormatting();\n        fill1.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);\n        fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A1:Z100")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.createRow(0).createCell(1).setCellValue("Shade Bands of Rows");\n        sheet.createRow(1).createCell(1).setCellValue("Condition: Formula Is  =MOD(ROW(),6)<2   (Light Grey Fill)");\n    }
1363	public static XSSFBCellRange parse(byte[] data, int offset, XSSFBCellRange cellRange) {\n        if (cellRange == null) {\n            cellRange = new XSSFBCellRange();\n        }\n        cellRange.firstRow = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.lastRow = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.firstCol = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset)); offset += LittleEndian.INT_SIZE;\n        cellRange.lastCol = XSSFBUtils.castToInt(LittleEndian.getUInt(data, offset));\n\n        return cellRange;\n    }
1364	public boolean verifyPassword(KeyPair keyPair, X509Certificate x509) throws GeneralSecurityException {\n        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)getEncryptionInfo().getVerifier();\n        AgileEncryptionHeader header = (AgileEncryptionHeader)getEncryptionInfo().getHeader();\n        HashAlgorithm hashAlgo = header.getHashAlgorithm();\n        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();\n        int blockSize = header.getBlockSize();\n        \n        AgileCertificateEntry ace = null;\n        for (AgileCertificateEntry aceEntry : ver.getCertificates()) {\n            if (x509.equals(aceEntry.x509)) {\n                ace = aceEntry;\n                break;\n            }\n        }\n        if (ace == null) {\n            return false;\n        }\n        \n        Cipher cipher = Cipher.getInstance("RSA");\n        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n        byte keyspec[] = cipher.doFinal(ace.encryptedKey);\n        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);\n        \n        Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);\n        x509Hmac.init(secretKey);\n        byte certVerifier[] = x509Hmac.doFinal(ace.x509.getEncoded());\n\n        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); \n        cipher = getCipher(secretKey, cipherAlgo, header.getChainingMode(), vec, Cipher.DECRYPT_MODE);\n        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());\n        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);\n\n        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);\n        cipher = getCipher(secretKey, cipherAlgo, header.getChainingMode(), vec, Cipher.DECRYPT_MODE);\n        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());\n        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);\n        \n        \n        if (Arrays.equals(ace.certVerifier, certVerifier)) {\n            setSecretKey(secretKey);\n            setIntegrityHmacKey(hmacKey);\n            setIntegrityHmacValue(hmacValue);\n            return true;\n        } else {\n            return false;\n        }\n    }
1365	private byte[] imageToBytes(String imageFilename) throws IOException {\n        File imageFile;\n        FileInputStream fis = null;\n        ByteArrayOutputStream bos;\n        int read;\n        try {\n            imageFile = new File(imageFilename);\n            fis = new FileInputStream(imageFile);\n            bos = new ByteArrayOutputStream();\n            while((read = fis.read()) != -1) {\n                bos.write(read);\n            }\n            return(bos.toByteArray());\n        }\n        finally {\n            if(fis != null) {\n                try {\n                    fis.close();\n                    fis = null;\n                }\n                catch(IOException ioEx) {\n                    // Nothing to do here\n                }\n            }\n        }\n    }
1366	private static int handleMidValueTypeMismatch(LookupValueComparer lookupComparer, ValueVector vector,\n			BinarySearchIndexes bsi, int midIx) {\n		int newMid = midIx;\n		int highIx = bsi.getHighIx();\n\n		while(true) {\n			newMid++;\n			if(newMid == highIx) {\n				// every element from midIx to highIx was the wrong type\n				// move highIx down to the low end of the mid values\n				bsi.narrowSearch(midIx, true);\n				return -1;\n			}\n			CompareResult cr = lookupComparer.compareTo(vector.getItem(newMid));\n			if(cr.isLessThan() && newMid == highIx-1) {\n				// move highIx down to the low end of the mid values\n				bsi.narrowSearch(midIx, true);\n				return -1;\n				// but only when "newMid == highIx-1"? slightly weird.\n				// It would seem more efficient to always do this.\n			}\n			if(cr.isTypeMismatch()) {\n				// keep stepping over values until the right type is found\n				continue;\n			}\n			if(cr.isEqual()) {\n				return newMid;\n			}\n			// Note - if moving highIx down (due to lookup<vector[newMid]),\n			// this execution path only moves highIx it down as far as newMid, not midIx,\n			// which would be more efficient.\n			bsi.narrowSearch(newMid, cr.isLessThan());\n			return -1;\n		}\n	}
1367	private void fixTabIdRecord() {\n        Record rec = records.get(records.getTabpos());\n\n        // see bug 55982, quite a number of documents do not have a TabIdRecord and\n        // thus there is no way to do the fixup here,\n        // we use the same check on Tabpos as done in other places\n        if(records.getTabpos() <= 0) {\n            return;\n        }\n\n        TabIdRecord tir = ( TabIdRecord ) rec;\n        short[]     tia = new short[ boundsheets.size() ];\n\n        for (short k = 0; k < tia.length; k++) {\n            tia[ k ] = k;\n        }\n        tir.setTabIdArray(tia);\n    }
1368	public boolean removeValue(final int o)\n    {\n        boolean rval = false;\n\n        for (int j = 0; !rval && (j < _limit); j++)\n        {\n            if (o == _array[ j ])\n            {\n                if (j+1 < _limit) {\n                    System.arraycopy(_array, j + 1, _array, j, _limit - j);\n                }\n                _limit--;\n                rval = true;\n            }\n        }\n        return rval;\n    }
1369	public static double convertTime(String timeStr) {\n        try {\n            return convertTimeInternal(timeStr);\n        } catch (FormatException e) {\n            String msg = "Bad time format '" + timeStr\n                + "' expected 'HH:MM' or 'HH:MM:SS' - " + e.getMessage();\n            throw new IllegalArgumentException(msg);\n        }\n    }
1370	public XDGFCell getCell(String cellName) {\n        return _cells.get(cellName);\n    }
1371	@Internal\n    public boolean isFBackward()\n    {\n        return fBackward.isSet(field_1_rgf);\n    }
1372	protected void shift(int n) {\n        int rownum = getRowNum() + n;\n        String msg = "Row[rownum=" + getRowNum() + "] contains cell(s) included in a multi-cell array formula. " +\n                "You cannot change part of an array.";\n        for(Cell c : this){\n            ((XSSFCell)c).updateCellReferencesForShifting(msg);\n          }\n        setRowNum(rownum);\n    }
1373	/* package */ int getValueIndex(int colIx, int rowIx) {\n		if(colIx < 0 || colIx >= _nColumns) {\n			throw new IllegalArgumentException("Specified colIx (" + colIx\n					+ ") is outside the allowed range (0.." + (_nColumns-1) + ")");\n		}\n		if(rowIx < 0 || rowIx >= _nRows) {\n			throw new IllegalArgumentException("Specified rowIx (" + rowIx\n					+ ") is outside the allowed range (0.." + (_nRows-1) + ")");\n		}\n		return rowIx * _nColumns + colIx;\n	}
1374	public static int ubyteToInt( byte b )\n    {\n        return b & 0xFF;\n    }
1375	private void setRunAttributes(CTFont ctFont, CTRPrElt pr){\n        if(ctFont.sizeOfBArray() > 0) pr.addNewB().setVal(ctFont.getBArray(0).getVal());\n        if(ctFont.sizeOfUArray() > 0) pr.addNewU().setVal(ctFont.getUArray(0).getVal());\n        if(ctFont.sizeOfIArray() > 0) pr.addNewI().setVal(ctFont.getIArray(0).getVal());\n        if(ctFont.sizeOfColorArray() > 0) {\n            CTColor c1 = ctFont.getColorArray(0);\n            CTColor c2 = pr.addNewColor();\n            if(c1.isSetAuto()) c2.setAuto(c1.getAuto());\n            if(c1.isSetIndexed()) c2.setIndexed(c1.getIndexed());\n            if(c1.isSetRgb()) c2.setRgb(c1.getRgb());\n            if(c1.isSetTheme()) c2.setTheme(c1.getTheme());\n            if(c1.isSetTint()) c2.setTint(c1.getTint());\n        }\n        if(ctFont.sizeOfSzArray() > 0) pr.addNewSz().setVal(ctFont.getSzArray(0).getVal());\n        if(ctFont.sizeOfNameArray() > 0) pr.addNewRFont().setVal(ctFont.getNameArray(0).getVal());\n        if(ctFont.sizeOfFamilyArray() > 0) pr.addNewFamily().setVal(ctFont.getFamilyArray(0).getVal());\n        if(ctFont.sizeOfSchemeArray() > 0) pr.addNewScheme().setVal(ctFont.getSchemeArray(0).getVal());\n        if(ctFont.sizeOfCharsetArray() > 0) pr.addNewCharset().setVal(ctFont.getCharsetArray(0).getVal());\n        if(ctFont.sizeOfCondenseArray() > 0) pr.addNewCondense().setVal(ctFont.getCondenseArray(0).getVal());\n        if(ctFont.sizeOfExtendArray() > 0) pr.addNewExtend().setVal(ctFont.getExtendArray(0).getVal());\n        if(ctFont.sizeOfVertAlignArray() > 0) pr.addNewVertAlign().setVal(ctFont.getVertAlignArray(0).getVal());\n        if(ctFont.sizeOfOutlineArray() > 0) pr.addNewOutline().setVal(ctFont.getOutlineArray(0).getVal());\n        if(ctFont.sizeOfShadowArray() > 0) pr.addNewShadow().setVal(ctFont.getShadowArray(0).getVal());\n        if(ctFont.sizeOfStrikeArray() > 0) pr.addNewStrike().setVal(ctFont.getStrikeArray(0).getVal());\n    }
1376	private static void readModuleMetadataFromDirStream(RLEDecompressingInputStream in, String streamName, ModuleMap modules) throws IOException {\n        int moduleOffset = in.readInt();\n        ModuleImpl module = modules.get(streamName);\n        if (module == null) {\n            // First time we've seen the module. Add it to the ModuleMap and decompress it later\n            module = new ModuleImpl();\n            module.offset = moduleOffset;\n            modules.put(streamName, module);\n            // Would adding module.read(in) here be correct?\n        } else {\n            // Decompress a previously found module and store the decompressed result into module.buf\n            InputStream stream = new RLEDecompressingInputStream(\n                    new ByteArrayInputStream(module.buf, moduleOffset, module.buf.length - moduleOffset)\n            );\n            module.read(stream);\n            stream.close();\n        }\n    }
1377	public boolean nameAlreadyExists(NameRecord name) {\n        // Check to ensure no other names have the same case-insensitive name\n        for (int i = getNumNames() - 1; i >= 0; i--) {\n            NameRecord rec = getNameRecord(i);\n            if (rec != name) {\n                if (isDuplicatedNames(name, rec))\n                    return true;\n            }\n        }\n        return false;\n    }
1378	@Internal\n    public boolean isFOutline()\n    {\n        return fOutline.isSet(field_25_internalFlags);\n    }
1379	private boolean isValid(Document xml) throws SAXException{\n        try{\n            String language = "http://www.w3.org/2001/XMLSchema";\n            SchemaFactory factory = SchemaFactory.newInstance(language);\n\n            Source source = new DOMSource(map.getSchema());\n            Schema schema = factory.newSchema(source);\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(xml));\n            \n            //if no exceptions where raised, the document is valid\n            return true;\n        } catch(IOException e) {\n            LOG.log(POILogger.ERROR, "document is not valid", e);\n        }\n\n        return false;\n    }
1380	public static OPCPackage openOrCreate(File file) throws InvalidFormatException {\n		if (file.exists()) {\n			return open(file.getAbsolutePath());\n		} else {\n			return create(file);\n		}\n	}
1381	@Internal\n    public boolean isFObfuscated()\n    {\n        return fObfuscated.isSet(field_6_flags1);\n    }
1382	public void trackAllColumnsForAutoSizing()\n    {\n        _autoSizeColumnTracker.trackAllColumns();\n    }
1383	private void updateNamedRangesAfterSheetReorder(int oldIndex, int newIndex) {\n        // update sheet index of sheet-scoped named ranges\n        for (final XSSFName name : namedRanges) {\n            final int i = name.getSheetIndex();\n            // name has sheet-level scope\n            if (i != -1) {\n                // name refers to this sheet\n                if (i == oldIndex) {\n                    name.setSheetIndex(newIndex);\n                }\n                // if oldIndex > newIndex then this sheet moved left and sheets between newIndex and oldIndex moved right\n                else if (newIndex <= i && i < oldIndex) {\n                    name.setSheetIndex(i+1);\n                }\n                // if oldIndex < newIndex then this sheet moved right and sheets between oldIndex and newIndex moved left\n                else if (oldIndex < i && i <= newIndex) {\n                    name.setSheetIndex(i-1);\n                }\n            }\n        }\n    }
1384	private void setPropertiesFromWorkbook(InternalWorkbook book)\n    {\n        this.workbook = book;\n\n        // none currently\n    }
1385	private static double accumulate(AreaEval sumRange, int relRowIndex, int relColIndex) {\n        if (sumRange == null) return 1.0; // count\n        \n        ValueEval addend = sumRange.getRelativeValue(relRowIndex, relColIndex);\n        if (addend instanceof NumberEval) {\n            return ((NumberEval)addend).getNumberValue();\n        }\n        // everything else (including string and boolean values) counts as zero\n        return 0.0;\n\n    }
1386	public static CellRangeAddress createEnclosingCellRange(CellRangeAddress crA, CellRangeAddress crB) {\n        if( crB == null) {\n            return crA.copy();\n        }\n        \n        int minRow = lt(crB.getFirstRow(),   crA.getFirstRow())   ?crB.getFirstRow()   :crA.getFirstRow();\n        int maxRow = gt(crB.getLastRow(),    crA.getLastRow())    ?crB.getLastRow()    :crA.getLastRow();\n        int minCol = lt(crB.getFirstColumn(),crA.getFirstColumn())?crB.getFirstColumn():crA.getFirstColumn();\n        int maxCol = gt(crB.getLastColumn(), crA.getLastColumn()) ?crB.getLastColumn() :crA.getLastColumn();\n\n        return new CellRangeAddress(minRow, maxRow, minCol, maxCol);\n    }
1387	public void setFunctionGroupId(int functionGroupId) {\n        _ctName.setFunctionGroupId(functionGroupId);\n    }
1388	public DocumentSummaryInformation getDocumentSummaryInformation() {\n        if(!initialized) {\n            readProperties();\n        }\n        return dsInf;\n    }
1389	public void setNotesID(int id) { notesID = id; }
1390	public int calculateWorkdays(double start, double end, double[] holidays) {\n        int saturdaysPast = this.pastDaysOfWeek(start, end, Calendar.SATURDAY);\n        int sundaysPast = this.pastDaysOfWeek(start, end, Calendar.SUNDAY);\n        int nonWeekendHolidays = this.calculateNonWeekendHolidays(start, end, holidays);\n        return (int) (end - start + 1) - saturdaysPast - sundaysPast - nonWeekendHolidays;\n    }
1391	private void paintDashDotDotBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             ((northBorderType == BorderStyle.DASH_DOT_DOT) ||\n              (northBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n        for (int l=x; l < width;) {\n          l=l+drawDashDotDot(g, l, y, thickness, true, true);\n        }\n\n      }\n\n      if (eastBorder &&\n              ((eastBorderType == BorderStyle.DASH_DOT_DOT) ||\n               (eastBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n\n      	g.setColor(eastColor);\n\n        for (int l=y;l < height;) {\n          //System.err.println("drawing east");\n          l=l+drawDashDotDot(g,width-1,l,thickness,false,false);\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.DASH_DOT_DOT) ||\n               (southBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(southBorderType);\n\n      	g.setColor(southColor);\n\n        for (int l=x; l < width;) {\n          //System.err.println("drawing south");\n          l=l+drawDashDotDot(g, l, height-1, thickness, true, false);\n        }\n      }\n\n      if (westBorder &&\n            ((westBorderType == BorderStyle.DASH_DOT_DOT) ||\n             (westBorderType == BorderStyle.MEDIUM_DASH_DOT_DOT))\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int l=y;l < height;) {\n          //System.err.println("drawing west");\n          l=l+drawDashDotDot(g,x,l,thickness,false,true);\n        }\n\n      }\n   }
1392	private void updateSheetTable(CTTable ctTable, String title, int index) {\n        CTTableColumns tableColumnList = ctTable.getTableColumns();\n        CTTableColumn column = null;\n        if (tableColumnList.getCount() >= index) {\n            column = tableColumnList.getTableColumnArray(index);\n        } else {\n            column = tableColumnList.addNewTableColumn();\n            column.setId(index);\n        }\n        column.setName(title);\n    }
1393	private void isCellFontBoldMatches(Locator loc1, Locator loc2) {\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        boolean b1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getBold();\n        boolean b2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getBold();\n        if (b1 != b2) {\n            addMessage(loc1, loc2,\n                CELL_FONT_ATTRIBUTES_DOES_NOT_MATCH,\n                (b1 ? "" : "NOT ")+"BOLD",\n                (b2 ? "" : "NOT ")+"BOLD"\n            );\n        }\n    }
1394	public void removeRelationship(String id) {\n        PackageRelationship rel = relationshipsByID.get(id);\n        if (rel != null) {\n            relationshipsByID.remove(rel.getId());\n            relationshipsByType.values().remove(rel);\n            internalRelationshipsByTargetName.values().remove(rel);\n        }\n    }
1395	private int store(InputStream stream) throws IOException {\n       final int bigBlockSize = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;\n       BufferedInputStream bis = new BufferedInputStream(stream, bigBlockSize+1);\n       bis.mark(bigBlockSize);\n\n       // Do we need to store as a mini stream or a full one?\n       long streamBlockSize = IOUtils.skipFully(bis, bigBlockSize);\n       if (streamBlockSize < bigBlockSize) {\n          _stream = new POIFSStream(_filesystem.getMiniStore());\n          _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();\n       } else {\n          _stream = new POIFSStream(_filesystem);\n          _block_size = _filesystem.getBlockStoreBlockSize();\n       }\n\n       // start from the beginning \n       bis.reset();\n       \n       // Store it\n       final long length;\n       try (OutputStream os = _stream.getOutputStream()) {\n           length = IOUtils.copy(bis, os);\n\n           // Pad to the end of the block with -1s\n           int usedInBlock = (int) (length % _block_size);\n           if (usedInBlock != 0 && usedInBlock != _block_size) {\n               int toBlockEnd = _block_size - usedInBlock;\n               byte[] padding = IOUtils.safelyAllocate(toBlockEnd, MAX_RECORD_LENGTH);\n               Arrays.fill(padding, (byte) 0xFF);\n               os.write(padding);\n           }\n       }\n\n       return (int)length;\n   }
1396	@Internal\n    public byte getIftcHtml()\n    {\n        return ( byte )iftcHtml.getValue(field_3_info3);\n    }
1397	public boolean isSubTotal(int rowIndex, int columnIndex) {\n        return false;\n    }
1398	public void removeContentType() {\n        remove1stProperty(PropertyIDMap.PID_CONTENTTYPE);\n    }
1399	private static TabIdRecord createTabId() {\n        return new TabIdRecord();\n    }
1400	public void removeColumnBreak(int column) {\n        getColumnBreaksRecord().removeBreak(column);\n    }
1401	public Map<String, String> readMacros() throws IOException {\n        Map<String, Module> modules = readMacroModules();\n        Map<String, String> moduleSources = new HashMap<>();\n        for (Map.Entry<String, Module> entry : modules.entrySet()) {\n            moduleSources.put(entry.getKey(), entry.getValue().getContent());\n        }\n        return moduleSources;\n    }
1402	public void removeTable(XWPFTable table) {\n        if (tables.contains(table)) {\n            CTTbl ctTbl = table.getCTTbl();\n            XmlCursor c = ctTbl.newCursor();\n            c.removeXml();\n            c.dispose();\n            tables.remove(table);\n            bodyElements.remove(table);\n        }\n    }
1403	private static boolean isValidRangeOperand(ParseNode a) {\n        Ptg tkn = a.getToken();\n        // Note - order is important for these instance-of checks\n        if (tkn instanceof OperandPtg) {\n            // notably cell refs and area refs\n            return true;\n        }\n\n        // next 2 are special cases of OperationPtg\n        if (tkn instanceof AbstractFunctionPtg) {\n            AbstractFunctionPtg afp = (AbstractFunctionPtg) tkn;\n            byte returnClass = afp.getDefaultOperandClass();\n            return Ptg.CLASS_REF == returnClass;\n        }\n        if (tkn instanceof ValueOperatorPtg) {\n            return false;\n        }\n        if (tkn instanceof OperationPtg) {\n            return true;\n        }\n\n        // one special case of ControlPtg\n        if (tkn instanceof ParenthesisPtg) {\n            // parenthesis Ptg should have only one child\n            return isValidRangeOperand(a.getChildren()[0]);\n        }\n\n        // one special case of ScalarConstantPtg\n        if (tkn == ErrPtg.REF_INVALID) {\n            return true;\n        }\n\n        // All other ControlPtgs and ScalarConstantPtgs cannot be used with ':'\n        return false;\n    }
1404	protected static List<ValueEval> getValidationValuesForConstraint(DataValidationContext context) {\n        final DataValidationConstraint val = context.getValidation().getValidationConstraint();\n        if (val.getValidationType() != ValidationType.LIST) return null;\n        \n        String formula = val.getFormula1();\n        \n        final List<ValueEval> values = new ArrayList<>();\n        \n        if (val.getExplicitListValues() != null && val.getExplicitListValues().length > 0) {\n            // assumes parsing interprets the overloaded property right for XSSF\n            for (String s : val.getExplicitListValues()) {\n                if (s != null) values.add(new StringEval(s)); // constructor throws exception on null\n            }\n        } else if (formula != null) {\n            // evaluate formula for cell refs then get their values\n            // note this should return the raw formula result, not the "unwrapped" version that returns a single value.\n            ValueEval eval = context.getEvaluator().getWorkbookEvaluator().evaluateList(formula, context.getTarget(), context.getRegion());\n            // formula is a StringEval if the validation is by a fixed list.  Use the explicit list later.\n            // there is no way from the model to tell if the list is fixed values or formula based.\n            if (eval instanceof TwoDEval) {\n                TwoDEval twod = (TwoDEval) eval;\n                for (int i=0; i < twod.getHeight(); i++) {\n                    final ValueEval cellValue = twod.getValue(i,  0);\n                    values.add(cellValue);\n                }\n            }\n        }\n        return Collections.unmodifiableList(values);\n    }
1405	private void notYetImplemented(final String msg) {\n        throw new UnsupportedOperationException(msg + " is not yet implemented.");\n    }
1406	public int getAccentAndFollowingHyperlinkColourRGB()\n		{ return accentAndFollowingHyperlinkColourRGB; }
1407	public static int srgb2lin(float sRGB) {\n        // scRGB has a linear gamma of 1.0, scale the AWT-Color which is in sRGB to linear RGB\n        // see https://en.wikipedia.org/wiki/SRGB (the reverse transformation)\n        if (sRGB <= 0.04045d) {\n            return (int)Math.rint(100000d * sRGB / 12.92d);\n        } else {\n            return (int)Math.rint(100000d * Math.pow((sRGB + 0.055d) / 1.055d, 2.4d));\n        }\n    }
1408	private void createChart() {\n        CTPlotArea plotArea = getCTPlotArea();\n\n        plotArea.addNewLayout();\n        chart.addNewPlotVisOnly().setVal(true);\n\n        CTPrintSettings printSettings = chartSpace.addNewPrintSettings();\n        printSettings.addNewHeaderFooter();\n\n        CTPageMargins pageMargins = printSettings.addNewPageMargins();\n        pageMargins.setB(0.75);\n        pageMargins.setL(0.70);\n        pageMargins.setR(0.70);\n        pageMargins.setT(0.75);\n        pageMargins.setHeader(0.30);\n        pageMargins.setFooter(0.30);\n        printSettings.addNewPageSetup();\n    }
1409	public boolean isFShading()\n    {\n        return fShading.isSet( field_2_tlp_flags );\n\n    }
1410	private void initHyperlinks() {\n        hyperlinks = new ArrayList<>();\n\n        if(!worksheet.isSetHyperlinks()) {\n            return;\n        }\n\n        try {\n            PackageRelationshipCollection hyperRels =\n                    getPackagePart().getRelationshipsByType(XSSFRelation.SHEET_HYPERLINKS.getRelation());\n\n            // Turn each one into a XSSFHyperlink\n            for(CTHyperlink hyperlink : worksheet.getHyperlinks().getHyperlinkArray()) {\n                PackageRelationship hyperRel = null;\n                if(hyperlink.getId() != null) {\n                    hyperRel = hyperRels.getRelationshipByID(hyperlink.getId());\n                }\n\n                hyperlinks.add( new XSSFHyperlink(hyperlink, hyperRel) );\n            }\n        } catch (InvalidFormatException e){\n            throw new POIXMLException(e);\n        }\n    }
1411	protected void processCommands() {\n		if(commandDefinitions == null) {\n			throw new IllegalStateException("You must supply the command definitions before calling processCommands!");\n		}\n\n		// Loop over the definitions, building the commands\n		//  and getting their values\n		ArrayList<Command> commandList = new ArrayList<>();\n		for(CommandDefinition cdef : commandDefinitions) {\n			int type = cdef.getType();\n			int offset = cdef.getOffset();\n\n			// Handle virtual commands\n			if(type == 10) {\n				name = cdef.getName();\n				continue;\n			} else if(type == 18) {\n				continue;\n			}\n\n\n			// Build the appropriate command for the type\n			Command command;\n			if(type == 11 || type == 21) {\n				command = new BlockOffsetCommand(cdef);\n			} else {\n				command = new Command(cdef);\n			}\n\n			// Bizarrely, many of the offsets are from the start of the\n			//  header, not from the start of the chunk body\n			switch(type) {\n			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n			case 11: case 21:\n			case 12: case 16: case 17: case 18: case 28: case 29:\n				// Offset is from start of chunk\n				break;\n			default:\n				// Offset is from start of header!\n				if(offset >= 19) {\n					offset -= 19;\n				}\n			}\n\n			// Check we seem to have enough data\n			if(offset >= contents.length) {\n				logger.log(POILogger.WARN,\n						"Command offset " + offset + " past end of data at " + contents.length\n				);\n				continue;\n			}\n\n			try {\n				// Process\n				switch(type) {\n				// Types 0->7 = a flat at bit 0->7\n				case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n					int val = contents[offset] & (1<<type);\n					command.value = Boolean.valueOf(val > 0);\n					break;\n				case 8:\n					command.value = Byte.valueOf(contents[offset]);\n					break;\n				case 9:\n					command.value = Double.valueOf(\n							LittleEndian.getDouble(contents, offset)\n					);\n					break;\n				case 12:\n					// A Little Endian String\n					// Starts 8 bytes into the data segment\n					// Ends at end of data, or 00 00\n\n					// Ensure we have enough data\n					if(contents.length < 8) {\n						command.value = "";\n						break;\n					}\n\n					// Find the end point\n					int startsAt = 8;\n					int endsAt = startsAt;\n					for(int j=startsAt; j<contents.length-1 && endsAt == startsAt; j++) {\n						if(contents[j] == 0 && contents[j+1] == 0) {\n							endsAt = j;\n						}\n					}\n					if(endsAt == startsAt) {\n						endsAt = contents.length;\n					}\n\n					int strLen = endsAt - startsAt;\n					command.value = new String(contents, startsAt, strLen, header.getChunkCharset().name());\n					break;\n				case 25:\n					command.value = Short.valueOf(\n						LittleEndian.getShort(contents, offset)\n					);\n					break;\n				case 26:\n					command.value = Integer.valueOf(\n							LittleEndian.getInt(contents, offset)\n					);\n					break;\n\n				// Types 11 and 21 hold the offset to the blocks\n				case 11: case 21:\n					if(offset < contents.length - 3) {\n						int bOffset = (int)LittleEndian.getUInt(contents, offset);\n						BlockOffsetCommand bcmd = (BlockOffsetCommand)command;\n						bcmd.setOffset(bOffset);\n					}\n					break;\n\n				default:\n					logger.log(POILogger.INFO,\n							"Command of type " + type + " not processed!");\n				}\n			}\n			catch (Exception e) {\n				logger.log(POILogger.ERROR, "Unexpected error processing command, ignoring and continuing. Command: " +\n						command, e);\n			}\n\n			// Add to the array\n			commandList.add(command);\n		}\n\n		// Save the commands we liked the look of\n		this.commands = commandList.toArray(\n							new Command[commandList.size()] );\n\n		// Now build up the blocks, if we had a command that tells\n		//  us where a block is\n	}
1412	@Internal\n    public boolean isFPersonalReply()\n    {\n        return fPersonalReply.isSet(field_5_grfstd);\n    }
1413	public PackagePart createPart(PackagePartName partName, String contentType,\n			ByteArrayOutputStream content) {\n		PackagePart addedPart = this.createPart(partName, contentType);\n		if (addedPart == null) {\n			return null;\n		}\n		// Extract the zip entry content to put it in the part content\n		if (content != null) {\n			try {\n				OutputStream partOutput = addedPart.getOutputStream();\n				if (partOutput == null) {\n					return null;\n				}\n\n				partOutput.write(content.toByteArray(), 0, content.size());\n				partOutput.close();\n\n			} catch (IOException ioe) {\n				return null;\n			}\n		} else {\n			return null;\n		}\n		return addedPart;\n	}
1414	public String getText() {\n        StringBuffer text = new StringBuffer();\n        \n        // To track formats and encodings\n        CodepageRecord codepage = null;\n        // TODO track the XFs and Format Strings\n\n        // Process each record in turn, looking for interesting ones\n        while (ris.hasNextRecord()) {\n            int sid = ris.getNextSid();\n            ris.nextRecord();\n\n            switch (sid) {\n                case  FILE_PASS_RECORD_SID:\n                    throw new EncryptedDocumentException("Encryption not supported for Old Excel files");\n\n                case OldSheetRecord.sid:\n                    OldSheetRecord shr = new OldSheetRecord(ris);\n                    shr.setCodePage(codepage);\n                    text.append("Sheet: ");\n                    text.append(shr.getSheetname());\n                    text.append('\n');\n                    break;\n            \n                case OldLabelRecord.biff2_sid:\n                case OldLabelRecord.biff345_sid:\n                    OldLabelRecord lr = new OldLabelRecord(ris);\n                    lr.setCodePage(codepage);\n                    text.append(lr.getValue());\n                    text.append('\n');\n                    break;\n                case OldStringRecord.biff2_sid:\n                case OldStringRecord.biff345_sid:\n                    OldStringRecord sr = new OldStringRecord(ris);\n                    sr.setCodePage(codepage);\n                    text.append(sr.getString());\n                    text.append('\n');\n                    break;\n                    \n                case NumberRecord.sid:\n                    NumberRecord nr = new NumberRecord(ris);\n                    handleNumericCell(text, nr.getValue());\n                    break;\n                case OldFormulaRecord.biff2_sid:\n                case OldFormulaRecord.biff3_sid:\n                case OldFormulaRecord.biff4_sid:\n                    // Biff 2 and 5+ share the same SID, due to a bug...\n                    if (biffVersion == 5) {\n                        FormulaRecord fr = new FormulaRecord(ris);\n                        if (fr.getCachedResultType() == CellType.NUMERIC.getCode()) {\n                            handleNumericCell(text, fr.getValue());\n                        }\n                    } else {\n                        OldFormulaRecord fr = new OldFormulaRecord(ris);\n                        if (fr.getCachedResultType() == CellType.NUMERIC.getCode()) {\n                            handleNumericCell(text, fr.getValue());\n                        }\n                    }\n                    break;\n                case RKRecord.sid:\n                    RKRecord rr = new RKRecord(ris);\n                    handleNumericCell(text, rr.getRKNumber());\n                    break;\n                    \n                case CodepageRecord.sid:\n                    codepage = new CodepageRecord(ris);\n                    break;\n                    \n                default:\n                    ris.readFully(IOUtils.safelyAllocate(ris.remaining(), MAX_RECORD_LENGTH));\n            }\n        }\n\n        close();\n        ris = null;\n\n        return text.toString();\n    }
1415	protected static HSLFTextRun appendText(List<HSLFTextParagraph> paragraphs, String text, boolean newParagraph) {\n        text = toInternalString(text);\n\n        // check paragraphs\n        assert(!paragraphs.isEmpty() && !paragraphs.get(0).getTextRuns().isEmpty());\n\n        HSLFTextParagraph htp = paragraphs.get(paragraphs.size() - 1);\n        HSLFTextRun htr = htp.getTextRuns().get(htp.getTextRuns().size() - 1);\n\n        boolean addParagraph = newParagraph;\n        for (String rawText : text.split("(?<=\r)")) {\n            // special case, if last text paragraph or run is empty, we will reuse it\n            boolean lastRunEmpty = (htr.getLength() == 0);\n            boolean lastParaEmpty = lastRunEmpty && (htp.getTextRuns().size() == 1);\n\n            if (addParagraph && !lastParaEmpty) {\n                TextPropCollection tpc = htp.getParagraphStyle();\n                HSLFTextParagraph prevHtp = htp;\n                htp = new HSLFTextParagraph(htp._headerAtom, htp._byteAtom, htp._charAtom, paragraphs);\n                htp.getParagraphStyle().copy(tpc);\n                htp.setParentShape(prevHtp.getParentShape());\n                htp.setShapeId(prevHtp.getShapeId());\n                htp.supplySheet(prevHtp.getSheet());\n                paragraphs.add(htp);\n            }\n            addParagraph = true;\n\n            if (!lastRunEmpty) {\n                TextPropCollection tpc = htr.getCharacterStyle();\n                htr = new HSLFTextRun(htp);\n                htr.getCharacterStyle().copy(tpc);\n                htp.addTextRun(htr);\n            }\n            htr.setText(rawText);\n        }\n\n        storeText(paragraphs);\n\n        return htr;\n    }
1416	public static CustomGeometry convertCustomGeometry(XMLStreamReader staxReader) {\n        try {\n            JAXBContext jaxbContext = JAXBContext.newInstance(BINDING_PACKAGE);\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            JAXBElement<CTCustomGeometry2D> el = unmarshaller.unmarshal(staxReader, CTCustomGeometry2D.class);\n            return new CustomGeometry(el.getValue());\n        } catch (JAXBException e) {\n            LOG.log(POILogger.ERROR, "Unable to parse single custom geometry", e);\n            return null;\n        }\n    }
1417	public void removeUnmarshaller(String contentType) {\n        try {\n            partUnmarshallers.remove(new ContentType(contentType));\n        } catch (InvalidFormatException e) {\n            throw new RuntimeException(e);\n        }\n	}
1418	public static void putUShort( int value, OutputStream outputStream )\n            throws IOException\n    {\n        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n    }
1419	public CharacterRun insertAfter( String text )\n    {\n        initAll();\n\n        _text.insert( _end, text );\n\n        _doc.getCharacterTable().adjustForInsert( _charEnd - 1, text.length() );\n        _doc.getParagraphTable().adjustForInsert( _parEnd - 1, text.length() );\n        _doc.getSectionTable().adjustForInsert( _sectionEnd - 1, text.length() );\n        if ( _doc instanceof HWPFDocument )\n        {\n            ( (BookmarksImpl) ( (HWPFDocument) _doc ).getBookmarks() )\n                    .afterInsert( _end, text.length() );\n        }\n        adjustForInsert( text.length() );\n\n        sanityCheck();\n        return getCharacterRun( numCharacterRuns() - 1 );\n    }
1420	protected final void recurseClearCachedFormulaResults() {\n		FormulaCellCacheEntry[] formulaCells = getConsumingCells();\n\n		for (int i = 0; i < formulaCells.length; i++) {\n			FormulaCellCacheEntry fc = formulaCells[i];\n			fc.clearFormulaEntry();\n			fc.recurseClearCachedFormulaResults();\n		}\n	}
1421	public static void main(String[] args) {\n        // Check the number of arguments passed to the main method. There\n        // must be two, three or four; the name of and path to either the folder\n        // containing the Excel files or an individual Excel workbook that is/are\n        // to be converted, the name of and path to the folder to which the CSV\n        // files should be written, - optionally - the separator character\n        // that should be used to separate individual items (fields) on the\n        // lines (records) of the CSV file and - again optionally - an integer\n        // that idicates whether the CSV file ought to obey Excel's or UNIX\n        // convnetions with regard to formatting fields that contain embedded\n        // separator, Speech mark or EOL character(s).\n        //\n        // Note that the names of the CSV files will be derived from those\n        // of the Excel file(s). Put simply the .xls or .xlsx extension will be\n        // replaced with .csv. Therefore, if the source folder contains files\n        // with matching names but different extensions - Test.xls and Test.xlsx\n        // for example - then the CSV file generated from one will overwrite\n        // that generated from the other.\n        ToCSV converter;\n        boolean converted = true;\n        long startTime = System.currentTimeMillis();\n        try {\n            converter = new ToCSV();\n            if(args.length == 2) {\n                // Just the Source File/Folder and Destination Folder were\n                // passed to the main method.\n                converter.convertExcelToCSV(args[0], args[1]);\n            }\n            else if(args.length == 3){\n                // The Source File/Folder, Destination Folder and Separator\n                // were passed to the main method.\n                converter.convertExcelToCSV(args[0], args[1], args[2]);\n            }\n            else if(args.length == 4) {\n                // The Source File/Folder, Destination Folder, Separator and\n                // Formatting Convnetion were passed to the main method.\n                converter.convertExcelToCSV(args[0], args[1],\n                                            args[2], Integer.parseInt(args[3]));\n            }\n            else {\n                // None or more than four parameters were passed so display\n                //a Usage message.\n                System.out.println("Usage: java ToCSV [Source File/Folder] " +\n                    "[Destination Folder] [Separator] [Formatting Convention]\n" +\n                    "\tSource File/Folder\tThis argument should contain the name of and\n" +\n                    "\t\t\t\tpath to either a single Excel workbook or a\n" +\n                    "\t\t\t\tfolder containing one or more Excel workbooks.\n" +\n                    "\tDestination Folder\tThe name of and path to the folder that the\n" +\n                    "\t\t\t\tCSV files should be written out into. The\n" +\n                    "\t\t\t\tfolder must exist before running the ToCSV\n" +\n                    "\t\t\t\tcode as it will not check for or create it.\n" +\n                    "\tSeparator\t\tOptional. The character or characters that\n" +\n                    "\t\t\t\tshould be used to separate fields in the CSV\n" +\n                    "\t\t\t\trecord. If no value is passed then the comma\n" +\n                    "\t\t\t\twill be assumed.\n" +\n                    "\tFormatting Convention\tOptional. This argument can take one of two\n" +\n                    "\t\t\t\tvalues. Passing 0 (zero) will result in a CSV\n" +\n                    "\t\t\t\tfile that obeys Excel's formatting conventions\n" +\n                    "\t\t\t\twhilst passing 1 (one) will result in a file\n" +\n                    "\t\t\t\tthat obeys UNIX formatting conventions. If no\n" +\n                    "\t\t\t\tvalue is passed, then the CSV file produced\n" +\n                    "\t\t\t\twill obey Excel's formatting conventions.");\n                converted = false;\n            }\n        }\n        // It is not wise to have such a wide catch clause - Exception is very\n        // close to being at the top of the inheritance hierarchy - though it\n        // will suffice for this example as it is really not possible to recover\n        // easilly from an exceptional set of circumstances at this point in the\n        // program. It should however, ideally be replaced with one or more\n        // catch clauses optimised to handle more specific problems.\n        catch(Exception ex) {\n            System.out.println("Caught an: " + ex.getClass().getName());\n            System.out.println("Message: " + ex.getMessage());\n            System.out.println("Stacktrace follows:.....");\n            ex.printStackTrace(System.out);\n            converted = false;\n        }\n        \n        if (converted) {\n            System.out.println("Conversion took " + \n                  (int)((System.currentTimeMillis() - startTime)/1000) + " seconds");\n        }\n    }
1422	public CellRangeAddress8Bit removeArrayFormula(int rowIndex, int columnIndex) {\n		for (ArrayRecord ar : _arrayRecords) {\n			if (ar.isInRange(rowIndex, columnIndex)) {\n				_arrayRecords.remove(ar);\n				return ar.getRange();\n			}\n		}\n		String ref = new CellReference(rowIndex, columnIndex, false, false).formatAsString();\n		throw new IllegalArgumentException("Specified cell " + ref\n				+ " is not part of an array formula.");\n	}
1423	public int getFcPlcfbkf()\n    {\n        return _fieldHandler.getFieldOffset( FIBFieldHandler.PLCFBKF );\n    }
1424	public boolean isFPub()\n    {\n        return fPub.isSet(field_2_bkf_flags);\n    }
1425	public static float lin2srgb(int linRGB) {\n        // color in percentage is in linear RGB color space, i.e. needs to be gamma corrected for AWT color\n        // see https://en.wikipedia.org/wiki/SRGB (The forward transformation)\n        if (linRGB <= 0.0031308d) {\n            return (float)(linRGB / 100000d * 12.92d);\n        } else {\n            return (float)(1.055d * Math.pow(linRGB / 100000d, 1.0d/2.4d) - 0.055d);\n        }\n    }
1426	@Internal\n    public void setCellReference(String ref) {\n        _ctHyperlink.setRef(ref);\n    }
1427	public static boolean areDirectoriesIdentical(DirectoryEntry dirA, DirectoryEntry dirB) {\n        return new DirectoryDelegate(dirA).equals(new DirectoryDelegate(dirB));\n    }
1428	public int addSSTString(UnicodeString string) {\n        LOG.log(DEBUG, "insert to sst string='", string);\n        if (sst == null) {\n            insertSST();\n        }\n      return sst.addString(string);\n    }
1429	private void paintNormalBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n\n      if (northBorder &&\n             ((northBorderType == BorderStyle.THIN) ||\n              (northBorderType == BorderStyle.MEDIUM) ||\n              (northBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(northBorderType);\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x,y+k,width,y+k);\n        }\n      }\n\n      if (eastBorder &&\n             ((eastBorderType == BorderStyle.THIN) ||\n              (eastBorderType == BorderStyle.MEDIUM) ||\n              (eastBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(width-k,y,width-k,height);\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.THIN) ||\n               (southBorderType == BorderStyle.MEDIUM) ||\n               (southBorderType == BorderStyle.THICK)\n              )\n         ) {\n\n        int thickness = getThickness(southBorderType);\n\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x,height - k,width,height - k);\n        }\n      }\n\n      if (westBorder &&\n             ((westBorderType == BorderStyle.THIN) ||\n              (westBorderType == BorderStyle.MEDIUM) ||\n              (westBorderType == BorderStyle.THICK)\n             )\n         ) {\n\n        int thickness = getThickness(westBorderType);\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           g.drawLine(x+k,y,x+k,height);\n        }\n      }\n   }
1430	public static boolean isRelationshipPartURI(URI partUri) {\n		if (partUri == null)\n			throw new IllegalArgumentException("partUri");\n\n		return partUri.getPath().matches(\n				".*" + RELATIONSHIP_PART_SEGMENT_NAME + ".*"\n						+ RELATIONSHIP_PART_EXTENSION_NAME + "$");\n	}
1431	private void paintDoubleBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             northBorderType == BorderStyle.DOUBLE) {\n\n      	g.setColor(northColor);\n\n        int leftx=x;\n        int rightx=width;\n\n                // if there are borders on the west or east then\n                // the second line shouldn't cross them\n        if (westBorder)\n           leftx = x+3;\n\n        if (eastBorder)\n           rightx = width-3;\n\n           g.drawLine(x,y,width,y);\n           g.drawLine(leftx,y+2,rightx,y+2);\n      }\n\n      if (eastBorder &&\n              eastBorderType == BorderStyle.DOUBLE\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; //need for dotted borders to show up east\n\n      	g.setColor(eastColor);\n\n        int topy=y;\n        int bottomy=height;\n\n        if (northBorder)\n          topy=y+3;\n\n        if (southBorder)\n            bottomy=height-3;\n\n        g.drawLine(width-1,y,width-1,height);\n        g.drawLine(width-3,topy,width-3,bottomy);\n      }\n\n      if (southBorder &&\n              southBorderType == BorderStyle.DOUBLE\n         ) {\n\n      	g.setColor(southColor);\n\n        int leftx=y;\n        int rightx=width;\n\n        if (westBorder)\n           leftx=x+3;\n\n        if (eastBorder)\n           rightx=width-3;\n\n\n        g.drawLine(x,height - 1,width,height - 1);\n        g.drawLine(leftx,height - 3,rightx,height - 3);\n      }\n\n      if (westBorder &&\n            westBorderType == BorderStyle.DOUBLE\n         ) {\n\n        int thickness = getThickness(westBorderType);\n//        thickness++;\n\n      	g.setColor(westColor);\n\n        int topy=y;\n        int bottomy=height-3;\n\n        if (northBorder)\n           topy=y+2;\n\n        if (southBorder)\n           bottomy=height-3;\n\n        g.drawLine(x,y,x,height);\n        g.drawLine(x+2,topy,x+2,bottomy);\n      }\n   }
1432	@Internal\n    public boolean isFCopyLang()\n    {\n        return fCopyLang.isSet(field_5_grfstd);\n    }
1433	public boolean isFResultDirty()\n    {\n        return fResultDirty.isSet( field_2_flt );\n\n    }
1434	public static int convertColStringToIndex(String ref) {\n        int retval=0;\n        char[] refs = ref.toUpperCase(Locale.ROOT).toCharArray();\n        for (int k=0; k<refs.length; k++) {\n            char thechar = refs[k];\n            if (thechar == ABSOLUTE_REFERENCE_MARKER) {\n                if (k != 0) {\n                    throw new IllegalArgumentException("Bad col ref format '" + ref + "'");\n                }\n                continue;\n            }\n\n            // Character is uppercase letter, find relative value to A\n            retval = (retval * 26) + (thechar - 'A' + 1);\n        }\n        return retval-1;\n    }
1435	public void removeParagraph(int pos) {\n        paragraphs.remove(pos);\n        ctTc.removeP(pos);\n    }
1436	public int getShadowsColourRGB() { return shadowsColourRGB; }
1437	@Internal\n    public byte getWrk()\n    {\n        return ( byte )wrk.getValue(field_6_flags);\n    }
1438	@SuppressWarnings("deprecation")\n    private void buildRunsInOrderFromXml(XmlObject object) {\n        XmlCursor c = object.newCursor();\n        c.selectPath("child::*");\n        while (c.toNextSelection()) {\n            XmlObject o = c.getObject();\n            if (o instanceof CTR) {\n                XWPFRun r = new XWPFRun((CTR) o, this);\n                runs.add(r);\n                iruns.add(r);\n            }\n            if (o instanceof CTHyperlink) {\n                CTHyperlink link = (CTHyperlink)o;\n                for (CTR r : link.getRArray()) {\n                    XWPFHyperlinkRun hr = new XWPFHyperlinkRun(link, r, this);\n                    runs.add(hr);\n                    iruns.add(hr);\n                }\n            }\n            if (o instanceof CTSimpleField) {\n                CTSimpleField field = (CTSimpleField)o;\n                for (CTR r : field.getRArray()) {\n                    XWPFFieldRun fr = new XWPFFieldRun(field, r, this);\n                    runs.add(fr);\n                    iruns.add(fr);\n                }\n            }\n            if (o instanceof CTSdtBlock) {\n                XWPFSDT cc = new XWPFSDT((CTSdtBlock) o, part);\n                iruns.add(cc);\n            }\n            if (o instanceof CTSdtRun) {\n                XWPFSDT cc = new XWPFSDT((CTSdtRun) o, part);\n                iruns.add(cc);\n            }\n            if (o instanceof CTRunTrackChange) {\n                for (CTR r : ((CTRunTrackChange) o).getRArray()) {\n                    XWPFRun cr = new XWPFRun(r, this);\n                    runs.add(cr);\n                    iruns.add(cr);\n                }\n            }\n            if (o instanceof CTSmartTagRun) {\n                // Smart Tags can be nested many times.\n                // This implementation does not preserve the tagging information\n                buildRunsInOrderFromXml(o);\n            }\n            if (o instanceof CTRunTrackChange) {\n                // add all the insertions as text\n                for (CTRunTrackChange change : ((CTRunTrackChange) o).getInsArray()) {\n                    buildRunsInOrderFromXml(change);\n                }\n            }\n        }\n        c.dispose();\n    }
1439	public PackageRelationship findExistingRelation(PackagePart packagePart) {\n        return _relationships.findExistingInternalRelation(packagePart);\n    }
1440	public void importContent(XDDFChart other) {\n        this.chart.set(other.chart);\n    }
1441	public static void createShapeTree(EscherContainerRecord container, EscherAggregate agg, HSSFShapeContainer out, DirectoryNode root) {\n        if (container.getRecordId() == EscherContainerRecord.SPGR_CONTAINER) {\n            ObjRecord obj = null;\n            EscherClientDataRecord clientData = ((EscherContainerRecord) container.getChild(0)).getChildById(EscherClientDataRecord.RECORD_ID);\n            if (null != clientData) {\n                obj = (ObjRecord) agg.getShapeToObjMapping().get(clientData);\n            }\n            HSSFShapeGroup group = new HSSFShapeGroup(container, obj);\n            List<EscherContainerRecord> children = container.getChildContainers();\n            // skip the first child record, it is group descriptor\n            for (int i = 0; i < children.size(); i++) {\n                EscherContainerRecord spContainer = children.get(i);\n                if (i != 0) {\n                    createShapeTree(spContainer, agg, group, root);\n                }\n            }\n            out.addShape(group);\n        } else if (container.getRecordId() == EscherContainerRecord.SP_CONTAINER) {\n            Map<EscherRecord, Record> shapeToObj = agg.getShapeToObjMapping();\n            ObjRecord objRecord = null;\n            TextObjectRecord txtRecord = null;\n\n            for (EscherRecord record : container) {\n                switch (record.getRecordId()) {\n                    case EscherClientDataRecord.RECORD_ID:\n                        objRecord = (ObjRecord) shapeToObj.get(record);\n                        break;\n                    case EscherTextboxRecord.RECORD_ID:\n                        txtRecord = (TextObjectRecord) shapeToObj.get(record);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (objRecord == null) {\n                throw new RecordFormatException("EscherClientDataRecord can't be found.");\n            }\n            if (isEmbeddedObject(objRecord)) {\n                HSSFObjectData objectData = new HSSFObjectData(container, objRecord, root);\n                out.addShape(objectData);\n                return;\n            }\n            CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord) objRecord.getSubRecords().get(0);\n            final HSSFShape shape;\n            switch (cmo.getObjectType()) {\n                case CommonObjectDataSubRecord.OBJECT_TYPE_PICTURE:\n                    shape = new HSSFPicture(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_RECTANGLE:\n                    shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_LINE:\n                    shape = new HSSFSimpleShape(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_COMBO_BOX:\n                    shape = new HSSFCombobox(container, objRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING:\n                    EscherOptRecord optRecord = container.getChildById(EscherOptRecord.RECORD_ID);\n                    if(optRecord == null) {\n                    	shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                    } else {\n                        EscherProperty property = optRecord.lookup(EscherProperties.GEOMETRY__VERTICES);\n                        if (null != property) {\n                            shape = new HSSFPolygon(container, objRecord, txtRecord);\n                        } else {\n                            shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n                        }\n                    }\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_TEXT:\n                    shape = new HSSFTextbox(container, objRecord, txtRecord);\n                    break;\n                case CommonObjectDataSubRecord.OBJECT_TYPE_COMMENT:\n                    shape = new HSSFComment(container, objRecord, txtRecord, agg.getNoteRecordByObj(objRecord));\n                    break;\n                default:\n                    shape = new HSSFSimpleShape(container, objRecord, txtRecord);\n            }\n            out.addShape(shape);\n        }\n    }
1442	private void updateHeaderFooterText(String[] parts) {\n		String _left = parts[0];\n		String _center = parts[1];\n		String _right = parts[2];\n		\n		if (_center.length() < 1 && _left.length() < 1 && _right.length() < 1) {\n			setHeaderFooterText("");\n			return;\n		}\n		StringBuilder sb = new StringBuilder(64);\n		sb.append("&C");\n		sb.append(_center);\n		sb.append("&L");\n		sb.append(_left);\n		sb.append("&R");\n		sb.append(_right);\n		String text = sb.toString();\n		setHeaderFooterText(text);\n	}
1443	private void unhookOldEnvironments(WorkbookEvaluator[] evaluators) {\n        Set<CollaboratingWorkbooksEnvironment> oldEnvs = new HashSet<>();\n        for(int i=0; i<evaluators.length; i++) {\n            oldEnvs.add(evaluators[i].getEnvironment());\n        }\n        CollaboratingWorkbooksEnvironment[] oldCWEs = new CollaboratingWorkbooksEnvironment[oldEnvs.size()];\n        oldEnvs.toArray(oldCWEs);\n        for (int i = 0; i < oldCWEs.length; i++) {\n            oldCWEs[i].unhook();\n        }\n    }
1444	@Internal\n    public boolean isFReadOnlyRecommended()\n    {\n        return fReadOnlyRecommended.isSet(field_6_flags1);\n    }
1445	public XSSFCellStyle createCellStyle() {\n        if (getNumCellStyles() > MAXIMUM_STYLE_ID) {\n            throw new IllegalStateException("The maximum number of Cell Styles was exceeded. " +\n                      "You can define up to " + MAXIMUM_STYLE_ID + " style in a .xlsx Workbook");\n        }\n\n        int xfSize = styleXfs.size();\n        CTXf xf = CTXf.Factory.newInstance();\n        xf.setNumFmtId(0);\n        xf.setFontId(0);\n        xf.setFillId(0);\n        xf.setBorderId(0);\n        xf.setXfId(0);\n        int indexXf = putCellXf(xf);\n        return new XSSFCellStyle(indexXf - 1, xfSize - 1, this, theme);\n    }
1446	public TextPropCollection addParagraphTextPropCollection(int charactersCovered) {\n        TextPropCollection tpc = new TextPropCollection(charactersCovered, TextPropType.paragraph);\n        paragraphStyles.add(tpc);\n        return tpc;\n    }
1447	private int calculateNewLastCellPlusOne(int lastcell) {\n        int cellIx = lastcell - 1;\n        HSSFCell r = retrieveCell(cellIx);\n\n        while (r == null) {\n            if (cellIx < 0) {\n                return 0;\n            }\n            r = retrieveCell(--cellIx);\n        }\n        return cellIx+1;\n    }
1448	public void dumpOld(long maxLength, InputStream in, PrintStream out)\n            throws IOException, LittleEndian.BufferUnderrunException {\n        long remainingBytes = maxLength;\n        short options;      // 4 bits for the version and 12 bits for the instance\n        short recordId;\n        int recordBytesRemaining;       // including enclosing records\n        short nDumpSize;\n        String recordName;\n\n        boolean atEOF = false;\n\n        while (!atEOF && (remainingBytes > 0)) {\n            options = LittleEndian.readShort( in );\n            recordId = LittleEndian.readShort( in );\n            recordBytesRemaining = LittleEndian.readInt( in );\n\n            remainingBytes -= 2 + 2 + 4;\n\n            switch ( recordId )\n            {\n                case (short) 0xF000:\n                    recordName = "MsofbtDggContainer";\n                    break;\n                case (short) 0xF006:\n                    recordName = "MsofbtDgg";\n                    break;\n                case (short) 0xF016:\n                    recordName = "MsofbtCLSID";\n                    break;\n                case (short) 0xF00B:\n                    recordName = "MsofbtOPT";\n                    break;\n                case (short) 0xF11A:\n                    recordName = "MsofbtColorMRU";\n                    break;\n                case (short) 0xF11E:\n                    recordName = "MsofbtSplitMenuColors";\n                    break;\n                case (short) 0xF001:\n                    recordName = "MsofbtBstoreContainer";\n                    break;\n                case (short) 0xF007:\n                    recordName = "MsofbtBSE";\n                    break;\n                case (short) 0xF002:\n                    recordName = "MsofbtDgContainer";\n                    break;\n                case (short) 0xF008:\n                    recordName = "MsofbtDg";\n                    break;\n                case (short) 0xF118:\n                    recordName = "MsofbtRegroupItem";\n                    break;\n                case (short) 0xF120:\n                    recordName = "MsofbtColorScheme";\n                    break;\n                case (short) 0xF003:\n                    recordName = "MsofbtSpgrContainer";\n                    break;\n                case (short) 0xF004:\n                    recordName = "MsofbtSpContainer";\n                    break;\n                case (short) 0xF009:\n                    recordName = "MsofbtSpgr";\n                    break;\n                case (short) 0xF00A:\n                    recordName = "MsofbtSp";\n                    break;\n                case (short) 0xF00C:\n                    recordName = "MsofbtTextbox";\n                    break;\n                case (short) 0xF00D:\n                    recordName = "MsofbtClientTextbox";\n                    break;\n                case (short) 0xF00E:\n                    recordName = "MsofbtAnchor";\n                    break;\n                case (short) 0xF00F:\n                    recordName = "MsofbtChildAnchor";\n                    break;\n                case (short) 0xF010:\n                    recordName = "MsofbtClientAnchor";\n                    break;\n                case (short) 0xF011:\n                    recordName = "MsofbtClientData";\n                    break;\n                case (short) 0xF11F:\n                    recordName = "MsofbtOleObject";\n                    break;\n                case (short) 0xF11D:\n                    recordName = "MsofbtDeletedPspl";\n                    break;\n                case (short) 0xF005:\n                    recordName = "MsofbtSolverContainer";\n                    break;\n                case (short) 0xF012:\n                    recordName = "MsofbtConnectorRule";\n                    break;\n                case (short) 0xF013:\n                    recordName = "MsofbtAlignRule";\n                    break;\n                case (short) 0xF014:\n                    recordName = "MsofbtArcRule";\n                    break;\n                case (short) 0xF015:\n                    recordName = "MsofbtClientRule";\n                    break;\n                case (short) 0xF017:\n                    recordName = "MsofbtCalloutRule";\n                    break;\n                case (short) 0xF119:\n                    recordName = "MsofbtSelection";\n                    break;\n                case (short) 0xF122:\n                    recordName = "MsofbtUDefProp";\n                    break;\n                default:\n                    if ( recordId >= (short) 0xF018 && recordId <= (short) 0xF117 ) {\n                        recordName = "MsofbtBLIP";\n                    } else if ( ( options & (short) 0x000F ) == (short) 0x000F ) {\n                        recordName = "UNKNOWN container";\n                    } else {\n                        recordName = "UNKNOWN ID";\n                    }\n            }\n\n            StringBuilder stringBuf = new StringBuilder();\n            stringBuf.append( "  " );\n            stringBuf.append( HexDump.toHex( recordId ) );\n            stringBuf.append( "  " ).append( recordName ).append( " [" );\n            stringBuf.append( HexDump.toHex( options ) );\n            stringBuf.append( ',' );\n            stringBuf.append( HexDump.toHex( recordBytesRemaining ) );\n            stringBuf.append( "]  instance: " );\n            stringBuf.append( HexDump.toHex( ( (short) ( options >> 4 ) ) ) );\n            out.println(stringBuf);\n            stringBuf.setLength(0);\n\n\n            if ( recordId == (short) 0xF007 && 36 <= remainingBytes && 36 <= recordBytesRemaining )\n            {	// BSE, FBSE\n                //                ULONG nP = pIn->GetRecPos();\n\n                byte n8;\n                //                short n16;\n                //                int n32;\n\n                stringBuf = stringBuf.append( "    btWin32: " );\n                n8 = (byte) in.read();\n                stringBuf.append( HexDump.toHex( n8 ) );\n                stringBuf.append( getBlipType( n8 ) );\n                stringBuf.append( "  btMacOS: " );\n                n8 = (byte) in.read();\n                stringBuf.append( HexDump.toHex( n8 ) );\n                stringBuf.append( getBlipType( n8 ) );\n                out.println(stringBuf);\n\n                out.println( "    rgbUid:" );\n                HexDump.dump( in, out, 0, 16 );\n\n                out.print( "    tag: " );\n                outHex( 2, in, out );\n                out.println();\n                out.print( "    size: " );\n                outHex( 4, in, out );\n                out.println();\n                out.print( "    cRef: " );\n                outHex( 4, in, out );\n                out.println();\n                out.print( "    offs: " );\n                outHex( 4, in, out );\n                out.println();\n                out.print( "    usage: " );\n                outHex( 1, in, out );\n                out.println();\n                out.print( "    cbName: " );\n                outHex( 1, in, out );\n                out.println();\n                out.print( "    unused2: " );\n                outHex( 1, in, out );\n                out.println();\n                out.print( "    unused3: " );\n                outHex( 1, in, out );\n                out.println();\n\n                // subtract the number of bytes we've read\n                remainingBytes -= 36;\n                //n -= pIn->GetRecPos() - nP;\n                recordBytesRemaining = 0;		// loop to MsofbtBLIP\n            }\n            else if ( recordId == (short) 0xF010 && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining )\n            {	// ClientAnchor\n                //ULONG nP = pIn->GetRecPos();\n                //                short n16;\n\n                out.print( "    Flag: " );\n                outHex( 2, in, out );\n                out.println();\n                out.print( "    Col1: " );\n                outHex( 2, in, out );\n                out.print( "    dX1: " );\n                outHex( 2, in, out );\n                out.print( "    Row1: " );\n                outHex( 2, in, out );\n                out.print( "    dY1: " );\n                outHex( 2, in, out );\n                out.println();\n                out.print( "    Col2: " );\n                outHex( 2, in, out );\n                out.print( "    dX2: " );\n                outHex( 2, in, out );\n                out.print( "    Row2: " );\n                outHex( 2, in, out );\n                out.print( "    dY2: " );\n                outHex( 2, in, out );\n                out.println();\n\n                remainingBytes -= 18;\n                recordBytesRemaining -= 18;\n\n            }\n            else if ( recordId == (short) 0xF00B || recordId == (short) 0xF122 )\n            {	// OPT\n                int nComplex = 0;\n                out.println( "    PROPID        VALUE" );\n                while ( recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex )\n                {\n                    short n16;\n                    int n32;\n                    n16 = LittleEndian.readShort( in );\n                    n32 = LittleEndian.readInt( in );\n\n                    recordBytesRemaining -= 6;\n                    remainingBytes -= 6;\n                    out.print( "    " );\n                    out.print( HexDump.toHex( n16 ) );\n                    out.print( " (" );\n                    int propertyId = n16 & (short) 0x3FFF;\n                    out.print( " " + propertyId  );\n                    if ( ( n16 & (short) 0x8000 ) == 0 )\n                    {\n                        if ( ( n16 & (short) 0x4000 ) != 0 ) {\n                            out.print( ", fBlipID" );\n                        }\n                        out.print( ")  " );\n\n                        out.print( HexDump.toHex( n32 ) );\n\n                        if ( ( n16 & (short) 0x4000 ) == 0 )\n                        {\n                            out.print( " (" );\n                            out.print( dec1616( n32 ) );\n                            out.print( ')' );\n                            out.print( " {" + propName( (short)propertyId ) + "}" );\n                        }\n                        out.println();\n                    }\n                    else\n                    {\n                        out.print( ", fComplex)  " );\n                        out.print( HexDump.toHex( n32 ) );\n                        out.print( " - Complex prop len" );\n                        out.println( " {" + propName( (short)propertyId ) + "}" );\n\n                        nComplex += n32;\n                    }\n\n                }\n                // complex property data\n                while ( ( nComplex & remainingBytes ) > 0 )\n                {\n                    nDumpSize = ( nComplex > (int) remainingBytes ) ? (short) remainingBytes : (short) nComplex;\n                    HexDump.dump( in, out, 0, nDumpSize );\n                    nComplex -= nDumpSize;\n                    recordBytesRemaining -= nDumpSize;\n                    remainingBytes -= nDumpSize;\n                }\n            }\n            else if ( recordId == (short) 0xF012 )\n            {\n                out.print( "    Connector rule: " );\n                out.print( LittleEndian.readInt( in ) );\n                out.print( "    ShapeID A: " );\n                out.print( LittleEndian.readInt( in ) );\n                out.print( "   ShapeID B: " );\n                out.print( LittleEndian.readInt( in ) );\n                out.print( "    ShapeID connector: " );\n                out.print( LittleEndian.readInt( in ) );\n                out.print( "   Connect pt A: " );\n                out.print( LittleEndian.readInt( in ) );\n                out.print( "   Connect pt B: " );\n                out.println( LittleEndian.readInt( in ) );\n\n                recordBytesRemaining -= 24;\n                remainingBytes -= 24;\n            }\n            else if ( recordId >= (short) 0xF018 && recordId < (short) 0xF117 )\n            {\n                out.println( "    Secondary UID: " );\n                HexDump.dump( in, out, 0, 16 );\n                out.println( "    Cache of size: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Boundary top: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Boundary left: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Boundary width: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Boundary height: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    X: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Y: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Cache of saved size: " + HexDump.toHex( LittleEndian.readInt( in ) ) );\n                out.println( "    Compression Flag: " + HexDump.toHex( (byte) in.read() ) );\n                out.println( "    Filter: " + HexDump.toHex( (byte) in.read() ) );\n                out.println( "    Data (after decompression): " );\n\n                recordBytesRemaining -= 34 + 16;\n                remainingBytes -= 34 + 16;\n\n                nDumpSize = ( recordBytesRemaining > (int) remainingBytes ) ? (short) remainingBytes : (short) recordBytesRemaining;\n\n\n                byte[] buf = new byte[nDumpSize];\n                int read = in.read( buf );\n                while ( read != -1 && read < nDumpSize ) {\n                    read += in.read( buf, read, buf.length );\n                }\n                ByteArrayInputStream bin = new ByteArrayInputStream( buf );\n\n                InputStream in1 = new InflaterInputStream( bin );\n                int bytesToDump = -1;\n                HexDump.dump( in1, out, 0, bytesToDump );\n\n                recordBytesRemaining -= nDumpSize;\n                remainingBytes -= nDumpSize;\n\n            }\n\n            boolean isContainer = ( options & (short) 0x000F ) == (short) 0x000F;\n            if ( isContainer && remainingBytes >= 0 )\n            {	// Container\n                if ( recordBytesRemaining <= (int) remainingBytes ) {\n                    out.println( "            completed within" );\n                } else {\n                    out.println( "            continued elsewhere" );\n                }\n            }\n            else if ( remainingBytes >= 0 )\n            // -> 0x0000 ... 0x0FFF\n            {\n                nDumpSize = ( recordBytesRemaining > (int) remainingBytes ) ? (short) remainingBytes : (short) recordBytesRemaining;\n\n                if ( nDumpSize != 0 )\n                {\n                    HexDump.dump( in, out, 0, nDumpSize );\n                    remainingBytes -= nDumpSize;\n                }\n            } else {\n                out.println( " >> OVERRUN <<" );\n            }\n        }\n\n    }
1449	public XWPFTable getTable(CTTbl ctTable) {\n        for (XWPFTable table : tables) {\n            if (table == null)\n                return null;\n            if (table.getCTTbl().equals(ctTable))\n                return table;\n        }\n        return null;\n    }
1450	public CharacterRun insertBefore( String text )\n    {\n        initAll();\n\n        _text.insert( _start, text );\n        _doc.getCharacterTable().adjustForInsert( _charStart, text.length() );\n        _doc.getParagraphTable().adjustForInsert( _parStart, text.length() );\n        _doc.getSectionTable().adjustForInsert( _sectionStart, text.length() );\n        if ( _doc instanceof HWPFDocument )\n        {\n            ( (BookmarksImpl) ( (HWPFDocument) _doc ).getBookmarks() )\n                    .afterInsert( _start, text.length() );\n        }\n        adjustForInsert( text.length() );\n\n        // update the FIB.CCPText + friends fields\n        adjustFIB( text.length() );\n\n		sanityCheck();\n\n        return getCharacterRun( 0 );\n    }
1451	private CTTextParagraphProperties getDefaultMasterStyle(){\n        CTPlaceholder ph = _shape.getPlaceholderDetails().getCTPlaceholder(false);\n        String defaultStyleSelector;  \n        switch(ph == null ? -1 : ph.getType().intValue()) {\n            case STPlaceholderType.INT_TITLE:\n            case STPlaceholderType.INT_CTR_TITLE:\n                defaultStyleSelector = "titleStyle";\n                break;\n            case -1: // no placeholder means plain text box\n            case STPlaceholderType.INT_FTR:\n            case STPlaceholderType.INT_SLD_NUM:\n            case STPlaceholderType.INT_DT:\n                defaultStyleSelector = "otherStyle";\n                break;\n            default:\n                defaultStyleSelector = "bodyStyle";\n                break;\n        }\n        int level = getIndentLevel();\n\n        // wind up and find the root master sheet which must be slide master\n        final String nsPML = "http://schemas.openxmlformats.org/presentationml/2006/main";\n        XSLFSheet masterSheet = _shape.getSheet();\n        for (XSLFSheet m = masterSheet; m != null; m = (XSLFSheet)m.getMasterSheet()) {\n            masterSheet = m;\n            XmlObject xo = masterSheet.getXmlObject();\n            XmlCursor cur = xo.newCursor();\n            try {\n                cur.push();\n                if ((cur.toChild(nsPML, "txStyles") && cur.toChild(nsPML, defaultStyleSelector)) ||\n            		(cur.pop() && cur.toChild(nsPML, "notesStyle"))) {\n                    while (level >= 0) {\n                        cur.push();\n                    	if (cur.toChild(XSLFRelation.NS_DRAWINGML, "lvl" +(level+1)+ "pPr")) {\n                    		return (CTTextParagraphProperties)cur.getObject();\n                    	}\n                    	cur.pop();\n                    	level--;\n                    }\n                }\n            } finally {\n            	cur.dispose();\n            }\n        }\n        \n        return null;\n    }
1452	public static String xorHashPasswordReversed(String password) {\n        int hashedPassword = createXorVerifier2(password);\n        \n        return String.format(Locale.ROOT, "%1$02X%2$02X%3$02X%4$02X"\n            , ( hashedPassword >>> 0 ) & 0xFF\n            , ( hashedPassword >>> 8 ) & 0xFF\n            , ( hashedPassword >>> 16 ) & 0xFF\n            , ( hashedPassword >>> 24 ) & 0xFF\n        );\n    }
1453	public boolean isDoNotSizeWithWindow() {\n        return doNotSizeWithWindow.isSet(field_1_flags);\n    }
1454	public int serialize( int offset, byte[] data ) {\n        LOG.log( DEBUG, "Serializing Workbook with offsets" );\n\n        int pos = 0;\n\n        SSTRecord lSST = null;\n        int sstPos = 0;\n        boolean wroteBoundSheets = false;\n        for ( Record record : records.getRecords() ) {\n            int len = 0;\n            if (record instanceof SSTRecord) {\n                lSST = (SSTRecord)record;\n                sstPos = pos;\n            }\n            if (record.getSid() == ExtSSTRecord.sid && lSST != null) {\n                record = lSST.createExtSSTRecord(sstPos + offset);\n            }\n            if (record instanceof BoundSheetRecord) {\n                 if(!wroteBoundSheets) {\n                    for (BoundSheetRecord bsr : boundsheets) {\n                        len += bsr.serialize(pos+offset+len, data);\n                    }\n                    wroteBoundSheets = true;\n                 }\n            } else {\n               len = record.serialize( pos + offset, data );\n            }\n            pos += len;\n        }\n        \n        LOG.log( DEBUG, "Exiting serialize workbook" );\n        return pos;\n    }
1455	private void openWorkbook(File file) throws FileNotFoundException,\n                                           IOException {\n        System.out.println("Opening workbook [" + file.getName() + "]");\n        try (FileInputStream fis = new FileInputStream(file)) {\n\n            // Open the workbook and then create the FormulaEvaluator and\n            // DataFormatter instances that will be needed to, respectively,\n            // force evaluation of forumlae found in cells and create a\n            // formatted String encapsulating the cells contents.\n            this.workbook = WorkbookFactory.create(fis);\n            this.evaluator = this.workbook.getCreationHelper().createFormulaEvaluator();\n            this.formatter = new DataFormatter(true);\n        }\n    }
1456	public int getNumberOfLevels(){\n        return numLevels == null ? 0 : numLevels;\n    }
1457	public static void putUShort( byte[] data, int offset, int value )\n    {\n        int i = offset;\n        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );\n    }
1458	public void multiLevelBulletedListInCell(HSSFWorkbook workbook,\n                                             ArrayList<MultiLevelListItem> multiLevelListItems,\n                                             HSSFCell cell) {\n        StringBuilder buffer = new StringBuilder();\n        // Note that again, an HSSFCellStye object is required and that\n        // it's wrap text property should be set to 'true'\n        HSSFCellStyle wrapStyle = workbook.createCellStyle();\n        wrapStyle.setWrapText(true);\n        // Step through the ArrayList of MultilLevelListItem instances.\n        for(MultiLevelListItem multiLevelListItem : multiLevelListItems) {\n            // For each element in the ArrayList, get the text for the high\n            // level list item......\n            buffer.append(InCellLists.BULLET_CHARACTER);\n            buffer.append(" ");\n            buffer.append(multiLevelListItem.getItemText());\n            buffer.append("\n");\n            // and then an ArrayList whose elements encapsulate the text\n            // for the lower level list items.\n            ArrayList<String> lowerLevelItems = multiLevelListItem.getLowerLevelItems();\n            if(!(lowerLevelItems == null) && !(lowerLevelItems.isEmpty())) {\n                for(String item : lowerLevelItems) {\n                    buffer.append(InCellLists.TAB);\n                    buffer.append(InCellLists.BULLET_CHARACTER);\n                    buffer.append(" ");\n                    buffer.append(item);\n                    buffer.append("\n");\n                }\n            }\n        }\n        // The StringBuffer's contents are the source for the contents\n        // of the cell.\n        cell.setCellValue(new HSSFRichTextString(buffer.toString().trim()));\n        cell.setCellStyle(wrapStyle);\n    }
1459	protected void read(POIXMLFactory factory, Map<PackagePart, POIXMLDocumentPart> context) throws OpenXML4JException {\n        PackagePart pp = getPackagePart();\n        // add mapping a second time, in case of initial caller hasn't done so\n        POIXMLDocumentPart otherChild = context.put(pp, this);\n        if (otherChild != null && otherChild != this) {\n            throw new POIXMLException("Unique PackagePart-POIXMLDocumentPart relation broken!");\n        }\n\n        if (!pp.hasRelationships()) return;\n\n        PackageRelationshipCollection rels = packagePart.getRelationships();\n        List<POIXMLDocumentPart> readLater = new ArrayList<>();\n\n        // scan breadth-first, so parent-relations are hopefully the shallowest element\n        for (PackageRelationship rel : rels) {\n            if (rel.getTargetMode() == TargetMode.INTERNAL) {\n                URI uri = rel.getTargetURI();\n\n                // check for internal references (e.g. '#Sheet1!A1')\n                PackagePartName relName;\n                if (uri.getRawFragment() != null) {\n                    relName = PackagingURIHelper.createPartName(uri.getPath());\n                } else {\n                    relName = PackagingURIHelper.createPartName(uri);\n                }\n\n                final PackagePart p = packagePart.getPackage().getPart(relName);\n                if (p == null) {\n                    logger.log(POILogger.ERROR, "Skipped invalid entry " + rel.getTargetURI());\n                    continue;\n                }\n\n                POIXMLDocumentPart childPart = context.get(p);\n                if (childPart == null) {\n                    childPart = factory.createDocumentPart(this, p);\n                    //here we are checking if part if embedded and excel then set it to chart class\n                    //so that at the time to writing we can also write updated embedded part\n                    if (this instanceof XDDFChart && childPart instanceof XSSFWorkbook) {\n                        ((XDDFChart) this).setWorkbook((XSSFWorkbook) childPart);\n                    }\n                    childPart.parent = this;\n                    // already add child to context, so other children can reference it\n                    context.put(p, childPart);\n                    readLater.add(childPart);\n                }\n\n                addRelation(rel, childPart);\n            }\n        }\n\n        for (POIXMLDocumentPart childPart : readLater) {\n            childPart.read(factory, context);\n        }\n    }
1460	public boolean isUnknown()\n    {\n        return unknown.isSet(field_4_format);\n    }
1461	public void setWordWrap(boolean wrap) {\n        CTTextBodyProperties bodyPr = ctShape.getTxBody().getBodyPr();\n        if (bodyPr != null) {\n            bodyPr.setWrap(wrap ? STTextWrappingType.SQUARE : STTextWrappingType.NONE);\n        }\n    }
1462	public void setFormulaValue(String cellName, String formula) {\n        Cell cell = getCell(cellName);\n        cell.setCellFormula(formula);\n    }
1463	default InputStream readObjectData() throws IOException {\n        final String progId = getProgId();\n        if (progId == null) {\n            throw new IllegalStateException(\n                "Ole object hasn't been initialized or provided in the source xml. " +\n                "use updateObjectData() first or check the corresponding slideXXX.xml");\n        }\n\n        final Application app = Application.lookup(progId);\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream(50000);\n        try (final InputStream is = FileMagic.prepareToCheckMagic(readObjectDataRaw())) {\n            final FileMagic fm = FileMagic.valueOf(is);\n            if (fm == FileMagic.OLE2) {\n                try (final POIFSFileSystem poifs = new POIFSFileSystem(is)) {\n                    String[] names = {\n                        (app == null) ? null : app.getMetaData().getOleEntry(),\n                        // fallback to the usual suspects\n                        "Package",\n                        "Contents",\n                        "CONTENTS",\n                        "CONTENTSV30",\n                    };\n                    final DirectoryNode root = poifs.getRoot();\n                    String entryName = null;\n                    for (String n : names) {\n                        if (root.hasEntry(n)) {\n                            entryName = n;\n                            break;\n                        }\n                    }\n                    if (entryName == null) {\n                        poifs.writeFilesystem(bos);\n                    } else {\n                        try (final InputStream is2 = poifs.createDocumentInputStream(entryName)) {\n                            IOUtils.copy(is2, bos);\n                        }\n                    }\n                }\n            } else {\n                IOUtils.copy(is, bos);\n            }\n        }\n\n        return new ByteArrayInputStream(bos.toByteArray());\n    }
1464	static OldFfn build(byte[] buf, int offset, int fontTableEnd) {\n        int start = offset;\n        //preliminary bytes\n        if (offset + 6 > fontTableEnd) {\n            return null;\n        }\n        //first byte\n        short fontDescriptionLength = buf[offset];\n        offset += 1;\n        if (offset + fontDescriptionLength > fontTableEnd) {\n            logger.log(POILogger.WARN, "Asked to read beyond font table end. Skipping font");\n            return null;\n        }\n\n        //no idea what these 3 bytes do\n        offset += 3;\n        byte chs = buf[offset];\n        Charset charset = null;\n        FontCharset wmfCharset = FontCharset.valueOf(chs & 0xff);\n        if (wmfCharset == null) {\n            logger.log(POILogger.WARN, "Couldn't find font for type: " + (chs & 0xff));\n        } else {\n            charset = wmfCharset.getCharset();\n        }\n        charset = charset == null ? StringUtil.WIN_1252 : charset;\n        offset += LittleEndian.BYTE_SIZE;\n        //if this byte here == 7, it _may_ signify existence of\n        //an altername font name\n\n        //not sure what the byte after the _chs does\n        offset += LittleEndian.BYTE_SIZE;\n        int fontNameLength = -1;\n        for (int i = offset; i < fontTableEnd; i++) {\n            if (buf[i] == 0) {\n                fontNameLength = i - offset;\n                break;\n            }\n        }\n        if (fontNameLength == -1) {\n            logger.log(POILogger.WARN, "Couldn't find the zero-byte delimited font name length");\n            return null;\n        }\n        String fontName = new String(buf, offset, fontNameLength, charset);\n        String altFontName = null;\n        int altFontNameLength = -1;\n        offset += fontNameLength + 1;\n        if (offset - start < fontDescriptionLength) {\n            for (int i = offset; i <= start + fontDescriptionLength; i++) {\n                if (buf[i] == 0) {\n                    altFontNameLength = i - offset;\n                    break;\n                }\n            }\n            if (altFontNameLength > -1) {\n                altFontName = new String(buf, offset, altFontNameLength, charset);\n            }\n        }\n        //reset to 0 for length calculation\n        altFontNameLength = (altFontNameLength < 0) ? 0 : altFontNameLength + 1;//add one for zero byte\n\n        int len = LittleEndian.INT_SIZE + LittleEndian.BYTE_SIZE + LittleEndian.BYTE_SIZE +//6 starting bytes\n                fontNameLength + altFontNameLength + 1;//+1 is for the zero byte\n        //this len should == fontDescriptionLength\n\n        return new OldFfn(chs, fontName, altFontName, len);\n\n    }
1465	public static URI getZipURIFromOPCName(String opcItemName) {\n        if (opcItemName == null) {\n            throw new IllegalArgumentException("opcItemName");\n        }\n\n        String retVal = opcItemName;\n        while (retVal.startsWith(FORWARD_SLASH)) {\n            retVal = retVal.substring(1);\n        }\n        try {\n            return new URI(retVal);\n        } catch (URISyntaxException e) {\n            return null;\n        }\n    }
1466	@Internal\n    public boolean isFStartAt()\n    {\n        return fStartAt.isSet(field_2_flags);\n    }
1467	public void dumpPictures(byte[] data, int padding) throws IOException {\n        int pos = 0;\n        while (pos < data.length) {\n            byte[] header = new byte[PICT_HEADER_SIZE];\n\n            System.arraycopy(data, pos, header, 0, header.length);\n            int size = LittleEndian.getInt(header, 4) - 17;\n            byte[] pictdata = IOUtils.safelyAllocate(size, MAX_RECORD_LENGTH);\n            System.arraycopy(data, pos + PICT_HEADER_SIZE, pictdata, 0, pictdata.length);\n            pos += PICT_HEADER_SIZE + size;\n\n            padding++;\n            write(out, "<picture size=\""+size+"\" type=\""+getPictureType(header)+"\">" + CR, padding);\n            padding++;\n            write(out, "<header>" + CR, padding);\n            dump(out, header, 0, header.length, padding, true);\n            write(out, "</header>" + CR, padding);\n            write(out, "<imgdata>" + CR, padding);\n            dump(out, pictdata, 0, Math.min(pictdata.length, 100), padding, true);\n            write(out, "</imgdata>" + CR, padding);\n            padding--;\n            write(out, "</picture>" + CR, padding);\n            padding--;\n\n        }\n    }
1468	public static AreaReference[] generateContiguous(SpreadsheetVersion version, String reference) {\n        if (null == version) {\n            version = DEFAULT_SPREADSHEET_VERSION; // how the code used to behave. \n        }\n        List<AreaReference> refs = new ArrayList<>();\n        StringTokenizer st = new StringTokenizer(reference, ",");\n        while(st.hasMoreTokens()) {\n            refs.add(\n                    new AreaReference(st.nextToken(), version)\n            );\n        }\n        return refs.toArray(new AreaReference[refs.size()]);\n    }
1469	public XSSFFontFormatting createFontFormatting(){\n        CTDxf dxf = getDxf(true);\n        CTFont font;\n        if(!dxf.isSetFont()) {\n            font = dxf.addNewFont();\n        } else {\n            font = dxf.getFont();\n        }\n\n        return new XSSFFontFormatting(font, _sh.getWorkbook().getStylesSource().getIndexedColors());\n    }
1470	public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount, boolean iteratorFirst) {\n        // If no password was given, use the default\n        if (password == null) {\n            password = Decryptor.DEFAULT_PASSWORD;\n        }\n        \n        MessageDigest hashAlg = getMessageDigest(hashAlgorithm);\n        \n        hashAlg.update(salt);\n        byte[] hash = hashAlg.digest(StringUtil.getToUnicodeLE(password));\n        byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];\n\n        byte[] first = (iteratorFirst ? iterator : hash);\n        byte[] second = (iteratorFirst ? hash : iterator);\n        \n        try {\n            for (int i = 0; i < spinCount; i++) {\n                LittleEndian.putInt(iterator, 0, i);\n                hashAlg.reset();\n                hashAlg.update(first);\n                hashAlg.update(second);\n                hashAlg.digest(hash, 0, hash.length); // don't create hash buffer everytime new\n            }\n        } catch (DigestException e) {\n            throw new EncryptedDocumentException("error in password hashing");\n        }\n        \n        return hash;\n    }
1471	public int getNoteCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_NOTECOUNT);\n    }
1472	public void setUpdateConfigOnValidate(boolean updateConfigOnValidate) {\n        this.updateConfigOnValidate = updateConfigOnValidate;\n    }
1473	public short getFirstColumn() {\n		return field_2_first_col;\n	}
1474	public boolean isFLocked()\n    {\n        return fLocked.isSet( field_2_flt );\n\n    }
1475	@SuppressWarnings("unused")\n    public void setFontAlign(FontAlign align){\n        CTTextParagraphProperties pr = _p.isSetPPr() ? _p.getPPr() : _p.addNewPPr();\n        if(align == null) {\n            if(pr.isSetFontAlgn()) pr.unsetFontAlgn();\n        } else {\n            pr.setFontAlgn(STTextFontAlignType.Enum.forInt(align.ordinal() + 1));\n        }\n    }
1476	protected void afterProcess()\n    {\n        // by default no such actions needed\n    }
1477	public void extractMessageBody(OutputStream out) throws IOException {\n        MAPIRtfAttribute body = (MAPIRtfAttribute)\n                message.getMessageMAPIAttribute(MAPIProperty.RTF_COMPRESSED);\n        if (body != null) {\n            out.write(body.getData());\n        }\n    }
1478	public PackageRelationship getRelationship(int index) {\n        if (index < 0 || index > relationshipsByID.values().size())\n            throw new IllegalArgumentException("index");\n\n        int i = 0;\n        for (PackageRelationship rel : relationshipsByID.values()) {\n            if (index == i++)\n                return rel;\n        }\n\n        return null;\n    }
1479	private void paintDashedBorders(Graphics g, int x, int y, int width,\n                                  int height) {\n      if (northBorder &&\n             ((northBorderType == BorderStyle.DASHED) ||\n              (northBorderType == BorderStyle.HAIR))\n         ) {\n        int thickness = getThickness(northBorderType);\n\n        int dashlength = 1;\n\n        if (northBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(northColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+5) {\n             g.drawLine(xc,y+k,xc+dashlength,y+k);\n           }\n        }\n      }\n\n      if (eastBorder &&\n              ((eastBorderType == BorderStyle.DASHED) ||\n               (eastBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(eastBorderType);\n        thickness++; //need for dotted borders to show up east\n\n\n        int dashlength = 1;\n\n        if (eastBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(eastColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+5) {\n                g.drawLine(width-k,yc,width-k,yc+dashlength);\n           }\n        }\n      }\n\n      if (southBorder &&\n              ((southBorderType == BorderStyle.DASHED) ||\n               (southBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(southBorderType);\n        thickness++;\n\n        int dashlength = 1;\n\n        if (southBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(southColor);\n        for (int k=0; k < thickness; k++) {\n           for (int xc = x; xc < width; xc=xc+5) {\n             g.drawLine(xc,height-k,xc+dashlength,height-k);\n           }\n        }\n      }\n\n      if (westBorder &&\n            ((westBorderType == BorderStyle.DASHED) ||\n             (westBorderType == BorderStyle.HAIR))\n         ) {\n\n        int thickness = getThickness(westBorderType);\n//        thickness++;\n\n        int dashlength = 1;\n\n        if (westBorderType == BorderStyle.DASHED)\n           dashlength = 2;\n\n      	g.setColor(westColor);\n\n        for (int k=0; k < thickness; k++) {\n           for (int yc=y;yc < height; yc=yc+5) {\n                g.drawLine(x+k,yc,x+k,yc+dashlength);\n           }\n        }\n      }\n   }
1480	@Internal\n    public boolean getFMinHeight()\n    {\n        return field_27_fMinHeight;\n    }
1481	protected void removeAllCells() {\n        for (HSSFCell cell : cells) {\n            if (cell != null) {\n                removeCell(cell, true);\n            }\n        }\n        cells=new HSSFCell[INITIAL_CAPACITY];\n    }
1482	private static FillPatternType getFillPattern(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        FillPatternType pattern;\n        if (value instanceof FillPatternType) {\n            pattern = (FillPatternType) value;\n        }\n        // @deprecated 3.15 beta 2. getFillPattern will only work on FillPatternType enums instead of codes in the future.\n        else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map uses Short values for "\n                        + name + ". Should use FillPatternType enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            pattern = FillPatternType.forInt(code);\n        }\n        else if (value == null) {\n            pattern = FillPatternType.NO_FILL;\n        }\n        else {\n            throw new RuntimeException("Unexpected fill pattern style class. Must be FillPatternType or Short (deprecated).");\n        }\n        return pattern;\n    }
1483	public XWPFTableCell addNewTableCell() {\n        CTTc cell = ctRow.addNewTc();\n        XWPFTableCell tableCell = new XWPFTableCell(cell, this, table.getBody());\n        tableCells.add(tableCell);\n        return tableCell;\n    }
1484	private int convertToExternalSheetIndex(int sheetIndex) {\n        return sheetIndex;\n    }
1485	public CellFormatResult apply(JLabel label, Cell c) {\n        switch (ultimateType(c)) {\n            case BLANK:\n                return apply(label, "");\n            case BOOLEAN:\n                return apply(label, c.getBooleanCellValue());\n            case NUMERIC:\n                Double value = c.getNumericCellValue();\n                if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                    if (DateUtil.isValidExcelDate(value)) {\n                        return apply(label, c.getDateCellValue(), value);\n                    } else {\n                        return apply(label, INVALID_VALUE_FOR_FORMAT);\n                    }\n                } else {\n                    return apply(label, value);\n                }\n            case STRING:\n                return apply(label, c.getStringCellValue());\n            default:\n                return apply(label, "?");\n            }\n    }
1486	protected int getEnd(int index)\n    {\n        return LittleEndian.getInt(_fkp, _offset + ((index + 1) * 4));\n    }
1487	public static String getZipItemNameFromOPCName(String opcItemName) {\n        if (opcItemName == null) {\n            throw new IllegalArgumentException("opcItemName cannot be null");\n        }\n\n        String retVal = opcItemName;\n        while (retVal.startsWith(FORWARD_SLASH)) {\n            retVal = retVal.substring(1);\n        }\n        return retVal;\n    }
1488	public BigInteger addNum(BigInteger abstractNumID) {\n        CTNum ctNum = this.ctNumbering.addNewNum();\n        ctNum.addNewAbstractNumId();\n        ctNum.getAbstractNumId().setVal(abstractNumID);\n        ctNum.setNumId(BigInteger.valueOf(nums.size() + 1));\n        XWPFNum num = new XWPFNum(ctNum, this);\n        nums.add(num);\n        return ctNum.getNumId();\n    }
1489	public void setValue(byte value) {\n		setValue(FormulaError.forInt(value));\n	}
1490	public void traverse(CellHandler handler) {\n        int firstRow = range.getFirstRow();\n        int lastRow = range.getLastRow();\n        int firstColumn = range.getFirstColumn();\n        int lastColumn = range.getLastColumn();\n        final int width = lastColumn - firstColumn + 1;\n        SimpleCellWalkContext ctx = new SimpleCellWalkContext();\n        Row currentRow = null;\n        Cell currentCell = null;\n\n        for (ctx.rowNumber = firstRow; ctx.rowNumber <= lastRow; ++ctx.rowNumber) {\n            currentRow = sheet.getRow(ctx.rowNumber);\n            if (currentRow == null) {\n                continue;\n            }\n            for (ctx.colNumber = firstColumn; ctx.colNumber <= lastColumn; ++ctx.colNumber) {\n                currentCell = currentRow.getCell(ctx.colNumber);\n\n                if (currentCell == null) {\n                    continue;\n                }\n                if (isEmpty(currentCell) && !traverseEmptyCells) {\n                    continue;\n                }\n\n                ctx.ordinalNumber =\n                        (ctx.rowNumber - firstRow) * width +\n                                (ctx.colNumber - firstColumn + 1);\n\n                handler.onCell(currentCell, ctx);\n            }\n        }\n    }
1491	private void syncWithDataSource() throws IOException {\n        // Mini Stream + SBATs first, as mini-stream details have\n        //  to be stored in the Root Property\n        _mini_store.syncWithDataSource();\n        \n        // Properties\n        POIFSStream propStream = new POIFSStream(this, _header.getPropertyStart());\n        _property_table.preWrite();\n        _property_table.write(propStream);\n        // _header.setPropertyStart has been updated on write ...\n        \n        // HeaderBlock\n        ByteArrayOutputStream baos = new ByteArrayOutputStream(\n                _header.getBigBlockSize().getBigBlockSize()\n        );\n        _header.writeData(baos);\n        getBlockAt(-1).put(baos.toByteArray());\n\n       \n       // BATs\n       for(BATBlock bat : _bat_blocks) {\n          ByteBuffer block = getBlockAt(bat.getOurBlockIndex());\n          bat.writeData(block);\n       }\n       // XBats\n       for(BATBlock bat : _xbat_blocks) {\n           ByteBuffer block = getBlockAt(bat.getOurBlockIndex());\n           bat.writeData(block);\n        }\n    }
1492	protected static short readInstance( byte data[], int offset ) {\n        final short options = LittleEndian.getShort( data, offset );\n        return fInstance.getShortValue( options );\n    }
1493	public static void handleParentAwareRecords(RecordContainer br) {\n        // Loop over child records, looking for interesting ones\n        for (Record record : br.getChildRecords()) {\n            // Tell parent aware records of their parent\n            if (record instanceof ParentAwareRecord) {\n                ((ParentAwareRecord) record).setParentRecord(br);\n            }\n            // Walk on down for the case of container records\n            if (record instanceof RecordContainer) {\n                handleParentAwareRecords((RecordContainer)record);\n            }\n        }\n    }
1494	public void postSign(Document document) throws MarshalException {\n        // empty\n    }
1495	public HSSFBorderFormatting createBorderFormatting() {\n        return getBorderFormatting(true);\n    }
1496	public void trackAllColumns() {\n        trackAllColumns = true;\n        untrackedColumns.clear();\n    }
1497	public void addTailRecord(NoteRecord note) {\n        tailRec.put(note.getShapeId(), note);\n    }
1498	private CTTwoCellAnchor createTwoCellAnchor(XSSFClientAnchor anchor) {\n        CTTwoCellAnchor ctAnchor = drawing.addNewTwoCellAnchor();\n        ctAnchor.setFrom(anchor.getFrom());\n        ctAnchor.setTo(anchor.getTo());\n        ctAnchor.addNewClientData();\n        anchor.setTo(ctAnchor.getTo());\n        anchor.setFrom(ctAnchor.getFrom());\n        STEditAs.Enum aditAs;\n        switch(anchor.getAnchorType()) {\n            case DONT_MOVE_AND_RESIZE: aditAs = STEditAs.ABSOLUTE; break;\n            case MOVE_AND_RESIZE: aditAs = STEditAs.TWO_CELL; break;\n            case MOVE_DONT_RESIZE: aditAs = STEditAs.ONE_CELL; break;\n            default: aditAs = STEditAs.ONE_CELL;\n        }\n        ctAnchor.setEditAs(aditAs);\n        return ctAnchor;\n    }
1499	public int addOlePackage(POIFSFileSystem poiData, String label, String fileName, String command)\n    throws IOException {\n    	DirectoryNode root = poiData.getRoot();\n    	Map<String,ClassID> olemap = getOleMap();\n    	for (Map.Entry<String,ClassID> entry : olemap.entrySet()) {\n    		if (root.hasEntry(entry.getKey())) {\n    			root.setStorageClsid(entry.getValue());\n    			break;\n    		}\n    	}\n\n    	ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    	poiData.writeFilesystem(bos);\n        return addOlePackage(bos.toByteArray(), label, fileName, command);\n    }
1500	public static void buildAxDataSource(CTAxDataSource ctAxDataSource, ChartDataSource<?> dataSource) {\n        if (dataSource.isNumeric()) {\n            if (dataSource.isReference()) {\n                buildNumRef(ctAxDataSource.addNewNumRef(), dataSource);\n            } else {\n                buildNumLit(ctAxDataSource.addNewNumLit(), dataSource);\n            }\n        } else {\n            if (dataSource.isReference()) {\n                buildStrRef(ctAxDataSource.addNewStrRef(), dataSource);\n            } else {\n                buildStrLit(ctAxDataSource.addNewStrLit(), dataSource);\n            }\n        }\n    }
1501	public void setRepeatHeader(boolean repeat) {\n        CTTrPr trpr = getTrPr();\n        CTOnOff onoff = (trpr.sizeOfTblHeaderArray() > 0 ? trpr.getTblHeaderArray(0) : trpr.addNewTblHeader());\n        onoff.setVal(WMLHelper.convertBooleanToSTOnOff(repeat));\n    }
1502	public static void putShort( byte[] data, int offset, short value )\n    {\n        int i = offset;\n        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );\n    }
1503	public SummaryInformation getSummaryInformation() {\n       throw new IllegalStateException("Metadata extraction not supported in streaming mode, please use ExcelExtractor");\n   }
1504	public static CellRangeAddress valueOf(String ref) {\n        int sep = ref.indexOf(":");\n        CellReference a;\n        CellReference b;\n        if (sep == -1) {\n            a = new CellReference(ref);\n            b = a;\n        } else {\n            a = new CellReference(ref.substring(0, sep));\n            b = new CellReference(ref.substring(sep + 1));\n        }\n        return new CellRangeAddress(a.getRow(), b.getRow(), a.getCol(), b.getCol());\n    }
1505	public void setTopBorder(boolean f) {\n    	field_8_option_flags = topBorder.setBoolean(field_8_option_flags, f);\n    }
1506	@SuppressWarnings("resource")\n    protected PackageRelationship addPictureReference(int pictureIndex){\n        XSSFWorkbook wb = (XSSFWorkbook)getParent().getParent();\n        XSSFPictureData data = wb.getAllPictures().get(pictureIndex);\n        XSSFPictureData pic = new XSSFPictureData(data.getPackagePart());\n        RelationPart rp = addRelation(null, XSSFRelation.IMAGES, pic);\n        return rp.getRelationship();\n    }
1507	public int getFontIndex(FontRecord font) {\n        for(int i=0; i<=numfonts; i++) {\n            FontRecord thisFont =\n                ( FontRecord ) records.get((records.getFontpos() - (numfonts - 1)) + i);\n            if(thisFont == font) {\n                // There is no 4!\n                return (i > 3) ? i+1 : i;\n            }\n        }\n        throw new IllegalArgumentException("Could not find that font!");\n    }
1508	private void buildBaseTree() {\n        EscherContainerRecord dgContainer = new EscherContainerRecord();\n        EscherContainerRecord spgrContainer = new EscherContainerRecord();\n        EscherContainerRecord spContainer1 = new EscherContainerRecord();\n        EscherSpgrRecord spgr = new EscherSpgrRecord();\n        EscherSpRecord sp1 = new EscherSpRecord();\n        dgContainer.setRecordId(EscherContainerRecord.DG_CONTAINER);\n        dgContainer.setOptions((short) 0x000F);\n        EscherDgRecord dg = new EscherDgRecord();\n        dg.setRecordId(EscherDgRecord.RECORD_ID);\n        short dgId = 1;\n        dg.setOptions((short) (dgId << 4));\n        dg.setNumShapes(0);\n        dg.setLastMSOSPID(1024);\n        spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);\n        spgrContainer.setOptions((short) 0x000F);\n        spContainer1.setRecordId(EscherContainerRecord.SP_CONTAINER);\n        spContainer1.setOptions((short) 0x000F);\n        spgr.setRecordId(EscherSpgrRecord.RECORD_ID);\n        spgr.setOptions((short) 0x0001);    // version\n        spgr.setRectX1(0);\n        spgr.setRectY1(0);\n        spgr.setRectX2(1023);\n        spgr.setRectY2(255);\n        sp1.setRecordId(EscherSpRecord.RECORD_ID);\n\n        sp1.setOptions((short) 0x0002);\n        sp1.setVersion((short) 0x2);\n        sp1.setShapeId(-1);\n        sp1.setFlags(EscherSpRecord.FLAG_GROUP | EscherSpRecord.FLAG_PATRIARCH);\n        dgContainer.addChildRecord(dg);\n        dgContainer.addChildRecord(spgrContainer);\n        spgrContainer.addChildRecord(spContainer1);\n        spContainer1.addChildRecord(spgr);\n        spContainer1.addChildRecord(sp1);\n        addEscherRecord(dgContainer);\n    }
1509	public short getRotation()\n    {\n        return rotation.getShortValue(field_10_options);\n    }
1510	public ArrayList<PackagePart> getPartsByContentType(String contentType) {\n		ArrayList<PackagePart> retArr = new ArrayList<>();\n		for (PackagePart part : partList.sortedValues()) {\n			if (part.getContentType().equals(contentType)) {\n				retArr.add(part);\n			}\n		}\n		return retArr;\n	}
1511	protected int widthToPixels(final double widthUnits) {\n        return (int) (Math.round(widthUnits * 9 / 256));\n    }
1512	private int getSizeOfInitialSheetRecords(int bofRecordIndex) {\n\n        int result = 0;\n        // start just after BOF record (INDEX is not present in this list)\n        for (int j = bofRecordIndex + 1; j < _records.size(); j++) {\n            RecordBase tmpRec = _records.get(j);\n            if (tmpRec instanceof RowRecordsAggregate) {\n                break;\n            }\n            result += tmpRec.getRecordSize();\n        }\n        if (_isUncalced) {\n            result += UncalcedRecord.getStaticRecordSize();\n        }\n        return result;\n    }
1513	public static synchronized FontDetails getFontDetails(Font font) {\n		// If we haven't already identified out font metrics file,\n		// figure out which one to use and load it\n		if (fontMetricsProps == null) {\n		    try {\n		        fontMetricsProps = loadMetrics();\n		    } catch (IOException e) {\n		        throw new RuntimeException("Could not load font metrics", e);\n		    }\n		}\n\n		// Grab the base name of the font they've asked about\n		String fontName = font.getName();\n\n		// Some fonts support plain/bold/italic/bolditalic variants\n		// Others have different font instances for bold etc\n		// (eg font.dialog.plain.* vs font.Californian FB Bold.*)\n		String fontStyle = "";\n		if (font.isPlain()) {\n			fontStyle += "plain";\n		}\n		if (font.isBold()) {\n			fontStyle += "bold";\n		}\n		if (font.isItalic()) {\n			fontStyle += "italic";\n		}\n\n		// Do we have a definition for this font with just the name?\n		// If not, check with the font style added\n		String fontHeight = FontDetails.buildFontHeightProperty(fontName);\n		String styleHeight = FontDetails.buildFontHeightProperty(fontName + "." + fontStyle);\n		\n		if (fontMetricsProps.get(fontHeight) == null\n			&& fontMetricsProps.get(styleHeight) != null) {\n			// Need to add on the style to the font name\n			fontName += "." + fontStyle;\n		}\n\n		// Get the details on this font\n		FontDetails fontDetails = fontDetailsMap.get(fontName);\n		if (fontDetails == null) {\n			fontDetails = FontDetails.create(fontName, fontMetricsProps);\n			fontDetailsMap.put(fontName, fontDetails);\n		}\n        return fontDetails;\n	}
1514	public void clear() {\n        _slideLocations.clear();\n    }
1515	public String suggestFileExtension()\n    {\n        return suggestPictureType().getExtension();\n    }
1516	@Beta\n    private XSSFPivotTable createPivotTable() {\n        XSSFWorkbook wb = getWorkbook();\n        List<XSSFPivotTable> pivotTables = wb.getPivotTables();\n        int tableId = getWorkbook().getPivotTables().size()+1;\n        //Create relationship between pivotTable and the worksheet\n        XSSFPivotTable pivotTable = (XSSFPivotTable) createRelationship(XSSFRelation.PIVOT_TABLE,\n                XSSFFactory.getInstance(), tableId);\n        pivotTable.setParentSheet(this);\n        pivotTables.add(pivotTable);\n        XSSFWorkbook workbook = getWorkbook();\n\n        //Create relationship between the pivot cache defintion and the workbook\n        XSSFPivotCacheDefinition pivotCacheDefinition = (XSSFPivotCacheDefinition) workbook.\n                createRelationship(XSSFRelation.PIVOT_CACHE_DEFINITION, XSSFFactory.getInstance(), tableId);\n        String rId = workbook.getRelationId(pivotCacheDefinition);\n        //Create relationship between pivotTable and pivotCacheDefinition without creating a new instance\n        PackagePart pivotPackagePart = pivotTable.getPackagePart();\n        pivotPackagePart.addRelationship(pivotCacheDefinition.getPackagePart().getPartName(),\n                TargetMode.INTERNAL, XSSFRelation.PIVOT_CACHE_DEFINITION.getRelation());\n\n        pivotTable.setPivotCacheDefinition(pivotCacheDefinition);\n\n        //Create pivotCache and sets up it's relationship with the workbook\n        pivotTable.setPivotCache(new XSSFPivotCache(workbook.addPivotCache(rId)));\n\n        //Create relationship between pivotcacherecord and pivotcachedefinition\n        XSSFPivotCacheRecords pivotCacheRecords = (XSSFPivotCacheRecords) pivotCacheDefinition.\n                createRelationship(XSSFRelation.PIVOT_CACHE_RECORDS, XSSFFactory.getInstance(), tableId);\n\n        //Set relationships id for pivotCacheDefinition to pivotCacheRecords\n        pivotTable.getPivotCacheDefinition().getCTPivotCacheDefinition().setId(pivotCacheDefinition.getRelationId(pivotCacheRecords));\n\n        wb.setPivotTables(pivotTables);\n\n        return pivotTable;\n    }
1517	public PackageProperties getPackageProperties()\n			throws InvalidFormatException {\n		this.throwExceptionIfWriteOnly();\n		// If no properties part has been found then we create one\n		if (this.packageProperties == null) {\n			this.packageProperties = new PackagePropertiesPart(this,\n					PackagingURIHelper.CORE_PROPERTIES_PART_NAME);\n		}\n		return this.packageProperties;\n	}
1518	private int findLastRow(int lastrow) {\n        if (lastrow < 1) {\n            return 0;\n        }\n        int rownum = lastrow - 1;\n        HSSFRow r = getRow(rownum);\n\n        while (r == null && rownum > 0) {\n            r = getRow(--rownum);\n        }\n        if (r == null) {\n            return 0;\n        }\n        return rownum;\n    }
1519	private static boolean canPaddingBeDiscarded(byte[] data, int nRemainingBytes) {\n        // make sure none of the padding looks important\n		for(int i=data.length-nRemainingBytes; i<data.length; i++) {\n			if (data[i] != 0x00) {\n				return false;\n			}\n		}\n		return true;\n	}
1520	default boolean hasDirectoryEntry() {\n        try (final InputStream is = FileMagic.prepareToCheckMagic(getInputStream())) {\n            FileMagic fm = FileMagic.valueOf(is);\n            return fm == FileMagic.OLE2;\n        } catch (IOException e) {\n            POILogger LOG = POILogFactory.getLogger(ObjectData.class);\n            LOG.log(POILogger.WARN, "Can't determine filemagic of ole stream", e);\n            return false;\n        }\n    }
1521	private PackagePart getWorksheetPart() throws InvalidFormatException {\n        for (RelationPart part : getRelationParts()) {\n            if (POIXMLDocument.PACK_OBJECT_REL_TYPE.equals(part.getRelationship().getRelationshipType())) {\n                return getTargetPart(part.getRelationship());\n            }\n        }\n        return null;\n    }
1522	@Internal\n    public byte getIWarichuBracket()\n    {\n        return ( byte )iWarichuBracket.getValue(field_30_copt);\n    }
1523	static String expandChar(String part) {\n        List<String> codePoints = new ArrayList<>();\n        new StringCodepointsIterable(part).iterator().forEachRemaining(codePoints::add);\n        if (codePoints.size() < 2) throw new IllegalArgumentException("Expected part string to have at least 2 chars");\n        String ch = codePoints.get(1);\n        return ch + ch + ch;\n    }
1524	public int getRowCellBlockSize(int startRow, int endRow) {\n		int result = 0;\n		for(int rowIx=startRow; rowIx<=endRow && rowIx<records.length; rowIx++) {\n			result += getRowSerializedSize(records[rowIx]);\n		}\n		return result;\n	}
1525	protected static int getSoundReference(HSLFShape shape){\n        int soundRef = -1;\n        //dive into the shape container and search for InteractiveInfoAtom\n        InteractiveInfoAtom info = shape.getClientDataRecord(RecordTypes.InteractiveInfo.typeID);\n        if (info != null && info.getAction() == InteractiveInfoAtom.ACTION_MEDIA) {\n            soundRef = info.getSoundRef();\n        }\n        return soundRef;\n    }
1526	public static byte[] toByteArray(InputStream stream) throws IOException {\n        return toByteArray(stream, Integer.MAX_VALUE);\n    }
1527	public void append(String text, XSSFFont font){\n        if(st.sizeOfRArray() == 0 && st.isSetT()) {\n            //convert <t>string</t> into a text run: <r><t>string</t></r>\n            CTRElt lt = st.addNewR();\n            lt.setT(st.getT());\n            preserveSpaces(lt.xgetT());\n            st.unsetT();\n        }\n        CTRElt lt = st.addNewR();\n        lt.setT(text);\n        preserveSpaces(lt.xgetT());\n        \n        if (font != null) {\n            CTRPrElt pr = lt.addNewRPr();\n            setRunAttributes(font.getCTFont(), pr);\n        }\n    }
1528	private void appendDefaultType(Element root, Entry<String, String> entry) {\n        Element defaultType = root.getOwnerDocument().createElementNS(TYPES_NAMESPACE_URI, DEFAULT_TAG_NAME);\n        defaultType.setAttribute(EXTENSION_ATTRIBUTE_NAME, entry.getKey());\n        defaultType.setAttribute(CONTENT_TYPE_ATTRIBUTE_NAME, entry.getValue());\n        root.appendChild(defaultType);\n    }
1529	public boolean styleExist(String styleID) {\n        for (XWPFStyle style : listStyle) {\n            if (style.getStyleId().equals(styleID))\n                return true;\n        }\n        return false;\n    }
1530	@Internal\n    public boolean isFWebHidden()\n    {\n        return fWebHidden.isSet(field_1_grpfChp);\n    }
1531	public static void main(final String args[]) {\n        if (args.length == 0) {\n            System.err.println("Must specify at least one file to view");\n            System.exit(1);\n        }\n        boolean printNames = (args.length > 1);\n\n        for (String arg : args) {\n            viewFile(arg, printNames);\n        }\n    }
1532	public static long calculateMaximumSize(final POIFSBigBlockSize bigBlockSize,\n          final int numBATs) {\n       // Header isn't FAT addressed\n       long size = 1;\n       \n       // The header has up to 109 BATs, and extra ones are referenced\n       //  from XBATs\n       // However, all BATs can contain 128/1024 blocks\n       size += (((long)numBATs) * bigBlockSize.getBATEntriesPerBlock());\n       \n       // So far we've been in sector counts, turn into bytes\n       return size * bigBlockSize.getBigBlockSize();\n    }
1533	public void applyTransform(Graphics2D graphics) {\n    }
1534	public void lockWindows() {\n        safeGetWorkbookProtection().setLockWindows(true);\n    }
1535	public CellFormatResult apply(JLabel label, Object value) {\n        CellFormatResult result = apply(value);\n        label.setText(result.text);\n        if (result.textColor != null) {\n            label.setForeground(result.textColor);\n        }\n        return result;\n    }
1536	public void addCarriageReturn() {\n        run.addNewCr();\n    }
1537	private static int getColumnForString(AreaEval db,String name)\n            throws EvaluationException {\n        int resultColumn = -1;\n        final int width = db.getWidth();\n        for(int column = 0; column < width; ++column) {\n            ValueEval columnNameValueEval = resolveReference(db, 0, column);\n            if(columnNameValueEval instanceof BlankEval) {\n                continue;\n            }\n            if(columnNameValueEval instanceof ErrorEval) {\n                continue;\n            }\n            String columnName = OperandResolver.coerceValueToString(columnNameValueEval);\n            if(name.equals(columnName)) {\n                resultColumn = column;\n                break;\n            }\n        }\n        return resultColumn;\n    }
1538	protected OutputStream decorateOutputStream(FileOutputStream fos) throws IOException {\n        return fos;\n    }
1539	public boolean containsRow(int rowInd) {\n		return _firstRow <= rowInd && rowInd <= _lastRow;\n	}
1540	public boolean isFZombieEmbed()\n    {\n        return fZombieEmbed.isSet( field_2_flt );\n\n    }
1541	@Beta\n    public void addDataColumn(int columnIndex, boolean isDataField) {\n        checkColumnIndex(columnIndex);\n\n        CTPivotFields pivotFields = pivotTableDefinition.getPivotFields();\n        CTPivotField pivotField = CTPivotField.Factory.newInstance();\n\n        pivotField.setDataField(isDataField);\n        pivotField.setShowAll(false);\n        pivotFields.setPivotFieldArray(columnIndex, pivotField);\n    }
1542	public XWPFFooter createFooter(Enum type, XWPFParagraph[] pars) {\n        XWPFFooter footer = getFooter(type);\n\n        if (footer == null) {\n            FtrDocument ftrDoc = FtrDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.FOOTER;\n            int i = getRelationIndex(relation);\n\n            XWPFFooter wrapper = (XWPFFooter) doc.createRelationship(relation,\n                    XWPFFactory.getInstance(), i);\n            wrapper.setXWPFDocument(doc);\n\n            CTHdrFtr ftr = buildFtr(type, wrapper, pars);\n            wrapper.setHeaderFooter(ftr);\n            ftrDoc.setFtr(ftr);\n            assignFooter(wrapper, type);\n            footer = wrapper;\n        }\n\n        return footer;\n    }
1543	private void validateMergedRegions(CellRangeAddress candidateRegion) {\n        for (final CellRangeAddress existingRegion : getMergedRegions()) {\n            if (existingRegion.intersects(candidateRegion)) {\n                throw new IllegalStateException("Cannot add merged region " + candidateRegion.formatAsString() +\n                        " to sheet because it overlaps with an existing merged region (" + existingRegion.formatAsString() + ").");\n            }\n        }\n    }
1544	public void setCantSplitRow(boolean split) {\n        CTTrPr trpr = getTrPr();\n        CTOnOff onoff = (trpr.sizeOfCantSplitArray() > 0 ? trpr.getCantSplitArray(0) : trpr.addNewCantSplit());\n        onoff.setVal(WMLHelper.convertBooleanToSTOnOff(split));\n    }
1545	private void updateRawContents() throws IOException {\n        if (initialised) {\n            // Only update the style bytes, if the styles have been potentially\n            // changed\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    \n            // First up, we need to serialise the paragraph properties\n            for(TextPropCollection tpc : paragraphStyles) {\n                tpc.writeOut(baos);\n            }\n    \n            // Now, we do the character ones\n            for(TextPropCollection tpc : charStyles) {\n                tpc.writeOut(baos);\n            }\n    \n            rawContents = baos.toByteArray();\n        }\n        \n        // Now ensure that the header size is correct\n        int newSize = rawContents.length + reserved.length;\n        LittleEndian.putInt(_header,4,newSize);\n    }
1546	public int numParagraphs() {\n		initParagraphs();\n		return _parEnd - _parStart;\n	}
1547	public int adjustForInsert(int listIndex, int length) {\n        int size = _textPieces.size();\n\n        TextPiece tp = _textPieces.get(listIndex);\n\n        // Update with the new end\n        tp.setEnd(tp.getEnd() + length);\n\n        // Now change all subsequent ones\n        for (int x = listIndex + 1; x < size; x++) {\n            tp = _textPieces.get(x);\n            tp.setStart(tp.getStart() + length);\n            tp.setEnd(tp.getEnd() + length);\n        }\n\n        // All done\n        return length;\n    }
1548	public List<byte[]> getOCSPs() {\n        return this.ocsps;\n    }
1549	void resetFontCache() {\n        fonts = new HashMap<>();\n    }
1550	public Record findFirstOfType(long type) {\n		for (Record r : _children) {\n			if (r.getRecordType() == type) {\n				return r;\n			}\n		}\n		return null;\n	}
1551	@Internal\n    public boolean isFConverted()\n    {\n        return fConverted.isSet(field_3_info);\n    }
1552	private static byte[] toAnsiPassword(String password) {\n        // TODO: charset conversion (see ecma spec) \n        \n        // Get the single-byte values by iterating through the Unicode characters.\n        // For each character, if the low byte is not equal to 0, take it.\n        // Otherwise, take the high byte.\n        byte[] arrByteChars = new byte[password.length()];\n        \n        for (int i = 0; i < password.length(); i++) {\n            int intTemp = password.charAt(i);\n            byte lowByte = (byte)(intTemp & 0xFF);\n            byte highByte = (byte)((intTemp >>> 8) & 0xFF);\n            arrByteChars[i] = (lowByte != 0 ? lowByte : highByte);\n        }\n\n        return arrByteChars;\n    }
1553	public Document getDocumentRecord() {\n		return _documentRecord;\n	}
1554	@Internal\n    public boolean isFLocked()\n    {\n        return fLocked.isSet(field_5_grfstd);\n    }
1555	public int aggregateDrawingRecords(DrawingManager2 drawingManager, boolean createIfMissing) {\n        int loc = findFirstRecordLocBySid(DrawingRecord.sid);\n        boolean noDrawingRecordsFound = (loc == -1);\n        if (noDrawingRecordsFound) {\n            if(!createIfMissing) {\n                // None found, and not allowed to add in\n                return -1;\n            }\n\n            EscherAggregate aggregate = new EscherAggregate(true);\n            loc = findFirstRecordLocBySid(EscherAggregate.sid);\n            if (loc == -1) {\n                loc = findFirstRecordLocBySid( WindowTwoRecord.sid );\n            } else {\n                getRecords().remove(loc);\n            }\n            getRecords().add( loc, aggregate );\n            return loc;\n        }\n        List<RecordBase> records = getRecords();\n\n        EscherAggregate.createAggregate(records, loc);\n\n        return loc;\n    }
1556	public void write(final OutputStream out) throws IOException, WritingNotSupportedException {\n\n        out.write(toBytes());\n\n        /* Indicate that we're done */\n        out.close();\n    }
1557	protected EscherContainerRecord createSpContainer(boolean isChild) {\n        if (_escherContainer == null) {\n            _escherContainer = new EscherContainerRecord();\n            _escherContainer.setOptions((short)15);\n        }\n        return _escherContainer;\n    }
1558	@Internal\n    public boolean isFInvalAutofit()\n    {\n        return fInvalAutofit.isSet(field_13_widthAndFitsFlags);\n    }
1559	protected int getStart(int index)\n    {\n        return LittleEndian.getInt(_fkp, _offset + (index * 4));\n    }
1560	private String dec1616( int n32 )\n    {\n        String result = "";\n        result += (short) ( n32 >> 16 );\n        result += '.';\n        result += (short) ( n32 & 0xFFFF );\n        return result;\n    }
1561	@Internal\n    public boolean isFSemiHidden()\n    {\n        return fSemiHidden.isSet(field_5_grfstd);\n    }
1562	public void removeShapeToObjRecord(EscherRecord rec) {\n        shapeToObj.remove(rec);\n    }
1563	protected static CTGroupShape prototype() {\n        if (prototype == null) {\n            CTGroupShape shape = CTGroupShape.Factory.newInstance();\n\n            CTGroupShapeNonVisual nv = shape.addNewNvGrpSpPr();\n            CTNonVisualDrawingProps nvpr = nv.addNewCNvPr();\n            nvpr.setId(0);\n            nvpr.setName("Group 0");\n            nv.addNewCNvGrpSpPr();\n            CTGroupShapeProperties sp = shape.addNewGrpSpPr();\n            CTGroupTransform2D t2d = sp.addNewXfrm();\n            CTPositiveSize2D p1 = t2d.addNewExt();\n            p1.setCx(0);\n            p1.setCy(0);\n            CTPoint2D p2 = t2d.addNewOff();\n            p2.setX(0);\n            p2.setY(0);\n            CTPositiveSize2D p3 = t2d.addNewChExt();\n            p3.setCx(0);\n            p3.setCy(0);\n            CTPoint2D p4 = t2d.addNewChOff();\n            p4.setX(0);\n            p4.setY(0);\n\n            prototype = shape;\n        }\n        return prototype;\n    }
1564	int getBlue(){\n        return getPercentageValue("blue");\n    }
1565	@Internal\n    public void reset() throws IOException {\n        ((InputStream)_dataInput).reset();\n        _currentDataOffset = _markedDataOffset;\n    }
1566	@Internal\n    public boolean isFMerged()\n    {\n        return fMerged.isSet(field_1_rgf);\n    }
1567	@Internal\n    public byte getPcVert()\n    {\n        return ( byte )pcVert.getValue(field_13_widthAndFitsFlags);\n    }
1568	public String readUnicodeLEString(int requestedLength) {\n		return readStringCommon(requestedLength, false);\n	}
1569	public StylesTable getStylesTable() throws IOException, InvalidFormatException {\n        ArrayList<PackagePart> parts = pkg.getPartsByContentType(XSSFRelation.STYLES.getContentType());\n        if (parts.size() == 0) return null;\n\n        // Create the Styles Table, and associate the Themes if present\n        StylesTable styles = new StylesTable(parts.get(0));\n        parts = pkg.getPartsByContentType(XSSFRelation.THEME.getContentType());\n        if (parts.size() != 0) {\n            styles.setTheme(new ThemesTable(parts.get(0)));\n        }\n        return styles;\n    }
1570	public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IOException {\n        // Look for certain entries in the stream, to figure it\n        // out from\n        for (String workbookName : WORKBOOK_DIR_ENTRY_NAMES) {\n            if (poifsDir.hasEntry(workbookName)) {\n                if (getPreferEventExtractor()) {\n                    return new EventBasedExcelExtractor(poifsDir);\n                }\n                return new ExcelExtractor(poifsDir);\n            }\n        }\n        if (poifsDir.hasEntry(OLD_WORKBOOK_DIR_ENTRY_NAME)) {\n            throw new OldExcelFormatException("Old Excel Spreadsheet format (1-95) "\n                    + "found. Please call OldExcelExtractor directly for basic text extraction");\n        }\n        \n        // Ask Scratchpad, or fail trying\n        Class<?> cls = getScratchpadClass();\n        try {\n            Method m = cls.getDeclaredMethod("createExtractor", DirectoryNode.class);\n            POITextExtractor ext = (POITextExtractor)m.invoke(null, poifsDir);\n            if (ext != null) return ext;\n        } catch (IllegalArgumentException iae) {\n            throw iae;\n        } catch (Exception e) {\n            throw new IllegalArgumentException("Error creating Scratchpad Extractor", e);\n        }\n\n        throw new IllegalArgumentException("No supported documents found in the OLE2 stream");\n    }
1571	private void collectValues(ValueEval operand, DoubleList temp) throws EvaluationException {\n        if (operand instanceof ThreeDEval) {\n            ThreeDEval ae = (ThreeDEval) operand;\n            for (int sIx=ae.getFirstSheetIndex(); sIx <= ae.getLastSheetIndex(); sIx++) {\n                int width = ae.getWidth();\n                int height = ae.getHeight();\n                for (int rrIx=0; rrIx<height; rrIx++) {\n                    for (int rcIx=0; rcIx<width; rcIx++) {\n                        ValueEval ve = ae.getValue(sIx, rrIx, rcIx);\n                        if(!isSubtotalCounted() && ae.isSubTotal(rrIx, rcIx)) continue;\n                        collectValue(ve, true, temp);\n                    }\n                }\n            }\n            return;\n        }\n		if (operand instanceof TwoDEval) {\n			TwoDEval ae = (TwoDEval) operand;\n			int width = ae.getWidth();\n			int height = ae.getHeight();\n			for (int rrIx=0; rrIx<height; rrIx++) {\n				for (int rcIx=0; rcIx<width; rcIx++) {\n					ValueEval ve = ae.getValue(rrIx, rcIx);\n                    if(!isSubtotalCounted() && ae.isSubTotal(rrIx, rcIx)) continue;\n                    collectValue(ve, true, temp);\n				}\n			}\n			return;\n		}\n		if (operand instanceof RefEval) {\n			RefEval re = (RefEval) operand;\n			for (int sIx = re.getFirstSheetIndex(); sIx <= re.getLastSheetIndex(); sIx++) {\n			    collectValue(re.getInnerValueEval(sIx), true, temp);\n			}\n			return;\n		}\n		collectValue(operand, false, temp);\n	}
1572	public void setSigningCertificateChain(\n            List<X509Certificate> signingCertificateChain) {\n        this.signingCertificateChain = signingCertificateChain;\n    }
1573	public boolean isDisplayAsPercentage()\n    {\n        return displayAsPercentage.isSet(field_3_formatFlags);\n    }
1574	public void setMaxNumberOfDataFormats(int num) {\n        if (num < getNumDataFormats()) {\n            if (num < 0) {\n                throw new IllegalArgumentException("Maximum Number of Data Formats must be greater than or equal to 0");\n            } else {\n                throw new IllegalStateException("Cannot set the maximum number of data formats less than the current quantity." +\n                        "Data formats must be explicitly removed (via StylesTable.removeNumberFormat) before the limit can be decreased.");\n            }\n        }\n        MAXIMUM_NUMBER_OF_DATA_FORMATS = num;\n    }
1575	public XSSFTableColumn createColumn(String columnName) {\n        return createColumn(columnName, getColumnCount());\n    }
1576	public void addOCSP(byte[] encodedOcsp) {\n        this.ocsps.add(encodedOcsp);\n    }
1577	public static CFRule12Record create(HSSFSheet sheet, ExtendedColor color) {\n        CFRule12Record r = new CFRule12Record(CONDITION_TYPE_DATA_BAR, \n                                              ComparisonOperator.NO_COMPARISON);\n        DataBarFormatting dbf = r.createDataBarFormatting();\n        dbf.setColor(color);\n        dbf.setPercentMin((byte)0);\n        dbf.setPercentMax((byte)100);\n        \n        DataBarThreshold min = new DataBarThreshold();\n        min.setType(RangeType.MIN.id);\n        dbf.setThresholdMin(min);\n        \n        DataBarThreshold max = new DataBarThreshold();\n        max.setType(RangeType.MAX.id);\n        dbf.setThresholdMax(max);\n        \n        return r;\n    }
1578	static void evaluateRules(Workbook wb, String sheetName) {\n        final WorkbookEvaluatorProvider wbEvalProv = (WorkbookEvaluatorProvider) wb.getCreationHelper().createFormulaEvaluator();\n        final ConditionalFormattingEvaluator cfEval = new ConditionalFormattingEvaluator(wb, wbEvalProv);\n        // if cell values have changed, clear cached format results\n        cfEval.clearAllCachedValues();\n        \n        final Sheet sheet = wb.getSheet(sheetName);\n        for (Row r : sheet) {\n            for (Cell c : r) {\n                final List<EvaluationConditionalFormatRule> rules = cfEval.getConditionalFormattingForCell(c);\n                // check rules list for null, although current implementation will return an empty list, not null, then do what you want with results\n                if (rules == null || rules.isEmpty()) continue;\n                final CellReference ref = ConditionalFormattingEvaluator.getRef(c);\n                if (rules.isEmpty()) continue;\n\n                System.out.println("\n"\n                  + ref.formatAsString()\n                  + " has conditional formatting.");\n\n                for (EvaluationConditionalFormatRule rule : rules) {\n                    ConditionalFormattingRule cf = rule.getRule();\n\n                    StringBuilder b = new StringBuilder();\n                    b.append("\tRule ")\n                     .append(rule.getFormattingIndex())\n                     .append(": ");\n                    \n                    // check for color scale\n                    if (cf.getColorScaleFormatting() != null) {\n                        b.append("\n\t\tcolor scale (caller must calculate bucket)");\n                    }\n                    // check for data bar\n                    if (cf.getDataBarFormatting() != null) {\n                        b.append("\n\t\tdata bar (caller must calculate bucket)");\n                    }\n                    // check for icon set\n                    if (cf.getMultiStateFormatting() != null) {\n                        b.append("\n\t\ticon set (caller must calculate icon bucket)");\n                    }\n                    // check for fill\n                    if (cf.getPatternFormatting() != null) {\n                        final PatternFormatting fill = cf.getPatternFormatting();\n                        b.append("\n\t\tfill pattern ")\n                         .append(fill.getFillPattern())\n                         .append(" color index ")\n                         .append(fill.getFillBackgroundColor());\n                    }\n                    // font stuff\n                    if (cf.getFontFormatting() != null) {\n                        final FontFormatting ff = cf.getFontFormatting();\n                        b.append("\n\t\tfont format ")\n                         .append("color index ")\n                         .append(ff.getFontColorIndex());\n                        if (ff.isBold()) b.append(" bold");\n                        if (ff.isItalic()) b.append(" italic");\n                        if (ff.isStruckout()) b.append(" strikeout");\n                        b.append(" underline index ")\n                         .append(ff.getUnderlineType());\n                    }\n                    \n                    System.out.println(b);\n                }\n            }\n        }\n    }
1579	private void isCellFontFamilyMatches(Locator loc1, Locator loc2) {\n        // TODO: Check for NPEs\n        if (!(loc1.cell instanceof XSSFCell)) return;\n        String family1 = ((XSSFCell)loc1.cell).getCellStyle().getFont().getFontName();\n        String family2 = ((XSSFCell)loc2.cell).getCellStyle().getFont().getFontName();\n        if (!family1.equals(family2)) {\n            addMessage(loc1, loc2, "Cell Font Family does not Match ::", family1, family2);\n        }\n    }
1580	public boolean isUserDateVisible(){\n        return isVisible(HeadersFootersAtom.fHasUserDate, Placeholder.DATETIME);\n    }
1581	public static CFRecordsAggregate createCFAggregate(RecordStream rs) {\n        Record rec = rs.getNext();\n        if (rec.getSid() != CFHeaderRecord.sid &&\n            rec.getSid() != CFHeader12Record.sid) {\n            throw new IllegalStateException("next record sid was " + rec.getSid() \n                    + " instead of " + CFHeaderRecord.sid + " or " +\n                    CFHeader12Record.sid + " as expected");\n        }\n\n        CFHeaderBase header = (CFHeaderBase)rec;\n        int nRules = header.getNumberOfConditionalFormats();\n\n        CFRuleBase[] rules = new CFRuleBase[nRules];\n        for (int i = 0; i < rules.length; i++) {\n            rules[i] = (CFRuleBase) rs.getNext();\n        }\n\n        return new CFRecordsAggregate(header, rules);\n    }
1582	public void confirmSignature() throws XMLSignatureException, MarshalException {\n        final Document document = DocumentHelper.createDocument();\n        final DOMSignContext xmlSignContext = createXMLSignContext(document);\n\n        // operate\n        final DOMSignedInfo signedInfo = preSign(xmlSignContext);\n\n        // setup: key material, signature value\n        final String signatureValue = signDigest(xmlSignContext, signedInfo);\n\n        // operate: postSign\n        postSign(xmlSignContext, signatureValue);\n    }
1583	public static void putLong( long value, OutputStream outputStream )\n            throws IOException\n    {\n        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 32 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 40 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 48 ) & 0xFF ) );\n        outputStream.write( (byte) ( ( value >>> 56 ) & 0xFF ) );\n    }
1584	protected boolean isValidNumericCell(Cell cell, DataValidationContext context) {\n            if ( ! isType(cell, CellType.NUMERIC)) return false;\n\n            Double value = Double.valueOf(cell.getNumericCellValue());\n            return isValidNumericValue(value, context);\n        }
1585	private int getBodyElementSpecificPos(int pos, List<? extends IBodyElement> list) {\n        // If there's nothing to find, skip it\n        if (list.size() == 0) {\n            return -1;\n        }\n\n        if (pos >= 0 && pos < bodyElements.size()) {\n            // Ensure the type is correct\n            IBodyElement needle = bodyElements.get(pos);\n            if (needle.getElementType() != list.get(0).getElementType()) {\n                // Wrong type\n                return -1;\n            }\n\n            // Work back until we find it\n            int startPos = Math.min(pos, list.size() - 1);\n            for (int i = startPos; i >= 0; i--) {\n                if (list.get(i) == needle) {\n                    return i;\n                }\n            }\n        }\n\n        // Couldn't be found\n        return -1;\n    }
1586	void registerListener(final POIFSReaderListener listener,\n                          final POIFSDocumentPath path,\n                          final String documentName)\n    {\n        if (!omnivorousListeners.contains(listener))\n        {\n\n            // not an omnivorous listener (if it was, this method is a\n            // no-op)\n            Set<DocumentDescriptor> descriptors =\n                    selectiveListeners.computeIfAbsent(listener, k -> new HashSet<>());\n\n            // this listener has not registered before\n            DocumentDescriptor descriptor = new DocumentDescriptor(path, documentName);\n\n            if (descriptors.add(descriptor)) {\n\n                // this listener wasn't already listening for this\n                // document -- add the listener to the set of\n                // listeners for this document\n                Set<POIFSReaderListener> listeners =\n                        chosenDocumentDescriptors.computeIfAbsent(descriptor, k -> new HashSet<>());\n\n                // nobody was listening for this document before\n                listeners.add(listener);\n            }\n        }\n    }
1587	@SuppressWarnings("resource")\n    @Internal\n    protected boolean initDirectory() {\n        if (directory == null) {\n            directory = new POIFSFileSystem().getRoot(); // NOSONAR\n            return true;\n        }\n        return false;\n    }
1588	public void removeHyperlink() {\n        for (Iterator<RecordBase> it = _sheet.getSheet().getRecords().iterator(); it.hasNext();) {\n            RecordBase rec = it.next();\n            if (rec instanceof HyperlinkRecord) {\n                HyperlinkRecord link = (HyperlinkRecord) rec;\n                if (link.getFirstColumn() == _record.getColumn() && link.getFirstRow() == _record.getRow()) {\n                    it.remove();\n                    return;\n                }\n            }\n        }\n    }
1589	public void writeOut(OutputStream out) throws IOException {\n		// Write out our children, and stuff them into the Escher layer\n\n		// Grab the children's data\n		ByteArrayOutputStream baos = new ByteArrayOutputStream();\n		for (Record r : _children) r.writeOut(baos);\n		byte[] data = baos.toByteArray();\n\n		// Save in the escher layer\n		_escherRecord.setData(data);\n	}
1590	public boolean isAutoSize()\n    {\n        return autoSize.isSet(field_2_options);\n    }
1591	protected void handleEmails(StringBuffer s, String type, String displayText, StringsIterator emails) {\n      if(displayText == null || displayText.length() == 0) {\n         return;\n      }\n      \n      String[] names = displayText.split(";\\s*");\n      boolean first = true;\n      \n      s.append(type).append(": ");\n      for(String name : names) {\n         if(first) {\n            first = false;\n         } else {\n            s.append("; ");\n         }\n         \n         s.append(name);\n         if(emails.hasNext()) {\n            String email = emails.next();\n            // Append the email address in <>, assuming\n            //  the name wasn't already the email address\n            if(! email.equals(name)) {\n               s.append(" <").append(email).append(">");\n            }\n         }\n      }\n      s.append("\n");\n   }
1592	@Internal\n    public byte getBx()\n    {\n        return ( byte )bx.getValue(field_6_flags);\n    }
1593	@Internal\n    public boolean isFRMark()\n    {\n        return fRMark.isSet(field_1_grpfChp);\n    }
1594	@Internal\n    public byte getIType()\n    {\n        return ( byte )iType.getValue(field_2_bits);\n    }
1595	private void addCategory() {\n        setElementTextContent(KEYWORD_CATEGORY, namespaceCoreProperties, propsPart.getCategoryProperty());\n	}
1596	public void createInformationProperties() {\n        if (!initialized) {\n            readProperties();\n        }\n        if (sInf == null) {\n            sInf = PropertySetFactory.newSummaryInformation();\n        }\n        if (dsInf == null) {\n            dsInf = newDocumentSummaryInformation();\n        }\n    }
1597	public void addIgnoredErrors(CellReference cell, IgnoredErrorType... ignoredErrorTypes) {\n        addIgnoredErrors(cell.formatAsString(), ignoredErrorTypes);\n    }
1598	public String getEntryName() {\n        String type = this.type.asFileEnding();\n\n        String chunkId = Integer.toHexString(this.chunkId);\n        while (chunkId.length() < 4) {\n            chunkId = "0" + chunkId;\n        }\n\n        return this.namePrefix\n            + chunkId.toUpperCase(Locale.ROOT)\n            + type.toUpperCase(Locale.ROOT);\n    }
1599	public static Cell translateUnicodeValues(Cell cell) {\n\n        String s = cell.getRichStringCellValue().getString();\n        boolean foundUnicode = false;\n        String lowerCaseStr = s.toLowerCase(Locale.ROOT);\n\n        for (UnicodeMapping entry : unicodeMappings) {\n            String key = entry.entityName;\n            if (lowerCaseStr.contains(key)) {\n                s = s.replaceAll(key, entry.resolvedValue);\n                foundUnicode = true;\n            }\n        }\n        if (foundUnicode) {\n            cell.setCellValue(cell.getRow().getSheet().getWorkbook().getCreationHelper()\n                    .createRichTextString(s));\n        }\n        return cell;\n    }
1600	public int buildTextPropList(int containsField, byte[] data, int dataOffset) {\n		int bytesPassed = 0;\n\n		// For each possible entry, see if we match the mask\n		// If we do, decode that, save it, and shuffle on\n		for(TextProp tp : getPotentialProperties()) {\n			// Check there's still data left to read\n\n			// Check if this property is found in the mask\n			if((containsField & tp.getMask()) != 0) {\n                if(dataOffset+bytesPassed >= data.length) {\n                    // Out of data, can't be any more properties to go\n                    // remember the mask and return\n                    maskSpecial |= tp.getMask();\n                    return bytesPassed;\n                }\n\n				// Bingo, data contains this property\n				TextProp prop = tp.clone();\n				int val = 0;\n				if (prop instanceof HSLFTabStopPropCollection) {\n                    ((HSLFTabStopPropCollection)prop).parseProperty(data, dataOffset+bytesPassed);\n                } else if (prop.getSize() == 2) {\n					val = LittleEndian.getShort(data,dataOffset+bytesPassed);\n				} else if(prop.getSize() == 4) {\n					val = LittleEndian.getInt(data,dataOffset+bytesPassed);\n				} else if (prop.getSize() == 0) {\n                    //remember "special" bits.\n                    maskSpecial |= tp.getMask();\n                    continue;\n                }\n				\n				if (prop instanceof BitMaskTextProp) {\n				    ((BitMaskTextProp)prop).setValueWithMask(val, containsField);\n				} else if (!(prop instanceof HSLFTabStopPropCollection)) {\n				    prop.setValue(val);\n				}\n				bytesPassed += prop.getSize();\n				addProp(prop);\n			}\n		}\n\n		// Return how many bytes were used\n		return bytesPassed;\n	}
1601	public MAPIMessage getAsEmbededMessage() throws IOException {\n        return new MAPIMessage(dir);\n    }
1602	private void updateFormula(XSSFCell cell, String oldName, String newName) {\n        CTCellFormula f = cell.getCTCell().getF();\n        if (f != null) {\n            String formula = f.getStringValue();\n            if (formula != null && formula.length() > 0) {\n                int sheetIndex = _wb.getSheetIndex(cell.getSheet());\n                Ptg[] ptgs = FormulaParser.parse(formula, _fpwb, FormulaType.CELL, sheetIndex, cell.getRowIndex());\n                for (Ptg ptg : ptgs) {\n                    updatePtg(ptg, oldName, newName);\n                }\n                String updatedFormula = FormulaRenderer.toFormulaString(_fpwb, ptgs);\n                if (!formula.equals(updatedFormula)) f.setStringValue(updatedFormula);\n            }\n        }\n    }
1603	protected String getCellFormula(XSSFEvaluationWorkbook fpb) {\n        CellType cellType = getCellType();\n        if(cellType != CellType.FORMULA) {\n            throw typeMismatch(CellType.FORMULA, cellType, false);\n        }\n\n        CTCellFormula f = _cell.getF();\n        if (isPartOfArrayFormulaGroup()) {\n            /* In an excel generated array formula, the formula property might be set, but the string is empty in slave cells */\n            if (f == null || f.getStringValue().isEmpty()) {\n                XSSFCell cell = getSheet().getFirstCellInArrayFormula(this);\n                return cell.getCellFormula(fpb);\n            }\n        }\n        if (f.getT() == STCellFormulaType.SHARED) {\n            return convertSharedFormula((int)f.getSi(), fpb == null ? XSSFEvaluationWorkbook.create(getSheet().getWorkbook()) : fpb);\n        }\n        return f.getStringValue();\n    }
1604	static void preserveSpaces(XmlString xs) {\n        String text = xs.getStringValue();\n        if (text != null && (text.startsWith(" ") || text.endsWith(" "))) {\n            XmlCursor c = xs.newCursor();\n            c.toNextToken();\n            c.insertAttributeWithValue(new QName("http://www.w3.org/XML/1998/namespace", "space"), "preserve");\n            c.dispose();\n        }\n    }
1605	public boolean isUsing1904DateWindowing() {\n        return uses1904datewindowing;\n    }
1606	protected List<PropertyValue> writeProperties(OutputStream out) throws IOException {\n        List<PropertyValue> variableLengthProperties = new ArrayList<>();\n        for (Entry<MAPIProperty, PropertyValue> entry : properties.entrySet()) {\n            MAPIProperty property = entry.getKey();\n            PropertyValue value = entry.getValue();\n            if (value == null) {\n                continue;\n            }\n            if (property.id < 0) {\n                continue;\n            }\n            // generic header\n            // page 23, point 2.4.2\n  	        // tag is the property id and its type\n            long tag = Long.parseLong(getFileName(property, value.getActualType()), 16);\n            LittleEndian.putUInt(tag, out);\n            LittleEndian.putUInt(value.getFlags(), out); // readable + writable\n\n            MAPIType type = getTypeMapping(value.getActualType());\n            if (type.isFixedLength()) {\n                // page 11, point 2.1.2\n                writeFixedLengthValueHeader(out, property, type, value);\n            } else {\n                // page 12, point 2.1.3\n                writeVariableLengthValueHeader(out, property, type, value);\n                variableLengthProperties.add(value);\n            }\n        }\n        return variableLengthProperties;\n    }
1607	@Beta\n    public void copyRowFrom(Row srcRow, CellCopyPolicy policy) {\n        if (srcRow == null) {\n            // srcRow is blank. Overwrite cells with blank values, blank styles, etc per cell copy policy\n            for (Cell destCell : this) {\n                final XSSFCell srcCell = null;\n                // FIXME: remove type casting when copyCellFrom(Cell, CellCopyPolicy) is added to Cell interface\n                ((XSSFCell)destCell).copyCellFrom(srcCell, policy);\n            }\n\n            if (policy.isCopyMergedRegions()) {\n                // Remove MergedRegions in dest row\n                final int destRowNum = getRowNum();\n                int index = 0;\n                final Set<Integer> indices = new HashSet<>();\n                for (CellRangeAddress destRegion : getSheet().getMergedRegions()) {\n                    if (destRowNum == destRegion.getFirstRow() && destRowNum == destRegion.getLastRow()) {\n                        indices.add(index);\n                    }\n                    index++;\n                }\n                getSheet().removeMergedRegions(indices);\n            }\n\n            if (policy.isCopyRowHeight()) {\n                // clear row height\n                setHeight((short)-1);\n            }\n\n        }\n        else {\n            for (final Cell c : srcRow){\n                final XSSFCell srcCell = (XSSFCell)c;\n                final XSSFCell destCell = createCell(srcCell.getColumnIndex(), srcCell.getCellType());\n                destCell.copyCellFrom(srcCell, policy);\n            }\n\n            final int sheetIndex = _sheet.getWorkbook().getSheetIndex(_sheet);\n            final String sheetName = _sheet.getWorkbook().getSheetName(sheetIndex);\n            final int srcRowNum = srcRow.getRowNum();\n            final int destRowNum = getRowNum();\n            final int rowDifference = destRowNum - srcRowNum;\n            \n            final FormulaShifter formulaShifter = FormulaShifter.createForRowCopy(sheetIndex, sheetName, srcRowNum, srcRowNum, rowDifference, SpreadsheetVersion.EXCEL2007);\n            final XSSFRowShifter rowShifter = new XSSFRowShifter(_sheet);\n            rowShifter.updateRowFormulas(this, formulaShifter);\n\n            // Copy merged regions that are fully contained on the row\n            // FIXME: is this something that rowShifter could be doing?\n            if (policy.isCopyMergedRegions()) {\n                for (CellRangeAddress srcRegion : srcRow.getSheet().getMergedRegions()) {\n                    if (srcRowNum == srcRegion.getFirstRow() && srcRowNum == srcRegion.getLastRow()) {\n                        CellRangeAddress destRegion = srcRegion.copy();\n                        destRegion.setFirstRow(destRowNum);\n                        destRegion.setLastRow(destRowNum);\n                        getSheet().addMergedRegion(destRegion);\n                    }\n                }\n            }\n\n            if (policy.isCopyRowHeight()) {\n                setHeight(srcRow.getHeight());\n            }\n        }\n    }
1608	public void registerListener(final POIFSReaderListener listener,\n                                 final POIFSDocumentPath path,\n                                 final String name) {\n        if ((listener == null) || (name == null) || (name.length() == 0)) {\n            throw new NullPointerException();\n        }\n        if (registryClosed) {\n            throw new IllegalStateException();\n        }\n        registry.registerListener(listener, (path == null) ? new POIFSDocumentPath() : path, name);\n    }
1609	public Date calculateWorkdays(double start, int workdays, double[] holidays) {\n		Date startDate = DateUtil.getJavaDate(start);\n		int direction = workdays < 0 ? -1 : 1;\n		Calendar endDate = LocaleUtil.getLocaleCalendar();\n		endDate.setTime(startDate);\n		double excelEndDate = DateUtil.getExcelDate(endDate.getTime());\n		while (workdays != 0) {\n			endDate.add(Calendar.DAY_OF_YEAR, direction);\n			excelEndDate += direction;\n			if (endDate.get(Calendar.DAY_OF_WEEK) != Calendar.SATURDAY\n					&& endDate.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY\n					&& !isHoliday(excelEndDate,	holidays)) {\n				workdays -= direction;\n			}\n		}\n		return endDate.getTime();\n	}
1610	public int createFormat(String formatString) {\n\n        maxformatid = maxformatid >= 0xa4 ? maxformatid + 1 : 0xa4; //Starting value from M$ empircal study.\n        FormatRecord rec = new FormatRecord(maxformatid, formatString);\n\n        int pos = 0;\n        while ( pos < records.size() && records.get( pos ).getSid() != FormatRecord.sid ) {\n            pos++;\n        }\n        pos += formats.size();\n        formats.add( rec );\n        records.add( pos, rec );\n        return maxformatid;\n    }
1611	public int getLfoMac()\n    {\n        return _lfoMac;\n    }
1612	@SuppressWarnings("resource")\n    public final void write(OutputStream stream) throws IOException {\n        OPCPackage p = getPackage();\n        if(p == null) {\n            throw new IOException("Cannot write data, document seems to have been closed already");\n        }\n        \n        //force all children to commit their changes into the underlying OOXML Package\n        // TODO Shouldn't they be committing to the new one instead?\n        Set<PackagePart> context = new HashSet<>();\n        onSave(context);\n        context.clear();\n\n        //save extended and custom properties\n        getProperties().commit();\n\n        p.save(stream);\n    }
1613	public int getLineCount() {\n        return getPropertyIntValue(PropertyIDMap.PID_LINECOUNT);\n    }
1614	public static byte[] getToUnicodeLE(String string) {\n        return string.getBytes(UTF16LE);\n    }
1615	public boolean isIncludeEntireCertificateChain() {\n        return includeEntireCertificateChain;\n    }
1616	public static Map<Integer,HSSFColor> getMutableIndexHash() {\n       return createColorsByIndexMap();\n    }
1617	public static Color HSL2RGB(double h, double s, double l, double alpha) {\n        // we clamp the values, as it possible to come up with more than 100% sat/lum\n        // (see links in applyColorTransform() for more info)\n        s = Math.max(0, Math.min(100, s));\n        l = Math.max(0, Math.min(100, l));\n\n        if (alpha <0.0f || alpha > 1.0f) {\n            String message = "Color parameter outside of expected range - Alpha: " + alpha;\n            throw new IllegalArgumentException( message );\n        }\n\n        //  Formula needs all values between 0 - 1.\n\n        h = h % 360.0f;\n        h /= 360f;\n        s /= 100f;\n        l /= 100f;\n\n        double q = (l < 0.5d)\n            ? l * (1d + s)\n            : (l + s) - (s * l);\n\n        double p = 2d * l - q;\n\n        double r = Math.max(0, HUE2RGB(p, q, h + (1.0d / 3.0d)));\n        double g = Math.max(0, HUE2RGB(p, q, h));\n        double b = Math.max(0, HUE2RGB(p, q, h - (1.0d / 3.0d)));\n\n        r = Math.min(r, 1.0d);\n        g = Math.min(g, 1.0d);\n        b = Math.min(b, 1.0d);\n\n        return new Color((float)r, (float)g, (float)b, (float)alpha);\n    }
1618	public void addChild(final Property property)\n        throws IOException\n    {\n        String name = property.getName();\n\n        if (_children_names.contains(name))\n        {\n            throw new IOException("Duplicate name \"" + name + "\"");\n        }\n        _children_names.add(name);\n        _children.add(property);\n    }
1619	private SheetIdentifier parseSheetRange(String bookname, NameIdentifier sheet1Name) {\n        GetChar();\n        SheetIdentifier sheet2 = parseSheetName();\n        if (sheet2 != null) {\n           return new SheetRangeIdentifier(bookname, sheet1Name, sheet2.getSheetIdentifier());\n        }\n        return null;\n    }
1620	public void updateSize(int size)\n    {\n        setSize(size);\n    }
1621	public int setArrayData(byte[] data, int offset) {\n        if (emptyComplexPart){\n            setComplexData(new byte[0]);\n        } else {\n            short numElements = LittleEndian.getShort(data, offset);\n            // LittleEndian.getShort(data, offset + 2); // numReserved\n            short sizeOfElements = LittleEndian.getShort(data, offset + 4);\n\n            // the code here seems to depend on complexData already being\n            // sized correctly via the constructor\n            int arraySize = getActualSizeOfElements(sizeOfElements) * numElements;\n            if (arraySize == getComplexData().length) {\n                // The stored data size in the simple block excludes the header size\n                setComplexData(new byte[arraySize + 6]);\n                sizeIncludesHeaderSize = false;\n            }\n            System.arraycopy(data, offset, getComplexData(), 0, getComplexData().length );\n        }\n        return getComplexData().length;\n    }
1622	private void getAllEmbeddedObjects(HSSFShapeContainer parent, List<HSSFObjectData> objects)\n    {\n        for (HSSFShape shape : parent.getChildren()) {\n            if (shape instanceof HSSFObjectData) {\n                objects.add((HSSFObjectData) shape);\n            } else if (shape instanceof HSSFShapeContainer) {\n                getAllEmbeddedObjects((HSSFShapeContainer) shape, objects);\n            }\n        }\n    }
1623	public void setRightMargin(double value){\n        CTTextParagraphProperties pr = _p.isSetPPr() ? _p.getPPr() : _p.addNewPPr();\n        if(value == -1) {\n            if(pr.isSetMarR()) pr.unsetMarR();\n        } else {\n            pr.setMarR(Units.toEMU(value));\n        }\n\n    }
1624	public void compress(InputStream src, OutputStream res) throws IOException {\n      HDGFLZWCompressor c = new HDGFLZWCompressor();\n      c.compress(src, res);\n   }
1625	private void findMasterSlides() {\n        SlideListWithText masterSLWT = _documentRecord.getMasterSlideListWithText();\n        if (masterSLWT == null) {\n            return;\n        }\n\n        for (SlideAtomsSet sas : masterSLWT.getSlideAtomsSets()) {\n            Record r = getCoreRecordForSAS(sas);\n            int sheetNo = sas.getSlidePersistAtom().getSlideIdentifier();\n            if (r instanceof Slide) {\n                HSLFTitleMaster master = new HSLFTitleMaster((Slide)r, sheetNo);\n                master.setSlideShow(this);\n                _titleMasters.add(master);\n            } else if (r instanceof MainMaster) {\n                HSLFSlideMaster master = new HSLFSlideMaster((MainMaster)r, sheetNo);\n                master.setSlideShow(this);\n                _masters.add(master);\n            }\n        }\n	}
1626	public static void putUInt( byte[] data, int offset, long value )\n    {\n        int i = offset;\n        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );\n    }
1627	ArrayList<PAPX> getOverflow()\n    {\n      return _overFlow;\n    }
1628	private static ValueEval resolveReference(AreaEval db, int dbRow, int dbCol) {\n        try {\n            return OperandResolver.getSingleValue(db.getValue(dbRow, dbCol), db.getFirstRow()+dbRow, db.getFirstColumn()+dbCol);\n        } catch (EvaluationException e) {\n            return e.getErrorEval();\n        }\n    }
1629	public XWPFNumbering createNumbering() {\n        if (numbering == null) {\n            NumberingDocument numberingDoc = NumberingDocument.Factory.newInstance();\n\n            XWPFRelation relation = XWPFRelation.NUMBERING;\n            int i = getRelationIndex(relation);\n\n            XWPFNumbering wrapper = (XWPFNumbering) createRelationship(relation, XWPFFactory.getInstance(), i);\n            wrapper.setNumbering(numberingDoc.addNewNumbering());\n            numbering = wrapper;\n        }\n\n        return numbering;\n    }
1630	public boolean isCustomNumberFormat()\n    {\n        return customNumberFormat.isSet(field_3_options);\n    }
1631	public byte getBlipTypeWin32() {\n        return field_1_blipTypeWin32;\n    }
1632	public void copyRange(CellRangeAddress tilePatternRange, CellRangeAddress tileDestRange) {\n        Sheet sourceCopy = sourceSheet.getWorkbook().cloneSheet(sourceSheet.getWorkbook().getSheetIndex(sourceSheet));\n        int sourceWidthMinus1 = tilePatternRange.getLastColumn() - tilePatternRange.getFirstColumn();\n        int sourceHeightMinus1 = tilePatternRange.getLastRow() - tilePatternRange.getFirstRow();\n        int rightLimitToCopy; \n        int bottomLimitToCopy;\n\n        int nextRowIndexToCopy = tileDestRange.getFirstRow();\n        do { \n            int nextCellIndexInRowToCopy = tileDestRange.getFirstColumn();\n            int heightToCopyMinus1 = Math.min(sourceHeightMinus1, tileDestRange.getLastRow() - nextRowIndexToCopy);\n            bottomLimitToCopy = tilePatternRange.getFirstRow() + heightToCopyMinus1;\n            do { \n                int widthToCopyMinus1 = Math.min(sourceWidthMinus1, tileDestRange.getLastColumn() - nextCellIndexInRowToCopy);\n                rightLimitToCopy = tilePatternRange.getFirstColumn() + widthToCopyMinus1;\n                CellRangeAddress rangeToCopy = new CellRangeAddress(\n                        tilePatternRange.getFirstRow(),     bottomLimitToCopy,\n                        tilePatternRange.getFirstColumn(),  rightLimitToCopy \n                       );\n                copyRange(rangeToCopy, nextCellIndexInRowToCopy - rangeToCopy.getFirstColumn(), nextRowIndexToCopy - rangeToCopy.getFirstRow(), sourceCopy);\n                nextCellIndexInRowToCopy += widthToCopyMinus1 + 1; \n            } while (nextCellIndexInRowToCopy <= tileDestRange.getLastColumn());\n            nextRowIndexToCopy += heightToCopyMinus1 + 1;\n        } while (nextRowIndexToCopy <= tileDestRange.getLastRow());\n        \n        int tempCopyIndex = sourceSheet.getWorkbook().getSheetIndex(sourceCopy);\n        sourceSheet.getWorkbook().removeSheetAt(tempCopyIndex); \n    }
1633	public final void moveTo(double x, double y) {\n        // This convenience method should be implemented via setAnchor in subclasses\n        // see HSLFGroupShape.setAnchor() for a reference\n        Rectangle2D anchor = getAnchor();\n        anchor.setRect(x, y, anchor.getWidth(), anchor.getHeight());\n        setAnchor(anchor);\n    }
1634	public static synchronized Map<Integer,HSSFColor> getIndexHash() {\n        if(indexHash == null) {\n           indexHash = Collections.unmodifiableMap( createColorsByIndexMap() );\n        }\n\n        return indexHash;\n    }
1635	public static FuncVarPtg create(LittleEndianInput in)  {\n        return create(in.readByte(), in.readShort());\n    }
1636	@Internal\n    public boolean isISize()\n    {\n        return iSize.isSet(field_2_bits);\n    }
1637	public void replaceValueRecord(CellValueRecordInterface newval) {\n\n        if (log.check( POILogger.DEBUG ))\n            log.log(POILogger.DEBUG, "replaceValueRecord ");\n        //The ValueRecordsAggregate use a tree map underneath.\n        //The tree Map uses the CellValueRecordInterface as both the\n        //key and the value, if we dont do a remove, then\n        //the previous instance of the key is retained, effectively using\n        //double the memory\n        _rowsAggregate.removeCell(newval);\n        _rowsAggregate.insertCell(newval);\n    }
1638	public static EscherAggregate createAggregate(List<RecordBase> records, int locFirstDrawingRecord) {\n        // Keep track of any shape records created so we can match them back to the object id's.\n        // Textbox objects are also treated as shape objects.\n        final List<EscherRecord> shapeRecords = new ArrayList<>();\n        EscherRecordFactory recordFactory = new DefaultEscherRecordFactory() {\n            public EscherRecord createRecord(byte[] data, int offset) {\n                EscherRecord r = super.createRecord(data, offset);\n                if (r.getRecordId() == EscherClientDataRecord.RECORD_ID || r.getRecordId() == EscherTextboxRecord.RECORD_ID) {\n                    shapeRecords.add(r);\n                }\n                return r;\n            }\n        };\n\n        // Create one big buffer\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        EscherAggregate agg = new EscherAggregate(false);\n        int loc = locFirstDrawingRecord;\n        while (loc + 1 < records.size()\n                && (isDrawingLayerRecord(sid(records, loc)))) {\n            try {\n                if (!(sid(records, loc) == DrawingRecord.sid || sid(records, loc) == ContinueRecord.sid)) {\n                    loc++;\n                    continue;\n                }\n                if (sid(records, loc) == DrawingRecord.sid) {\n                    buffer.write(((DrawingRecord) records.get(loc)).getRecordData());\n                } else {\n                    buffer.write(((ContinueRecord) records.get(loc)).getData());\n                }\n            } catch (IOException e) {\n                throw new RuntimeException("Couldn't get data from drawing/continue records", e);\n            }\n            loc++;\n        }\n\n        // Decode the shapes\n        // agg.escherRecords = new ArrayList();\n        int pos = 0;\n        while (pos < buffer.size()) {\n            EscherRecord r = recordFactory.createRecord(buffer.toByteArray(), pos);\n            int bytesRead = r.fillFields(buffer.toByteArray(), pos, recordFactory);\n            agg.addEscherRecord(r);\n            pos += bytesRead;\n        }\n\n        // Associate the object records with the shapes\n        loc = locFirstDrawingRecord + 1;\n        int shapeIndex = 0;\n        while (loc < records.size()\n                && (isDrawingLayerRecord(sid(records, loc)))) {\n            if (!isObjectRecord(records, loc)) {\n                loc++;\n                continue;\n            }\n            Record objRecord = (Record) records.get(loc);\n            agg.shapeToObj.put(shapeRecords.get(shapeIndex++), objRecord);\n            loc++;\n        }\n\n        // any NoteRecords that follow the drawing block must be aggregated and and saved in the tailRec collection\n        while (loc < records.size()) {\n            if (sid(records, loc) == NoteRecord.sid) {\n                NoteRecord r = (NoteRecord) records.get(loc);\n                agg.tailRec.put(r.getShapeId(), r);\n            } else {\n                break;\n            }\n            loc++;\n        }\n\n        int locLastDrawingRecord = loc;\n        // replace drawing block with the created EscherAggregate\n        records.subList(locFirstDrawingRecord, locLastDrawingRecord).clear();\n        records.add(locFirstDrawingRecord, agg);\n        return agg;\n    }
1639	public short getRow1()\n    {\n        return field_4_row1;\n    }
1640	public static CellRangeAddress[][] buildMergedRangesMap( Sheet sheet ) {\n        CellRangeAddress[][] mergedRanges = new CellRangeAddress[1][];\n        for ( final CellRangeAddress cellRangeAddress : sheet.getMergedRegions() ) {\n            final int requiredHeight = cellRangeAddress.getLastRow() + 1;\n            if ( mergedRanges.length < requiredHeight ) {\n                CellRangeAddress[][] newArray = new CellRangeAddress[requiredHeight][];\n                System.arraycopy( mergedRanges, 0, newArray, 0,\n                        mergedRanges.length );\n                mergedRanges = newArray;\n            }\n\n            for ( int r = cellRangeAddress.getFirstRow(); r <= cellRangeAddress\n                    .getLastRow(); r++ ) {\n                final int requiredWidth = cellRangeAddress.getLastColumn() + 1;\n\n                CellRangeAddress[] rowMerged = mergedRanges[r];\n                if ( rowMerged == null ) {\n                    rowMerged = new CellRangeAddress[requiredWidth];\n                    mergedRanges[r] = rowMerged;\n                } else {\n                    final int rowMergedLength = rowMerged.length;\n                    if ( rowMergedLength < requiredWidth )\n                    {\n                        final CellRangeAddress[] newRow = new CellRangeAddress[requiredWidth];\n                        System.arraycopy( rowMerged, 0, newRow, 0,\n                                rowMergedLength );\n\n                        mergedRanges[r] = newRow;\n                        rowMerged = newRow;\n                    }\n                }\n\n                Arrays.fill( rowMerged, cellRangeAddress.getFirstColumn(),\n                        cellRangeAddress.getLastColumn() + 1, cellRangeAddress );\n            }\n        }\n        return mergedRanges;\n    }
1641	public static String format(String rawSheetName) {\n        StringBuilder sb = new StringBuilder(rawSheetName.length() + 2);\n		appendFormat(sb, rawSheetName);\n		return sb.toString();\n	}
1642	public int addConditionalFormatting(CellRangeAddress[] regions, HSSFConditionalFormattingRule[] cfRules) {\n        if (regions == null) {\n            throw new IllegalArgumentException("regions must not be null");\n        }\n        for(CellRangeAddress range : regions) range.validate(SpreadsheetVersion.EXCEL97);\n\n        if (cfRules == null) {\n            throw new IllegalArgumentException("cfRules must not be null");\n        }\n        if (cfRules.length == 0) {\n            throw new IllegalArgumentException("cfRules must not be empty");\n        }\n        if (cfRules.length > 3) {\n            throw new IllegalArgumentException("Number of rules must not exceed 3");\n        }\n\n        CFRuleBase[] rules = new CFRuleBase[cfRules.length];\n        for (int i = 0; i != cfRules.length; i++) {\n            rules[i] = cfRules[i].getCfRuleRecord();\n        }\n        CFRecordsAggregate cfra = new CFRecordsAggregate(regions, rules);\n        return _conditionalFormattingTable.add(cfra);\n    }
1643	@Internal\n    public boolean isFData()\n    {\n        return fData.isSet(field_1_grpfChp);\n    }
1644	public int getLineWidth() {\n    return _dptLineWidth.getShortValue(_info);\n  }
1645	private static VerticalAlignment getVerticalAlignment(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        VerticalAlignment align;\n        if (value instanceof VerticalAlignment) {\n            align = (VerticalAlignment) value;\n        }\n        // @deprecated 3.15 beta 2. getVerticalAlignment will only work on VerticalAlignment enums instead of codes in the future.\n        else if (value instanceof Short) {\n            if (log.check(POILogger.WARN)) {\n                log.log(POILogger.WARN, "Deprecation warning: CellUtil properties map used a Short value for "\n                        + name + ". Should use VerticalAlignment enums instead.");\n            }\n            short code = ((Short) value).shortValue();\n            align = VerticalAlignment.forInt(code);\n        }\n        else if (value == null) {\n            align = VerticalAlignment.BOTTOM;\n        }\n        else {\n            throw new RuntimeException("Unexpected vertical alignment style class. Must be VerticalAlignment or Short (deprecated).");\n        }\n        return align;\n    }
1646	public static Dimension setPreferredSize(Picture picture, double scaleX, double scaleY){\n        ClientAnchor anchor = picture.getClientAnchor();\n        boolean isHSSF = (anchor instanceof HSSFClientAnchor);\n        PictureData data = picture.getPictureData();\n        Sheet sheet = picture.getSheet();\n        \n        // in pixel\n        Dimension imgSize = getImageDimension(new ByteArrayInputStream(data.getData()), data.getPictureType());\n        // in emus\n        Dimension anchorSize = ImageUtils.getDimensionFromAnchor(picture);\n        final double scaledWidth = (scaleX == Double.MAX_VALUE)\n            ? imgSize.getWidth() : anchorSize.getWidth()/EMU_PER_PIXEL * scaleX;\n        final double scaledHeight = (scaleY == Double.MAX_VALUE)\n            ? imgSize.getHeight() : anchorSize.getHeight()/EMU_PER_PIXEL * scaleY;\n\n        double w = 0;\n        int col2 = anchor.getCol1();\n        int dx2 = 0;\n\n        //space in the leftmost cell\n        w = sheet.getColumnWidthInPixels(col2++);\n        if (isHSSF) {\n            w *= 1d - anchor.getDx1()/1024d;\n        } else {\n            w -= anchor.getDx1()/(double)EMU_PER_PIXEL;\n        }\n        \n        while(w < scaledWidth){\n            w += sheet.getColumnWidthInPixels(col2++);\n        }\n        \n        if(w > scaledWidth) {\n            //calculate dx2, offset in the rightmost cell\n            double cw = sheet.getColumnWidthInPixels(--col2);\n            double delta = w - scaledWidth;\n            if (isHSSF) {\n                dx2 = (int)((cw-delta)/cw*1024);\n            } else {\n                dx2 = (int)((cw-delta)*EMU_PER_PIXEL);\n            }\n            if (dx2 < 0) dx2 = 0;\n        }\n        anchor.setCol2(col2);\n        anchor.setDx2(dx2);\n\n        double h = 0;\n        int row2 = anchor.getRow1();\n        int dy2 = 0;\n        \n        h = getRowHeightInPixels(sheet,row2++);\n        if (isHSSF) {\n            h *= 1 - anchor.getDy1()/256d;\n        } else {\n            h -= anchor.getDy1()/(double)EMU_PER_PIXEL;\n        }\n\n        while(h < scaledHeight){\n            h += getRowHeightInPixels(sheet,row2++);\n        }\n        \n        if(h > scaledHeight) {\n            double ch = getRowHeightInPixels(sheet,--row2);\n            double delta = h - scaledHeight;\n            if (isHSSF) {\n                dy2 = (int)((ch-delta)/ch*256);\n            } else {\n                dy2 = (int)((ch-delta)*EMU_PER_PIXEL);\n            }\n            if (dy2 < 0) dy2 = 0;\n        }\n\n        anchor.setRow2(row2);\n        anchor.setDy2(dy2);\n\n        return new Dimension(\n            (int)Math.round(scaledWidth*EMU_PER_PIXEL),\n            (int)Math.round(scaledHeight*EMU_PER_PIXEL)\n        );\n    }
1647	public static TNEFAttribute create(InputStream inp) throws IOException {\n      int id   = LittleEndian.readUShort(inp);\n      int type = LittleEndian.readUShort(inp);\n      \n      // Create as appropriate\n      if(id == TNEFProperty.ID_MAPIPROPERTIES.id ||\n            id == TNEFProperty.ID_ATTACHMENT.id) {\n         return new TNEFMAPIAttribute(id, type, inp);\n      }\n      if(type == TNEFProperty.TYPE_STRING ||\n           type == TNEFProperty.TYPE_TEXT) {\n         return new TNEFStringAttribute(id, type, inp);\n      }\n      if(type == TNEFProperty.TYPE_DATE) {\n         return new TNEFDateAttribute(id, type, inp);\n      }\n      return new TNEFAttribute(id, type, inp); \n   }
1648	public double drawParagraphs(Graphics2D graphics, double x, double y) {\n        DrawFactory fact = DrawFactory.getInstance(graphics);\n\n        double y0 = y;\n        Iterator<? extends TextParagraph<?,?,? extends TextRun>> paragraphs = getShape().iterator();\n        \n        boolean isFirstLine = true;\n        for (int autoNbrIdx=0; paragraphs.hasNext(); autoNbrIdx++){\n            TextParagraph<?,?,? extends TextRun> p = paragraphs.next();\n            DrawTextParagraph dp = fact.getDrawable(p);\n            BulletStyle bs = p.getBulletStyle();\n            if (bs == null || bs.getAutoNumberingScheme() == null) {\n                autoNbrIdx = -1;\n            } else {\n                Integer startAt = bs.getAutoNumberingStartAt();\n                if (startAt == null) startAt = 1;\n                // TODO: handle reset auto number indexes\n                if (startAt > autoNbrIdx) autoNbrIdx = startAt;\n            }\n            dp.setAutoNumberingIdx(autoNbrIdx);\n            dp.breakText(graphics);\n\n            if (isFirstLine) {\n                y += dp.getFirstLineLeading();\n            } else {\n                // the amount of vertical white space before the paragraph\n                Double spaceBefore = p.getSpaceBefore();\n                if (spaceBefore == null) spaceBefore = 0d;\n                if(spaceBefore > 0) {\n                    // positive value means percentage spacing of the height of the first line, e.g.\n                    // the higher the first line, the bigger the space before the paragraph\n                    y += spaceBefore*0.01*dp.getFirstLineHeight();\n                } else {\n                    // negative value means the absolute spacing in points\n                    y += -spaceBefore;\n                }\n            }\n            isFirstLine = false;\n            \n            dp.setPosition(x, y);\n            dp.draw(graphics);\n            y += dp.getY();\n\n            if (paragraphs.hasNext()) {\n                Double spaceAfter = p.getSpaceAfter();\n                if (spaceAfter == null) spaceAfter = 0d;\n                if(spaceAfter > 0) {\n                    // positive value means percentage spacing of the height of the last line, e.g.\n                    // the higher the last line, the bigger the space after the paragraph\n                    y += spaceAfter*0.01*dp.getLastLineHeight();\n                } else {\n                    // negative value means the absolute spacing in points\n                    y += -spaceAfter;\n                }\n            }\n        }\n        return y - y0;\n    }
1649	@Internal\n    public byte getFtsWidthAfter()\n    {\n        return ( byte )ftsWidthAfter.getValue(field_13_widthAndFitsFlags);\n    }
1650	private String parseAsSpecialQuantifier(){\n        if ( look != '[') {\n            return null;\n        }\n        GetChar();\n        if( look != '#') {\n            return null;\n        }\n        GetChar();\n        String name = parseAsName();\n        if ( name.equals("This")) {\n            name = name + ' ' + parseAsName();\n        }\n        Match(']');\n        return name;\n    }
1651	public static void registerFunction(String name, Function func){\n        FunctionMetadata metaData = FunctionMetadataRegistry.getFunctionByName(name);\n        if(metaData == null) {\n            if(AnalysisToolPak.isATPFunction(name)) {\n                throw new IllegalArgumentException(name + " is a function from the Excel Analysis Toolpack. " +\n                        "Use AnalysisToolpack.registerFunction(String name, FreeRefFunction func) instead.");\n            }\n\n            throw new IllegalArgumentException("Unknown function: " + name);\n        }\n\n        int idx = metaData.getIndex();\n        if(functions[idx] instanceof NotImplementedFunction) {\n            functions[idx] = func;\n        } else {\n            throw new IllegalArgumentException("POI already implememts " + name +\n                    ". You cannot override POI's implementations of Excel functions");\n        }\n    }
1652	public boolean isShadow() {\n    return _fShadow.getValue(_info2) != 0;\n  }
1653	@Internal\n    public int putDxf(CTDxf dxf) {\n        this.dxfs.add(dxf);\n        return this.dxfs.size();\n    }
1654	public static void main( String[] args ) throws IOException {\n        if ( args.length == 0 ) {\n            System.err.println( "Use:" );\n            System.err\n                    .println( "   java org.apache.poi.hwpf.extractor.WordExtractor <filename>" );\n            System.exit( 1 );\n        }\n\n        // Process the first argument as a file\n        InputStream fin = new FileInputStream( args[0] );\n        WordExtractor extractor = new WordExtractor( fin );\n        try {\n        	System.out.println( extractor.getText() );\n        } finally {\n        	extractor.close();\n        }\n    }
1655	public void setLocale(Locale locale) {\n        this.locale = locale;\n    }
1656	public Thumbnail getThumbnailThumbnail() {\n        byte[] data = getThumbnail();\n        if (data == null) {\n            return null;\n        }\n        return new Thumbnail(data);\n    }
1657	public TableStyle getExplicitTableStyle(String name) {\n        return tableStyles.get(name);\n    }
1658	@Internal\n    public boolean isFQFormat()\n    {\n        return fQFormat.isSet(field_5_grfstd);\n    }
1659	private static PrintHeadersRecord createPrintHeaders() {\n        PrintHeadersRecord retval = new PrintHeadersRecord();\n\n        retval.setPrintHeaders(false);\n        return retval;\n    }
1660	public void removeParagraph(XWPFParagraph paragraph) {\n        if (paragraphs.contains(paragraph)) {\n            CTP ctP = paragraph.getCTP();\n            XmlCursor c = ctP.newCursor();\n            c.removeXml();\n            c.dispose();\n            paragraphs.remove(paragraph);\n            bodyElements.remove(paragraph);\n        }\n    }
1661	public String getAbsPathMetadata() throws IOException {\n        try (InputStream is = workbookPart.getInputStream()) {\n            PathExtractor p = new PathExtractor(is);\n            p.parse();\n            return p.getPath();\n        }\n    }
1662	private ClientAnchorDetail fitImageToColumns(Sheet sheet, int colNumber,\n            double reqImageWidthMM, int resizeBehaviour) {\n\n        double colWidthMM;\n        double colCoordinatesPerMM;\n        int pictureWidthCoordinates;\n        ClientAnchorDetail colClientAnchorDetail = null;\n\n        // Get the colum's width in millimetres\n        colWidthMM = ConvertImageUnits.widthUnits2Millimetres(\n                (short)sheet.getColumnWidth(colNumber));\n\n        // Check that the column's width will accomodate the image at the\n        // required dimension. If the width of the column is LESS than the\n        // required width of the image, decide how the application should\n        // respond - resize the column or overlay the image across one or more\n        // columns.\n        if(colWidthMM < reqImageWidthMM) {\n\n            // Should the column's width simply be expanded?\n            if((resizeBehaviour == AddDimensionedImage.EXPAND_COLUMN) ||\n               (resizeBehaviour == AddDimensionedImage.EXPAND_ROW_AND_COLUMN)) {\n                // Set the width of the column by converting the required image\n                // width from millimetres into Excel's column width units.\n                sheet.setColumnWidth(colNumber,\n                        ConvertImageUnits.millimetres2WidthUnits(reqImageWidthMM));\n                // To make the image occupy the full width of the column, convert\n                // the required width of the image into co-ordinates. This value\n                // will become the inset for the ClientAnchorDetail class that\n                // is then instantiated.\n                if(sheet instanceof HSSFSheet) {\n                    colWidthMM = reqImageWidthMM;\n                    colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                        colWidthMM;\n                    pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n\n                }\n                else {\n                    pictureWidthCoordinates = (int)reqImageWidthMM * AddDimensionedImage.EMU_PER_MM;\n                }\n                colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                        colNumber, pictureWidthCoordinates);\n            }\n            // If the user has chosen to overlay both rows and columns or just\n            // to expand ONLY the size of the rows, then calculate how to lay\n            // the image out across one or more columns.\n            else if ((resizeBehaviour == AddDimensionedImage.OVERLAY_ROW_AND_COLUMN) ||\n                     (resizeBehaviour == AddDimensionedImage.EXPAND_ROW)) {\n                colClientAnchorDetail = this.calculateColumnLocation(sheet,\n                        colNumber, reqImageWidthMM);\n            }\n        }\n        // If the column is wider than the image.\n        else {\n            if(sheet instanceof HSSFSheet) {\n                // Mow many co-ordinate positions are there per millimetre?\n                colCoordinatesPerMM = ConvertImageUnits.TOTAL_COLUMN_COORDINATE_POSITIONS /\n                    colWidthMM;\n                // Given the width of the image, what should be it's co-ordinate?\n                pictureWidthCoordinates = (int)(reqImageWidthMM * colCoordinatesPerMM);\n            }\n            else {\n                pictureWidthCoordinates = (int)reqImageWidthMM *\n                        AddDimensionedImage.EMU_PER_MM;\n            }\n            colClientAnchorDetail = new ClientAnchorDetail(colNumber,\n                    colNumber, pictureWidthCoordinates);\n        }\n        return(colClientAnchorDetail);\n    }
1663	int getAlpha(){\n        return getPercentageValue("alpha");        \n    }
1664	private void initCharacterRuns() {\n		if (!_charRangeFound) {\n			int[] point = findRange(_characters, _start, _end);\n			_charStart = point[0];\n			_charEnd = point[1];\n			_charRangeFound = true;\n		}\n	}
1665	public static double npv(double r, double[] cfs) {\n        double npv = 0;\n        double r1 = r + 1;\n        double trate = r1;\n        for (int i=0, iSize=cfs.length; i<iSize; i++) {\n            npv += cfs[i] / trate;\n            trate *= r1;\n        }\n        return npv;\n    }
1666	public NameXPtg addNameXPtg(String name) {\n        int extBlockIndex = -1;\n        ExternalBookBlock extBlock = null;\n\n        // find ExternalBlock for Add-In functions and remember its index\n        for (int i = 0; i < _externalBookBlocks.length; i++) {\n            SupBookRecord ebr = _externalBookBlocks[i].getExternalBookRecord();\n            if (ebr.isAddInFunctions()) {\n                extBlock = _externalBookBlocks[i];\n                extBlockIndex = i;\n                break;\n            }\n        }\n        // An ExternalBlock for Add-In functions was not found. Create a new one.\n        if (extBlock == null) {\n            extBlock = new ExternalBookBlock();\n            extBlockIndex = extendExternalBookBlocks(extBlock);\n\n            // add the created SupBookRecord before ExternSheetRecord\n            int idx = findFirstRecordLocBySid(ExternSheetRecord.sid);\n            _workbookRecordList.add(idx, extBlock.getExternalBookRecord());\n\n            // register the SupBookRecord in the ExternSheetRecord\n            // -2 means that the scope of this name is Workbook and the reference applies to the entire workbook.\n            _externSheetRecord.addRef(_externalBookBlocks.length - 1, -2, -2);\n        }\n\n        // create a ExternalNameRecord that will describe this name\n        ExternalNameRecord extNameRecord = new ExternalNameRecord();\n        extNameRecord.setText(name);\n        // The docs don't explain why Excel set the formula to #REF!\n        extNameRecord.setParsedExpression(new Ptg[]{ErrPtg.REF_INVALID});\n\n        int nameIndex = extBlock.addExternalName(extNameRecord);\n        int supLinkIndex = 0;\n        // find the posistion of the Add-In SupBookRecord in the workbook stream,\n        // the created ExternalNameRecord will be appended to it\n        for (Record record : _workbookRecordList.getRecords()) {\n            if (record instanceof SupBookRecord && ((SupBookRecord) record).isAddInFunctions()) {\n                break;\n            }\n            supLinkIndex++;\n        }\n        int numberOfNames = extBlock.getNumberOfNames();\n        // a new name is inserted in the end of the SupBookRecord, after the last name\n        _workbookRecordList.add(supLinkIndex + numberOfNames, extNameRecord);\n        int fakeSheetIdx = -2; /* the scope is workbook*/\n        int ix = _externSheetRecord.getRefIxForSheet(extBlockIndex, fakeSheetIdx, fakeSheetIdx);\n        return new NameXPtg(ix, nameIndex);\n    }
1667	public int getSpacingBeforeLines() {\n        CTSpacing spacing = getCTSpacing(false);\n        return (spacing != null && spacing.isSetBeforeLines()) ? spacing.getBeforeLines().intValue() : -1;\n    }
1668	public POIXMLDocumentPart getOwner() {\n        return footnotes;\n    }
1669	protected static void writeUnsupportedTypeMessage\n        (final UnsupportedVariantTypeException ex) {\n        if (isLogUnsupportedTypes())\n        {\n            if (unsupportedMessage == null) {\n                unsupportedMessage = new LinkedList<>();\n            }\n            Long vt = Long.valueOf(ex.getVariantType());\n            if (!unsupportedMessage.contains(vt))\n            {\n            	logger.log( POILogger.ERROR, ex.getMessage());\n                unsupportedMessage.add(vt);\n            }\n        }\n    }
1670	@Internal\n    public boolean isFUnhideWhenUsed()\n    {\n        return fUnhideWhenUsed.isSet(field_5_grfstd);\n    }
1671	private int calcSize() throws WritingNotSupportedException, IOException {\n        sectionBytes.reset();\n        write(sectionBytes);\n        padSectionBytes();\n        return sectionBytes.size();\n    }
1672	private static PrintSetupRecord createPrintSetup() {\n        PrintSetupRecord retval = new PrintSetupRecord();\n\n        retval.setPaperSize(( short ) 1);\n        retval.setScale(( short ) 100);\n        retval.setPageStart(( short ) 1);\n        retval.setFitWidth(( short ) 1);\n        retval.setFitHeight(( short ) 1);\n        retval.setOptions(( short ) 2);\n        retval.setHResolution(( short ) 300);\n        retval.setVResolution(( short ) 300);\n        retval.setHeaderMargin( 0.5);\n        retval.setFooterMargin( 0.5);\n        retval.setCopies(( short ) 1);\n        return retval;\n    }
1673	public void removeRelationship(String id) {\n        this._container.throwExceptionIfReadOnly();\n        if (this._relationships != null)\n            this._relationships.removeRelationship(id);\n    }
1674	public boolean isExternalRef()\n    {\n        if (path[0] == 0x01)\n            return true;\n        return false;\n    }
1675	private static void hexDumpAligned(Writer w, byte[] data, int dumpLen, int globalOffset,\n			boolean zeroAlignEachRecord) {\n		int baseDataOffset = 0;\n\n		// perhaps this code should be moved to HexDump\n		int globalStart = globalOffset + baseDataOffset;\n		int globalEnd = globalOffset + baseDataOffset + dumpLen;\n		int startDelta = globalStart % DUMP_LINE_LEN;\n		int endDelta = globalEnd % DUMP_LINE_LEN;\n		if (zeroAlignEachRecord) {\n			endDelta -= startDelta;\n			if (endDelta < 0) {\n				endDelta += DUMP_LINE_LEN;\n			}\n			startDelta = 0;\n		}\n		int startLineAddr;\n		int endLineAddr;\n		if (zeroAlignEachRecord) {\n			endLineAddr = globalEnd - endDelta - (globalStart - startDelta);\n			startLineAddr = 0;\n		} else {\n			startLineAddr = globalStart - startDelta;\n			endLineAddr = globalEnd - endDelta;\n		}\n\n		int lineDataOffset = baseDataOffset - startDelta;\n		int lineAddr = startLineAddr;\n\n		// output (possibly incomplete) first line\n		if (startLineAddr == endLineAddr) {\n			hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, endDelta);\n			return;\n		}\n		hexDumpLine(w, data, lineAddr, lineDataOffset, startDelta, DUMP_LINE_LEN);\n\n		// output all full lines in the middle\n		while (true) {\n			lineAddr += DUMP_LINE_LEN;\n			lineDataOffset += DUMP_LINE_LEN;\n			if (lineAddr >= endLineAddr) {\n				break;\n			}\n			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, DUMP_LINE_LEN);\n		}\n\n\n		// output (possibly incomplete) last line\n		if (endDelta != 0) {\n			hexDumpLine(w, data, lineAddr, lineDataOffset, 0, endDelta);\n		}\n	}
1676	@Internal\n    public boolean isFEncrypted()\n    {\n        return fEncrypted.isSet(field_6_flags1);\n    }
1677	public void writeToBytes(final byte [] data)\n        throws ArrayIndexOutOfBoundsException\n    {\n        LittleEndian.putInt(data, _offset, _value);\n    }
1678	public void addFootnoteReference(XWPFAbstractFootnoteEndnote footnote) {\n        XWPFRun run = createRun();\n        CTR ctRun = run.getCTR();\n        ctRun.addNewRPr().addNewRStyle().setVal("FootnoteReference");\n        if (footnote instanceof XWPFEndnote) {\n            ctRun.addNewEndnoteReference().setId(footnote.getId());\n        } else {\n            ctRun.addNewFootnoteReference().setId(footnote.getId());\n        }\n    }
1679	public int getRawValue(final int holder)\n    {\n        return (holder & _mask);\n    }
1680	public static long calculateChecksum(InputStream stream) throws IOException {\n        Checksum sum = new CRC32();\n\n        byte[] buf = new byte[4096];\n        int count;\n        while ((count = stream.read(buf)) != -1) {\n            if (count > 0) {\n                sum.update(buf, 0, count);\n            }\n        }\n        return sum.getValue();\n    }
1681	private void compareNumberOfRowsInSheets(Locator loc1, Locator loc2) {\n        for (int i = 0; i < loc1.workbook.getNumberOfSheets(); i++) {\n            if (loc2.workbook.getNumberOfSheets() <= i) return;\n\n            loc1.sheet = loc1.workbook.getSheetAt(i);\n            loc2.sheet = loc2.workbook.getSheetAt(i);\n            \n            int num1 = loc1.sheet.getPhysicalNumberOfRows();\n            int num2 = loc2.sheet.getPhysicalNumberOfRows();\n\n            if (num1 != num2) {\n                String str = String.format(Locale.ROOT, "%s\nworkbook1 -> %s [%d] != workbook2 -> %s [%d]",\n                    "Number Of Rows does not Match ::",\n                    loc1.sheet.getSheetName(), num1,\n                    loc2.sheet.getSheetName(), num2\n                );\n                listOfDifferences.add(str);\n            }\n        }\n\n    }
1682	public int getCharWidth( char c )\n    {\n        Integer widthInteger = charWidths.get(Character.valueOf(c));\n        if (widthInteger == null) {\n            return 'W' == c ? 0 : getCharWidth('W');\n        }\n        return widthInteger;\n    }
1683	public int getBiffVersion() {\n        return biffVersion;\n    }
1684	public XWPFTable createTable() {\n        XWPFTable table = new XWPFTable(ctDocument.getBody().addNewTbl(), this);\n        bodyElements.add(table);\n        tables.add(table);\n        return table;\n    }
1685	public static boolean hasExactSharedBorder(CellRangeAddress crA, CellRangeAddress crB) {\n        int oFirstRow = crB.getFirstRow();\n        int oLastRow  = crB.getLastRow();\n        int oFirstCol = crB.getFirstColumn();\n        int oLastCol  = crB.getLastColumn();\n\n        if (crA.getFirstRow() > 0 && crA.getFirstRow()-1 == oLastRow || \n                oFirstRow > 0 && oFirstRow-1 == crA.getLastRow()) {\n            // ranges have a horizontal border in common\n            // make sure columns are identical:\n            return crA.getFirstColumn() == oFirstCol && crA.getLastColumn() == oLastCol;\n        }\n\n        if (crA.getFirstColumn()>0 && crA.getFirstColumn() - 1 == oLastCol ||\n                oFirstCol>0 && crA.getLastColumn() == oFirstCol -1) {\n            // ranges have a vertical border in common\n            // make sure rows are identical:\n            return crA.getFirstRow() == oFirstRow && crA.getLastRow() == oLastRow;\n        }\n        return false;\n    }
1686	protected static Map<Short, Constructor<? extends EscherRecord>> recordsToMap(Class<?>[] recClasses) {\n        Map<Short, Constructor<? extends EscherRecord>> result = new HashMap<>();\n        final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n\n        for (Class<?> recClass : recClasses) {\n            @SuppressWarnings("unchecked")\n            Class<? extends EscherRecord> recCls = (Class<? extends EscherRecord>) recClass;\n            short sid;\n            try {\n                sid = recCls.getField("RECORD_ID").getShort(null);\n            } catch (IllegalArgumentException e) {\n                throw new RuntimeException(e);\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(e);\n            } catch (NoSuchFieldException e) {\n                throw new RuntimeException(e);\n            }\n            Constructor<? extends EscherRecord> constructor;\n            try {\n                constructor = recCls.getConstructor(EMPTY_CLASS_ARRAY);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(e);\n            }\n            result.put(Short.valueOf(sid), constructor);\n        }\n        return result;\n    }
1687	@Internal\n    public byte getFtsWidth()\n    {\n        return ( byte )ftsWidth.getValue(field_13_widthAndFitsFlags);\n    }
1688	public int getSheetNumber()\n	{\n		return field_6_sheetNumber;\n	}
1689	public HSLFFontInfo getFontInfo(int index) {\n        for (HSLFFontInfo fi : fonts.values()) {\n            if (fi.getIndex() == index) {\n                return fi;\n            }\n        }\n        return null;\n    }
1690	private Ptg columnCopyRefPtg(RefPtgBase rptg) {\n        final int refColumn = rptg.getColumn();\n        if (rptg.isColRelative()) {\n            // check new location where the ref is located\n            final int destColumnIndex = _firstMovedIndex + _amountToMove;\n            if (destColumnIndex < 0 || _version.getLastColumnIndex() < destColumnIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            // check new location where the ref points to\n            final int newColumnIndex = refColumn + _amountToMove;\n            if(newColumnIndex < 0 || _version.getLastColumnIndex() < newColumnIndex) {\n                return createDeletedRef(rptg);\n            }\n\n            rptg.setColumn(newColumnIndex);\n            return rptg;\n        }\n        return null;\n    }
1691	static void unCompressTAPOperation (TableProperties newTAP, SprmOperation sprm)\n  {\n    switch (sprm.getOperation())\n    {\n      case 0:\n        newTAP.setJc ((short) sprm.getOperand());\n        break;\n      case 0x01:\n      {\n        short[] rgdxaCenter = newTAP.getRgdxaCenter ();\n        short itcMac = newTAP.getItcMac ();\n        int adjust = sprm.getOperand() - (rgdxaCenter[0] + newTAP.getDxaGapHalf ());\n        for (int x = 0; x < itcMac; x++)\n        {\n          rgdxaCenter[x] += adjust;\n        }\n        break;\n      }\n      case 0x02:\n      {\n        short[] rgdxaCenter = newTAP.getRgdxaCenter ();\n        if (rgdxaCenter != null)\n        {\n          int adjust = newTAP.getDxaGapHalf () - sprm.getOperand();\n          rgdxaCenter[0] += adjust;\n        }\n        newTAP.setDxaGapHalf (sprm.getOperand());\n        break;\n      }\n      case 0x03:\n        newTAP.setFCantSplit (getFlag(sprm.getOperand()));\n        break;\n      case 0x04:\n        newTAP.setFTableHeader (getFlag (sprm.getOperand()));\n        break;\n      case 0x05:\n      {\n        byte[] buf = sprm.getGrpprl();\n        int offset = sprm.getGrpprlOffset();\n        newTAP.setBrcTop(new BorderCode(buf, offset));\n        offset += BorderCode.SIZE;\n        newTAP.setBrcLeft(new BorderCode(buf, offset));\n        offset += BorderCode.SIZE;\n        newTAP.setBrcBottom(new BorderCode(buf, offset));\n        offset += BorderCode.SIZE;\n        newTAP.setBrcRight(new BorderCode(buf, offset));\n        offset += BorderCode.SIZE;\n        newTAP.setBrcHorizontal(new BorderCode(buf, offset));\n        offset += BorderCode.SIZE;\n        newTAP.setBrcVertical(new BorderCode(buf, offset));\n        break;\n      }\n      case 0x06:\n\n        //obsolete, used in word 1.x\n        break;\n      case 0x07:\n        newTAP.setDyaRowHeight (sprm.getOperand());\n        break;\n      case 0x08:\n      {\n        byte[] grpprl = sprm.getGrpprl();\n        int offset = sprm.getGrpprlOffset();\n        short itcMac = grpprl[offset];\n        short[] rgdxaCenter = new short[itcMac + 1];\n        TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];\n        //I use varParam[0] and newTAP._itcMac interchangably\n        newTAP.setItcMac (itcMac);\n        newTAP.setRgdxaCenter (rgdxaCenter);\n        newTAP.setRgtc (rgtc);\n\n        // get the rgdxaCenters\n        for (int x = 0; x < itcMac; x++)\n        {\n          rgdxaCenter[x] = LittleEndian.getShort (grpprl, offset + (1 + (x * 2)));\n        }\n\n        // only try to get the TC entries if they exist...\n        int endOfSprm = offset+sprm.size()-6; // -2 bytes for sprm - 2 for size short - 2 to correct offsets being 0 based\n        int startOfTCs = offset + (1 + (itcMac + 1) * 2);\n\n        boolean hasTCs = startOfTCs < endOfSprm;\n\n        for (int x = 0; x < itcMac; x++)\n        {\n          // Sometimes, the grpprl does not contain data at every offset. I have no idea why this happens.\n          if(hasTCs && offset + (1 + ( (itcMac + 1) * 2) + (x * 20)) < grpprl.length)\n            rgtc[x] = TableCellDescriptor.convertBytesToTC(grpprl,\n               offset + (1 + ( (itcMac + 1) * 2) + (x * 20)));\n          else\n            rgtc[x] = new TableCellDescriptor();\n        }\n\n        rgdxaCenter[itcMac] = LittleEndian.getShort (grpprl, offset + (1 + (itcMac * 2)));\n        break;\n      }\n      case 0x09:\n\n        /** @todo handle cell shading*/\n        break;\n      case 0x0a:\n\n        /** @todo handle word defined table styles*/\n        break;\n      case 0x20:\n//      {\n//        TableCellDescriptor[] rgtc = newTAP.getRgtc();\n//\n//        for (int x = varParam[0]; x < varParam[1]; x++)\n//        {\n//\n//          if ((varParam[2] & 0x08) > 0)\n//          {\n//            short[] brcRight = rgtc[x].getBrcRight ();\n//            brcRight[0] = LittleEndian.getShort (varParam, 6);\n//            brcRight[1] = LittleEndian.getShort (varParam, 8);\n//          }\n//          else if ((varParam[2] & 0x04) > 0)\n//          {\n//            short[] brcBottom = rgtc[x].getBrcBottom ();\n//            brcBottom[0] = LittleEndian.getShort (varParam, 6);\n//            brcBottom[1] = LittleEndian.getShort (varParam, 8);\n//          }\n//          else if ((varParam[2] & 0x02) > 0)\n//          {\n//            short[] brcLeft = rgtc[x].getBrcLeft ();\n//            brcLeft[0] = LittleEndian.getShort (varParam, 6);\n//            brcLeft[1] = LittleEndian.getShort (varParam, 8);\n//          }\n//          else if ((varParam[2] & 0x01) > 0)\n//          {\n//            short[] brcTop = rgtc[x].getBrcTop ();\n//            brcTop[0] = LittleEndian.getShort (varParam, 6);\n//            brcTop[1] = LittleEndian.getShort (varParam, 8);\n//          }\n//        }\n//        break;\n//      }\n        break;\n      case 0x21:\n      {\n        int param = sprm.getOperand();\n        int index = (param & 0xff000000) >> 24;\n        int count = (param & 0x00ff0000) >> 16;\n        int width = (param & 0x0000ffff);\n        int itcMac = newTAP.getItcMac();\n\n        short[] rgdxaCenter = new short[itcMac + count + 1];\n        TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];\n        if (index >= itcMac)\n        {\n          index = itcMac;\n          System.arraycopy(newTAP.getRgdxaCenter(), 0, rgdxaCenter, 0,\n                           itcMac + 1);\n          System.arraycopy(newTAP.getRgtc(), 0, rgtc, 0, itcMac);\n        }\n        else\n        {\n          //copy rgdxaCenter\n          System.arraycopy(newTAP.getRgdxaCenter(), 0, rgdxaCenter, 0,\n                           index + 1);\n          System.arraycopy(newTAP.getRgdxaCenter(), index + 1, rgdxaCenter,\n                           index + count, itcMac - (index));\n          //copy rgtc\n          System.arraycopy(newTAP.getRgtc(), 0, rgtc, 0, index);\n          System.arraycopy(newTAP.getRgtc(), index, rgtc, index + count,\n                           itcMac - index);\n        }\n\n        for (int x = index; x < index + count; x++)\n        {\n          rgtc[x] = new TableCellDescriptor();\n          rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);\n        }\n        rgdxaCenter[index +\n          count] = (short)(rgdxaCenter[(index + count) - 1] + width);\n        break;\n      }\n      /**@todo handle table sprms from complex files*/\n      case 0x22:\n      case 0x23:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x27:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n        break;\n      case 0x34:\n        // sprmTCellPaddingDefault -- (0xd634)\n        // TODO: extract into CSSA structure\n        byte itcFirst = sprm.getGrpprl()[sprm.getGrpprlOffset()];\n        byte itcLim = sprm.getGrpprl()[sprm.getGrpprlOffset() + 1];\n        byte grfbrc = sprm.getGrpprl()[sprm.getGrpprlOffset() + 2];\n        byte ftsWidth = sprm.getGrpprl()[sprm.getGrpprlOffset() + 3];\n        short wWidth = LittleEndian.getShort(sprm.getGrpprl(),\n            sprm.getGrpprlOffset() + 4);\n\n        for (int c = itcFirst; c < itcLim; c++) {\n          TableCellDescriptor tableCellDescriptor = newTAP.getRgtc()[c];\n\n          if ((grfbrc & 0x01) != 0) {\n            tableCellDescriptor.setFtsCellPaddingTop(ftsWidth);\n            tableCellDescriptor.setWCellPaddingTop(wWidth);\n          }\n          if ((grfbrc & 0x02) != 0) {\n            tableCellDescriptor.setFtsCellPaddingLeft(ftsWidth);\n            tableCellDescriptor.setWCellPaddingLeft(wWidth);\n          }\n          if ((grfbrc & 0x04) != 0) {\n            tableCellDescriptor.setFtsCellPaddingBottom(ftsWidth);\n            tableCellDescriptor.setWCellPaddingBottom(wWidth);\n          }\n          if ((grfbrc & 0x08) != 0) {\n            tableCellDescriptor.setFtsCellPaddingRight(ftsWidth);\n            tableCellDescriptor.setWCellPaddingRight(wWidth);\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }
1692	protected void setPictureReference(PackageRelationship rel){\n        ctPicture.getBlipFill().getBlip().setEmbed(rel.getId());\n    }
1693	public String[] getAllText() {\n		List<String> text = new ArrayList<>();\n		for(Stream stream : hdgf.getTopLevelStreams()) {\n			findText(stream, text);\n		}\n		return text.toArray(new String[0]);\n	}
1694	private static String getFormulaFromTextExpression(String textExpr) {\n		if (textExpr == null) {\n			return null;\n		}\n		if (textExpr.length() < 1) {\n			throw new IllegalArgumentException("Empty string is not a valid formula/value expression");\n		}\n		if (textExpr.charAt(0) == '=') {\n			return textExpr.substring(1);\n		}\n		return null;\n	}
1695	public CellFormatResult apply(JLabel label, Object value) {\n        CellFormatResult result = apply(value);\n        label.setText(result.text);\n        if (result.textColor != null) {\n            label.setForeground(result.textColor);\n        }\n        return result;\n    }
1696	static void expiry(Sheet sheet) {\n        CellStyle style = sheet.getWorkbook().createCellStyle();\n        style.setDataFormat((short)BuiltinFormats.getBuiltinFormat("d-mmm"));\n\n        sheet.createRow(0).createCell(0).setCellValue("Date");\n        sheet.createRow(1).createCell(0).setCellFormula("TODAY()+29");\n        sheet.createRow(2).createCell(0).setCellFormula("A2+1");\n        sheet.createRow(3).createCell(0).setCellFormula("A3+1");\n\n        for(int rownum = 1; rownum <= 3; rownum++) {\n            sheet.getRow(rownum).getCell(0).setCellStyle(style);\n        }\n\n        SheetConditionalFormatting sheetCF = sheet.getSheetConditionalFormatting();\n\n        // Condition 1: Formula Is   =A2=A1   (White Font)\n        ConditionalFormattingRule rule1 = sheetCF.createConditionalFormattingRule("AND(A2-TODAY()>=0,A2-TODAY()<=30)");\n        FontFormatting font = rule1.createFontFormatting();\n        font.setFontStyle(false, true);\n        font.setFontColorIndex(IndexedColors.BLUE.index);\n\n        CellRangeAddress[] regions = {\n                CellRangeAddress.valueOf("A2:A4")\n        };\n\n        sheetCF.addConditionalFormatting(regions, rule1);\n\n        sheet.getRow(0).createCell(1).setCellValue("Dates within the next 30 days are highlighted");\n    }
1697	public POIFSFileSystem getNFileSystem()\n    {\n        return _nfilesystem;\n    }
1698	protected Object getProperty(final int id) throws NoSingleSectionException {\n        return getFirstSection().getProperty(id);\n    }
1699	public XWPFTableRow createRow() {\n        int sizeCol = ctTbl.sizeOfTrArray() > 0 ? ctTbl.getTrArray(0)\n                .sizeOfTcArray() : 0;\n        XWPFTableRow tabRow = new XWPFTableRow(ctTbl.addNewTr(), this);\n        addColumn(tabRow, sizeCol);\n        tableRows.add(tabRow);\n        return tabRow;\n    }
1700	public void close() throws IOException {\n       _data.close();\n    }
1701	private void initDrawingAndShapes() {\n        CTGroupShape cgs = getSpTree();\n        if(_drawing == null) {\n            _drawing = new XSLFDrawing(this, cgs);\n        }\n        if (_shapes == null) {\n            _shapes = buildShapes(cgs, this);\n        }\n    }
1702	public Format createFormat(Cell cell) {\n\n        int formatIndex = cell.getCellStyle().getDataFormat();\n        String formatStr = cell.getCellStyle().getDataFormatString();\n        return createFormat(cell.getNumericCellValue(), formatIndex, formatStr);\n    }
1703	public Map<Integer, NoteRecord> getTailRecords() {\n        return Collections.unmodifiableMap(tailRec);\n    }
1704	public double getBlur(){\n        CTOuterShadowEffect ct = (CTOuterShadowEffect)getXmlObject();\n        return ct.isSetBlurRad() ? Units.toPoints(ct.getBlurRad()) : 0;\n    }
1705	public void unsetObjectTableEntry(int index) {\n        objectTable.set(index, null);\n    }
1706	public XSLFSlideLayout findLayout(String name) {\n        for (XSLFSlideMaster master : getSlideMasters()) {\n            XSLFSlideLayout layout = master.getLayout(name);\n            if (layout != null) {\n                return layout;\n            }\n        }\n        return null;\n    }
1707	public HSSFFontFormatting createFontFormatting() {\n        return getFontFormatting(true);\n    }
1708	public CellFormatResult apply(Object value) {\n        boolean applies = applies(value);\n        String text;\n        Color textColor;\n        if (applies) {\n            text = format.format(value);\n            textColor = color;\n        } else {\n            text = format.simpleFormat(value);\n            textColor = null;\n        }\n        return new CellFormatResult(applies, text, textColor);\n    }
1709	@Internal\n    public boolean isFComplex()\n    {\n        return fComplex.isSet(field_6_flags1);\n    }
1710	protected static void setCertID\n        (CertIDType certId, SignatureConfig signatureConfig, boolean issuerNameNoReverseOrder, X509Certificate certificate) {\n        X509IssuerSerialType issuerSerial = certId.addNewIssuerSerial();\n        String issuerName;\n        if (issuerNameNoReverseOrder) {\n            /*\n             * Make sure the DN is encoded using the same order as present\n             * within the certificate. This is an Office2010 work-around.\n             * Should be reverted back.\n             * \n             * XXX: not correct according to RFC 4514.\n             */\n            // TODO: check if issuerName is different on getTBSCertificate\n            // issuerName = PrincipalUtil.getIssuerX509Principal(certificate).getName().replace(",", ", ");\n            issuerName = certificate.getIssuerDN().getName().replace(",", ", ");\n        } else {\n            issuerName = certificate.getIssuerX500Principal().toString();\n        }\n        issuerSerial.setX509IssuerName(issuerName);\n        issuerSerial.setX509SerialNumber(certificate.getSerialNumber());\n\n        byte[] encodedCertificate;\n        try {\n            encodedCertificate = certificate.getEncoded();\n        } catch (CertificateEncodingException e) {\n            throw new RuntimeException("certificate encoding error: "\n                    + e.getMessage(), e);\n        }\n        DigestAlgAndValueType certDigest = certId.addNewCertDigest(); \n        setDigestAlgAndValue(certDigest, encodedCertificate, signatureConfig.getXadesDigestAlgo());\n    }
1711	public String[] getSubPropNames() { return subPropNames; }
1712	private static UnicodeString resolveTitleText(String str) {\n		if (str == null || str.length() < 1) {\n			return NULL_TEXT_STRING;\n		}\n		return new UnicodeString(str);\n	}
1713	int getGreen(){\n        return getPercentageValue("green");\n    }
1714	private static String translateBuiltInName(byte name)\n	{\n		switch (name)\n		{\n			case NameRecord.BUILTIN_AUTO_ACTIVATE :     return "Auto_Activate";\n			case NameRecord.BUILTIN_AUTO_CLOSE :        return "Auto_Close";\n			case NameRecord.BUILTIN_AUTO_DEACTIVATE :   return "Auto_Deactivate";\n			case NameRecord.BUILTIN_AUTO_OPEN :         return "Auto_Open";\n			case NameRecord.BUILTIN_CONSOLIDATE_AREA :  return "Consolidate_Area";\n			case NameRecord.BUILTIN_CRITERIA :          return "Criteria";\n			case NameRecord.BUILTIN_DATABASE :          return "Database";\n			case NameRecord.BUILTIN_DATA_FORM :         return "Data_Form";\n			case NameRecord.BUILTIN_PRINT_AREA :        return "Print_Area";\n			case NameRecord.BUILTIN_PRINT_TITLE :       return "Print_Titles";\n			case NameRecord.BUILTIN_RECORDER :          return "Recorder";\n			case NameRecord.BUILTIN_SHEET_TITLE :       return "Sheet_Title";\n			case NameRecord.BUILTIN_FILTER_DB  :        return "_FilterDatabase";\n\n		}\n\n		return "Unknown";\n	}
1715	private String convertSharedFormula(int si, XSSFEvaluationWorkbook fpb){\n        XSSFSheet sheet = getSheet();\n\n        CTCellFormula f = sheet.getSharedFormula(si);\n        if(f == null) {\n            throw new IllegalStateException(\n                    "Master cell of a shared formula with sid="+si+" was not found");\n        }\n\n        String sharedFormula = f.getStringValue();\n        //Range of cells which the shared formula applies to\n        String sharedFormulaRange = f.getRef();\n\n        CellRangeAddress ref = CellRangeAddress.valueOf(sharedFormulaRange);\n\n        int sheetIndex = sheet.getWorkbook().getSheetIndex(sheet);\n        SharedFormula sf = new SharedFormula(SpreadsheetVersion.EXCEL2007);\n\n        Ptg[] ptgs = FormulaParser.parse(sharedFormula, fpb, FormulaType.CELL, sheetIndex, getRowIndex());\n        Ptg[] fmla = sf.convertSharedFormulas(ptgs,\n                getRowIndex() - ref.getFirstRow(), getColumnIndex() - ref.getFirstColumn());\n        return FormulaRenderer.toFormulaString(fpb, fmla);\n    }
1716	int getLumOff(){\n        return getPercentageValue("lumOff");\n    }
1717	public void write(POIFSStream stream) throws IOException {\n       OutputStream os = stream.getOutputStream();\n       for(Property property : _properties) {\n          if(property != null) {\n             property.writeData(os);\n          }\n       }\n       os.close();\n       \n       // Update the start position if needed\n       if(getStartBlock() != stream.getStartBlock()) {\n          setStartBlock(stream.getStartBlock());\n       }\n    }
1718	public static void putDouble( byte[] data, int offset, double value )\n    {\n        putLong( data, offset, Double.doubleToLongBits( value ) );\n    }
1719	private void addName(String functionName) {\n        final Name name = _book.createName();\n        name.setFunction(true);\n        name.setNameName(functionName);\n        name.setSheetIndex(_sheetIndex);\n    }
1720	public static POIFSFileSystem verifyAndBuildPOIFS(InputStream istream) throws IOException {\n        InputStream is = FileMagic.prepareToCheckMagic(istream);\n        FileMagic fm = FileMagic.valueOf(is);\n\n        if (fm != FileMagic.OLE2) {\n            throw new IllegalArgumentException("The document is really a "+fm+" file");\n        }\n\n        return new POIFSFileSystem(is);\n    }
1721	public static void putInt( byte[] data, int offset, int value )\n    {\n        int i = offset;\n        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );\n        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );\n    }
1722	public static void main(String[] args) throws IOException {\n        Workbook wb;\n\n        if(args.length > 0 && args[0].equals("-xls")) {\n            wb = new HSSFWorkbook();\n        } else {\n            wb = new XSSFWorkbook();\n        }\n\n        sameCell(wb.createSheet("Same Cell"));\n        multiCell(wb.createSheet("MultiCell"));\n        overlapping(wb.createSheet("Overlapping"));\n        errors(wb.createSheet("Errors"));\n        hideDupplicates(wb.createSheet("Hide Dups"));\n        formatDuplicates(wb.createSheet("Duplicates"));\n        inList(wb.createSheet("In List"));\n        expiry(wb.createSheet("Expiry"));\n        shadeAlt(wb.createSheet("Shade Alt"));\n        shadeBands(wb.createSheet("Shade Bands"));\n        iconSets(wb.createSheet("Icon Sets"));\n        colourScales(wb.createSheet("Colour Scales"));\n        dataBars(wb.createSheet("Data Bars"));\n\n        // print overlapping rule results\n        evaluateRules(wb, "Overlapping");\n        \n        // Write the output to a file\n        String file = "cf-poi.xls";\n        if(wb instanceof XSSFWorkbook) {\n            file += "x";\n        }\n        FileOutputStream out = new FileOutputStream(file);\n        wb.write(out);\n        out.close();\n        System.out.println("Generated: " + file);\n        wb.close();\n    }
1723	public static FuncVarPtg create(String pName, int numArgs) {\n        return create(numArgs, lookupIndex(pName));\n    }
1724	public void close() throws IOException {\n        _out.flush();\n        _out.close();\n    }
1725	public void registerPartAndContentType(PackagePart part) {\n        addPackagePart(part);\n        this.contentTypeManager.addContentType(part.getPartName(), part.getContentType());\n        this.isDirty = true;\n    }
1726	@Internal\n    public boolean isFTNY()\n    {\n        return fTNY.isSet(field_29_ufel);\n    }
1727	private static boolean getBoolean(Map<String, Object> properties, String name) {\n        Object value = properties.get(name);\n        //noinspection SimplifiableIfStatement\n        if (value instanceof Boolean) {\n            return ((Boolean) value).booleanValue();\n        }\n        return false;\n    }
1728	private static int unsignedValue(final short s) {\n        return (s < 0 ? 0x10000 + s : s);\n    }
1729	public FontRecord createNewFont() {\n        FontRecord rec = createFont();\n\n        records.add(records.getFontpos()+1, rec);\n        records.setFontpos( records.getFontpos() + 1 );\n        numfonts++;\n        return rec;\n    }
1730	public void setString(String s) {\n        clearFormatting();\n        st.setT(s);\n        preserveSpaces(st.xgetT());\n    }
1731	private void addKeywords() {\n        setElementTextContent(KEYWORD_KEYWORDS, namespaceCoreProperties, propsPart.getKeywordsProperty());\n	}
1732	public void addMarshaller(String contentType, PartMarshaller marshaller) {\n		try {\n			partMarshallers.put(new ContentType(contentType), marshaller);\n		} catch (InvalidFormatException e) {\n			logger.log(POILogger.WARN, "The specified content type is not valid: '"\n					+ e.getMessage() + "'. The marshaller will not be added !");\n		}\n	}
1733	public void setParagraphStyles(List<TextPropCollection> ps) { paragraphStyles = ps; }
1734	public int getValue() { return dataValue; }
1735	public static Cipher getCipher(Key key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode, String padding) {\n        int keySizeInBytes = key.getEncoded().length;\n        if (padding == null) padding = "NoPadding";\n        \n        try {\n            // Ensure the JCE policies files allow for this sized key\n            if (Cipher.getMaxAllowedKeyLength(cipherAlgorithm.jceId) < keySizeInBytes*8) {\n                throw new EncryptedDocumentException("Export Restrictions in place - please install JCE Unlimited Strength Jurisdiction Policy files");\n            }\n\n            Cipher cipher;\n            if (cipherAlgorithm == CipherAlgorithm.rc4) {\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId);\n            } else if (cipherAlgorithm.needsBouncyCastle) {\n                registerBouncyCastle();\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding, "BC");\n            } else {\n                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding);\n            }\n            \n            if (vec == null) {\n                cipher.init(cipherMode, key);\n            } else {\n                AlgorithmParameterSpec aps;\n                if (cipherAlgorithm == CipherAlgorithm.rc2) {\n                    aps = new RC2ParameterSpec(key.getEncoded().length*8, vec);\n                } else {\n                    aps = new IvParameterSpec(vec);\n                }\n                cipher.init(cipherMode, key, aps);\n            }\n            return cipher;\n        } catch (GeneralSecurityException e) {\n            throw new EncryptedDocumentException(e);\n        }\n    }
1736	public byte getItcFirst()\n    {\n        return ( byte )itcFirst.getValue(field_2_bkf_flags);\n    }
1737	private static BackupRecord createBackup() {\n        BackupRecord retval = new BackupRecord();\n\n        retval.setBackup(( short ) 0);   // by default DONT save backups of files...just loose data\n        return retval;\n    }
1738	@Internal\n    public int putCellStyleXf(CTXf cellStyleXf) {\n        styleXfs.add(cellStyleXf);\n        // TODO: check for duplicate\n        return styleXfs.size();\n    }
1739	public boolean removeChildRecord(EscherRecord toBeRemoved) {\n        return _childRecords.remove(toBeRemoved);\n    }
1740	public void free() throws IOException {\n      ChainLoopDetector loopDetector = blockStore.getChainLoopDetector();\n      free(loopDetector);\n   }
1741	public XSLFChart createChart(XSLFSlide slide) {\n        int chartIdx = findNextAvailableFileNameIndex(XSLFRelation.CHART, _charts.size() + 1);\n        XSLFChart chart = (XSLFChart) createRelationship(XSLFRelation.CHART, XSLFFactory.getInstance(), chartIdx, true).getDocumentPart();\n        slide.addRelation(null, XSLFRelation.CHART, chart);\n        chart.setChartIndex(chartIdx);\n        _charts.add(chart);\n        return chart;\n    }
1742	private void create(){\n		EscherContainerRecord dgContainer = new EscherContainerRecord();\n		dgContainer.setRecordId( EscherContainerRecord.DG_CONTAINER );\n		dgContainer.setOptions((short)15);\n\n		dg = new EscherDgRecord();\n		dg.setOptions((short)16);\n		dg.setNumShapes(1);\n		dgContainer.addChildRecord(dg);\n\n		EscherContainerRecord spgrContainer = new EscherContainerRecord();\n		spgrContainer.setOptions((short)15);\n		spgrContainer.setRecordId(EscherContainerRecord.SPGR_CONTAINER);\n\n		EscherContainerRecord spContainer = new EscherContainerRecord();\n		spContainer.setOptions((short)15);\n		spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n\n		EscherSpgrRecord spgr = new EscherSpgrRecord();\n		spgr.setOptions((short)1);\n		spContainer.addChildRecord(spgr);\n\n		EscherSpRecord sp = new EscherSpRecord();\n		sp.setOptions((short)((ShapeType.NOT_PRIMITIVE.nativeId << 4) + 2));\n		sp.setFlags(EscherSpRecord.FLAG_PATRIARCH | EscherSpRecord.FLAG_GROUP);\n		spContainer.addChildRecord(sp);\n		spgrContainer.addChildRecord(spContainer);\n		dgContainer.addChildRecord(spgrContainer);\n\n		spContainer = new EscherContainerRecord();\n		spContainer.setOptions((short)15);\n		spContainer.setRecordId(EscherContainerRecord.SP_CONTAINER);\n		sp = new EscherSpRecord();\n		sp.setOptions((short)((ShapeType.RECT.nativeId << 4) + 2));\n		sp.setFlags(EscherSpRecord.FLAG_BACKGROUND | EscherSpRecord.FLAG_HASSHAPETYPE);\n		spContainer.addChildRecord(sp);\n\n		EscherOptRecord opt = new EscherOptRecord();\n		opt.setRecordId(EscherOptRecord.RECORD_ID);\n		opt.addEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLCOLOR, 134217728));\n		opt.addEscherProperty(new EscherRGBProperty(EscherProperties.FILL__FILLBACKCOLOR, 134217733));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.FILL__RECTRIGHT, 10064750));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.FILL__RECTBOTTOM, 7778750));\n		opt.addEscherProperty(new EscherBoolProperty(EscherProperties.FILL__NOFILLHITTEST, 1179666));\n		opt.addEscherProperty(new EscherBoolProperty(EscherProperties.LINESTYLE__NOLINEDRAWDASH, 524288));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.SHAPE__BLACKANDWHITESETTINGS, 9));\n		opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.SHAPE__BACKGROUNDSHAPE, 65537));\n		spContainer.addChildRecord(opt);\n\n		dgContainer.addChildRecord(spContainer);\n		\n		childRecords.add(dgContainer);\n	}
1743	public void addParagraph(XWPFParagraph p) {\n        paragraphs.add(p);\n    }
1744	@Internal\n    public short getIstdLink()\n    {\n        return ( short )istdLink.getValue(field_1_info1);\n    }
1745	protected void onDocumentCreate() throws IOException {\n\n    }
1746	@Internal\n    public void mark(int readlimit) {\n        ((InputStream)_dataInput).mark(readlimit);\n        _markedDataOffset = _currentDataOffset;\n    }
1747	// TODO: What is this?\n    @NotImplemented\n    public CellRangeAddress getArrayFormulaRange()\n    {\n        return null;\n    }
1748	public int getNumPointers(int offset, byte[] data) {\n        return getNumPointersV6(offset, data);\n    }
1749	private void collectIfPtgs(TokenCollector temp) {\n\n		// condition goes first\n		getChildren()[0].collectPtgs(temp);\n\n		// placeholder for tAttrIf\n		int ifAttrIndex = temp.createPlaceholder();\n\n		// true parameter\n		getChildren()[1].collectPtgs(temp);\n\n		// placeholder for first skip attr\n		int skipAfterTrueParamIndex = temp.createPlaceholder();\n		int trueParamSize = temp.sumTokenSizes(ifAttrIndex+1, skipAfterTrueParamIndex);\n\n		AttrPtg attrIf = AttrPtg.createIf(trueParamSize + 4); // distance to start of false parameter/tFuncVar. +4 for tAttrSkip after true\n\n		if (getChildren().length > 2) {\n			// false param present\n\n			// false parameter\n			getChildren()[2].collectPtgs(temp);\n\n			int skipAfterFalseParamIndex = temp.createPlaceholder();\n\n			int falseParamSize =  temp.sumTokenSizes(skipAfterTrueParamIndex+1, skipAfterFalseParamIndex);\n\n			AttrPtg attrSkipAfterTrue = AttrPtg.createSkip(falseParamSize + 4 + 4 - 1); // 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before\n			AttrPtg attrSkipAfterFalse = AttrPtg.createSkip(4 - 1); // 1 less than distance to end of if FuncVar(size=4).\n\n			temp.setPlaceholder(ifAttrIndex, attrIf);\n			temp.setPlaceholder(skipAfterTrueParamIndex, attrSkipAfterTrue);\n			temp.setPlaceholder(skipAfterFalseParamIndex, attrSkipAfterFalse);\n		} else {\n			// false parameter not present\n			AttrPtg attrSkipAfterTrue = AttrPtg.createSkip(4 - 1); // 1 less than distance to end of if FuncVar(size=4).\n\n			temp.setPlaceholder(ifAttrIndex, attrIf);\n			temp.setPlaceholder(skipAfterTrueParamIndex, attrSkipAfterTrue);\n		}\n		temp.add(_token);\n	}
1750	public static boolean isEndOfRowBlock(int sid) {\n		switch(sid) {\n			case ViewDefinitionRecord.sid:\n				// should have been prefixed with DrawingRecord (0x00EC), but bug 46280 seems to allow this\n			case DrawingRecord.sid:\n			case DrawingSelectionRecord.sid:\n			case ObjRecord.sid:\n			case TextObjectRecord.sid:\n            case ColumnInfoRecord.sid: // See Bugzilla 53984\n            case GutsRecord.sid:   // see Bugzilla 50426\n			case WindowOneRecord.sid:\n				// should really be part of workbook stream, but some apps seem to put this before WINDOW2\n			case WindowTwoRecord.sid:\n				return true;\n\n			case DVALRecord.sid:\n				return true;\n			case EOFRecord.sid:\n				// WINDOW2 should always be present, so shouldn't have got this far\n				throw new RuntimeException("Found EOFRecord before WindowTwoRecord was encountered");\n		}\n		return PageSettingsBlock.isComponentRecord(sid);\n	}
1751	public void notifyFormulaChanging() {\n		if (_sharedFormulaRecord != null) {\n			_sharedValueManager.unlink(_sharedFormulaRecord);\n		}\n	}
1752	public void setForwardDiagonalOn(boolean on) {\n        field_13_border_styles1 = bordBlTrtLineOnOff.setBoolean(field_13_border_styles1, on);\n    }
1753	public static short lookupIndexByName(String name) {\n		FunctionMetadata fd = getInstance().getFunctionByNameInternal(name);\n		if (fd == null) {\n			return -1;\n		}\n		return (short) fd.getIndex();\n	}
1754	private static CellRefParts separateRefParts(String reference) {\n        int plingPos = reference.lastIndexOf(SHEET_NAME_DELIMITER);\n        final String sheetName = parseSheetName(reference, plingPos);\n        String cell = reference.substring(plingPos+1).toUpperCase(Locale.ROOT);\n        Matcher matcher = CELL_REF_PATTERN.matcher(cell);\n        if (!matcher.matches()) {\n            throw new IllegalArgumentException("Invalid CellReference: " + reference);\n        }\n        String col = matcher.group(1);\n        String row = matcher.group(2);\n\n        return new CellRefParts(sheetName, row, col);\n    }
1755	private void setPropertiesFromSheet(InternalSheet sheet) {\n        RowRecord row = sheet.getNextRow();\n\n        while (row != null) {\n            createRowFromRecord(row);\n\n            row = sheet.getNextRow();\n        }\n\n        Iterator<CellValueRecordInterface> iter = sheet.getCellValueIterator();\n        long timestart = System.currentTimeMillis();\n\n        if (log.check( POILogger.DEBUG )) {\n            log.log(DEBUG, "Time at start of cell creating in HSSF sheet = ",\n                    Long.valueOf(timestart));\n        }\n        HSSFRow lastrow = null;\n\n        // Add every cell to its row\n        while (iter.hasNext()) {\n            CellValueRecordInterface cval = iter.next();\n\n            long cellstart = System.currentTimeMillis();\n            HSSFRow hrow = lastrow;\n\n            if (hrow == null || hrow.getRowNum() != cval.getRow()) {\n                hrow = getRow(cval.getRow());\n                lastrow = hrow;\n                if (hrow == null) {\n                    /* we removed this check, see bug 47245 for the discussion around this\n                    // Some tools (like Perl module Spreadsheet::WriteExcel - bug 41187) skip the RowRecords\n                    // Excel, OpenOffice.org and GoogleDocs are all OK with this, so POI should be too.\n                    if (rowRecordsAlreadyPresent) {\n                        // if at least one row record is present, all should be present.\n                        throw new RuntimeException("Unexpected missing row when some rows already present");\n                    }*/\n\n                    // create the row record on the fly now.\n                    RowRecord rowRec = new RowRecord(cval.getRow());\n                    sheet.addRow(rowRec);\n                    hrow = createRowFromRecord(rowRec);\n                }\n            }\n            if (log.check( POILogger.DEBUG )) {\n                if (cval instanceof Record) {\n                log.log( DEBUG, "record id = " + Integer.toHexString( ( (Record) cval ).getSid() ) );\n                } else {\n                    log.log( DEBUG, "record = " + cval );\n                }\n            }\n            hrow.createCellFromRecord( cval );\n            if (log.check( POILogger.DEBUG )) {\n                log.log( DEBUG, "record took ",\n                    Long.valueOf( System.currentTimeMillis() - cellstart ) );\n            }\n\n        }\n        if (log.check( POILogger.DEBUG )) {\n            log.log(DEBUG, "total sheet cell creation took ",\n                Long.valueOf(System.currentTimeMillis() - timestart));\n    }\n    }
1756	private void appendHeaderFooter( String text, StringBuffer out ) {\n        if ( text == null || text.length() == 0 )\n            return;\n\n        text = text.replace( '\r', '\n' );\n        if ( !text.endsWith( "\n" ))\n        {\n            out.append( text );\n            out.append( '\n' );\n            return;\n        }\n        if ( text.endsWith( "\n\n" ))\n        {\n            out.append( text.substring( 0, text.length() - 1 ));\n            return;\n        }\n        out.append( text );\n    }
1757	@Internal\n    public boolean isFNoWrap()\n    {\n        return fNoWrap.isSet(field_1_rgf);\n    }
1758	public ExcelAntEvaluationResult evaluateCell(String cellName, double expectedValue,\n            double precision) {\n\n        ExcelAntEvaluationResult evalResults = null;\n\n        Cell cell = getCell(cellName);\n\n        FormulaEvaluator evaluator = getEvaluator(excelFileName);\n\n\n        CellValue resultOfEval = evaluator.evaluate(cell);\n\n        if (resultOfEval.getErrorValue() == 0) {\n            // the evaluation did not encounter errors\n            double result = resultOfEval.getNumberValue();\n            double delta = Math.abs(result - expectedValue);\n            if (delta > precision) {\n                evalResults = new ExcelAntEvaluationResult(false, false,\n                        resultOfEval.getNumberValue(),\n                        "Results was out of range based on precision " + " of "\n                                + precision + ".  Delta was actually " + delta, delta, cellName);\n            } else {\n                evalResults = new ExcelAntEvaluationResult(false, true,\n                        resultOfEval.getNumberValue(),\n                        "Evaluation passed without error within in range.", delta, cellName);\n            }\n        } else {\n            String errorMeaning = null;\n            try {\n                errorMeaning = FormulaError.forInt(resultOfEval.getErrorValue()).getString();\n            } catch(IllegalArgumentException iae) {\n                errorMeaning =  "unknown error code: " +\n                                Byte.toString(resultOfEval.getErrorValue());\n            }\n\n            evalResults = new ExcelAntEvaluationResult(true, false,\n                    resultOfEval.getNumberValue(),\n                    "Evaluation failed due to an evaluation error of "\n                            + resultOfEval.getErrorValue()\n                            + " which is "\n                            + errorMeaning, 0, cellName);\n        }\n\n        return evalResults;\n    }
1759	public static boolean hasMultibyte(String value) {\n        if (value == null)\n            return false;\n        for (char c : value.toCharArray()) {\n            if (c > 0xFF) {\n                return true;\n            }\n        }\n        return false;\n    }
1760	protected void prepareForCommit() {\n        // do not clear the part here\n    }
1761	public int getNumberFormat()\n    {\n        return _lvlf.getNfc();\n    }
1762	@Beta\n    private void addDataField(DataConsolidateFunction function, int columnIndex, String valueFieldName, String valueFormat) {\n        checkColumnIndex(columnIndex);\n        \n        AreaReference pivotArea = getPivotArea();\n        \n        CTDataFields dataFields;\n        if(pivotTableDefinition.getDataFields() != null) {\n            dataFields = pivotTableDefinition.getDataFields();\n        } else {\n            dataFields = pivotTableDefinition.addNewDataFields();\n        }\n        CTDataField dataField = dataFields.addNewDataField();\n        dataField.setSubtotal(STDataConsolidateFunction.Enum.forInt(function.getValue()));\n        Cell cell = getDataSheet().getRow(pivotArea.getFirstCell().getRow())\n                .getCell(pivotArea.getFirstCell().getCol() + columnIndex);\n        cell.setCellType(CellType.STRING);\n        dataField.setName(valueFieldName);\n        dataField.setFld(columnIndex);\n        if (valueFormat != null && !valueFormat.trim().isEmpty()) {\n            DataFormat df = parentSheet.getWorkbook().createDataFormat();\n            dataField.setNumFmtId(df.getFormat(valueFormat));\n        }\n        dataFields.setCount(dataFields.sizeOfDataFieldArray());\n    }
1763	public int allocateShapeId() {\n        EscherDggRecord dgg = _slideShow.getDocumentRecord().getPPDrawingGroup().getEscherDggRecord();\n        EscherDgRecord dg = _container.getPPDrawing().getEscherDgRecord();\n        return dgg.allocateShapeId(dg, false);\n    }
1764	private ParagraphHeight getParagraphHeight(int index)\n    {\n      int pheOffset = _offset + 1 + (((_crun + 1) * 4) + (index * 13));\n\n        return new ParagraphHeight(_fkp, pheOffset);\n    }
1765	private void addCreator() {\n        setElementTextContent(KEYWORD_CREATOR, namespaceDC, propsPart.getCreatorProperty());\n	}
1766	private void findMostRecentCoreRecords() {\n		// To start with, find the most recent in the byte offset domain\n		Map<Integer,Integer> mostRecentByBytes = new HashMap<>();\n		for (Record record : _hslfSlideShow.getRecords()) {\n			if (record instanceof PersistPtrHolder) {\n				PersistPtrHolder pph = (PersistPtrHolder) record;\n\n				// If we've already seen any of the "slide" IDs for this\n				// PersistPtr, remove their old positions\n				int[] ids = pph.getKnownSlideIDs();\n				for (int id : ids) {\n					mostRecentByBytes.remove(id);\n				}\n\n				// Now, update the byte level locations with their latest values\n				Map<Integer,Integer> thisSetOfLocations = pph.getSlideLocationsLookup();\n				for (int id : ids) {\n					mostRecentByBytes.put(id, thisSetOfLocations.get(id));\n				}\n			}\n		}\n\n		// We now know how many unique special records we have, so init\n		// the array\n		_mostRecentCoreRecords = new Record[mostRecentByBytes.size()];\n\n		// We'll also want to be able to turn the slide IDs into a position\n		// in this array\n		_sheetIdToCoreRecordsLookup = new HashMap<>();\n		Integer[] allIDs = mostRecentByBytes.keySet().toArray(new Integer[0]);\n		Arrays.sort(allIDs);\n		for (int i = 0; i < allIDs.length; i++) {\n			_sheetIdToCoreRecordsLookup.put(allIDs[i], i);\n		}\n\n		Map<Integer,Integer> mostRecentByBytesRev = new HashMap<>(mostRecentByBytes.size());\n		for (Map.Entry<Integer,Integer> me : mostRecentByBytes.entrySet()) {\n		    mostRecentByBytesRev.put(me.getValue(), me.getKey());\n		}\n\n		// Now convert the byte offsets back into record offsets\n		for (Record record : _hslfSlideShow.getRecords()) {\n			if (!(record instanceof PositionDependentRecord)) {\n                continue;\n            }\n\n			PositionDependentRecord pdr = (PositionDependentRecord) record;\n			int recordAt = pdr.getLastOnDiskOffset();\n\n			Integer thisID = mostRecentByBytesRev.get(recordAt);\n\n			if (thisID == null) {\n                continue;\n            }\n\n			// Bingo. Now, where do we store it?\n			int storeAt = _sheetIdToCoreRecordsLookup.get(thisID);\n\n			// Tell it its Sheet ID, if it cares\n			if (pdr instanceof PositionDependentRecordContainer) {\n				PositionDependentRecordContainer pdrc = (PositionDependentRecordContainer) record;\n				pdrc.setSheetId(thisID);\n			}\n\n			// Finally, save the record\n			_mostRecentCoreRecords[storeAt] = record;\n		}\n\n		// Now look for the interesting records in there\n		for (Record record : _mostRecentCoreRecords) {\n			// Check there really is a record at this number\n			if (record != null) {\n				// Find the Document, and interesting things in it\n				if (record.getRecordType() == RecordTypes.Document.typeID) {\n					_documentRecord = (Document) record;\n					_fonts = _documentRecord.getEnvironment().getFontCollection();\n				}\n			} /*else {\n				// No record at this number\n				// Odd, but not normally a problem\n			}*/\n		}\n	}
1767	public static byte[] getChecksum(byte[] data) {\n        MessageDigest md5 = CryptoFunctions.getMessageDigest(HashAlgorithm.md5);\n        md5.update(data);\n        return md5.digest();\n    }
1768	protected static String toDebugFriendlyString(byte[] value) {\n        if (value == null) {\n            return "(Null Byte Array)";\n        }\n\n        StringBuffer text = new StringBuffer();\n        text.append("Bytes len=").append(value.length);\n        text.append(" [");\n\n        int limit = Math.min(value.length, 16);\n        if (value.length > 16) {\n            limit = 12;\n        }\n        for (int i = 0; i < limit; i++) {\n            if (i > 0) {\n                text.append(',');\n            }\n            text.append(value[i]);\n        }\n        if (value.length > 16) {\n            text.append(",....");\n        }\n        text.append("]");\n        return text.toString();\n    }
1769	public static void putFloat( byte[] data, int offset, float value )\n    {\n        putInt( data, offset, Float.floatToIntBits( value ) );\n    }
1770	public void setSignatureDescription(String signatureDescription) {\n        this.signatureDescription = signatureDescription;\n    }
1771	public Integer getToPart() {\n        if (_connect.isSetToPart())\n            return _connect.getToPart();\n        else\n            return null;\n    }
1772	public int getY1() {\n        return _spgrRecord.getRectY1();\n    }
1773	public void dumpDrawingGroupRecords(boolean fat) {\n        DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );\n        if (r == null) {\n            return;\n        }\n        r.decode();\n        List<EscherRecord> escherRecords = r.getEscherRecords();\n        PrintWriter w = new PrintWriter(new OutputStreamWriter(System.out, Charset.defaultCharset()));\n        for (EscherRecord escherRecord : escherRecords) {\n            if (fat) {\n                System.out.println(escherRecord);\n            } else {\n                escherRecord.display(w, 0);\n            }\n        }\n        w.flush();\n    }
1774	public void setFontFamily(String fontFamily, FontCharRange fcr) {\n        CTRPr pr = getRunProperties(true);\n        CTFonts fonts = pr.isSetRFonts() ? pr.getRFonts() : pr.addNewRFonts();\n\n        if (fcr == null) {\n            fonts.setAscii(fontFamily);\n            if (!fonts.isSetHAnsi()) {\n                fonts.setHAnsi(fontFamily);\n            }\n            if (!fonts.isSetCs()) {\n                fonts.setCs(fontFamily);\n            }\n            if (!fonts.isSetEastAsia()) {\n                fonts.setEastAsia(fontFamily);\n            }\n        } else {\n            switch (fcr) {\n                case ascii:\n                    fonts.setAscii(fontFamily);\n                    break;\n                case cs:\n                    fonts.setCs(fontFamily);\n                    break;\n                case eastAsia:\n                    fonts.setEastAsia(fontFamily);\n                    break;\n                case hAnsi:\n                    fonts.setHAnsi(fontFamily);\n                    break;\n            }\n        }\n    }
1775	private static byte[] findCompressedStreamWBruteForce(InputStream is) throws IOException {\n        //buffer to memory for multiple tries\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        IOUtils.copy(is, bos);\n        byte[] compressed = bos.toByteArray();\n        byte[] decompressed = null;\n        for (int i = 0; i < compressed.length; i++) {\n            if (compressed[i] == 0x01 && i < compressed.length-1) {\n                int w = LittleEndian.getUShort(compressed, i+1);\n                if (w <= 0 || (w & 0x7000) != 0x3000) {\n                    continue;\n                }\n                decompressed = tryToDecompress(new ByteArrayInputStream(compressed, i, compressed.length - i));\n                if (decompressed != null) {\n                    if (decompressed.length > 9) {\n                        //this is a complete hack.  The challenge is that there\n                        //can be many 0 length or junk streams that are uncompressed\n                        //look in the first 20 characters for "Attribute"\n                        int firstX = Math.min(20, decompressed.length);\n                        String start = new String(decompressed, 0, firstX, StringUtil.WIN_1252);\n                        if (start.contains("Attribute")) {\n                            return decompressed;\n                        }\n                    }\n                }\n            }\n        }\n        return decompressed;\n    }
1776	public boolean isShowPercent()\n    {\n        return showPercent.isSet(field_1_formatFlags);\n    }
1777	@Internal\n    public XWPFFootnote addFootnote(CTFtnEdn note) {\n        return footnotes.addFootnote(note);\n    }
1778	private void notifyFormulaChanging() {\n        if (_record instanceof FormulaRecordAggregate) {\n            ((FormulaRecordAggregate)_record).notifyFormulaChanging();\n        }\n    }
1779	public static void main(String[] args) throws IOException\n    {\n        // create a new file input stream with the input file specified\n        // at the command line\n        try (FileInputStream fin = new FileInputStream(args[0])) {\n            // create a new org.apache.poi.poifs.filesystem.Filesystem\n            try (POIFSFileSystem poifs = new POIFSFileSystem(fin)) {\n                // get the Workbook (excel part) stream in a InputStream\n                try (InputStream din = poifs.createDocumentInputStream("Workbook")) {\n                    // construct out HSSFRequest object\n                    HSSFRequest req = new HSSFRequest();\n                    // lazy listen for ALL records with the listener shown above\n                    req.addListenerForAllRecords(new EventExample());\n                    // create our event factory\n                    HSSFEventFactory factory = new HSSFEventFactory();\n                    // process our events based on the document input stream\n                    factory.processEvents(req, din);\n                }\n            }\n        }\n        System.out.println("done.");\n    }
1780	boolean hasLeadingTrailingSpaces(String str) {\n        if (str != null && str.length() > 0) {\n            char firstChar = str.charAt(0);\n            char lastChar  = str.charAt(str.length() - 1);\n            return Character.isWhitespace(firstChar) || Character.isWhitespace(lastChar) ;\n        }\n        return false;\n    }
1781	public void setRncEdn(final short field_61_rncedn) {\n        this.field_61_rncedn = field_61_rncedn;\n    }
1782	private void unhook() {\n        if (_evaluators.length < 1) {\n            // Never dismantle the EMPTY environment\n            return;\n        }\n        for (int i = 0; i < _evaluators.length; i++) {\n            _evaluators[i].detachFromEnvironment();\n        }\n        _unhooked = true;\n    }
1783	public void revert() {\n        revertImpl();\n    }
1784	public void setRunType(int type) {\n        getEscherTextboxWrapper();\n        if (_txtbox == null) {\n            return;\n        }\n        List<HSLFTextParagraph> paras = HSLFTextParagraph.findTextParagraphs(_txtbox, getSheet());\n        if (!paras.isEmpty()) {\n            paras.get(0).setRunType(type);\n        }\n    }
1785	public void findChildren(byte[] documentData) {\n		// For each pointer, generate the Stream it points to\n		childStreams = new Stream[childPointers.length];\n		for(int i=0; i<childPointers.length; i++) {\n			Pointer ptr = childPointers[i];\n			childStreams[i] = Stream.createStream(ptr, documentData, chunkFactory, pointerFactory);\n\n			// Process chunk streams into their chunks\n			if(childStreams[i] instanceof ChunkStream) {\n				ChunkStream child = (ChunkStream)childStreams[i];\n				child.findChunks();\n			}\n\n			// Recurse into pointer containing streams\n			if(childStreams[i] instanceof PointerContainingStream) {\n				PointerContainingStream child =\n					(PointerContainingStream)childStreams[i];\n				child.findChildren(documentData);\n			}\n		}\n	}
1786	@Internal\n    public boolean isFFormatting()\n    {\n        return fFormatting.isSet(field_2_flags);\n    }
1787	@Internal\n    public boolean isFTentative()\n    {\n        return fTentative.isSet(field_3_info);\n    }
